#pragma section("__nv_managed_data__")
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
#line 1 "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu"
#define __nv_is_extended_device_lambda_closure_type(X) false
#define __nv_is_extended_host_device_lambda_closure_type(X) false

#line 1
#line 67 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_runtime.h"
#pragma warning(push)
#pragma warning(disable: 4820)
#line 708 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\sal.h"
#pragma region Input Buffer SAL 1 compatibility macros
#line 1472
#pragma endregion Input Buffer SAL 1 compatibility macros
#line 2361 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\sal.h"
extern "C" {
#line 2967 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\sal.h"
}
#line 22 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\concurrencysal.h"
extern "C" {
#line 354 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\concurrencysal.h"
}
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vadefs.h"
#pragma pack ( push, 8 )
#line 18
extern "C" {
#line 28 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vadefs.h"
typedef unsigned __int64 uintptr_t; 
#line 39 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vadefs.h"
typedef char *va_list; 
#line 112 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vadefs.h"
void __cdecl __va_start(va_list *, ...); 
#line 124 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vadefs.h"
}
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vadefs.h"
extern "C++" {
#line 130
template< class _Ty> 
#line 131
struct __vcrt_va_list_is_reference { 
#line 133
enum: bool { __the_value}; 
#line 134
}; 
#line 136
template< class _Ty> 
#line 137
struct __vcrt_va_list_is_reference< _Ty &>  { 
#line 139
enum: bool { __the_value = '\001'}; 
#line 140
}; 
#line 142
template< class _Ty> 
#line 143
struct __vcrt_va_list_is_reference< _Ty &&>  { 
#line 145
enum: bool { __the_value = '\001'}; 
#line 146
}; 
#line 148
template< class _Ty> 
#line 149
struct __vcrt_assert_va_start_is_not_reference { 
#line 151
static_assert((!__vcrt_va_list_is_reference< _Ty> ::__the_value), "va_start argument must not have reference type and must not be parenthesized");
#line 153
}; 
#line 154
}
#line 164 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vadefs.h"
#pragma pack ( pop )
#line 83 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 180 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime.h"
typedef unsigned __int64 size_t; 
#if !defined(__CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__)
#define __CUDA_INCLUDE_COMPILER_INTERNAL_HEADERS__
#endif
#include "crt/host_runtime.h"
#line 181
typedef __int64 ptrdiff_t; 
#line 182
typedef __int64 intptr_t; 
#line 190 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime.h"
typedef bool __vcrt_bool; 
#line 233 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime.h"
extern "C++" {
#line 235
template< class _CountofType, size_t _SizeOfArray> char (*__countof_helper(__unaligned _CountofType (& _Array)[_SizeOfArray]))[_SizeOfArray]; 
#line 239
}
#line 277 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime.h"
void __cdecl __security_init_cookie(); 
#line 283
void __cdecl __security_check_cookie(uintptr_t _StackCookie); 
#line 284
__declspec(noreturn) void __cdecl __report_gsfailure(uintptr_t _StackCookie); 
#line 288 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime.h"
extern uintptr_t __security_cookie; 
#line 296 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime.h"
}__pragma( pack ( pop )) 
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
extern "C++" {
#line 138
template< bool _Enable, class _Ty> struct _CrtEnableIf; 
#line 141
template< class _Ty> 
#line 142
struct _CrtEnableIf< true, _Ty>  { 
#line 144
typedef _Ty _Type; 
#line 145
}; 
#line 146
}
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
typedef bool __crt_bool; 
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
__declspec(dllimport) void __cdecl _invalid_parameter(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); 
#line 278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(); 
#line 279
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(); 
#line 281
__declspec(noreturn) 
#line 282
__declspec(dllimport) void __cdecl _invoke_watson(const __wchar_t * _Expression, const __wchar_t * _FunctionName, const __wchar_t * _FileName, unsigned _LineNo, uintptr_t _Reserved); 
#line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
typedef int errno_t; 
#line 511
typedef unsigned short wint_t; 
#line 512
typedef unsigned short wctype_t; 
#line 513
typedef long __time32_t; 
#line 514
typedef __int64 __time64_t; 
#line 521
typedef 
#line 516
struct __crt_locale_data_public { 
#line 518
const unsigned short *_locale_pctype; 
#line 519
int _locale_mb_cur_max; 
#line 520
unsigned _locale_lc_codepage; 
#line 521
} __crt_locale_data_public; 
#line 527
typedef 
#line 523
struct __crt_locale_pointers { 
#line 525
struct __crt_locale_data *locinfo; 
#line 526
struct __crt_multibyte_data *mbcinfo; 
#line 527
} __crt_locale_pointers; 
#line 529
typedef __crt_locale_pointers *_locale_t; 
#line 535
typedef 
#line 531
struct _Mbstatet { 
#line 533
unsigned long _Wchar; 
#line 534
unsigned short _Byte, _State; 
#line 535
} _Mbstatet; 
#line 537
typedef _Mbstatet mbstate_t; 
#line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
typedef __time64_t time_t; 
#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
typedef size_t rsize_t; 
#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt.h"
}__pragma( pack ( pop )) 
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_types.h"
#if 0
#line 66
enum cudaRoundMode { 
#line 68
cudaRoundNearest, 
#line 69
cudaRoundZero, 
#line 70
cudaRoundPosInf, 
#line 71
cudaRoundMinInf
#line 72
}; 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 98
struct char1 { 
#line 100
signed char x; 
#line 101
}; 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 103
struct uchar1 { 
#line 105
unsigned char x; 
#line 106
}; 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 109
struct __declspec(align(2)) char2 { 
#line 111
signed char x, y; 
#line 112
}; 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 114
struct __declspec(align(2)) uchar2 { 
#line 116
unsigned char x, y; 
#line 117
}; 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 119
struct char3 { 
#line 121
signed char x, y, z; 
#line 122
}; 
#endif
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 124
struct uchar3 { 
#line 126
unsigned char x, y, z; 
#line 127
}; 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 129
struct __declspec(align(4)) char4 { 
#line 131
signed char x, y, z, w; 
#line 132
}; 
#endif
#line 134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 134
struct __declspec(align(4)) uchar4 { 
#line 136
unsigned char x, y, z, w; 
#line 137
}; 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 139
struct short1 { 
#line 141
short x; 
#line 142
}; 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 144
struct ushort1 { 
#line 146
unsigned short x; 
#line 147
}; 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 149
struct __declspec(align(4)) short2 { 
#line 151
short x, y; 
#line 152
}; 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 154
struct __declspec(align(4)) ushort2 { 
#line 156
unsigned short x, y; 
#line 157
}; 
#endif
#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 159
struct short3 { 
#line 161
short x, y, z; 
#line 162
}; 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 164
struct ushort3 { 
#line 166
unsigned short x, y, z; 
#line 167
}; 
#endif
#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 169
struct __declspec(align(8)) short4 { short x; short y; short z; short w; }; 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 170
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 172
struct int1 { 
#line 174
int x; 
#line 175
}; 
#endif
#line 177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 177
struct uint1 { 
#line 179
unsigned x; 
#line 180
}; 
#endif
#line 182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 182
struct __declspec(align(8)) int2 { int x; int y; }; 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 183
struct __declspec(align(8)) uint2 { unsigned x; unsigned y; }; 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 185
struct int3 { 
#line 187
int x, y, z; 
#line 188
}; 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 190
struct uint3 { 
#line 192
unsigned x, y, z; 
#line 193
}; 
#endif
#line 195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 195
struct __declspec(align(16)) int4 { 
#line 197
int x, y, z, w; 
#line 198
}; 
#endif
#line 200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 200
struct __declspec(align(16)) uint4 { 
#line 202
unsigned x, y, z, w; 
#line 203
}; 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 205
struct long1 { 
#line 207
long x; 
#line 208
}; 
#endif
#line 210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 210
struct ulong1 { 
#line 212
unsigned long x; 
#line 213
}; 
#endif
#line 216 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 216
struct __declspec(align(8)) long2 { long x; long y; }; 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 217
struct __declspec(align(8)) ulong2 { unsigned long x; unsigned long y; }; 
#endif
#line 232 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 232
struct long3 { 
#line 234
long x, y, z; 
#line 235
}; 
#endif
#line 237 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 237
struct ulong3 { 
#line 239
unsigned long x, y, z; 
#line 240
}; 
#endif
#line 242 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 242
struct __declspec(align(16)) long4 { 
#line 244
long x, y, z, w; 
#line 245
}; 
#endif
#line 247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 247
struct __declspec(align(16)) ulong4 { 
#line 249
unsigned long x, y, z, w; 
#line 250
}; 
#endif
#line 252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 252
struct float1 { 
#line 254
float x; 
#line 255
}; 
#endif
#line 274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 274
struct __declspec(align(8)) float2 { float x; float y; }; 
#endif
#line 279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 279
struct float3 { 
#line 281
float x, y, z; 
#line 282
}; 
#endif
#line 284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 284
struct __declspec(align(16)) float4 { 
#line 286
float x, y, z, w; 
#line 287
}; 
#endif
#line 289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 289
struct longlong1 { 
#line 291
__int64 x; 
#line 292
}; 
#endif
#line 294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 294
struct ulonglong1 { 
#line 296
unsigned __int64 x; 
#line 297
}; 
#endif
#line 299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 299
struct __declspec(align(16)) longlong2 { 
#line 301
__int64 x, y; 
#line 302
}; 
#endif
#line 304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 304
struct __declspec(align(16)) ulonglong2 { 
#line 306
unsigned __int64 x, y; 
#line 307
}; 
#endif
#line 309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 309
struct longlong3 { 
#line 311
__int64 x, y, z; 
#line 312
}; 
#endif
#line 314 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 314
struct ulonglong3 { 
#line 316
unsigned __int64 x, y, z; 
#line 317
}; 
#endif
#line 319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 319
struct __declspec(align(16)) longlong4 { 
#line 321
__int64 x, y, z, w; 
#line 322
}; 
#endif
#line 324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 324
struct __declspec(align(16)) ulonglong4 { 
#line 326
unsigned __int64 x, y, z, w; 
#line 327
}; 
#endif
#line 329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 329
struct double1 { 
#line 331
double x; 
#line 332
}; 
#endif
#line 334 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 334
struct __declspec(align(16)) double2 { 
#line 336
double x, y; 
#line 337
}; 
#endif
#line 339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 339
struct double3 { 
#line 341
double x, y, z; 
#line 342
}; 
#endif
#line 344 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 344
struct __declspec(align(16)) double4 { 
#line 346
double x, y, z, w; 
#line 347
}; 
#endif
#line 361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef char1 
#line 361
char1; 
#endif
#line 362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uchar1 
#line 362
uchar1; 
#endif
#line 363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef char2 
#line 363
char2; 
#endif
#line 364 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uchar2 
#line 364
uchar2; 
#endif
#line 365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef char3 
#line 365
char3; 
#endif
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uchar3 
#line 366
uchar3; 
#endif
#line 367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef char4 
#line 367
char4; 
#endif
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uchar4 
#line 368
uchar4; 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef short1 
#line 369
short1; 
#endif
#line 370 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ushort1 
#line 370
ushort1; 
#endif
#line 371 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef short2 
#line 371
short2; 
#endif
#line 372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ushort2 
#line 372
ushort2; 
#endif
#line 373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef short3 
#line 373
short3; 
#endif
#line 374 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ushort3 
#line 374
ushort3; 
#endif
#line 375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef short4 
#line 375
short4; 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ushort4 
#line 376
ushort4; 
#endif
#line 377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef int1 
#line 377
int1; 
#endif
#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uint1 
#line 378
uint1; 
#endif
#line 379 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef int2 
#line 379
int2; 
#endif
#line 380 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uint2 
#line 380
uint2; 
#endif
#line 381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef int3 
#line 381
int3; 
#endif
#line 382 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uint3 
#line 382
uint3; 
#endif
#line 383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef int4 
#line 383
int4; 
#endif
#line 384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef uint4 
#line 384
uint4; 
#endif
#line 385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef long1 
#line 385
long1; 
#endif
#line 386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulong1 
#line 386
ulong1; 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef long2 
#line 387
long2; 
#endif
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulong2 
#line 388
ulong2; 
#endif
#line 389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef long3 
#line 389
long3; 
#endif
#line 390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulong3 
#line 390
ulong3; 
#endif
#line 391 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef long4 
#line 391
long4; 
#endif
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulong4 
#line 392
ulong4; 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef float1 
#line 393
float1; 
#endif
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef float2 
#line 394
float2; 
#endif
#line 395 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef float3 
#line 395
float3; 
#endif
#line 396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef float4 
#line 396
float4; 
#endif
#line 397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef longlong1 
#line 397
longlong1; 
#endif
#line 398 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulonglong1 
#line 398
ulonglong1; 
#endif
#line 399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef longlong2 
#line 399
longlong2; 
#endif
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulonglong2 
#line 400
ulonglong2; 
#endif
#line 401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef longlong3 
#line 401
longlong3; 
#endif
#line 402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulonglong3 
#line 402
ulonglong3; 
#endif
#line 403 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef longlong4 
#line 403
longlong4; 
#endif
#line 404 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef ulonglong4 
#line 404
ulonglong4; 
#endif
#line 405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef double1 
#line 405
double1; 
#endif
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef double2 
#line 406
double2; 
#endif
#line 407 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef double3 
#line 407
double3; 
#endif
#line 408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef double4 
#line 408
double4; 
#endif
#line 416 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
#line 416
struct dim3 { 
#line 418
unsigned x, y, z; 
#line 428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
}; 
#endif
#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_types.h"
#if 0
typedef dim3 
#line 430
dim3; 
#endif
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\limits.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\limits.h"
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
namespace std { 
#line 21
typedef decltype((nullptr)) nullptr_t; 
#line 22
}
#line 24
using std::nullptr_t;
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
__declspec(dllimport) int *__cdecl _errno(); 
#line 34
__declspec(dllimport) errno_t __cdecl _set_errno(int _Value); 
#line 35
__declspec(dllimport) errno_t __cdecl _get_errno(int * _Value); 
#line 51 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stddef.h"
__declspec(dllimport) extern unsigned long __cdecl __threadid(); 
#line 53
__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(); 
#line 57
}__pragma( pack ( pop )) 
#line 189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 189
enum cudaError { 
#line 196
cudaSuccess, 
#line 202
cudaErrorInvalidValue, 
#line 208
cudaErrorMemoryAllocation, 
#line 214
cudaErrorInitializationError, 
#line 221
cudaErrorCudartUnloading, 
#line 228
cudaErrorProfilerDisabled, 
#line 236
cudaErrorProfilerNotInitialized, 
#line 243
cudaErrorProfilerAlreadyStarted, 
#line 250
cudaErrorProfilerAlreadyStopped, 
#line 259
cudaErrorInvalidConfiguration, 
#line 265
cudaErrorInvalidPitchValue = 12, 
#line 271
cudaErrorInvalidSymbol, 
#line 279
cudaErrorInvalidHostPointer = 16, 
#line 287
cudaErrorInvalidDevicePointer, 
#line 293
cudaErrorInvalidTexture, 
#line 299
cudaErrorInvalidTextureBinding, 
#line 306
cudaErrorInvalidChannelDescriptor, 
#line 312
cudaErrorInvalidMemcpyDirection, 
#line 322
cudaErrorAddressOfConstant, 
#line 331
cudaErrorTextureFetchFailed, 
#line 340
cudaErrorTextureNotBound, 
#line 349
cudaErrorSynchronizationError, 
#line 355
cudaErrorInvalidFilterSetting, 
#line 361
cudaErrorInvalidNormSetting, 
#line 369
cudaErrorMixedDeviceExecution, 
#line 377
cudaErrorNotYetImplemented = 31, 
#line 386
cudaErrorMemoryValueTooLarge, 
#line 393
cudaErrorInsufficientDriver = 35, 
#line 399
cudaErrorInvalidSurface = 37, 
#line 405
cudaErrorDuplicateVariableName = 43, 
#line 411
cudaErrorDuplicateTextureName, 
#line 417
cudaErrorDuplicateSurfaceName, 
#line 427
cudaErrorDevicesUnavailable, 
#line 440
cudaErrorIncompatibleDriverContext = 49, 
#line 446
cudaErrorMissingConfiguration = 52, 
#line 455
cudaErrorPriorLaunchFailure, 
#line 462
cudaErrorLaunchMaxDepthExceeded = 65, 
#line 470
cudaErrorLaunchFileScopedTex, 
#line 478
cudaErrorLaunchFileScopedSurf, 
#line 493
cudaErrorSyncDepthExceeded, 
#line 505
cudaErrorLaunchPendingCountExceeded, 
#line 511
cudaErrorInvalidDeviceFunction = 98, 
#line 517
cudaErrorNoDevice = 100, 
#line 523
cudaErrorInvalidDevice, 
#line 528
cudaErrorStartupFailure = 127, 
#line 533
cudaErrorInvalidKernelImage = 200, 
#line 543
cudaErrorDeviceUninitilialized, 
#line 548
cudaErrorMapBufferObjectFailed = 205, 
#line 553
cudaErrorUnmapBufferObjectFailed, 
#line 559
cudaErrorArrayIsMapped, 
#line 564
cudaErrorAlreadyMapped, 
#line 572
cudaErrorNoKernelImageForDevice, 
#line 577
cudaErrorAlreadyAcquired, 
#line 582
cudaErrorNotMapped, 
#line 588
cudaErrorNotMappedAsArray, 
#line 594
cudaErrorNotMappedAsPointer, 
#line 600
cudaErrorECCUncorrectable, 
#line 606
cudaErrorUnsupportedLimit, 
#line 612
cudaErrorDeviceAlreadyInUse, 
#line 618
cudaErrorPeerAccessUnsupported, 
#line 624
cudaErrorInvalidPtx, 
#line 629
cudaErrorInvalidGraphicsContext, 
#line 635
cudaErrorNvlinkUncorrectable, 
#line 642
cudaErrorJitCompilerNotFound, 
#line 647
cudaErrorInvalidSource = 300, 
#line 652
cudaErrorFileNotFound, 
#line 657
cudaErrorSharedObjectSymbolNotFound, 
#line 662
cudaErrorSharedObjectInitFailed, 
#line 667
cudaErrorOperatingSystem, 
#line 674
cudaErrorInvalidResourceHandle = 400, 
#line 680
cudaErrorIllegalState, 
#line 686
cudaErrorSymbolNotFound = 500, 
#line 694
cudaErrorNotReady = 600, 
#line 702
cudaErrorIllegalAddress = 700, 
#line 711
cudaErrorLaunchOutOfResources, 
#line 722
cudaErrorLaunchTimeout, 
#line 728
cudaErrorLaunchIncompatibleTexturing, 
#line 735
cudaErrorPeerAccessAlreadyEnabled, 
#line 742
cudaErrorPeerAccessNotEnabled, 
#line 755
cudaErrorSetOnActiveProcess = 708, 
#line 762
cudaErrorContextIsDestroyed, 
#line 769
cudaErrorAssert, 
#line 776
cudaErrorTooManyPeers, 
#line 782
cudaErrorHostMemoryAlreadyRegistered, 
#line 788
cudaErrorHostMemoryNotRegistered, 
#line 797
cudaErrorHardwareStackError, 
#line 805
cudaErrorIllegalInstruction, 
#line 814
cudaErrorMisalignedAddress, 
#line 825
cudaErrorInvalidAddressSpace, 
#line 833
cudaErrorInvalidPc, 
#line 844
cudaErrorLaunchFailure, 
#line 853
cudaErrorCooperativeLaunchTooLarge, 
#line 858
cudaErrorNotPermitted = 800, 
#line 864
cudaErrorNotSupported, 
#line 873
cudaErrorSystemNotReady, 
#line 880
cudaErrorSystemDriverMismatch, 
#line 889
cudaErrorCompatNotSupportedOnDevice, 
#line 894
cudaErrorStreamCaptureUnsupported = 900, 
#line 900
cudaErrorStreamCaptureInvalidated, 
#line 906
cudaErrorStreamCaptureMerge, 
#line 911
cudaErrorStreamCaptureUnmatched, 
#line 917
cudaErrorStreamCaptureUnjoined, 
#line 924
cudaErrorStreamCaptureIsolation, 
#line 930
cudaErrorStreamCaptureImplicit, 
#line 936
cudaErrorCapturedEvent, 
#line 943
cudaErrorStreamCaptureWrongThread, 
#line 948
cudaErrorUnknown = 999, 
#line 956
cudaErrorApiFailureBase = 10000
#line 957
}; 
#endif
#line 962 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 962
enum cudaChannelFormatKind { 
#line 964
cudaChannelFormatKindSigned, 
#line 965
cudaChannelFormatKindUnsigned, 
#line 966
cudaChannelFormatKindFloat, 
#line 967
cudaChannelFormatKindNone
#line 968
}; 
#endif
#line 973 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 973
struct cudaChannelFormatDesc { 
#line 975
int x; 
#line 976
int y; 
#line 977
int z; 
#line 978
int w; 
#line 979
cudaChannelFormatKind f; 
#line 980
}; 
#endif
#line 985 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
typedef struct cudaArray *cudaArray_t; 
#line 990
typedef const cudaArray *cudaArray_const_t; 
#line 992
struct cudaArray; 
#line 997
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
#line 1002
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
#line 1004
struct cudaMipmappedArray; 
#line 1009
#if 0
#line 1009
enum cudaMemoryType { 
#line 1011
cudaMemoryTypeUnregistered, 
#line 1012
cudaMemoryTypeHost, 
#line 1013
cudaMemoryTypeDevice, 
#line 1014
cudaMemoryTypeManaged
#line 1015
}; 
#endif
#line 1020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1020
enum cudaMemcpyKind { 
#line 1022
cudaMemcpyHostToHost, 
#line 1023
cudaMemcpyHostToDevice, 
#line 1024
cudaMemcpyDeviceToHost, 
#line 1025
cudaMemcpyDeviceToDevice, 
#line 1026
cudaMemcpyDefault
#line 1027
}; 
#endif
#line 1034 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1034
struct cudaPitchedPtr { 
#line 1036
void *ptr; 
#line 1037
size_t pitch; 
#line 1038
size_t xsize; 
#line 1039
size_t ysize; 
#line 1040
}; 
#endif
#line 1047 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1047
struct cudaExtent { 
#line 1049
size_t width; 
#line 1050
size_t height; 
#line 1051
size_t depth; 
#line 1052
}; 
#endif
#line 1059 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1059
struct cudaPos { 
#line 1061
size_t x; 
#line 1062
size_t y; 
#line 1063
size_t z; 
#line 1064
}; 
#endif
#line 1069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1069
struct cudaMemcpy3DParms { 
#line 1071
cudaArray_t srcArray; 
#line 1072
cudaPos srcPos; 
#line 1073
cudaPitchedPtr srcPtr; 
#line 1075
cudaArray_t dstArray; 
#line 1076
cudaPos dstPos; 
#line 1077
cudaPitchedPtr dstPtr; 
#line 1079
cudaExtent extent; 
#line 1080
cudaMemcpyKind kind; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1081
}; 
#endif
#line 1086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1086
struct cudaMemcpy3DPeerParms { 
#line 1088
cudaArray_t srcArray; 
#line 1089
cudaPos srcPos; 
#line 1090
cudaPitchedPtr srcPtr; 
#line 1091
int srcDevice; 
#line 1093
cudaArray_t dstArray; 
#line 1094
cudaPos dstPos; 
#line 1095
cudaPitchedPtr dstPtr; 
#line 1096
int dstDevice; 
#line 1098
cudaExtent extent; 
#line 1099
}; 
#endif
#line 1104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1104
struct cudaMemsetParams { 
#line 1105
void *dst; 
#line 1106
size_t pitch; 
#line 1107
unsigned value; 
#line 1108
unsigned elementSize; 
#line 1109
size_t width; 
#line 1110
size_t height; 
#line 1111
}; 
#endif
#line 1123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
typedef void (__stdcall *cudaHostFn_t)(void * userData); 
#line 1128
#if 0
#line 1128
struct cudaHostNodeParams { 
#line 1129
cudaHostFn_t fn; 
#line 1130
void *userData; 
#line 1131
}; 
#endif
#line 1136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1136
enum cudaStreamCaptureStatus { 
#line 1137
cudaStreamCaptureStatusNone, 
#line 1138
cudaStreamCaptureStatusActive, 
#line 1139
cudaStreamCaptureStatusInvalidated
#line 1141
}; 
#endif
#line 1147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1147
enum cudaStreamCaptureMode { 
#line 1148
cudaStreamCaptureModeGlobal, 
#line 1149
cudaStreamCaptureModeThreadLocal, 
#line 1150
cudaStreamCaptureModeRelaxed
#line 1151
}; 
#endif
#line 1156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
struct cudaGraphicsResource; 
#line 1161
#if 0
#line 1161
enum cudaGraphicsRegisterFlags { 
#line 1163
cudaGraphicsRegisterFlagsNone, 
#line 1164
cudaGraphicsRegisterFlagsReadOnly, 
#line 1165
cudaGraphicsRegisterFlagsWriteDiscard, 
#line 1166
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
#line 1167
cudaGraphicsRegisterFlagsTextureGather = 8
#line 1168
}; 
#endif
#line 1173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1173
enum cudaGraphicsMapFlags { 
#line 1175
cudaGraphicsMapFlagsNone, 
#line 1176
cudaGraphicsMapFlagsReadOnly, 
#line 1177
cudaGraphicsMapFlagsWriteDiscard
#line 1178
}; 
#endif
#line 1183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1183
enum cudaGraphicsCubeFace { 
#line 1185
cudaGraphicsCubeFacePositiveX, 
#line 1186
cudaGraphicsCubeFaceNegativeX, 
#line 1187
cudaGraphicsCubeFacePositiveY, 
#line 1188
cudaGraphicsCubeFaceNegativeY, 
#line 1189
cudaGraphicsCubeFacePositiveZ, 
#line 1190
cudaGraphicsCubeFaceNegativeZ
#line 1191
}; 
#endif
#line 1196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1196
enum cudaResourceType { 
#line 1198
cudaResourceTypeArray, 
#line 1199
cudaResourceTypeMipmappedArray, 
#line 1200
cudaResourceTypeLinear, 
#line 1201
cudaResourceTypePitch2D
#line 1202
}; 
#endif
#line 1207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1207
enum cudaResourceViewFormat { 
#line 1209
cudaResViewFormatNone, 
#line 1210
cudaResViewFormatUnsignedChar1, 
#line 1211
cudaResViewFormatUnsignedChar2, 
#line 1212
cudaResViewFormatUnsignedChar4, 
#line 1213
cudaResViewFormatSignedChar1, 
#line 1214
cudaResViewFormatSignedChar2, 
#line 1215
cudaResViewFormatSignedChar4, 
#line 1216
cudaResViewFormatUnsignedShort1, 
#line 1217
cudaResViewFormatUnsignedShort2, 
#line 1218
cudaResViewFormatUnsignedShort4, 
#line 1219
cudaResViewFormatSignedShort1, 
#line 1220
cudaResViewFormatSignedShort2, 
#line 1221
cudaResViewFormatSignedShort4, 
#line 1222
cudaResViewFormatUnsignedInt1, 
#line 1223
cudaResViewFormatUnsignedInt2, 
#line 1224
cudaResViewFormatUnsignedInt4, 
#line 1225
cudaResViewFormatSignedInt1, 
#line 1226
cudaResViewFormatSignedInt2, 
#line 1227
cudaResViewFormatSignedInt4, 
#line 1228
cudaResViewFormatHalf1, 
#line 1229
cudaResViewFormatHalf2, 
#line 1230
cudaResViewFormatHalf4, 
#line 1231
cudaResViewFormatFloat1, 
#line 1232
cudaResViewFormatFloat2, 
#line 1233
cudaResViewFormatFloat4, 
#line 1234
cudaResViewFormatUnsignedBlockCompressed1, 
#line 1235
cudaResViewFormatUnsignedBlockCompressed2, 
#line 1236
cudaResViewFormatUnsignedBlockCompressed3, 
#line 1237
cudaResViewFormatUnsignedBlockCompressed4, 
#line 1238
cudaResViewFormatSignedBlockCompressed4, 
#line 1239
cudaResViewFormatUnsignedBlockCompressed5, 
#line 1240
cudaResViewFormatSignedBlockCompressed5, 
#line 1241
cudaResViewFormatUnsignedBlockCompressed6H, 
#line 1242
cudaResViewFormatSignedBlockCompressed6H, 
#line 1243
cudaResViewFormatUnsignedBlockCompressed7
#line 1244
}; 
#endif
#line 1249 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1249
struct cudaResourceDesc { 
#line 1250
cudaResourceType resType; 
#line 1252
union { 
#line 1253
struct { 
#line 1254
cudaArray_t array; 
#line 1255
} array; 
#line 1256
struct { 
#line 1257
cudaMipmappedArray_t mipmap; 
#line 1258
} mipmap; 
#line 1259
struct { 
#line 1260
void *devPtr; 
#line 1261
cudaChannelFormatDesc desc; 
#line 1262
size_t sizeInBytes; 
#line 1263
} linear; 
#line 1264
struct { 
#line 1265
void *devPtr; 
#line 1266
cudaChannelFormatDesc desc; 
#line 1267
size_t width; 
#line 1268
size_t height; 
#line 1269
size_t pitchInBytes; 
#line 1270
} pitch2D; 
#line 1271
} res; 
#line 1272
}; 
#endif
#line 1277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1277
struct cudaResourceViewDesc { 
#line 1279
cudaResourceViewFormat format; 
#line 1280
size_t width; 
#line 1281
size_t height; 
#line 1282
size_t depth; 
#line 1283
unsigned firstMipmapLevel; 
#line 1284
unsigned lastMipmapLevel; 
#line 1285
unsigned firstLayer; 
#line 1286
unsigned lastLayer; 
#line 1287
}; 
#endif
#line 1292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1292
struct cudaPointerAttributes { 
#line 1302
__declspec(deprecated) cudaMemoryType memoryType; 
#line 1308
cudaMemoryType type; 
#line 1319
int device; 
#line 1325
void *devicePointer; 
#line 1334
void *hostPointer; 
#line 1341
__declspec(deprecated) int isManaged; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1342
}; 
#endif
#line 1347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1347
struct cudaFuncAttributes { 
#line 1354
size_t sharedSizeBytes; 
#line 1360
size_t constSizeBytes; 
#line 1365
size_t localSizeBytes; 
#line 1372
int maxThreadsPerBlock; 
#line 1377
int numRegs; 
#line 1384
int ptxVersion; 
#line 1391
int binaryVersion; 
#line 1397
int cacheModeCA; 
#line 1404
int maxDynamicSharedSizeBytes; 
#line 1413
int preferredShmemCarveout; 
#line 1414
}; 
#endif
#line 1419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1419
enum cudaFuncAttribute { 
#line 1421
cudaFuncAttributeMaxDynamicSharedMemorySize = 8, 
#line 1422
cudaFuncAttributePreferredSharedMemoryCarveout, 
#line 1423
cudaFuncAttributeMax
#line 1424
}; 
#endif
#line 1429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1429
enum cudaFuncCache { 
#line 1431
cudaFuncCachePreferNone, 
#line 1432
cudaFuncCachePreferShared, 
#line 1433
cudaFuncCachePreferL1, 
#line 1434
cudaFuncCachePreferEqual
#line 1435
}; 
#endif
#line 1441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1441
enum cudaSharedMemConfig { 
#line 1443
cudaSharedMemBankSizeDefault, 
#line 1444
cudaSharedMemBankSizeFourByte, 
#line 1445
cudaSharedMemBankSizeEightByte
#line 1446
}; 
#endif
#line 1451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1451
enum cudaSharedCarveout { 
#line 1452
cudaSharedmemCarveoutDefault = (-1), 
#line 1453
cudaSharedmemCarveoutMaxShared = 100, 
#line 1454
cudaSharedmemCarveoutMaxL1 = 0
#line 1455
}; 
#endif
#line 1460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1460
enum cudaComputeMode { 
#line 1462
cudaComputeModeDefault, 
#line 1463
cudaComputeModeExclusive, 
#line 1464
cudaComputeModeProhibited, 
#line 1465
cudaComputeModeExclusiveProcess
#line 1466
}; 
#endif
#line 1471 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1471
enum cudaLimit { 
#line 1473
cudaLimitStackSize, 
#line 1474
cudaLimitPrintfFifoSize, 
#line 1475
cudaLimitMallocHeapSize, 
#line 1476
cudaLimitDevRuntimeSyncDepth, 
#line 1477
cudaLimitDevRuntimePendingLaunchCount, 
#line 1478
cudaLimitMaxL2FetchGranularity
#line 1479
}; 
#endif
#line 1484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1484
enum cudaMemoryAdvise { 
#line 1486
cudaMemAdviseSetReadMostly = 1, 
#line 1487
cudaMemAdviseUnsetReadMostly, 
#line 1488
cudaMemAdviseSetPreferredLocation, 
#line 1489
cudaMemAdviseUnsetPreferredLocation, 
#line 1490
cudaMemAdviseSetAccessedBy, 
#line 1491
cudaMemAdviseUnsetAccessedBy
#line 1492
}; 
#endif
#line 1497 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1497
enum cudaMemRangeAttribute { 
#line 1499
cudaMemRangeAttributeReadMostly = 1, 
#line 1500
cudaMemRangeAttributePreferredLocation, 
#line 1501
cudaMemRangeAttributeAccessedBy, 
#line 1502
cudaMemRangeAttributeLastPrefetchLocation
#line 1503
}; 
#endif
#line 1508 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1508
enum cudaOutputMode { 
#line 1510
cudaKeyValuePair, 
#line 1511
cudaCSV
#line 1512
}; 
#endif
#line 1517 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1517
enum cudaDeviceAttr { 
#line 1519
cudaDevAttrMaxThreadsPerBlock = 1, 
#line 1520
cudaDevAttrMaxBlockDimX, 
#line 1521
cudaDevAttrMaxBlockDimY, 
#line 1522
cudaDevAttrMaxBlockDimZ, 
#line 1523
cudaDevAttrMaxGridDimX, 
#line 1524
cudaDevAttrMaxGridDimY, 
#line 1525
cudaDevAttrMaxGridDimZ, 
#line 1526
cudaDevAttrMaxSharedMemoryPerBlock, 
#line 1527
cudaDevAttrTotalConstantMemory, 
#line 1528
cudaDevAttrWarpSize, 
#line 1529
cudaDevAttrMaxPitch, 
#line 1530
cudaDevAttrMaxRegistersPerBlock, 
#line 1531
cudaDevAttrClockRate, 
#line 1532
cudaDevAttrTextureAlignment, 
#line 1533
cudaDevAttrGpuOverlap, 
#line 1534
cudaDevAttrMultiProcessorCount, 
#line 1535
cudaDevAttrKernelExecTimeout, 
#line 1536
cudaDevAttrIntegrated, 
#line 1537
cudaDevAttrCanMapHostMemory, 
#line 1538
cudaDevAttrComputeMode, 
#line 1539
cudaDevAttrMaxTexture1DWidth, 
#line 1540
cudaDevAttrMaxTexture2DWidth, 
#line 1541
cudaDevAttrMaxTexture2DHeight, 
#line 1542
cudaDevAttrMaxTexture3DWidth, 
#line 1543
cudaDevAttrMaxTexture3DHeight, 
#line 1544
cudaDevAttrMaxTexture3DDepth, 
#line 1545
cudaDevAttrMaxTexture2DLayeredWidth, 
#line 1546
cudaDevAttrMaxTexture2DLayeredHeight, 
#line 1547
cudaDevAttrMaxTexture2DLayeredLayers, 
#line 1548
cudaDevAttrSurfaceAlignment, 
#line 1549
cudaDevAttrConcurrentKernels, 
#line 1550
cudaDevAttrEccEnabled, 
#line 1551
cudaDevAttrPciBusId, 
#line 1552
cudaDevAttrPciDeviceId, 
#line 1553
cudaDevAttrTccDriver, 
#line 1554
cudaDevAttrMemoryClockRate, 
#line 1555
cudaDevAttrGlobalMemoryBusWidth, 
#line 1556
cudaDevAttrL2CacheSize, 
#line 1557
cudaDevAttrMaxThreadsPerMultiProcessor, 
#line 1558
cudaDevAttrAsyncEngineCount, 
#line 1559
cudaDevAttrUnifiedAddressing, 
#line 1560
cudaDevAttrMaxTexture1DLayeredWidth, 
#line 1561
cudaDevAttrMaxTexture1DLayeredLayers, 
#line 1562
cudaDevAttrMaxTexture2DGatherWidth = 45, 
#line 1563
cudaDevAttrMaxTexture2DGatherHeight, 
#line 1564
cudaDevAttrMaxTexture3DWidthAlt, 
#line 1565
cudaDevAttrMaxTexture3DHeightAlt, 
#line 1566
cudaDevAttrMaxTexture3DDepthAlt, 
#line 1567
cudaDevAttrPciDomainId, 
#line 1568
cudaDevAttrTexturePitchAlignment, 
#line 1569
cudaDevAttrMaxTextureCubemapWidth, 
#line 1570
cudaDevAttrMaxTextureCubemapLayeredWidth, 
#line 1571
cudaDevAttrMaxTextureCubemapLayeredLayers, 
#line 1572
cudaDevAttrMaxSurface1DWidth, 
#line 1573
cudaDevAttrMaxSurface2DWidth, 
#line 1574
cudaDevAttrMaxSurface2DHeight, 
#line 1575
cudaDevAttrMaxSurface3DWidth, 
#line 1576
cudaDevAttrMaxSurface3DHeight, 
#line 1577
cudaDevAttrMaxSurface3DDepth, 
#line 1578
cudaDevAttrMaxSurface1DLayeredWidth, 
#line 1579
cudaDevAttrMaxSurface1DLayeredLayers, 
#line 1580
cudaDevAttrMaxSurface2DLayeredWidth, 
#line 1581
cudaDevAttrMaxSurface2DLayeredHeight, 
#line 1582
cudaDevAttrMaxSurface2DLayeredLayers, 
#line 1583
cudaDevAttrMaxSurfaceCubemapWidth, 
#line 1584
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
#line 1585
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
#line 1586
cudaDevAttrMaxTexture1DLinearWidth, 
#line 1587
cudaDevAttrMaxTexture2DLinearWidth, 
#line 1588
cudaDevAttrMaxTexture2DLinearHeight, 
#line 1589
cudaDevAttrMaxTexture2DLinearPitch, 
#line 1590
cudaDevAttrMaxTexture2DMipmappedWidth, 
#line 1591
cudaDevAttrMaxTexture2DMipmappedHeight, 
#line 1592
cudaDevAttrComputeCapabilityMajor, 
#line 1593
cudaDevAttrComputeCapabilityMinor, 
#line 1594
cudaDevAttrMaxTexture1DMipmappedWidth, 
#line 1595
cudaDevAttrStreamPrioritiesSupported, 
#line 1596
cudaDevAttrGlobalL1CacheSupported, 
#line 1597
cudaDevAttrLocalL1CacheSupported, 
#line 1598
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
#line 1599
cudaDevAttrMaxRegistersPerMultiprocessor, 
#line 1600
cudaDevAttrManagedMemory, 
#line 1601
cudaDevAttrIsMultiGpuBoard, 
#line 1602
cudaDevAttrMultiGpuBoardGroupID, 
#line 1603
cudaDevAttrHostNativeAtomicSupported, 
#line 1604
cudaDevAttrSingleToDoublePrecisionPerfRatio, 
#line 1605
cudaDevAttrPageableMemoryAccess, 
#line 1606
cudaDevAttrConcurrentManagedAccess, 
#line 1607
cudaDevAttrComputePreemptionSupported, 
#line 1608
cudaDevAttrCanUseHostPointerForRegisteredMem, 
#line 1609
cudaDevAttrReserved92, 
#line 1610
cudaDevAttrReserved93, 
#line 1611
cudaDevAttrReserved94, 
#line 1612
cudaDevAttrCooperativeLaunch, 
#line 1613
cudaDevAttrCooperativeMultiDeviceLaunch, 
#line 1614
cudaDevAttrMaxSharedMemoryPerBlockOptin, 
#line 1615
cudaDevAttrCanFlushRemoteWrites, 
#line 1616
cudaDevAttrHostRegisterSupported, 
#line 1617
cudaDevAttrPageableMemoryAccessUsesHostPageTables, 
#line 1618
cudaDevAttrDirectManagedMemAccessFromHost
#line 1619
}; 
#endif
#line 1625 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1625
enum cudaDeviceP2PAttr { 
#line 1626
cudaDevP2PAttrPerformanceRank = 1, 
#line 1627
cudaDevP2PAttrAccessSupported, 
#line 1628
cudaDevP2PAttrNativeAtomicSupported, 
#line 1629
cudaDevP2PAttrCudaArrayAccessSupported
#line 1630
}; 
#endif
#line 1637 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1637
struct CUuuid_st { 
#line 1638
char bytes[16]; 
#line 1639
}; 
#endif
#line 1640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef CUuuid_st 
#line 1640
CUuuid; 
#endif
#line 1642 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef CUuuid_st 
#line 1642
cudaUUID_t; 
#endif
#line 1647 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1647
struct cudaDeviceProp { 
#line 1649
char name[256]; 
#line 1650
cudaUUID_t uuid; 
#line 1651
char luid[8]; 
#line 1652
unsigned luidDeviceNodeMask; 
#line 1653
size_t totalGlobalMem; 
#line 1654
size_t sharedMemPerBlock; 
#line 1655
int regsPerBlock; 
#line 1656
int warpSize; 
#line 1657
size_t memPitch; 
#line 1658
int maxThreadsPerBlock; 
#line 1659
int maxThreadsDim[3]; 
#line 1660
int maxGridSize[3]; 
#line 1661
int clockRate; 
#line 1662
size_t totalConstMem; 
#line 1663
int major; 
#line 1664
int minor; 
#line 1665
size_t textureAlignment; 
#line 1666
size_t texturePitchAlignment; 
#line 1667
int deviceOverlap; 
#line 1668
int multiProcessorCount; 
#line 1669
int kernelExecTimeoutEnabled; 
#line 1670
int integrated; 
#line 1671
int canMapHostMemory; 
#line 1672
int computeMode; 
#line 1673
int maxTexture1D; 
#line 1674
int maxTexture1DMipmap; 
#line 1675
int maxTexture1DLinear; 
#line 1676
int maxTexture2D[2]; 
#line 1677
int maxTexture2DMipmap[2]; 
#line 1678
int maxTexture2DLinear[3]; 
#line 1679
int maxTexture2DGather[2]; 
#line 1680
int maxTexture3D[3]; 
#line 1681
int maxTexture3DAlt[3]; 
#line 1682
int maxTextureCubemap; 
#line 1683
int maxTexture1DLayered[2]; 
#line 1684
int maxTexture2DLayered[3]; 
#line 1685
int maxTextureCubemapLayered[2]; 
#line 1686
int maxSurface1D; 
#line 1687
int maxSurface2D[2]; 
#line 1688
int maxSurface3D[3]; 
#line 1689
int maxSurface1DLayered[2]; 
#line 1690
int maxSurface2DLayered[3]; 
#line 1691
int maxSurfaceCubemap; 
#line 1692
int maxSurfaceCubemapLayered[2]; 
#line 1693
size_t surfaceAlignment; 
#line 1694
int concurrentKernels; 
#line 1695
int ECCEnabled; 
#line 1696
int pciBusID; 
#line 1697
int pciDeviceID; 
#line 1698
int pciDomainID; 
#line 1699
int tccDriver; 
#line 1700
int asyncEngineCount; 
#line 1701
int unifiedAddressing; 
#line 1702
int memoryClockRate; 
#line 1703
int memoryBusWidth; 
#line 1704
int l2CacheSize; 
#line 1705
int maxThreadsPerMultiProcessor; 
#line 1706
int streamPrioritiesSupported; 
#line 1707
int globalL1CacheSupported; 
#line 1708
int localL1CacheSupported; 
#line 1709
size_t sharedMemPerMultiprocessor; 
#line 1710
int regsPerMultiprocessor; 
#line 1711
int managedMemory; 
#line 1712
int isMultiGpuBoard; 
#line 1713
int multiGpuBoardGroupID; 
#line 1714
int hostNativeAtomicSupported; 
#line 1715
int singleToDoublePrecisionPerfRatio; 
#line 1716
int pageableMemoryAccess; 
#line 1717
int concurrentManagedAccess; 
#line 1718
int computePreemptionSupported; 
#line 1719
int canUseHostPointerForRegisteredMem; 
#line 1720
int cooperativeLaunch; 
#line 1721
int cooperativeMultiDeviceLaunch; 
#line 1722
size_t sharedMemPerBlockOptin; 
#line 1723
int pageableMemoryAccessUsesHostPageTables; 
#line 1724
int directManagedMemAccessFromHost; 
#line 1725
}; 
#endif
#line 1818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef 
#line 1815
struct cudaIpcEventHandle_st { 
#line 1817
char reserved[64]; 
#line 1818
} cudaIpcEventHandle_t; 
#endif
#line 1826 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef 
#line 1823
struct cudaIpcMemHandle_st { 
#line 1825
char reserved[64]; 
#line 1826
} cudaIpcMemHandle_t; 
#endif
#line 1831 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1831
enum cudaExternalMemoryHandleType { 
#line 1835
cudaExternalMemoryHandleTypeOpaqueFd = 1, 
#line 1839
cudaExternalMemoryHandleTypeOpaqueWin32, 
#line 1843
cudaExternalMemoryHandleTypeOpaqueWin32Kmt, 
#line 1847
cudaExternalMemoryHandleTypeD3D12Heap, 
#line 1851
cudaExternalMemoryHandleTypeD3D12Resource
#line 1852
}; 
#endif
#line 1862 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1862
struct cudaExternalMemoryHandleDesc { 
#line 1866
cudaExternalMemoryHandleType type; 
#line 1867
union { 
#line 1873
int fd; 
#line 1885
struct { 
#line 1889
void *handle; 
#line 1894
const void *name; 
#line 1895
} win32; 
#line 1896
} handle; 
#line 1900
unsigned __int64 size; 
#line 1904
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 1905
}; 
#endif
#line 1910 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1910
struct cudaExternalMemoryBufferDesc { 
#line 1914
unsigned __int64 offset; 
#line 1918
unsigned __int64 size; 
#line 1922
unsigned flags; 
#line 1923
}; 
#endif
#line 1928 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1928
struct cudaExternalMemoryMipmappedArrayDesc { 
#line 1933
unsigned __int64 offset; 
#line 1937
cudaChannelFormatDesc formatDesc; 
#line 1941
cudaExtent extent; 
#line 1946
unsigned flags; 
#line 1950
unsigned numLevels; 
#line 1951
}; 
#endif
#line 1956 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1956
enum cudaExternalSemaphoreHandleType { 
#line 1960
cudaExternalSemaphoreHandleTypeOpaqueFd = 1, 
#line 1964
cudaExternalSemaphoreHandleTypeOpaqueWin32, 
#line 1968
cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt, 
#line 1972
cudaExternalSemaphoreHandleTypeD3D12Fence
#line 1973
}; 
#endif
#line 1978 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 1978
struct cudaExternalSemaphoreHandleDesc { 
#line 1982
cudaExternalSemaphoreHandleType type; 
#line 1983
union { 
#line 1988
int fd; 
#line 1999
struct { 
#line 2003
void *handle; 
#line 2008
const void *name; 
#line 2009
} win32; 
#line 2010
} handle; 
#line 2014
unsigned flags; __pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)__pad__(volatile char:8;)
#line 2015
}; 
#endif
#line 2020 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 2020
struct cudaExternalSemaphoreSignalParams { 
#line 2021
union { 
#line 2025
struct { 
#line 2029
unsigned __int64 value; 
#line 2030
} fence; 
#line 2031
} params; 
#line 2035
unsigned flags; 
#line 2036
}; 
#endif
#line 2041 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 2041
struct cudaExternalSemaphoreWaitParams { 
#line 2042
union { 
#line 2046
struct { 
#line 2050
unsigned __int64 value; 
#line 2051
} fence; 
#line 2052
} params; 
#line 2056
unsigned flags; 
#line 2057
}; 
#endif
#line 2069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef cudaError 
#line 2069
cudaError_t; 
#endif
#line 2074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef struct CUstream_st *
#line 2074
cudaStream_t; 
#endif
#line 2079 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef struct CUevent_st *
#line 2079
cudaEvent_t; 
#endif
#line 2084 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef cudaGraphicsResource *
#line 2084
cudaGraphicsResource_t; 
#endif
#line 2089 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef cudaOutputMode 
#line 2089
cudaOutputMode_t; 
#endif
#line 2094 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef struct CUexternalMemory_st *
#line 2094
cudaExternalMemory_t; 
#endif
#line 2099 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef struct CUexternalSemaphore_st *
#line 2099
cudaExternalSemaphore_t; 
#endif
#line 2104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef struct CUgraph_st *
#line 2104
cudaGraph_t; 
#endif
#line 2109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
typedef struct CUgraphNode_st *
#line 2109
cudaGraphNode_t; 
#endif
#line 2114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 2114
enum cudaCGScope { 
#line 2115
cudaCGScopeInvalid, 
#line 2116
cudaCGScopeGrid, 
#line 2117
cudaCGScopeMultiGrid
#line 2118
}; 
#endif
#line 2123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 2123
struct cudaLaunchParams { 
#line 2125
void *func; 
#line 2126
dim3 gridDim; 
#line 2127
dim3 blockDim; 
#line 2128
void **args; 
#line 2129
size_t sharedMem; 
#line 2130
cudaStream_t stream; 
#line 2131
}; 
#endif
#line 2136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 2136
struct cudaKernelNodeParams { 
#line 2137
void *func; 
#line 2138
dim3 gridDim; 
#line 2139
dim3 blockDim; 
#line 2140
unsigned sharedMemBytes; 
#line 2141
void **kernelParams; 
#line 2142
void **extra; 
#line 2143
}; 
#endif
#line 2148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
#if 0
#line 2148
enum cudaGraphNodeType { 
#line 2149
cudaGraphNodeTypeKernel, 
#line 2150
cudaGraphNodeTypeMemcpy, 
#line 2151
cudaGraphNodeTypeMemset, 
#line 2152
cudaGraphNodeTypeHost, 
#line 2153
cudaGraphNodeTypeGraph, 
#line 2154
cudaGraphNodeTypeEmpty, 
#line 2155
cudaGraphNodeTypeCount
#line 2156
}; 
#endif
#line 2161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_types.h"
typedef struct CUgraphExec_st *cudaGraphExec_t; 
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_types.h"
#if 0
#line 84
enum cudaSurfaceBoundaryMode { 
#line 86
cudaBoundaryModeZero, 
#line 87
cudaBoundaryModeClamp, 
#line 88
cudaBoundaryModeTrap
#line 89
}; 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_types.h"
#if 0
#line 94
enum cudaSurfaceFormatMode { 
#line 96
cudaFormatModeForced, 
#line 97
cudaFormatModeAuto
#line 98
}; 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_types.h"
#if 0
#line 103
struct surfaceReference { 
#line 108
cudaChannelFormatDesc channelDesc; 
#line 109
}; 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_types.h"
#if 0
typedef unsigned __int64 
#line 114
cudaSurfaceObject_t; 
#endif
#line 84 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_types.h"
#if 0
#line 84
enum cudaTextureAddressMode { 
#line 86
cudaAddressModeWrap, 
#line 87
cudaAddressModeClamp, 
#line 88
cudaAddressModeMirror, 
#line 89
cudaAddressModeBorder
#line 90
}; 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_types.h"
#if 0
#line 95
enum cudaTextureFilterMode { 
#line 97
cudaFilterModePoint, 
#line 98
cudaFilterModeLinear
#line 99
}; 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_types.h"
#if 0
#line 104
enum cudaTextureReadMode { 
#line 106
cudaReadModeElementType, 
#line 107
cudaReadModeNormalizedFloat
#line 108
}; 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_types.h"
#if 0
#line 113
struct textureReference { 
#line 118
int normalized; 
#line 122
cudaTextureFilterMode filterMode; 
#line 126
cudaTextureAddressMode addressMode[3]; 
#line 130
cudaChannelFormatDesc channelDesc; 
#line 134
int sRGB; 
#line 138
unsigned maxAnisotropy; 
#line 142
cudaTextureFilterMode mipmapFilterMode; 
#line 146
float mipmapLevelBias; 
#line 150
float minMipmapLevelClamp; 
#line 154
float maxMipmapLevelClamp; 
#line 155
int __cudaReserved[15]; 
#line 156
}; 
#endif
#line 161 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_types.h"
#if 0
#line 161
struct cudaTextureDesc { 
#line 166
cudaTextureAddressMode addressMode[3]; 
#line 170
cudaTextureFilterMode filterMode; 
#line 174
cudaTextureReadMode readMode; 
#line 178
int sRGB; 
#line 182
float borderColor[4]; 
#line 186
int normalizedCoords; 
#line 190
unsigned maxAnisotropy; 
#line 194
cudaTextureFilterMode mipmapFilterMode; 
#line 198
float mipmapLevelBias; 
#line 202
float minMipmapLevelClamp; 
#line 206
float maxMipmapLevelClamp; 
#line 207
}; 
#endif
#line 212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_types.h"
#if 0
typedef unsigned __int64 
#line 212
cudaTextureObject_t; 
#endif
#line 70 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\library_types.h"
typedef 
#line 54
enum cudaDataType_t { 
#line 56
CUDA_R_16F = 2, 
#line 57
CUDA_C_16F = 6, 
#line 58
CUDA_R_32F = 0, 
#line 59
CUDA_C_32F = 4, 
#line 60
CUDA_R_64F = 1, 
#line 61
CUDA_C_64F = 5, 
#line 62
CUDA_R_8I = 3, 
#line 63
CUDA_C_8I = 7, 
#line 64
CUDA_R_8U, 
#line 65
CUDA_C_8U, 
#line 66
CUDA_R_32I, 
#line 67
CUDA_C_32I, 
#line 68
CUDA_R_32U, 
#line 69
CUDA_C_32U
#line 70
} cudaDataType; 
#line 78
typedef 
#line 73
enum libraryPropertyType_t { 
#line 75
MAJOR_VERSION, 
#line 76
MINOR_VERSION, 
#line 77
PATCH_LEVEL
#line 78
} libraryPropertyType; 
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_device_runtime_api.h"
extern "C" {
#line 123
extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 124
extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 125
extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 126
extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 127
extern cudaError_t __stdcall cudaDeviceSynchronize(); 
#line 128
extern cudaError_t __stdcall cudaGetLastError(); 
#line 129
extern cudaError_t __stdcall cudaPeekAtLastError(); 
#line 130
extern const char *__stdcall cudaGetErrorString(cudaError_t error); 
#line 131
extern const char *__stdcall cudaGetErrorName(cudaError_t error); 
#line 132
extern cudaError_t __stdcall cudaGetDeviceCount(int * count); 
#line 133
extern cudaError_t __stdcall cudaGetDevice(int * device); 
#line 134
extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 135
extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); 
#line 136
extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 137
extern cudaError_t __stdcall cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 138
extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 139
extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream); 
#line 140
extern cudaError_t __stdcall cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); 
#line 141
extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); 
#line 142
extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 143
extern cudaError_t __stdcall cudaFree(void * devPtr); 
#line 144
extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); 
#line 145
extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 146
extern cudaError_t __stdcall cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); 
#line 147
extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 148
extern cudaError_t __stdcall cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); 
#line 149
extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 150
extern cudaError_t __stdcall cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); 
#line 151
extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 152
extern cudaError_t __stdcall cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); 
#line 153
extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 154
extern cudaError_t __stdcall cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); 
#line 155
extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 156
extern cudaError_t __stdcall cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); 
#line 157
extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); 
#line 178
extern void *__stdcall cudaGetParameterBuffer(size_t alignment, size_t size); 
#line 206
extern void *__stdcall cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); 
#line 207
extern cudaError_t __stdcall cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 208
extern cudaError_t __stdcall cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); 
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); 
#line 227
extern cudaError_t __stdcall cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); 
#line 230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_device_runtime_api.h"
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); 
#line 231
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 233
extern unsigned __int64 __stdcall cudaCGGetIntrinsicHandle(cudaCGScope scope); 
#line 234
extern cudaError_t __stdcall cudaCGSynchronize(unsigned __int64 handle, unsigned flags); 
#line 235
extern cudaError_t __stdcall cudaCGSynchronizeGrid(unsigned __int64 handle, unsigned flags); 
#line 236
extern cudaError_t __stdcall cudaCGGetSize(unsigned * numThreads, unsigned * numGrids, unsigned __int64 handle); 
#line 237
extern cudaError_t __stdcall cudaCGGetRank(unsigned * threadRank, unsigned * gridRank, unsigned __int64 handle); 
#line 238
}
#line 240
template< class T> static __inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
#line 241
template< class T> static __inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
#line 242
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
#line 243
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 245 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_runtime_api.h"
extern "C" {
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_runtime_api.h"
extern cudaError_t __stdcall cudaDeviceReset(); 
#line 301
extern cudaError_t __stdcall cudaDeviceSynchronize(); 
#line 384
extern cudaError_t __stdcall cudaDeviceSetLimit(cudaLimit limit, size_t value); 
#line 418
extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); 
#line 451
extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 488
extern cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); 
#line 532
extern cudaError_t __stdcall cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); 
#line 563
extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); 
#line 607
extern cudaError_t __stdcall cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); 
#line 634
extern cudaError_t __stdcall cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); 
#line 664
extern cudaError_t __stdcall cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); 
#line 711
extern cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); 
#line 751
extern cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); 
#line 794
extern cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); 
#line 852
extern cudaError_t __stdcall cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); 
#line 887
extern cudaError_t __stdcall cudaIpcCloseMemHandle(void * devPtr); 
#line 929
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadExit(); 
#line 955
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSynchronize(); 
#line 1004
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSetLimit(cudaLimit limit, size_t value); 
#line 1037
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadGetLimit(size_t * pValue, cudaLimit limit); 
#line 1073
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); 
#line 1120
__declspec(deprecated) extern cudaError_t __stdcall cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); 
#line 1179
extern cudaError_t __stdcall cudaGetLastError(); 
#line 1225
extern cudaError_t __stdcall cudaPeekAtLastError(); 
#line 1241
extern const char *__stdcall cudaGetErrorName(cudaError_t error); 
#line 1257
extern const char *__stdcall cudaGetErrorString(cudaError_t error); 
#line 1285
extern cudaError_t __stdcall cudaGetDeviceCount(int * count); 
#line 1556
extern cudaError_t __stdcall cudaGetDeviceProperties(cudaDeviceProp * prop, int device); 
#line 1745
extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); 
#line 1785
extern cudaError_t __stdcall cudaDeviceGetP2PAttribute(int * value, cudaDeviceP2PAttr attr, int srcDevice, int dstDevice); 
#line 1806
extern cudaError_t __stdcall cudaChooseDevice(int * device, const cudaDeviceProp * prop); 
#line 1843
extern cudaError_t __stdcall cudaSetDevice(int device); 
#line 1864
extern cudaError_t __stdcall cudaGetDevice(int * device); 
#line 1895
extern cudaError_t __stdcall cudaSetValidDevices(int * device_arr, int len); 
#line 1964
extern cudaError_t __stdcall cudaSetDeviceFlags(unsigned flags); 
#line 2010
extern cudaError_t __stdcall cudaGetDeviceFlags(unsigned * flags); 
#line 2050
extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t * pStream); 
#line 2082
extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); 
#line 2128
extern cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); 
#line 2155
extern cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int * priority); 
#line 2180
extern cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); 
#line 2211
extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); 
#line 2237
extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); 
#line 2245
typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); 
#line 2312
extern cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); 
#line 2336
extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream); 
#line 2361
extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream); 
#line 2444
extern cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length = 0, unsigned flags = 4); 
#line 2480
extern cudaError_t __stdcall cudaStreamBeginCapture(cudaStream_t stream, cudaStreamCaptureMode mode); 
#line 2531
extern cudaError_t __stdcall cudaThreadExchangeStreamCaptureMode(cudaStreamCaptureMode * mode); 
#line 2559
extern cudaError_t __stdcall cudaStreamEndCapture(cudaStream_t stream, cudaGraph_t * pGraph); 
#line 2597
extern cudaError_t __stdcall cudaStreamIsCapturing(cudaStream_t stream, cudaStreamCaptureStatus * pCaptureStatus); 
#line 2625
extern cudaError_t __stdcall cudaStreamGetCaptureInfo(cudaStream_t stream, cudaStreamCaptureStatus * pCaptureStatus, unsigned __int64 * pId); 
#line 2663
extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t * event); 
#line 2700
extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); 
#line 2739
extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); 
#line 2770
extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t event); 
#line 2800
extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event); 
#line 2827
extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); 
#line 2870
extern cudaError_t __stdcall cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); 
#line 3009
extern cudaError_t __stdcall cudaImportExternalMemory(cudaExternalMemory_t * extMem_out, const cudaExternalMemoryHandleDesc * memHandleDesc); 
#line 3063
extern cudaError_t __stdcall cudaExternalMemoryGetMappedBuffer(void ** devPtr, cudaExternalMemory_t extMem, const cudaExternalMemoryBufferDesc * bufferDesc); 
#line 3118
extern cudaError_t __stdcall cudaExternalMemoryGetMappedMipmappedArray(cudaMipmappedArray_t * mipmap, cudaExternalMemory_t extMem, const cudaExternalMemoryMipmappedArrayDesc * mipmapDesc); 
#line 3141
extern cudaError_t __stdcall cudaDestroyExternalMemory(cudaExternalMemory_t extMem); 
#line 3235
extern cudaError_t __stdcall cudaImportExternalSemaphore(cudaExternalSemaphore_t * extSem_out, const cudaExternalSemaphoreHandleDesc * semHandleDesc); 
#line 3274
extern cudaError_t __stdcall cudaSignalExternalSemaphoresAsync(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreSignalParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
#line 3317
extern cudaError_t __stdcall cudaWaitExternalSemaphoresAsync(const cudaExternalSemaphore_t * extSemArray, const cudaExternalSemaphoreWaitParams * paramsArray, unsigned numExtSems, cudaStream_t stream = 0); 
#line 3339
extern cudaError_t __stdcall cudaDestroyExternalSemaphore(cudaExternalSemaphore_t extSem); 
#line 3404
extern cudaError_t __stdcall cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 3461
extern cudaError_t __stdcall cudaLaunchCooperativeKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); 
#line 3560
extern cudaError_t __stdcall cudaLaunchCooperativeKernelMultiDevice(cudaLaunchParams * launchParamsList, unsigned numDevices, unsigned flags = 0); 
#line 3609
extern cudaError_t __stdcall cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); 
#line 3664
extern cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); 
#line 3699
extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); 
#line 3738
extern cudaError_t __stdcall cudaFuncSetAttribute(const void * func, cudaFuncAttribute attr, int value); 
#line 3762
__declspec(deprecated) extern cudaError_t __stdcall cudaSetDoubleForDevice(double * d); 
#line 3786
__declspec(deprecated) extern cudaError_t __stdcall cudaSetDoubleForHost(double * d); 
#line 3852
extern cudaError_t __stdcall cudaLaunchHostFunc(cudaStream_t stream, cudaHostFn_t fn, void * userData); 
#line 3907
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); 
#line 3951
extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); 
#line 4071
extern cudaError_t __stdcall cudaMallocManaged(void ** devPtr, size_t size, unsigned flags = 1); 
#line 4102
extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); 
#line 4135
extern cudaError_t __stdcall cudaMallocHost(void ** ptr, size_t size); 
#line 4178
extern cudaError_t __stdcall cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); 
#line 4224
extern cudaError_t __stdcall cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); 
#line 4253
extern cudaError_t __stdcall cudaFree(void * devPtr); 
#line 4276
extern cudaError_t __stdcall cudaFreeHost(void * ptr); 
#line 4299
extern cudaError_t __stdcall cudaFreeArray(cudaArray_t array); 
#line 4322
extern cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); 
#line 4388
extern cudaError_t __stdcall cudaHostAlloc(void ** pHost, size_t size, unsigned flags); 
#line 4472
extern cudaError_t __stdcall cudaHostRegister(void * ptr, size_t size, unsigned flags); 
#line 4495
extern cudaError_t __stdcall cudaHostUnregister(void * ptr); 
#line 4540
extern cudaError_t __stdcall cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); 
#line 4562
extern cudaError_t __stdcall cudaHostGetFlags(unsigned * pFlags, void * pHost); 
#line 4601
extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); 
#line 4740
extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); 
#line 4879
extern cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); 
#line 4908
extern cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); 
#line 5013
extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms * p); 
#line 5044
extern cudaError_t __stdcall cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); 
#line 5162
extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); 
#line 5188
extern cudaError_t __stdcall cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); 
#line 5210
extern cudaError_t __stdcall cudaMemGetInfo(size_t * free, size_t * total); 
#line 5236
extern cudaError_t __stdcall cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); 
#line 5279
extern cudaError_t __stdcall cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); 
#line 5314
extern cudaError_t __stdcall cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); 
#line 5362
extern cudaError_t __stdcall cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 5411
extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); 
#line 5460
extern cudaError_t __stdcall cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); 
#line 5507
extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 5550
extern cudaError_t __stdcall cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); 
#line 5593
extern cudaError_t __stdcall cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); 
#line 5649
extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5684
extern cudaError_t __stdcall cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); 
#line 5746
extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5803
extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5859
extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5910
extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5961
extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 5990
extern cudaError_t __stdcall cudaMemset(void * devPtr, int value, size_t count); 
#line 6024
extern cudaError_t __stdcall cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); 
#line 6068
extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); 
#line 6104
extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); 
#line 6145
extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); 
#line 6196
extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); 
#line 6224
extern cudaError_t __stdcall cudaGetSymbolAddress(void ** devPtr, const void * symbol); 
#line 6251
extern cudaError_t __stdcall cudaGetSymbolSize(size_t * size, const void * symbol); 
#line 6321
extern cudaError_t __stdcall cudaMemPrefetchAsync(const void * devPtr, size_t count, int dstDevice, cudaStream_t stream = 0); 
#line 6437
extern cudaError_t __stdcall cudaMemAdvise(const void * devPtr, size_t count, cudaMemoryAdvise advice, int device); 
#line 6496
extern cudaError_t __stdcall cudaMemRangeGetAttribute(void * data, size_t dataSize, cudaMemRangeAttribute attribute, const void * devPtr, size_t count); 
#line 6535
extern cudaError_t __stdcall cudaMemRangeGetAttributes(void ** data, size_t * dataSizes, cudaMemRangeAttribute * attributes, size_t numAttributes, const void * devPtr, size_t count); 
#line 6595
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); 
#line 6637
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); 
#line 6680
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); 
#line 6731
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6781
__declspec(deprecated) extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); 
#line 6947
extern cudaError_t __stdcall cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); 
#line 6988
extern cudaError_t __stdcall cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); 
#line 7030
extern cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); 
#line 7052
extern cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice); 
#line 7115
extern cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); 
#line 7150
extern cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); 
#line 7189
extern cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 7224
extern cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); 
#line 7256
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); 
#line 7294
extern cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); 
#line 7323
extern cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); 
#line 7394
extern cudaError_t __stdcall cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = 4294967295U); 
#line 7453
extern cudaError_t __stdcall cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); 
#line 7491
extern cudaError_t __stdcall cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
#line 7531
extern cudaError_t __stdcall cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); 
#line 7557
extern cudaError_t __stdcall cudaUnbindTexture(const textureReference * texref); 
#line 7586
extern cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); 
#line 7616
extern cudaError_t __stdcall cudaGetTextureReference(const textureReference ** texref, const void * symbol); 
#line 7661
extern cudaError_t __stdcall cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); 
#line 7686
extern cudaError_t __stdcall cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); 
#line 7721
extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); 
#line 7751
extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); 
#line 7966
extern cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); 
#line 7985
extern cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject); 
#line 8005
extern cudaError_t __stdcall cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); 
#line 8025
extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); 
#line 8046
extern cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); 
#line 8091
extern cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); 
#line 8110
extern cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); 
#line 8129
extern cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); 
#line 8163
extern cudaError_t __stdcall cudaDriverGetVersion(int * driverVersion); 
#line 8188
extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); 
#line 8235
extern cudaError_t __stdcall cudaGraphCreate(cudaGraph_t * pGraph, unsigned flags); 
#line 8332
extern cudaError_t __stdcall cudaGraphAddKernelNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaKernelNodeParams * pNodeParams); 
#line 8365
extern cudaError_t __stdcall cudaGraphKernelNodeGetParams(cudaGraphNode_t node, cudaKernelNodeParams * pNodeParams); 
#line 8390
extern cudaError_t __stdcall cudaGraphKernelNodeSetParams(cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
#line 8434
extern cudaError_t __stdcall cudaGraphAddMemcpyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemcpy3DParms * pCopyParams); 
#line 8457
extern cudaError_t __stdcall cudaGraphMemcpyNodeGetParams(cudaGraphNode_t node, cudaMemcpy3DParms * pNodeParams); 
#line 8480
extern cudaError_t __stdcall cudaGraphMemcpyNodeSetParams(cudaGraphNode_t node, const cudaMemcpy3DParms * pNodeParams); 
#line 8522
extern cudaError_t __stdcall cudaGraphAddMemsetNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaMemsetParams * pMemsetParams); 
#line 8545
extern cudaError_t __stdcall cudaGraphMemsetNodeGetParams(cudaGraphNode_t node, cudaMemsetParams * pNodeParams); 
#line 8568
extern cudaError_t __stdcall cudaGraphMemsetNodeSetParams(cudaGraphNode_t node, const cudaMemsetParams * pNodeParams); 
#line 8609
extern cudaError_t __stdcall cudaGraphAddHostNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, const cudaHostNodeParams * pNodeParams); 
#line 8632
extern cudaError_t __stdcall cudaGraphHostNodeGetParams(cudaGraphNode_t node, cudaHostNodeParams * pNodeParams); 
#line 8655
extern cudaError_t __stdcall cudaGraphHostNodeSetParams(cudaGraphNode_t node, const cudaHostNodeParams * pNodeParams); 
#line 8693
extern cudaError_t __stdcall cudaGraphAddChildGraphNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies, cudaGraph_t childGraph); 
#line 8717
extern cudaError_t __stdcall cudaGraphChildGraphNodeGetGraph(cudaGraphNode_t node, cudaGraph_t * pGraph); 
#line 8754
extern cudaError_t __stdcall cudaGraphAddEmptyNode(cudaGraphNode_t * pGraphNode, cudaGraph_t graph, const cudaGraphNode_t * pDependencies, size_t numDependencies); 
#line 8781
extern cudaError_t __stdcall cudaGraphClone(cudaGraph_t * pGraphClone, cudaGraph_t originalGraph); 
#line 8809
extern cudaError_t __stdcall cudaGraphNodeFindInClone(cudaGraphNode_t * pNode, cudaGraphNode_t originalNode, cudaGraph_t clonedGraph); 
#line 8840
extern cudaError_t __stdcall cudaGraphNodeGetType(cudaGraphNode_t node, cudaGraphNodeType * pType); 
#line 8871
extern cudaError_t __stdcall cudaGraphGetNodes(cudaGraph_t graph, cudaGraphNode_t * nodes, size_t * numNodes); 
#line 8902
extern cudaError_t __stdcall cudaGraphGetRootNodes(cudaGraph_t graph, cudaGraphNode_t * pRootNodes, size_t * pNumRootNodes); 
#line 8936
extern cudaError_t __stdcall cudaGraphGetEdges(cudaGraph_t graph, cudaGraphNode_t * from, cudaGraphNode_t * to, size_t * numEdges); 
#line 8967
extern cudaError_t __stdcall cudaGraphNodeGetDependencies(cudaGraphNode_t node, cudaGraphNode_t * pDependencies, size_t * pNumDependencies); 
#line 8999
extern cudaError_t __stdcall cudaGraphNodeGetDependentNodes(cudaGraphNode_t node, cudaGraphNode_t * pDependentNodes, size_t * pNumDependentNodes); 
#line 9030
extern cudaError_t __stdcall cudaGraphAddDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
#line 9061
extern cudaError_t __stdcall cudaGraphRemoveDependencies(cudaGraph_t graph, const cudaGraphNode_t * from, const cudaGraphNode_t * to, size_t numDependencies); 
#line 9087
extern cudaError_t __stdcall cudaGraphDestroyNode(cudaGraphNode_t node); 
#line 9123
extern cudaError_t __stdcall cudaGraphInstantiate(cudaGraphExec_t * pGraphExec, cudaGraph_t graph, cudaGraphNode_t * pErrorNode, char * pLogBuffer, size_t bufferSize); 
#line 9157
extern cudaError_t __stdcall cudaGraphExecKernelNodeSetParams(cudaGraphExec_t hGraphExec, cudaGraphNode_t node, const cudaKernelNodeParams * pNodeParams); 
#line 9182
extern cudaError_t __stdcall cudaGraphLaunch(cudaGraphExec_t graphExec, cudaStream_t stream); 
#line 9203
extern cudaError_t __stdcall cudaGraphExecDestroy(cudaGraphExec_t graphExec); 
#line 9223
extern cudaError_t __stdcall cudaGraphDestroy(cudaGraph_t graph); 
#line 9228
extern cudaError_t __stdcall cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); 
#line 9473 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_runtime_api.h"
}
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\channel_descriptor.h"
template< class T> __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 105
{ 
#line 106
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 107
} 
#line 109
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
#line 110
{ 
#line 111
int e = (((int)sizeof(unsigned short)) * 8); 
#line 113
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 114
} 
#line 116
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
#line 117
{ 
#line 118
int e = (((int)sizeof(unsigned short)) * 8); 
#line 120
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 121
} 
#line 123
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
#line 124
{ 
#line 125
int e = (((int)sizeof(unsigned short)) * 8); 
#line 127
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 128
} 
#line 130
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
#line 131
{ 
#line 132
int e = (((int)sizeof(unsigned short)) * 8); 
#line 134
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 135
} 
#line 137
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
#line 138
{ 
#line 139
int e = (((int)sizeof(char)) * 8); 
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\channel_descriptor.h"
} 
#line 148
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
#line 149
{ 
#line 150
int e = (((int)sizeof(signed char)) * 8); 
#line 152
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 153
} 
#line 155
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
#line 156
{ 
#line 157
int e = (((int)sizeof(unsigned char)) * 8); 
#line 159
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 160
} 
#line 162
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
#line 163
{ 
#line 164
int e = (((int)sizeof(signed char)) * 8); 
#line 166
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 167
} 
#line 169
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
#line 170
{ 
#line 171
int e = (((int)sizeof(unsigned char)) * 8); 
#line 173
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 174
} 
#line 176
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
#line 177
{ 
#line 178
int e = (((int)sizeof(signed char)) * 8); 
#line 180
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 181
} 
#line 183
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
#line 184
{ 
#line 185
int e = (((int)sizeof(unsigned char)) * 8); 
#line 187
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 188
} 
#line 190
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
#line 191
{ 
#line 192
int e = (((int)sizeof(signed char)) * 8); 
#line 194
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 195
} 
#line 197
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
#line 198
{ 
#line 199
int e = (((int)sizeof(unsigned char)) * 8); 
#line 201
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 202
} 
#line 204
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
#line 205
{ 
#line 206
int e = (((int)sizeof(short)) * 8); 
#line 208
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 209
} 
#line 211
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
#line 212
{ 
#line 213
int e = (((int)sizeof(unsigned short)) * 8); 
#line 215
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 216
} 
#line 218
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
#line 219
{ 
#line 220
int e = (((int)sizeof(short)) * 8); 
#line 222
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 223
} 
#line 225
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
#line 226
{ 
#line 227
int e = (((int)sizeof(unsigned short)) * 8); 
#line 229
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 230
} 
#line 232
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
#line 233
{ 
#line 234
int e = (((int)sizeof(short)) * 8); 
#line 236
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 237
} 
#line 239
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
#line 240
{ 
#line 241
int e = (((int)sizeof(unsigned short)) * 8); 
#line 243
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 244
} 
#line 246
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
#line 247
{ 
#line 248
int e = (((int)sizeof(short)) * 8); 
#line 250
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 251
} 
#line 253
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
#line 254
{ 
#line 255
int e = (((int)sizeof(unsigned short)) * 8); 
#line 257
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 258
} 
#line 260
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
#line 261
{ 
#line 262
int e = (((int)sizeof(int)) * 8); 
#line 264
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 265
} 
#line 267
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
#line 268
{ 
#line 269
int e = (((int)sizeof(unsigned)) * 8); 
#line 271
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 272
} 
#line 274
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
#line 275
{ 
#line 276
int e = (((int)sizeof(int)) * 8); 
#line 278
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 279
} 
#line 281
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
#line 282
{ 
#line 283
int e = (((int)sizeof(unsigned)) * 8); 
#line 285
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 286
} 
#line 288
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
#line 289
{ 
#line 290
int e = (((int)sizeof(int)) * 8); 
#line 292
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 293
} 
#line 295
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
#line 296
{ 
#line 297
int e = (((int)sizeof(unsigned)) * 8); 
#line 299
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 300
} 
#line 302
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
#line 303
{ 
#line 304
int e = (((int)sizeof(int)) * 8); 
#line 306
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 307
} 
#line 309
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
#line 310
{ 
#line 311
int e = (((int)sizeof(unsigned)) * 8); 
#line 313
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 314
} 
#line 318
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
#line 319
{ 
#line 320
int e = (((int)sizeof(long)) * 8); 
#line 322
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 323
} 
#line 325
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
#line 326
{ 
#line 327
int e = (((int)sizeof(unsigned long)) * 8); 
#line 329
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 330
} 
#line 332
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
#line 333
{ 
#line 334
int e = (((int)sizeof(long)) * 8); 
#line 336
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 337
} 
#line 339
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
#line 340
{ 
#line 341
int e = (((int)sizeof(unsigned long)) * 8); 
#line 343
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 344
} 
#line 346
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
#line 347
{ 
#line 348
int e = (((int)sizeof(long)) * 8); 
#line 350
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 351
} 
#line 353
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
#line 354
{ 
#line 355
int e = (((int)sizeof(unsigned long)) * 8); 
#line 357
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 358
} 
#line 360
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
#line 361
{ 
#line 362
int e = (((int)sizeof(long)) * 8); 
#line 364
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 365
} 
#line 367
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
#line 368
{ 
#line 369
int e = (((int)sizeof(unsigned long)) * 8); 
#line 371
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 372
} 
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
#line 377
{ 
#line 378
int e = (((int)sizeof(float)) * 8); 
#line 380
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 381
} 
#line 383
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
#line 384
{ 
#line 385
int e = (((int)sizeof(float)) * 8); 
#line 387
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 388
} 
#line 390
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
#line 391
{ 
#line 392
int e = (((int)sizeof(float)) * 8); 
#line 394
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 395
} 
#line 397
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
#line 398
{ 
#line 399
int e = (((int)sizeof(float)) * 8); 
#line 401
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 402
} 
#line 79 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
#line 80
{ 
#line 81
cudaPitchedPtr s; 
#line 83
(s.ptr) = d; 
#line 84
(s.pitch) = p; 
#line 85
(s.xsize) = xsz; 
#line 86
(s.ysize) = ysz; 
#line 88
return s; 
#line 89
} 
#line 106
static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
#line 107
{ 
#line 108
cudaPos p; 
#line 110
(p.x) = x; 
#line 111
(p.y) = y; 
#line 112
(p.z) = z; 
#line 114
return p; 
#line 115
} 
#line 132
static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
#line 133
{ 
#line 134
cudaExtent e; 
#line 136
(e.width) = w; 
#line 137
(e.height) = h; 
#line 138
(e.depth) = d; 
#line 140
return e; 
#line 141
} 
#line 73 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x); 
#line 75
static __inline uchar1 make_uchar1(unsigned char x); 
#line 77
static __inline char2 make_char2(signed char x, signed char y); 
#line 79
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
#line 81
static __inline char3 make_char3(signed char x, signed char y, signed char z); 
#line 83
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
#line 85
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
#line 87
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
#line 89
static __inline short1 make_short1(short x); 
#line 91
static __inline ushort1 make_ushort1(unsigned short x); 
#line 93
static __inline short2 make_short2(short x, short y); 
#line 95
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
#line 97
static __inline short3 make_short3(short x, short y, short z); 
#line 99
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
#line 101
static __inline short4 make_short4(short x, short y, short z, short w); 
#line 103
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
#line 105
static __inline int1 make_int1(int x); 
#line 107
static __inline uint1 make_uint1(unsigned x); 
#line 109
static __inline int2 make_int2(int x, int y); 
#line 111
static __inline uint2 make_uint2(unsigned x, unsigned y); 
#line 113
static __inline int3 make_int3(int x, int y, int z); 
#line 115
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
#line 117
static __inline int4 make_int4(int x, int y, int z, int w); 
#line 119
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
#line 121
static __inline long1 make_long1(long x); 
#line 123
static __inline ulong1 make_ulong1(unsigned long x); 
#line 125
static __inline long2 make_long2(long x, long y); 
#line 127
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
#line 129
static __inline long3 make_long3(long x, long y, long z); 
#line 131
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
#line 133
static __inline long4 make_long4(long x, long y, long z, long w); 
#line 135
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
#line 137
static __inline float1 make_float1(float x); 
#line 139
static __inline float2 make_float2(float x, float y); 
#line 141
static __inline float3 make_float3(float x, float y, float z); 
#line 143
static __inline float4 make_float4(float x, float y, float z, float w); 
#line 145
static __inline longlong1 make_longlong1(__int64 x); 
#line 147
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x); 
#line 149
static __inline longlong2 make_longlong2(__int64 x, __int64 y); 
#line 151
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y); 
#line 153
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z); 
#line 155
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z); 
#line 157
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w); 
#line 159
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w); 
#line 161
static __inline double1 make_double1(double x); 
#line 163
static __inline double2 make_double2(double x, double y); 
#line 165
static __inline double3 make_double3(double x, double y, double z); 
#line 167
static __inline double4 make_double4(double x, double y, double z, double w); 
#line 73 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\vector_functions.hpp"
static __inline char1 make_char1(signed char x) 
#line 74
{ 
#line 75
char1 t; (t.x) = x; return t; 
#line 76
} 
#line 78
static __inline uchar1 make_uchar1(unsigned char x) 
#line 79
{ 
#line 80
uchar1 t; (t.x) = x; return t; 
#line 81
} 
#line 83
static __inline char2 make_char2(signed char x, signed char y) 
#line 84
{ 
#line 85
char2 t; (t.x) = x; (t.y) = y; return t; 
#line 86
} 
#line 88
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
#line 89
{ 
#line 90
uchar2 t; (t.x) = x; (t.y) = y; return t; 
#line 91
} 
#line 93
static __inline char3 make_char3(signed char x, signed char y, signed char z) 
#line 94
{ 
#line 95
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 96
} 
#line 98
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
#line 99
{ 
#line 100
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 101
} 
#line 103
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
#line 104
{ 
#line 105
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 106
} 
#line 108
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
#line 109
{ 
#line 110
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 111
} 
#line 113
static __inline short1 make_short1(short x) 
#line 114
{ 
#line 115
short1 t; (t.x) = x; return t; 
#line 116
} 
#line 118
static __inline ushort1 make_ushort1(unsigned short x) 
#line 119
{ 
#line 120
ushort1 t; (t.x) = x; return t; 
#line 121
} 
#line 123
static __inline short2 make_short2(short x, short y) 
#line 124
{ 
#line 125
short2 t; (t.x) = x; (t.y) = y; return t; 
#line 126
} 
#line 128
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
#line 129
{ 
#line 130
ushort2 t; (t.x) = x; (t.y) = y; return t; 
#line 131
} 
#line 133
static __inline short3 make_short3(short x, short y, short z) 
#line 134
{ 
#line 135
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 136
} 
#line 138
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
#line 139
{ 
#line 140
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 141
} 
#line 143
static __inline short4 make_short4(short x, short y, short z, short w) 
#line 144
{ 
#line 145
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 146
} 
#line 148
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
#line 149
{ 
#line 150
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 151
} 
#line 153
static __inline int1 make_int1(int x) 
#line 154
{ 
#line 155
int1 t; (t.x) = x; return t; 
#line 156
} 
#line 158
static __inline uint1 make_uint1(unsigned x) 
#line 159
{ 
#line 160
uint1 t; (t.x) = x; return t; 
#line 161
} 
#line 163
static __inline int2 make_int2(int x, int y) 
#line 164
{ 
#line 165
int2 t; (t.x) = x; (t.y) = y; return t; 
#line 166
} 
#line 168
static __inline uint2 make_uint2(unsigned x, unsigned y) 
#line 169
{ 
#line 170
uint2 t; (t.x) = x; (t.y) = y; return t; 
#line 171
} 
#line 173
static __inline int3 make_int3(int x, int y, int z) 
#line 174
{ 
#line 175
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 176
} 
#line 178
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
#line 179
{ 
#line 180
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 181
} 
#line 183
static __inline int4 make_int4(int x, int y, int z, int w) 
#line 184
{ 
#line 185
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 186
} 
#line 188
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
#line 189
{ 
#line 190
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 191
} 
#line 193
static __inline long1 make_long1(long x) 
#line 194
{ 
#line 195
long1 t; (t.x) = x; return t; 
#line 196
} 
#line 198
static __inline ulong1 make_ulong1(unsigned long x) 
#line 199
{ 
#line 200
ulong1 t; (t.x) = x; return t; 
#line 201
} 
#line 203
static __inline long2 make_long2(long x, long y) 
#line 204
{ 
#line 205
long2 t; (t.x) = x; (t.y) = y; return t; 
#line 206
} 
#line 208
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
#line 209
{ 
#line 210
ulong2 t; (t.x) = x; (t.y) = y; return t; 
#line 211
} 
#line 213
static __inline long3 make_long3(long x, long y, long z) 
#line 214
{ 
#line 215
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 216
} 
#line 218
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
#line 219
{ 
#line 220
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 221
} 
#line 223
static __inline long4 make_long4(long x, long y, long z, long w) 
#line 224
{ 
#line 225
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 226
} 
#line 228
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
#line 229
{ 
#line 230
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 231
} 
#line 233
static __inline float1 make_float1(float x) 
#line 234
{ 
#line 235
float1 t; (t.x) = x; return t; 
#line 236
} 
#line 238
static __inline float2 make_float2(float x, float y) 
#line 239
{ 
#line 240
float2 t; (t.x) = x; (t.y) = y; return t; 
#line 241
} 
#line 243
static __inline float3 make_float3(float x, float y, float z) 
#line 244
{ 
#line 245
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 246
} 
#line 248
static __inline float4 make_float4(float x, float y, float z, float w) 
#line 249
{ 
#line 250
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 251
} 
#line 253
static __inline longlong1 make_longlong1(__int64 x) 
#line 254
{ 
#line 255
longlong1 t; (t.x) = x; return t; 
#line 256
} 
#line 258
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
#line 259
{ 
#line 260
ulonglong1 t; (t.x) = x; return t; 
#line 261
} 
#line 263
static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
#line 264
{ 
#line 265
longlong2 t; (t.x) = x; (t.y) = y; return t; 
#line 266
} 
#line 268
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
#line 269
{ 
#line 270
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
#line 271
} 
#line 273
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z) 
#line 274
{ 
#line 275
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 276
} 
#line 278
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z) 
#line 279
{ 
#line 280
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 281
} 
#line 283
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w) 
#line 284
{ 
#line 285
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 286
} 
#line 288
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w) 
#line 289
{ 
#line 290
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 291
} 
#line 293
static __inline double1 make_double1(double x) 
#line 294
{ 
#line 295
double1 t; (t.x) = x; return t; 
#line 296
} 
#line 298
static __inline double2 make_double2(double x, double y) 
#line 299
{ 
#line 300
double2 t; (t.x) = x; (t.y) = y; return t; 
#line 301
} 
#line 303
static __inline double3 make_double3(double x, double y, double z) 
#line 304
{ 
#line 305
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 306
} 
#line 308
static __inline double4 make_double4(double x, double y, double z, double w) 
#line 309
{ 
#line 310
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 311
} 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
__declspec(dllimport) int *__cdecl _errno(); 
#line 22
__declspec(dllimport) errno_t __cdecl _set_errno(int _Value); 
#line 23
__declspec(dllimport) errno_t __cdecl _get_errno(int * _Value); 
#line 25
__declspec(dllimport) unsigned long *__cdecl __doserrno(); 
#line 28
__declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 29
__declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\errno.h"
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_string.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
const void *__cdecl memchr(const void * _Buf, int _Val, size_t _MaxCount); 
#line 26
int __cdecl memcmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_string.h"
void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); 
#line 47
void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); 
#line 60 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_string.h"
void *__cdecl memset(void * _Dst, int _Val, size_t _Size); 
#line 67
const char *__cdecl strchr(const char * _Str, int _Val); 
#line 73
const char *__cdecl strrchr(const char * _Str, int _Ch); 
#line 79
const char *__cdecl strstr(const char * _Str, const char * _SubStr); 
#line 86
const __wchar_t *__cdecl wcschr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 92
const __wchar_t *__cdecl wcsrchr(const __wchar_t * _Str, __wchar_t _Ch); 
#line 99
const __wchar_t *__cdecl wcsstr(const __wchar_t * _Str, const __wchar_t * _SubStr); 
#line 106
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
static __inline errno_t __cdecl memcpy_s(void *const 
#line 36
_Destination, const rsize_t 
#line 37
_DestinationSize, const void *const 
#line 38
_Source, const rsize_t 
#line 39
_SourceSize) 
#line 41
{ 
#line 42
if (_SourceSize == (0)) 
#line 43
{ 
#line 44
return 0; 
#line 45
}  
#line 47
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 48
if ((_Source == (0)) || (_DestinationSize < _SourceSize)) 
#line 49
{ 
#line 50
memset(_Destination, 0, _DestinationSize); 
#line 52
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 53
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 56
return 22; 
#line 57
}  
#pragma warning(suppress:4996)
memcpy(_Destination, _Source, _SourceSize); 
#line 60
return 0; 
#line 61
} 
#line 64
static __inline errno_t __cdecl memmove_s(void *const 
#line 65
_Destination, const rsize_t 
#line 66
_DestinationSize, const void *const 
#line 67
_Source, const rsize_t 
#line 68
_SourceSize) 
#line 70
{ 
#line 71
if (_SourceSize == (0)) 
#line 72
{ 
#line 73
return 0; 
#line 74
}  
#line 76
{ int _Expr_val = !(!(_Destination != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 77
{ int _Expr_val = !(!(_Source != (0))); if (!_Expr_val) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; }  } ; 
#line 78
{ int _Expr_val = !(!(_DestinationSize >= _SourceSize)); if (!_Expr_val) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; }  } ; 
#line 80
#pragma warning(suppress:4996)
memmove(_Destination, _Source, _SourceSize); 
#line 82
return 0; 
#line 83
} 
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memcpy_s.h"
}__pragma( pack ( pop )) 
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 24
__declspec(dllimport) int __cdecl _memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 31
__declspec(dllimport) int __cdecl _memicmp_l(const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale); 
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
__declspec(dllimport) void *__cdecl memccpy(void * _Dst, const void * _Src, int _Val, size_t _Size); 
#line 87
__declspec(dllimport) int __cdecl memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); 
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
extern "C++" inline void *__cdecl memchr(void *
#line 101
_Pv, int 
#line 102
_C, size_t 
#line 103
_N) 
#line 105
{ 
#line 106
const void *const _Pvc = _Pv; 
#line 107
return const_cast< void *>(memchr(_Pvc, _C, _N)); 
#line 108
} 
#line 114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_memory.h"
}__pragma( pack ( pop )) 
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 28
__declspec(dllimport) errno_t __cdecl wcscat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 35
__declspec(dllimport) errno_t __cdecl wcscpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source); 
#line 42
__declspec(dllimport) errno_t __cdecl wcsncat_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 50
__declspec(dllimport) errno_t __cdecl wcsncpy_s(__wchar_t * _Destination, rsize_t _SizeInWords, const __wchar_t * _Source, rsize_t _MaxCount); 
#line 58
__declspec(dllimport) __wchar_t *__cdecl wcstok_s(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 79 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wcsdup(const __wchar_t * _String); 
#line 89 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscat_s ( _Destination, _Size, _Source ); }}
#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) __wchar_t *__cdecl wcscat(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl wcscmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 114
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source ) throw ( ) { return wcscpy_s ( _Destination, _Size, _Source ); }}
#line 120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) __wchar_t *__cdecl wcscpy(__wchar_t * _Destination, const __wchar_t * _Source); 
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 131
__declspec(dllimport) size_t __cdecl wcscspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 137
__declspec(dllimport) size_t __cdecl wcslen(const __wchar_t * _String); 
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(const __wchar_t * _Source, size_t _MaxCount); 
#line 166 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
static __inline size_t __cdecl wcsnlen_s(const __wchar_t *
#line 167
_Source, size_t 
#line 168
_MaxCount) 
#line 170
{ 
#line 171
return (_Source == (0)) ? 0 : wcsnlen(_Source, _MaxCount); 
#line 172
} 
#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl wcsncat(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl wcsncmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 198
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t const * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 205 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl wcsncpy(__wchar_t * _Destination, const __wchar_t * _Source, size_t _Count); 
#line 214 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) const __wchar_t *__cdecl wcspbrk(const __wchar_t * _String, const __wchar_t * _Control); 
#line 220
__declspec(dllimport) size_t __cdecl wcsspn(const __wchar_t * _String, const __wchar_t * _Control); 
#line 226
__declspec(dllimport) __wchar_t *__cdecl wcstok(__wchar_t * _String, const __wchar_t * _Delimiter, __wchar_t ** _Context); 
#line 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(push)
#pragma warning(disable: 4141 4996)
#pragma warning(disable: 28719 28726 28727)
#line 247
static __inline __wchar_t *__cdecl _wcstok(__wchar_t *const 
#line 248
_String, const __wchar_t *const 
#line 249
_Delimiter) 
#line 251
{ 
#line 252
return wcstok(_String, _Delimiter, 0); 
#line 253
} 
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
extern "C++" 
#line 260
__declspec(deprecated("wcstok has been changed to conform with the ISO C standard, adding an extra context parameter. To use the legacy Microsoft wcsto" "k, define _CRT_NON_CONFORMING_WCSTOK.")) inline __wchar_t *__cdecl 
#line 261
wcstok(__wchar_t *
#line 262
_String, const __wchar_t *
#line 263
_Delimiter) throw() 
#line 265
{ 
#line 266
return wcstok(_String, _Delimiter, 0); 
#line 267
} 
#line 270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
#pragma warning(pop)
#line 278 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcserror(int _ErrorNumber); 
#line 283
__declspec(dllimport) errno_t __cdecl _wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, int _ErrorNumber); 
#line 289
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }}
#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl __wcserror(const __wchar_t * _String); 
#line 302
__declspec(dllimport) errno_t __cdecl __wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _ErrorMessage); 
#line 308
extern "C++" {template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl _wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 319
__declspec(dllimport) int __cdecl _wcsicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 325
__declspec(dllimport) int __cdecl _wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 331
__declspec(dllimport) int __cdecl _wcsnicmp_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 338
__declspec(dllimport) errno_t __cdecl _wcsnset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value, size_t _MaxCount); 
#line 345
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Destination ) [ _Size ], wchar_t _Value, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Destination, _Size, _Value, _MaxCount ); }}
#line 352 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 360 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsrev(__wchar_t * _String); 
#line 364
__declspec(dllimport) errno_t __cdecl _wcsset_s(__wchar_t * _Destination, size_t _SizeInWords, __wchar_t _Value); 
#line 370
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _String ) [ _Size ], wchar_t _Value ) throw ( ) { return _wcsset_s ( _String, _Size, _Value ); }}
#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 383 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcslwr_s(__wchar_t * _String, size_t _SizeInWords); 
#line 388
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }}
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcslwr(__wchar_t * _String); 
#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(__wchar_t * _String, size_t _SizeInWords, _locale_t _Locale); 
#line 405
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }}
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcslwr_l(__wchar_t * _String, _locale_t _Locale); 
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcsupr_s(__wchar_t * _String, size_t _Size); 
#line 424
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }}
#line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsupr(__wchar_t * _String); 
#line 435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(__wchar_t * _String, size_t _Size, _locale_t _Locale); 
#line 441
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }}
#line 447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl _wcsupr_l(__wchar_t * _String, _locale_t _Locale); 
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsxfrm(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount); 
#line 464
__declspec(dllimport) size_t __cdecl _wcsxfrm_l(__wchar_t * _Destination, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 472
__declspec(dllimport) int __cdecl wcscoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 478
__declspec(dllimport) int __cdecl _wcscoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 485
__declspec(dllimport) int __cdecl _wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 491
__declspec(dllimport) int __cdecl _wcsicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, _locale_t _Locale); 
#line 498
__declspec(dllimport) int __cdecl _wcsncoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 505
__declspec(dllimport) int __cdecl _wcsncoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 513
__declspec(dllimport) int __cdecl _wcsnicoll(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 520
__declspec(dllimport) int __cdecl _wcsnicoll_l(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 535
extern "C++" {
#line 539
inline __wchar_t *__cdecl wcschr(__wchar_t *_String, __wchar_t _C) 
#line 540
{ 
#line 541
return const_cast< __wchar_t *>(wcschr(static_cast< const __wchar_t *>(_String), _C)); 
#line 542
} 
#line 545
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_String, const __wchar_t *_Control) 
#line 546
{ 
#line 547
return const_cast< __wchar_t *>(wcspbrk(static_cast< const __wchar_t *>(_String), _Control)); 
#line 548
} 
#line 551
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_String, __wchar_t _C) 
#line 552
{ 
#line 553
return const_cast< __wchar_t *>(wcsrchr(static_cast< const __wchar_t *>(_String), _C)); 
#line 554
} 
#line 558
inline __wchar_t *__cdecl wcsstr(__wchar_t *_String, const __wchar_t *_SubStr) 
#line 559
{ 
#line 560
return const_cast< __wchar_t *>(wcsstr(static_cast< const __wchar_t *>(_String), _SubStr)); 
#line 561
} 
#line 563
}
#line 580 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) __wchar_t *__cdecl wcsdup(const __wchar_t * _String); 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) int __cdecl wcsicmp(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 598
__declspec(dllimport) int __cdecl wcsnicmp(const __wchar_t * _String1, const __wchar_t * _String2, size_t _MaxCount); 
#line 606
__declspec(dllimport) __wchar_t *__cdecl wcsnset(__wchar_t * _String, __wchar_t _Value, size_t _MaxCount); 
#line 614
__declspec(dllimport) __wchar_t *__cdecl wcsrev(__wchar_t * _String); 
#line 620
__declspec(dllimport) __wchar_t *__cdecl wcsset(__wchar_t * _String, __wchar_t _Value); 
#line 627
__declspec(dllimport) __wchar_t *__cdecl wcslwr(__wchar_t * _String); 
#line 633
__declspec(dllimport) __wchar_t *__cdecl wcsupr(__wchar_t * _String); 
#line 638
__declspec(dllimport) int __cdecl wcsicoll(const __wchar_t * _String1, const __wchar_t * _String2); 
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstring.h"
}__pragma( pack ( pop )) 
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 28
__declspec(dllimport) errno_t __cdecl strcpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 35
__declspec(dllimport) errno_t __cdecl strcat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source); 
#line 42
__declspec(dllimport) errno_t __cdecl strerror_s(char * _Buffer, size_t _SizeInBytes, int _ErrorNumber); 
#line 48
__declspec(dllimport) errno_t __cdecl strncat_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 56
__declspec(dllimport) errno_t __cdecl strncpy_s(char * _Destination, rsize_t _SizeInBytes, const char * _Source, rsize_t _MaxCount); 
#line 64
__declspec(dllimport) char *__cdecl strtok_s(char * _String, const char * _Delimiter, char ** _Context); 
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) void *__cdecl _memccpy(void * _Dst, const void * _Src, int _Val, size_t _MaxCount); 
#line 79
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcat_s ( _Destination, _Size, _Source ); }}
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
char *__cdecl strcat(char * _Destination, const char * _Source); 
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(pop)
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
int __cdecl strcmp(const char * _Str1, const char * _Str2); 
#line 106
__declspec(dllimport) int __cdecl _strcmpi(const char * _String1, const char * _String2); 
#line 112
__declspec(dllimport) int __cdecl strcoll(const char * _String1, const char * _String2); 
#line 118
__declspec(dllimport) int __cdecl _strcoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 124
extern "C++" {template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Destination ) [ _Size ], char const * _Source ) throw ( ) { return strcpy_s ( _Destination, _Size, _Source ); }}
#line 130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
char *__cdecl strcpy(char * _Destination, const char * _Source); 
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
#pragma warning(pop)
#line 141
__declspec(dllimport) size_t __cdecl strcspn(const char * _Str, const char * _Control); 
#line 152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) __declspec(allocator) char *__cdecl _strdup(const char * _Source); 
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strerror(const char * _ErrorMessage); 
#line 168
__declspec(dllimport) errno_t __cdecl _strerror_s(char * _Buffer, size_t _SizeInBytes, const char * _ErrorMessage); 
#line 174
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], char const * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strerror(int _ErrorMessage); 
#line 186
extern "C++" {template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }}
#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) int __cdecl _stricmp(const char * _String1, const char * _String2); 
#line 199
__declspec(dllimport) int __cdecl _stricoll(const char * _String1, const char * _String2); 
#line 205
__declspec(dllimport) int __cdecl _stricoll_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 212
__declspec(dllimport) int __cdecl _stricmp_l(const char * _String1, const char * _String2, _locale_t _Locale); 
#line 219
size_t __cdecl strlen(const char * _Str); 
#line 224
__declspec(dllimport) errno_t __cdecl _strlwr_s(char * _String, size_t _Size); 
#line 229
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }}
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strlwr(char * _String); 
#line 240 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) errno_t __cdecl _strlwr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 246
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }}
#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strlwr_l(char * _String, _locale_t _Locale); 
#line 259 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Destination, _Size, _Source, _Count ); }}
#line 266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strncat(char * _Destination, const char * _Source, size_t _Count); 
#line 275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) int __cdecl strncmp(const char * _Str1, const char * _Str2, size_t _MaxCount); 
#line 282
__declspec(dllimport) int __cdecl _strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 289
__declspec(dllimport) int __cdecl _strnicmp_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 297
__declspec(dllimport) int __cdecl _strnicoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 304
__declspec(dllimport) int __cdecl _strnicoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 312
__declspec(dllimport) int __cdecl _strncoll(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 319
__declspec(dllimport) int __cdecl _strncoll_l(const char * _String1, const char * _String2, size_t _MaxCount, _locale_t _Locale); 
#line 326
__declspec(dllimport) size_t __cdecl __strncnt(const char * _String, size_t _Count); 
#line 331
extern "C++" {template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Destination ) [ _Size ], char const * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Destination, _Size, _Source, _Count ); }}
#line 338 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strncpy(char * _Destination, const char * _Source, size_t _Count); 
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(const char * _String, size_t _MaxCount); 
#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
static __inline size_t __cdecl strnlen_s(const char *
#line 372
_String, size_t 
#line 373
_MaxCount) 
#line 375
{ 
#line 376
return (_String == (0)) ? 0 : strnlen(_String, _MaxCount); 
#line 377
} 
#line 382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) errno_t __cdecl _strnset_s(char * _String, size_t _SizeInBytes, int _Value, size_t _MaxCount); 
#line 389
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Destination ) [ _Size ], int _Value, size_t _Count ) throw ( ) { return _strnset_s ( _Destination, _Size, _Value, _Count ); }}
#line 396 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strnset(char * _Destination, int _Value, size_t _Count); 
#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) const char *__cdecl strpbrk(const char * _Str, const char * _Control); 
#line 410
__declspec(dllimport) char *__cdecl _strrev(char * _Str); 
#line 415
__declspec(dllimport) errno_t __cdecl _strset_s(char * _Destination, size_t _DestinationSize, int _Value); 
#line 421
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Destination ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Destination, _Size, _Value ); }}
#line 427 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
char *__cdecl _strset(char * _Destination, int _Value); 
#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strspn(const char * _Str, const char * _Control); 
#line 440
__declspec(dllimport) char *__cdecl strtok(char * _String, const char * _Delimiter); 
#line 446
__declspec(dllimport) errno_t __cdecl _strupr_s(char * _String, size_t _Size); 
#line 451
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }}
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strupr(char * _String); 
#line 462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) errno_t __cdecl _strupr_s_l(char * _String, size_t _Size, _locale_t _Locale); 
#line 468
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }}
#line 474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl _strupr_l(char * _String, _locale_t _Locale); 
#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strxfrm(char * _Destination, const char * _Source, size_t _MaxCount); 
#line 491
__declspec(dllimport) size_t __cdecl _strxfrm_l(char * _Destination, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 501
extern "C++" {
#line 504
inline char *__cdecl strchr(char *const _String, const int _Ch) 
#line 505
{ 
#line 506
return const_cast< char *>(strchr(static_cast< const char *>(_String), _Ch)); 
#line 507
} 
#line 510
inline char *__cdecl strpbrk(char *const _String, const char *const _Control) 
#line 511
{ 
#line 512
return const_cast< char *>(strpbrk(static_cast< const char *>(_String), _Control)); 
#line 513
} 
#line 516
inline char *__cdecl strrchr(char *const _String, const int _Ch) 
#line 517
{ 
#line 518
return const_cast< char *>(strrchr(static_cast< const char *>(_String), _Ch)); 
#line 519
} 
#line 522
inline char *__cdecl strstr(char *const _String, const char *const _SubString) 
#line 523
{ 
#line 524
return const_cast< char *>(strstr(static_cast< const char *>(_String), _SubString)); 
#line 525
} 
#line 526
}
#line 536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
__declspec(dllimport) char *__cdecl strdup(const char * _String); 
#line 543
__declspec(dllimport) int __cdecl strcmpi(const char * _String1, const char * _String2); 
#line 549
__declspec(dllimport) int __cdecl stricmp(const char * _String1, const char * _String2); 
#line 555
__declspec(dllimport) char *__cdecl strlwr(char * _String); 
#line 560
__declspec(dllimport) int __cdecl strnicmp(const char * _String1, const char * _String2, size_t _MaxCount); 
#line 567
__declspec(dllimport) char *__cdecl strnset(char * _String, int _Value, size_t _MaxCount); 
#line 574
__declspec(dllimport) char *__cdecl strrev(char * _String); 
#line 579
char *__cdecl strset(char * _String, int _Value); 
#line 584
__declspec(dllimport) char *__cdecl strupr(char * _String); 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\string.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 22
struct tm { 
#line 24
int tm_sec; 
#line 25
int tm_min; 
#line 26
int tm_hour; 
#line 27
int tm_mday; 
#line 28
int tm_mon; 
#line 29
int tm_year; 
#line 30
int tm_wday; 
#line 31
int tm_yday; 
#line 32
int tm_isdst; 
#line 33
}; 
#line 44
__declspec(dllimport) __wchar_t *__cdecl _wasctime(const tm * _Tm); 
#line 50
__declspec(dllimport) errno_t __cdecl _wasctime_s(__wchar_t * _Buffer, size_t _SizeInWords, const tm * _Tm); 
#line 56
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }}
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) size_t __cdecl wcsftime(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm); 
#line 74
__declspec(dllimport) size_t __cdecl _wcsftime_l(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm, _locale_t _Locale); 
#line 84
__declspec(dllimport) __wchar_t *__cdecl _wctime32(const __time32_t * _Time); 
#line 89
__declspec(dllimport) errno_t __cdecl _wctime32_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time32_t * _Time); 
#line 95
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }}
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) __wchar_t *__cdecl _wctime64(const __time64_t * _Time); 
#line 109
__declspec(dllimport) errno_t __cdecl _wctime64_s(__wchar_t * _Buffer, size_t _SizeInWords, const __time64_t * _Time); 
#line 114
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }}
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) errno_t __cdecl _wstrdate_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 126
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }}
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) __wchar_t *__cdecl _wstrdate(__wchar_t * _Buffer); 
#line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) errno_t __cdecl _wstrtime_s(__wchar_t * _Buffer, size_t _SizeInWords); 
#line 142
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }}
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__declspec(dllimport) __wchar_t *__cdecl _wstrtime(__wchar_t * _Buffer); 
#line 160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
#pragma warning(push)
#pragma warning(disable: 4996)
#line 185
static __inline __wchar_t *__cdecl _wctime(const time_t *const 
#line 186
_Time) 
#line 187
{ 
#line 188
return _wctime64(_Time); 
#line 189
} 
#line 192
static __inline errno_t __cdecl _wctime_s(__wchar_t *const 
#line 193
_Buffer, const size_t 
#line 194
_SizeInWords, const time_t *const 
#line 195
_Time) 
#line 197
{ 
#line 198
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
#line 199
} 
#line 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
}
#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
#pragma warning(pop)
#line 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wtime.h"
__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 24
typedef long clock_t; 
#line 26
struct _timespec32 { 
#line 28
__time32_t tv_sec; 
#line 29
long tv_nsec; 
#line 30
}; 
#line 32
struct _timespec64 { 
#line 34
__time64_t tv_sec; 
#line 35
long tv_nsec; 
#line 36
}; 
#line 39
struct timespec { 
#line 41
time_t tv_sec; 
#line 42
long tv_nsec; 
#line 43
}; 
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) int *__cdecl __daylight(); 
#line 68
__declspec(dllimport) long *__cdecl __dstbias(); 
#line 74
__declspec(dllimport) long *__cdecl __timezone(); 
#line 80
__declspec(dllimport) char **__cdecl __tzname(); 
#line 85
__declspec(dllimport) errno_t __cdecl _get_daylight(int * _Daylight); 
#line 90
__declspec(dllimport) errno_t __cdecl _get_dstbias(long * _DaylightSavingsBias); 
#line 95
__declspec(dllimport) errno_t __cdecl _get_timezone(long * _TimeZone); 
#line 100
__declspec(dllimport) errno_t __cdecl _get_tzname(size_t * _ReturnValue, char * _Buffer, size_t _SizeInBytes, int _Index); 
#line 117
__declspec(dllimport) char *__cdecl asctime(const tm * _Tm); 
#line 124
__declspec(dllimport) errno_t __cdecl asctime_s(char * _Buffer, size_t _SizeInBytes, const tm * _Tm); 
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
extern "C++" {template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], struct tm const * _Time ) throw ( ) { return asctime_s ( _Buffer, _Size, _Time ); }}
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) clock_t __cdecl clock(); 
#line 143
__declspec(dllimport) char *__cdecl _ctime32(const __time32_t * _Time); 
#line 148
__declspec(dllimport) errno_t __cdecl _ctime32_s(char * _Buffer, size_t _SizeInBytes, const __time32_t * _Time); 
#line 154
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], __time32_t const * _Time ) throw ( ) { return _ctime32_s ( _Buffer, _Size, _Time ); }}
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) char *__cdecl _ctime64(const __time64_t * _Time); 
#line 168
__declspec(dllimport) errno_t __cdecl _ctime64_s(char * _Buffer, size_t _SizeInBytes, const __time64_t * _Time); 
#line 174
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], __time64_t const * _Time ) throw ( ) { return _ctime64_s ( _Buffer, _Size, _Time ); }}
#line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) double __cdecl _difftime32(__time32_t _Time1, __time32_t _Time2); 
#line 187
__declspec(dllimport) double __cdecl _difftime64(__time64_t _Time1, __time64_t _Time2); 
#line 194
__declspec(dllimport) tm *__cdecl _gmtime32(const __time32_t * _Time); 
#line 199
__declspec(dllimport) errno_t __cdecl _gmtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 206
__declspec(dllimport) tm *__cdecl _gmtime64(const __time64_t * _Time); 
#line 211
__declspec(dllimport) errno_t __cdecl _gmtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 218
__declspec(dllimport) tm *__cdecl _localtime32(const __time32_t * _Time); 
#line 223
__declspec(dllimport) errno_t __cdecl _localtime32_s(tm * _Tm, const __time32_t * _Time); 
#line 230
__declspec(dllimport) tm *__cdecl _localtime64(const __time64_t * _Time); 
#line 235
__declspec(dllimport) errno_t __cdecl _localtime64_s(tm * _Tm, const __time64_t * _Time); 
#line 241
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(tm * _Tm); 
#line 246
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(tm * _Tm); 
#line 251
__declspec(dllimport) __time32_t __cdecl _mktime32(tm * _Tm); 
#line 256
__declspec(dllimport) __time64_t __cdecl _mktime64(tm * _Tm); 
#line 262
__declspec(dllimport) size_t __cdecl strftime(char * _Buffer, size_t _SizeInBytes, const char * _Format, const tm * _Tm); 
#line 271
__declspec(dllimport) size_t __cdecl _strftime_l(char * _Buffer, size_t _MaxSize, const char * _Format, const tm * _Tm, _locale_t _Locale); 
#line 280
__declspec(dllimport) errno_t __cdecl _strdate_s(char * _Buffer, size_t _SizeInBytes); 
#line 285
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strdate_s ( _Buffer, _Size ); }}
#line 290 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) char *__cdecl _strdate(char * _Buffer); 
#line 296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) errno_t __cdecl _strtime_s(char * _Buffer, size_t _SizeInBytes); 
#line 301
extern "C++" {template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strtime_s ( _Buffer, _Size ); }}
#line 306 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) char *__cdecl _strtime(char * _Buffer); 
#line 311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) __time32_t __cdecl _time32(__time32_t * _Time); 
#line 315
__declspec(dllimport) __time64_t __cdecl _time64(__time64_t * _Time); 
#line 321
__declspec(dllimport) int __cdecl _timespec32_get(_timespec32 * _Ts, int _Base); 
#line 328
__declspec(dllimport) int __cdecl _timespec64_get(_timespec64 * _Ts, int _Base); 
#line 342
__declspec(dllimport) void __cdecl _tzset(); 
#line 345
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime in" "stead. See online help for details.")) 
#line 346
__declspec(dllimport) unsigned __cdecl _getsystime(tm * _Tm); 
#line 350
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime in" "stead. See online help for details.")) 
#line 351
__declspec(dllimport) unsigned __cdecl _setsystime(tm * _Tm, unsigned _Milliseconds); 
#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
static __inline char *__cdecl ctime(const time_t *const 
#line 477
_Time) 
#line 479
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _ctime64(_Time); 
#pragma warning(pop)
} 
#line 487
static __inline double __cdecl difftime(const time_t 
#line 488
_Time1, const time_t 
#line 489
_Time2) 
#line 491
{ 
#line 492
return _difftime64(_Time1, _Time2); 
#line 493
} 
#line 496
static __inline tm *__cdecl gmtime(const time_t *const 
#line 497
_Time) 
#line 498
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _gmtime64(_Time); 
#pragma warning(pop)
} 
#line 506
static __inline tm *__cdecl localtime(const time_t *const 
#line 507
_Time) 
#line 509
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _localtime64(_Time); 
#pragma warning(pop)
} 
#line 517
static __inline time_t __cdecl _mkgmtime(tm *const 
#line 518
_Tm) 
#line 520
{ 
#line 521
return _mkgmtime64(_Tm); 
#line 522
} 
#line 525
static __inline time_t __cdecl mktime(tm *const 
#line 526
_Tm) 
#line 528
{ 
#line 529
return _mktime64(_Tm); 
#line 530
} 
#line 532
static __inline time_t __cdecl time(time_t *const 
#line 533
_Time) 
#line 535
{ 
#line 536
return _time64(_Time); 
#line 537
} 
#line 540
static __inline int __cdecl timespec_get(timespec *const 
#line 541
_Ts, const int 
#line 542
_Base) 
#line 544
{ 
#line 545
return _timespec64_get((_timespec64 *)_Ts, _Base); 
#line 546
} 
#line 550
static __inline errno_t __cdecl ctime_s(char *const 
#line 551
_Buffer, const size_t 
#line 552
_SizeInBytes, const time_t *const 
#line 553
_Time) 
#line 555
{ 
#line 556
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
#line 557
} 
#line 560
static __inline errno_t __cdecl gmtime_s(tm *const 
#line 561
_Tm, const time_t *const 
#line 562
_Time) 
#line 564
{ 
#line 565
return _gmtime64_s(_Tm, _Time); 
#line 566
} 
#line 569
static __inline errno_t __cdecl localtime_s(tm *const 
#line 570
_Tm, const time_t *const 
#line 571
_Time) 
#line 573
{ 
#line 574
return _localtime64_s(_Tm, _Time); 
#line 575
} 
#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
__declspec(dllimport) void __cdecl tzset(); 
#line 601 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\time.h"
}__pragma( pack ( pop )) 
#line 80 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt/common_functions.h"
extern "C" {
#line 83 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt/common_functions.h"
__declspec(dllimport) extern clock_t __cdecl clock(); 
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt/common_functions.h"
extern void *__cdecl memset(void *, int, size_t); 
#line 89
extern void *__cdecl memcpy(void *, const void *, size_t); 
#line 91
}
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern "C" {
#line 192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern int __cdecl abs(int); 
#line 193
extern long __cdecl labs(long); 
#line 194
extern __int64 llabs(__int64); 
#line 244 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double __cdecl fabs(double x); 
#line 285
extern __inline float fabsf(float x); 
#line 289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline int min(int, int); 
#line 291
extern inline unsigned umin(unsigned, unsigned); 
#line 292
extern inline __int64 llmin(__int64, __int64); 
#line 293
extern inline unsigned __int64 ullmin(unsigned __int64, unsigned __int64); 
#line 316 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fminf(float x, float y); 
#line 336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fmin(double x, double y); 
#line 341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline int max(int, int); 
#line 343
extern inline unsigned umax(unsigned, unsigned); 
#line 344
extern inline __int64 llmax(__int64, __int64); 
#line 345
extern inline unsigned __int64 ullmax(unsigned __int64, unsigned __int64); 
#line 368 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fmaxf(float x, float y); 
#line 388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fmax(double, double); 
#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double __cdecl sin(double x); 
#line 463
extern double __cdecl cos(double x); 
#line 482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern void sincos(double x, double * sptr, double * cptr); 
#line 498
extern void sincosf(float x, float * sptr, float * cptr); 
#line 543 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double __cdecl tan(double x); 
#line 612
extern double __cdecl sqrt(double x); 
#line 684 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double rsqrt(double x); 
#line 754
extern float rsqrtf(float x); 
#line 812 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl log2(double x); 
#line 837 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl exp2(double x); 
#line 862 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl exp2f(float x); 
#line 887 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double exp10(double x); 
#line 910
extern float exp10f(float x); 
#line 958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl expm1(double x); 
#line 1003 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl expm1f(float x); 
#line 1058 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl log2f(float x); 
#line 1110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double __cdecl log10(double x); 
#line 1181
extern double __cdecl log(double x); 
#line 1277 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl log1p(double x); 
#line 1374 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl log1pf(float x); 
#line 1447 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl floor(double x); 
#line 1486
extern double __cdecl exp(double x); 
#line 1517
extern double __cdecl cosh(double x); 
#line 1547
extern double __cdecl sinh(double x); 
#line 1577
extern double __cdecl tanh(double x); 
#line 1614 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl acosh(double x); 
#line 1652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl acoshf(float x); 
#line 1668 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl asinh(double x); 
#line 1684 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl asinhf(float x); 
#line 1738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl atanh(double x); 
#line 1792 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl atanhf(float x); 
#line 1849 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl ldexp(double x, int exp); 
#line 1905
extern __inline float ldexpf(float x, int exp); 
#line 1959 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl logb(double x); 
#line 2014 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl logbf(float x); 
#line 2044 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern int __cdecl ilogb(double x); 
#line 2074 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern int __cdecl ilogbf(float x); 
#line 2150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl scalbn(double x, int n); 
#line 2226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl scalbnf(float x, int n); 
#line 2302 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl scalbln(double x, long n); 
#line 2378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl scalblnf(float x, long n); 
#line 2454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl frexp(double x, int * nptr); 
#line 2529
extern __inline float frexpf(float x, int * nptr); 
#line 2545 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl round(double x); 
#line 2562 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl roundf(float x); 
#line 2580 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lround(double x); 
#line 2598 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lroundf(float x); 
#line 2616 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llround(double x); 
#line 2634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llroundf(float x); 
#line 2686 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl rintf(float x); 
#line 2703 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lrint(double x); 
#line 2720 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern long __cdecl lrintf(float x); 
#line 2737 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llrint(double x); 
#line 2754 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern __int64 __cdecl llrintf(float x); 
#line 2807 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl nearbyint(double x); 
#line 2860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl nearbyintf(float x); 
#line 2920 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl ceil(double x); 
#line 2934 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl trunc(double x); 
#line 2949 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl truncf(float x); 
#line 2975 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fdim(double x, double y); 
#line 3001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fdimf(float x, float y); 
#line 3035 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double __cdecl atan2(double y, double x); 
#line 3066
extern double __cdecl atan(double x); 
#line 3089
extern double __cdecl acos(double x); 
#line 3121
extern double __cdecl asin(double x); 
#line 3164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl hypot(double x, double y); 
#line 3219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double rhypot(double x, double y); 
#line 3263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline float __cdecl hypotf(float x, float y); 
#line 3317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern float rhypotf(float x, float y); 
#line 3361
__declspec(dllimport) extern double __cdecl norm3d(double a, double b, double c); 
#line 3412
extern double rnorm3d(double a, double b, double c); 
#line 3461
__declspec(dllimport) extern double __cdecl norm4d(double a, double b, double c, double d); 
#line 3517
extern double rnorm4d(double a, double b, double c, double d); 
#line 3562
extern double norm(int dim, const double * t); 
#line 3613
extern double rnorm(int dim, const double * t); 
#line 3665
extern float rnormf(int dim, const float * a); 
#line 3709
extern float normf(int dim, const float * a); 
#line 3754
extern float norm3df(float a, float b, float c); 
#line 3805
extern float rnorm3df(float a, float b, float c); 
#line 3854
extern float norm4df(float a, float b, float c, float d); 
#line 3910
extern float rnorm4df(float a, float b, float c, float d); 
#line 3999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl cbrt(double x); 
#line 4085 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl cbrtf(float x); 
#line 4138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double rcbrt(double x); 
#line 4188
extern float rcbrtf(float x); 
#line 4248
extern double sinpi(double x); 
#line 4308
extern float sinpif(float x); 
#line 4360
extern double cospi(double x); 
#line 4412
extern float cospif(float x); 
#line 4442
extern void sincospi(double x, double * sptr, double * cptr); 
#line 4472
extern void sincospif(float x, float * sptr, float * cptr); 
#line 4784 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double __cdecl pow(double x, double y); 
#line 4840
__declspec(dllimport) extern double __cdecl modf(double x, double * iptr); 
#line 4899
extern double __cdecl fmod(double x, double y); 
#line 4987 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl remainder(double x, double y); 
#line 5077 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl remainderf(float x, float y); 
#line 5131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl remquo(double x, double y, int * quo); 
#line 5185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl remquof(float x, float y, int * quo); 
#line 5224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl j0(double x); 
#line 5266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern float j0f(float x); 
#line 5327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl j1(double x); 
#line 5388 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern float j1f(float x); 
#line 5431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl jn(int n, double x); 
#line 5474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern float jnf(int n, float x); 
#line 5526 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl y0(double x); 
#line 5578 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern float y0f(float x); 
#line 5630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl y1(double x); 
#line 5682 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern float y1f(float x); 
#line 5735 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl yn(int n, double x); 
#line 5788 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern float ynf(int n, float x); 
#line 5815
__declspec(dllimport) extern double __cdecl cyl_bessel_i0(double x); 
#line 5841
extern float cyl_bessel_i0f(float x); 
#line 5868
__declspec(dllimport) extern double __cdecl cyl_bessel_i1(double x); 
#line 5894
extern float cyl_bessel_i1f(float x); 
#line 5979 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl erf(double x); 
#line 6061 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl erff(float x); 
#line 6123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double erfinv(double y); 
#line 6180
extern float erfinvf(float y); 
#line 6221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl erfc(double x); 
#line 6259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl erfcf(float x); 
#line 6387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl lgamma(double x); 
#line 6448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern double erfcinv(double y); 
#line 6504
extern float erfcinvf(float y); 
#line 6562
extern double normcdfinv(double y); 
#line 6620
extern float normcdfinvf(float y); 
#line 6663
extern double normcdf(double y); 
#line 6706
extern float normcdff(float y); 
#line 6781
extern double erfcx(double x); 
#line 6856
extern float erfcxf(float x); 
#line 6992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl lgammaf(float x); 
#line 7101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl tgamma(double x); 
#line 7210 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl tgammaf(float x); 
#line 7223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl copysign(double x, double y); 
#line 7236 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl copysignf(float x, float y); 
#line 7273 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl nextafter(double x, double y); 
#line 7310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl nextafterf(float x, float y); 
#line 7326 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl nan(const char * tagp); 
#line 7342 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl nanf(const char * tagp); 
#line 7347 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern int __isinff(float); 
#line 7348
extern int __isnanf(float); 
#line 7358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern int __finite(double); 
#line 7359
extern int __finitef(float); 
#line 7360
extern int __signbit(double); 
#line 7361
extern int __isnan(double); 
#line 7362
extern int __isinf(double); 
#line 7365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern int __signbitf(float); 
#line 7526 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern double __cdecl fma(double x, double y, double z); 
#line 7684 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl fmaf(float x, float y, float z); 
#line 7693 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern int __signbitl(long double); 
#line 7699 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern int __finitel(long double); 
#line 7700
extern int __isinfl(long double); 
#line 7701
extern int __isnanl(long double); 
#line 7705 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
__declspec(dllimport) extern float __cdecl acosf(float); 
#line 7706
__declspec(dllimport) extern float __cdecl asinf(float); 
#line 7707
__declspec(dllimport) extern float __cdecl atanf(float); 
#line 7708
__declspec(dllimport) extern float __cdecl atan2f(float, float); 
#line 7709
__declspec(dllimport) extern float __cdecl cosf(float); 
#line 7710
__declspec(dllimport) extern float __cdecl sinf(float); 
#line 7711
__declspec(dllimport) extern float __cdecl tanf(float); 
#line 7712
__declspec(dllimport) extern float __cdecl coshf(float); 
#line 7713
__declspec(dllimport) extern float __cdecl sinhf(float); 
#line 7714
__declspec(dllimport) extern float __cdecl tanhf(float); 
#line 7715
__declspec(dllimport) extern float __cdecl expf(float); 
#line 7716
__declspec(dllimport) extern float __cdecl logf(float); 
#line 7717
__declspec(dllimport) extern float __cdecl log10f(float); 
#line 7718
__declspec(dllimport) extern float __cdecl modff(float, float *); 
#line 7719
__declspec(dllimport) extern float __cdecl powf(float, float); 
#line 7720
__declspec(dllimport) extern float __cdecl sqrtf(float); 
#line 7721
__declspec(dllimport) extern float __cdecl ceilf(float); 
#line 7722
__declspec(dllimport) extern float __cdecl floorf(float); 
#line 7723
__declspec(dllimport) extern float __cdecl fmodf(float, float); 
#line 8856 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
}
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 16
#pragma warning(push)
#pragma warning(disable:4738)
#pragma warning(disable:4820)
#line 25
struct _exception { 
#line 27
int type; 
#line 28
char *name; 
#line 29
double arg1; 
#line 30
double arg2; 
#line 31
double retval; 
#line 32
}; 
#line 39
struct _complex { 
#line 41
double x, y; 
#line 42
}; 
#line 61 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
typedef float float_t; 
#line 62
typedef double double_t; 
#line 80 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
extern const double _HUGE; 
#line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
void __cdecl _fperrraise(int _Except); 
#line 173
__declspec(dllimport) short __cdecl _dclass(double _X); 
#line 174
__declspec(dllimport) short __cdecl _ldclass(long double _X); 
#line 175
__declspec(dllimport) short __cdecl _fdclass(float _X); 
#line 177
__declspec(dllimport) int __cdecl _dsign(double _X); 
#line 178
__declspec(dllimport) int __cdecl _ldsign(long double _X); 
#line 179
__declspec(dllimport) int __cdecl _fdsign(float _X); 
#line 181
__declspec(dllimport) int __cdecl _dpcomp(double _X, double _Y); 
#line 182
__declspec(dllimport) int __cdecl _ldpcomp(long double _X, long double _Y); 
#line 183
__declspec(dllimport) int __cdecl _fdpcomp(float _X, float _Y); 
#line 185
__declspec(dllimport) short __cdecl _dtest(double * _Px); 
#line 186
__declspec(dllimport) short __cdecl _ldtest(long double * _Px); 
#line 187
__declspec(dllimport) short __cdecl _fdtest(float * _Px); 
#line 189
__declspec(dllimport) short __cdecl _d_int(double * _Px, short _Xexp); 
#line 190
__declspec(dllimport) short __cdecl _ld_int(long double * _Px, short _Xexp); 
#line 191
__declspec(dllimport) short __cdecl _fd_int(float * _Px, short _Xexp); 
#line 193
__declspec(dllimport) short __cdecl _dscale(double * _Px, long _Lexp); 
#line 194
__declspec(dllimport) short __cdecl _ldscale(long double * _Px, long _Lexp); 
#line 195
__declspec(dllimport) short __cdecl _fdscale(float * _Px, long _Lexp); 
#line 197
__declspec(dllimport) short __cdecl _dunscale(short * _Pex, double * _Px); 
#line 198
__declspec(dllimport) short __cdecl _ldunscale(short * _Pex, long double * _Px); 
#line 199
__declspec(dllimport) short __cdecl _fdunscale(short * _Pex, float * _Px); 
#line 201
__declspec(dllimport) short __cdecl _dexp(double * _Px, double _Y, long _Eoff); 
#line 202
__declspec(dllimport) short __cdecl _ldexp(long double * _Px, long double _Y, long _Eoff); 
#line 203
__declspec(dllimport) short __cdecl _fdexp(float * _Px, float _Y, long _Eoff); 
#line 205
__declspec(dllimport) short __cdecl _dnorm(unsigned short * _Ps); 
#line 206
__declspec(dllimport) short __cdecl _fdnorm(unsigned short * _Ps); 
#line 208
__declspec(dllimport) double __cdecl _dpoly(double _X, const double * _Tab, int _N); 
#line 209
__declspec(dllimport) long double __cdecl _ldpoly(long double _X, const long double * _Tab, int _N); 
#line 210
__declspec(dllimport) float __cdecl _fdpoly(float _X, const float * _Tab, int _N); 
#line 212
__declspec(dllimport) double __cdecl _dlog(double _X, int _Baseflag); 
#line 213
__declspec(dllimport) long double __cdecl _ldlog(long double _X, int _Baseflag); 
#line 214
__declspec(dllimport) float __cdecl _fdlog(float _X, int _Baseflag); 
#line 216
__declspec(dllimport) double __cdecl _dsin(double _X, unsigned _Qoff); 
#line 217
__declspec(dllimport) long double __cdecl _ldsin(long double _X, unsigned _Qoff); 
#line 218
__declspec(dllimport) float __cdecl _fdsin(float _X, unsigned _Qoff); 
#line 225
typedef 
#line 222
union { 
#line 223
unsigned short _Sh[4]; 
#line 224
double _Val; 
#line 225
} _double_val; 
#line 232
typedef 
#line 229
union { 
#line 230
unsigned short _Sh[2]; 
#line 231
float _Val; 
#line 232
} _float_val; 
#line 239
typedef 
#line 236
union { 
#line 237
unsigned short _Sh[4]; 
#line 238
long double _Val; 
#line 239
} _ldouble_val; 
#line 247
typedef 
#line 242
union { 
#line 243
unsigned short _Word[4]; 
#line 244
float _Float; 
#line 245
double _Double; 
#line 246
long double _Long_double; 
#line 247
} _float_const; 
#line 249
extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C; 
#line 250
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C; 
#line 251
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C; 
#line 253
extern const _float_const _Eps_C, _Rteps_C; 
#line 254
extern const _float_const _FEps_C, _FRteps_C; 
#line 255
extern const _float_const _LEps_C, _LRteps_C; 
#line 257
extern const double _Zero_C, _Xbig_C; 
#line 258
extern const float _FZero_C, _FXbig_C; 
#line 259
extern const long double _LZero_C, _LXbig_C; 
#line 288
extern "C++" {
#line 290
inline int fpclassify(float _X) throw() 
#line 291
{ 
#line 292
return _fdtest(&_X); 
#line 293
} 
#line 295
inline int fpclassify(double _X) throw() 
#line 296
{ 
#line 297
return _dtest(&_X); 
#line 298
} 
#line 300
inline int fpclassify(long double _X) throw() 
#line 301
{ 
#line 302
return _ldtest(&_X); 
#line 303
} 
#line 305
inline bool signbit(float _X) throw() 
#line 306
{ 
#line 307
return _fdsign(_X) != 0; 
#line 308
} 
#line 310
inline bool signbit(double _X) throw() 
#line 311
{ 
#line 312
return _dsign(_X) != 0; 
#line 313
} 
#line 315
inline bool signbit(long double _X) throw() 
#line 316
{ 
#line 317
return _ldsign(_X) != 0; 
#line 318
} 
#line 320
inline int _fpcomp(float _X, float _Y) throw() 
#line 321
{ 
#line 322
return _fdpcomp(_X, _Y); 
#line 323
} 
#line 325
inline int _fpcomp(double _X, double _Y) throw() 
#line 326
{ 
#line 327
return _dpcomp(_X, _Y); 
#line 328
} 
#line 330
inline int _fpcomp(long double _X, long double _Y) throw() 
#line 331
{ 
#line 332
return _ldpcomp(_X, _Y); 
#line 333
} 
#line 335
template< class _Trc, class _Tre> struct _Combined_type { 
#line 337
typedef float _Type; 
#line 338
}; 
#line 340
template<> struct _Combined_type< float, double>  { 
#line 342
typedef double _Type; 
#line 343
}; 
#line 345
template<> struct _Combined_type< float, long double>  { 
#line 347
typedef long double _Type; 
#line 348
}; 
#line 350
template< class _Ty, class _T2> struct _Real_widened { 
#line 352
typedef long double _Type; 
#line 353
}; 
#line 355
template<> struct _Real_widened< float, float>  { 
#line 357
typedef float _Type; 
#line 358
}; 
#line 360
template<> struct _Real_widened< float, double>  { 
#line 362
typedef double _Type; 
#line 363
}; 
#line 365
template<> struct _Real_widened< double, float>  { 
#line 367
typedef double _Type; 
#line 368
}; 
#line 370
template<> struct _Real_widened< double, double>  { 
#line 372
typedef double _Type; 
#line 373
}; 
#line 375
template< class _Ty> struct _Real_type { 
#line 377
typedef double _Type; 
#line 378
}; 
#line 380
template<> struct _Real_type< float>  { 
#line 382
typedef float _Type; 
#line 383
}; 
#line 385
template<> struct _Real_type< long double>  { 
#line 387
typedef long double _Type; 
#line 388
}; 
#line 390
template < class _T1, class _T2 >
      inline int _fpcomp ( _T1 _X, _T2 _Y ) throw ( )
    {
        typedef typename _Combined_type < float,
            typename _Real_widened <
            typename _Real_type < _T1 > :: _Type,
            typename _Real_type < _T2 > :: _Type > :: _Type > :: _Type _Tw;
        return _fpcomp ( ( _Tw ) _X, ( _Tw ) _Y );
    }
#line 400
template < class _Ty >
      inline bool isfinite ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) <= 0;
    }
#line 406
template < class _Ty >
      inline bool isinf ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 1;
    }
#line 412
template < class _Ty >
      inline bool isnan ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == 2;
    }
#line 418
template < class _Ty >
      inline bool isnormal ( _Ty _X ) throw ( )
    {
        return fpclassify ( _X ) == ( - 1 );
    }
#line 424
template < class _Ty1, class _Ty2 >
      inline bool isgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 4 ) != 0;
    }
#line 430
template < class _Ty1, class _Ty2 >
      inline bool isgreaterequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 2 | 4 ) ) != 0;
    }
#line 436
template < class _Ty1, class _Ty2 >
      inline bool isless ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & 1 ) != 0;
    }
#line 442
template < class _Ty1, class _Ty2 >
      inline bool islessequal ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 2 ) ) != 0;
    }
#line 448
template < class _Ty1, class _Ty2 >
      inline bool islessgreater ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return ( _fpcomp ( _X, _Y ) & ( 1 | 4 ) ) != 0;
    }
#line 454
template < class _Ty1, class _Ty2 >
      inline bool isunordered ( _Ty1 _X, _Ty2 _Y ) throw ( )
    {
        return _fpcomp ( _X, _Y ) == 0;
    }
#line 459
}
#line 466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
int __cdecl abs(int _X); 
#line 467
long __cdecl labs(long _X); 
#line 468
__int64 __cdecl llabs(__int64 _X); 
#line 470
double __cdecl acos(double _X); 
#line 471
double __cdecl asin(double _X); 
#line 472
double __cdecl atan(double _X); 
#line 473
double __cdecl atan2(double _Y, double _X); 
#line 475
double __cdecl cos(double _X); 
#line 476
double __cdecl cosh(double _X); 
#line 477
double __cdecl exp(double _X); 
#line 478
double __cdecl fabs(double _X); 
#line 479
double __cdecl fmod(double _X, double _Y); 
#line 480
double __cdecl log(double _X); 
#line 481
double __cdecl log10(double _X); 
#line 482
double __cdecl pow(double _X, double _Y); 
#line 483
double __cdecl sin(double _X); 
#line 484
double __cdecl sinh(double _X); 
#line 485
double __cdecl sqrt(double _X); 
#line 486
double __cdecl tan(double _X); 
#line 487
double __cdecl tanh(double _X); 
#line 489
__declspec(dllimport) double __cdecl acosh(double _X); 
#line 490
__declspec(dllimport) double __cdecl asinh(double _X); 
#line 491
__declspec(dllimport) double __cdecl atanh(double _X); 
#line 492
__declspec(dllimport) double __cdecl atof(const char * _String); 
#line 493
__declspec(dllimport) double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 494
__declspec(dllimport) double __cdecl _cabs(_complex _Complex_value); 
#line 495
__declspec(dllimport) double __cdecl cbrt(double _X); 
#line 496
__declspec(dllimport) double __cdecl ceil(double _X); 
#line 497
__declspec(dllimport) double __cdecl _chgsign(double _X); 
#line 498
__declspec(dllimport) double __cdecl copysign(double _Number, double _Sign); 
#line 499
__declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign); 
#line 500
__declspec(dllimport) double __cdecl erf(double _X); 
#line 501
__declspec(dllimport) double __cdecl erfc(double _X); 
#line 502
__declspec(dllimport) double __cdecl exp2(double _X); 
#line 503
__declspec(dllimport) double __cdecl expm1(double _X); 
#line 504
__declspec(dllimport) double __cdecl fdim(double _X, double _Y); 
#line 505
__declspec(dllimport) double __cdecl floor(double _X); 
#line 506
__declspec(dllimport) double __cdecl fma(double _X, double _Y, double _Z); 
#line 507
__declspec(dllimport) double __cdecl fmax(double _X, double _Y); 
#line 508
__declspec(dllimport) double __cdecl fmin(double _X, double _Y); 
#line 509
__declspec(dllimport) double __cdecl frexp(double _X, int * _Y); 
#line 510
__declspec(dllimport) double __cdecl hypot(double _X, double _Y); 
#line 511
__declspec(dllimport) double __cdecl _hypot(double _X, double _Y); 
#line 512
__declspec(dllimport) int __cdecl ilogb(double _X); 
#line 513
__declspec(dllimport) double __cdecl ldexp(double _X, int _Y); 
#line 514
__declspec(dllimport) double __cdecl lgamma(double _X); 
#line 515
__declspec(dllimport) __int64 __cdecl llrint(double _X); 
#line 516
__declspec(dllimport) __int64 __cdecl llround(double _X); 
#line 517
__declspec(dllimport) double __cdecl log1p(double _X); 
#line 518
__declspec(dllimport) double __cdecl log2(double _X); 
#line 519
__declspec(dllimport) double __cdecl logb(double _X); 
#line 520
__declspec(dllimport) long __cdecl lrint(double _X); 
#line 521
__declspec(dllimport) long __cdecl lround(double _X); 
#line 523
int __cdecl _matherr(_exception * _Except); 
#line 525
__declspec(dllimport) double __cdecl modf(double _X, double * _Y); 
#line 526
__declspec(dllimport) double __cdecl nan(const char * _X); 
#line 527
__declspec(dllimport) double __cdecl nearbyint(double _X); 
#line 528
__declspec(dllimport) double __cdecl nextafter(double _X, double _Y); 
#line 529
__declspec(dllimport) double __cdecl nexttoward(double _X, long double _Y); 
#line 530
__declspec(dllimport) double __cdecl remainder(double _X, double _Y); 
#line 531
__declspec(dllimport) double __cdecl remquo(double _X, double _Y, int * _Z); 
#line 532
__declspec(dllimport) double __cdecl rint(double _X); 
#line 533
__declspec(dllimport) double __cdecl round(double _X); 
#line 534
__declspec(dllimport) double __cdecl scalbln(double _X, long _Y); 
#line 535
__declspec(dllimport) double __cdecl scalbn(double _X, int _Y); 
#line 536
__declspec(dllimport) double __cdecl tgamma(double _X); 
#line 537
__declspec(dllimport) double __cdecl trunc(double _X); 
#line 538
__declspec(dllimport) double __cdecl _j0(double _X); 
#line 539
__declspec(dllimport) double __cdecl _j1(double _X); 
#line 540
__declspec(dllimport) double __cdecl _jn(int _X, double _Y); 
#line 541
__declspec(dllimport) double __cdecl _y0(double _X); 
#line 542
__declspec(dllimport) double __cdecl _y1(double _X); 
#line 543
__declspec(dllimport) double __cdecl _yn(int _X, double _Y); 
#line 545
__declspec(dllimport) float __cdecl acoshf(float _X); 
#line 546
__declspec(dllimport) float __cdecl asinhf(float _X); 
#line 547
__declspec(dllimport) float __cdecl atanhf(float _X); 
#line 548
__declspec(dllimport) float __cdecl cbrtf(float _X); 
#line 549
__declspec(dllimport) float __cdecl _chgsignf(float _X); 
#line 550
__declspec(dllimport) float __cdecl copysignf(float _Number, float _Sign); 
#line 551
__declspec(dllimport) float __cdecl _copysignf(float _Number, float _Sign); 
#line 552
__declspec(dllimport) float __cdecl erff(float _X); 
#line 553
__declspec(dllimport) float __cdecl erfcf(float _X); 
#line 554
__declspec(dllimport) float __cdecl expm1f(float _X); 
#line 555
__declspec(dllimport) float __cdecl exp2f(float _X); 
#line 556
__declspec(dllimport) float __cdecl fdimf(float _X, float _Y); 
#line 557
__declspec(dllimport) float __cdecl fmaf(float _X, float _Y, float _Z); 
#line 558
__declspec(dllimport) float __cdecl fmaxf(float _X, float _Y); 
#line 559
__declspec(dllimport) float __cdecl fminf(float _X, float _Y); 
#line 560
__declspec(dllimport) float __cdecl _hypotf(float _X, float _Y); 
#line 561
__declspec(dllimport) int __cdecl ilogbf(float _X); 
#line 562
__declspec(dllimport) float __cdecl lgammaf(float _X); 
#line 563
__declspec(dllimport) __int64 __cdecl llrintf(float _X); 
#line 564
__declspec(dllimport) __int64 __cdecl llroundf(float _X); 
#line 565
__declspec(dllimport) float __cdecl log1pf(float _X); 
#line 566
__declspec(dllimport) float __cdecl log2f(float _X); 
#line 567
__declspec(dllimport) float __cdecl logbf(float _X); 
#line 568
__declspec(dllimport) long __cdecl lrintf(float _X); 
#line 569
__declspec(dllimport) long __cdecl lroundf(float _X); 
#line 570
__declspec(dllimport) float __cdecl nanf(const char * _X); 
#line 571
__declspec(dllimport) float __cdecl nearbyintf(float _X); 
#line 572
__declspec(dllimport) float __cdecl nextafterf(float _X, float _Y); 
#line 573
__declspec(dllimport) float __cdecl nexttowardf(float _X, long double _Y); 
#line 574
__declspec(dllimport) float __cdecl remainderf(float _X, float _Y); 
#line 575
__declspec(dllimport) float __cdecl remquof(float _X, float _Y, int * _Z); 
#line 576
__declspec(dllimport) float __cdecl rintf(float _X); 
#line 577
__declspec(dllimport) float __cdecl roundf(float _X); 
#line 578
__declspec(dllimport) float __cdecl scalblnf(float _X, long _Y); 
#line 579
__declspec(dllimport) float __cdecl scalbnf(float _X, int _Y); 
#line 580
__declspec(dllimport) float __cdecl tgammaf(float _X); 
#line 581
__declspec(dllimport) float __cdecl truncf(float _X); 
#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) float __cdecl _logbf(float _X); 
#line 592
__declspec(dllimport) float __cdecl _nextafterf(float _X, float _Y); 
#line 593
__declspec(dllimport) int __cdecl _finitef(float _X); 
#line 594
__declspec(dllimport) int __cdecl _isnanf(float _X); 
#line 595
__declspec(dllimport) int __cdecl _fpclassf(float _X); 
#line 597
__declspec(dllimport) int __cdecl _set_FMA3_enable(int _Flag); 
#line 598
__declspec(dllimport) int __cdecl _get_FMA3_enable(); 
#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) float __cdecl acosf(float _X); 
#line 612
__declspec(dllimport) float __cdecl asinf(float _X); 
#line 613
__declspec(dllimport) float __cdecl atan2f(float _Y, float _X); 
#line 614
__declspec(dllimport) float __cdecl atanf(float _X); 
#line 615
__declspec(dllimport) float __cdecl ceilf(float _X); 
#line 616
__declspec(dllimport) float __cdecl cosf(float _X); 
#line 617
__declspec(dllimport) float __cdecl coshf(float _X); 
#line 618
__declspec(dllimport) float __cdecl expf(float _X); 
#line 670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__inline float __cdecl fabsf(float _X) 
#line 671
{ 
#line 672
return (float)fabs(_X); 
#line 673
} 
#line 679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) float __cdecl floorf(float _X); 
#line 680
__declspec(dllimport) float __cdecl fmodf(float _X, float _Y); 
#line 696 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__inline float __cdecl frexpf(float _X, int *_Y) 
#line 697
{ 
#line 698
return (float)frexp(_X, _Y); 
#line 699
} 
#line 701
__inline float __cdecl hypotf(float _X, float _Y) 
#line 702
{ 
#line 703
return _hypotf(_X, _Y); 
#line 704
} 
#line 706
__inline float __cdecl ldexpf(float _X, int _Y) 
#line 707
{ 
#line 708
return (float)ldexp(_X, _Y); 
#line 709
} 
#line 713
__declspec(dllimport) float __cdecl log10f(float _X); 
#line 714
__declspec(dllimport) float __cdecl logf(float _X); 
#line 715
__declspec(dllimport) float __cdecl modff(float _X, float * _Y); 
#line 716
__declspec(dllimport) float __cdecl powf(float _X, float _Y); 
#line 717
__declspec(dllimport) float __cdecl sinf(float _X); 
#line 718
__declspec(dllimport) float __cdecl sinhf(float _X); 
#line 719
__declspec(dllimport) float __cdecl sqrtf(float _X); 
#line 720
__declspec(dllimport) float __cdecl tanf(float _X); 
#line 721
__declspec(dllimport) float __cdecl tanhf(float _X); 
#line 775 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) long double __cdecl acoshl(long double _X); 
#line 777
__inline long double __cdecl acosl(long double _X) 
#line 778
{ 
#line 779
return acos((double)_X); 
#line 780
} 
#line 782
__declspec(dllimport) long double __cdecl asinhl(long double _X); 
#line 784
__inline long double __cdecl asinl(long double _X) 
#line 785
{ 
#line 786
return asin((double)_X); 
#line 787
} 
#line 789
__inline long double __cdecl atan2l(long double _Y, long double _X) 
#line 790
{ 
#line 791
return atan2((double)_Y, (double)_X); 
#line 792
} 
#line 794
__declspec(dllimport) long double __cdecl atanhl(long double _X); 
#line 796
__inline long double __cdecl atanl(long double _X) 
#line 797
{ 
#line 798
return atan((double)_X); 
#line 799
} 
#line 801
__declspec(dllimport) long double __cdecl cbrtl(long double _X); 
#line 803
__inline long double __cdecl ceill(long double _X) 
#line 804
{ 
#line 805
return ceil((double)_X); 
#line 806
} 
#line 808
__inline long double __cdecl _chgsignl(long double _X) 
#line 809
{ 
#line 810
return _chgsign((double)_X); 
#line 811
} 
#line 813
__declspec(dllimport) long double __cdecl copysignl(long double _Number, long double _Sign); 
#line 815
__inline long double __cdecl _copysignl(long double _Number, long double _Sign) 
#line 816
{ 
#line 817
return _copysign((double)_Number, (double)_Sign); 
#line 818
} 
#line 820
__inline long double __cdecl coshl(long double _X) 
#line 821
{ 
#line 822
return cosh((double)_X); 
#line 823
} 
#line 825
__inline long double __cdecl cosl(long double _X) 
#line 826
{ 
#line 827
return cos((double)_X); 
#line 828
} 
#line 830
__declspec(dllimport) long double __cdecl erfl(long double _X); 
#line 831
__declspec(dllimport) long double __cdecl erfcl(long double _X); 
#line 833
__inline long double __cdecl expl(long double _X) 
#line 834
{ 
#line 835
return exp((double)_X); 
#line 836
} 
#line 838
__declspec(dllimport) long double __cdecl exp2l(long double _X); 
#line 839
__declspec(dllimport) long double __cdecl expm1l(long double _X); 
#line 841
__inline long double __cdecl fabsl(long double _X) 
#line 842
{ 
#line 843
return fabs((double)_X); 
#line 844
} 
#line 846
__declspec(dllimport) long double __cdecl fdiml(long double _X, long double _Y); 
#line 848
__inline long double __cdecl floorl(long double _X) 
#line 849
{ 
#line 850
return floor((double)_X); 
#line 851
} 
#line 853
__declspec(dllimport) long double __cdecl fmal(long double _X, long double _Y, long double _Z); 
#line 854
__declspec(dllimport) long double __cdecl fmaxl(long double _X, long double _Y); 
#line 855
__declspec(dllimport) long double __cdecl fminl(long double _X, long double _Y); 
#line 857
__inline long double __cdecl fmodl(long double _X, long double _Y) 
#line 858
{ 
#line 859
return fmod((double)_X, (double)_Y); 
#line 860
} 
#line 862
__inline long double __cdecl frexpl(long double _X, int *_Y) 
#line 863
{ 
#line 864
return frexp((double)_X, _Y); 
#line 865
} 
#line 867
__declspec(dllimport) int __cdecl ilogbl(long double _X); 
#line 869
__inline long double __cdecl _hypotl(long double _X, long double _Y) 
#line 870
{ 
#line 871
return _hypot((double)_X, (double)_Y); 
#line 872
} 
#line 874
__inline long double __cdecl hypotl(long double _X, long double _Y) 
#line 875
{ 
#line 876
return _hypot((double)_X, (double)_Y); 
#line 877
} 
#line 879
__inline long double __cdecl ldexpl(long double _X, int _Y) 
#line 880
{ 
#line 881
return ldexp((double)_X, _Y); 
#line 882
} 
#line 884
__declspec(dllimport) long double __cdecl lgammal(long double _X); 
#line 885
__declspec(dllimport) __int64 __cdecl llrintl(long double _X); 
#line 886
__declspec(dllimport) __int64 __cdecl llroundl(long double _X); 
#line 888
__inline long double __cdecl logl(long double _X) 
#line 889
{ 
#line 890
return log((double)_X); 
#line 891
} 
#line 893
__inline long double __cdecl log10l(long double _X) 
#line 894
{ 
#line 895
return log10((double)_X); 
#line 896
} 
#line 898
__declspec(dllimport) long double __cdecl log1pl(long double _X); 
#line 899
__declspec(dllimport) long double __cdecl log2l(long double _X); 
#line 900
__declspec(dllimport) long double __cdecl logbl(long double _X); 
#line 901
__declspec(dllimport) long __cdecl lrintl(long double _X); 
#line 902
__declspec(dllimport) long __cdecl lroundl(long double _X); 
#line 904
__inline long double __cdecl modfl(long double _X, long double *_Y) 
#line 905
{ 
#line 906
double _F, _I; 
#line 907
_F = modf((double)_X, &_I); 
#line 908
(*_Y) = _I; 
#line 909
return _F; 
#line 910
} 
#line 912
__declspec(dllimport) long double __cdecl nanl(const char * _X); 
#line 913
__declspec(dllimport) long double __cdecl nearbyintl(long double _X); 
#line 914
__declspec(dllimport) long double __cdecl nextafterl(long double _X, long double _Y); 
#line 915
__declspec(dllimport) long double __cdecl nexttowardl(long double _X, long double _Y); 
#line 917
__inline long double __cdecl powl(long double _X, long double _Y) 
#line 918
{ 
#line 919
return pow((double)_X, (double)_Y); 
#line 920
} 
#line 922
__declspec(dllimport) long double __cdecl remainderl(long double _X, long double _Y); 
#line 923
__declspec(dllimport) long double __cdecl remquol(long double _X, long double _Y, int * _Z); 
#line 924
__declspec(dllimport) long double __cdecl rintl(long double _X); 
#line 925
__declspec(dllimport) long double __cdecl roundl(long double _X); 
#line 926
__declspec(dllimport) long double __cdecl scalblnl(long double _X, long _Y); 
#line 927
__declspec(dllimport) long double __cdecl scalbnl(long double _X, int _Y); 
#line 929
__inline long double __cdecl sinhl(long double _X) 
#line 930
{ 
#line 931
return sinh((double)_X); 
#line 932
} 
#line 934
__inline long double __cdecl sinl(long double _X) 
#line 935
{ 
#line 936
return sin((double)_X); 
#line 937
} 
#line 939
__inline long double __cdecl sqrtl(long double _X) 
#line 940
{ 
#line 941
return sqrt((double)_X); 
#line 942
} 
#line 944
__inline long double __cdecl tanhl(long double _X) 
#line 945
{ 
#line 946
return tanh((double)_X); 
#line 947
} 
#line 949
__inline long double __cdecl tanl(long double _X) 
#line 950
{ 
#line 951
return tan((double)_X); 
#line 952
} 
#line 954
__declspec(dllimport) long double __cdecl tgammal(long double _X); 
#line 955
__declspec(dllimport) long double __cdecl truncl(long double _X); 
#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
extern double HUGE; 
#line 981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
__declspec(dllimport) double __cdecl j0(double _X); 
#line 982
__declspec(dllimport) double __cdecl j1(double _X); 
#line 983
__declspec(dllimport) double __cdecl jn(int _X, double _Y); 
#line 984
__declspec(dllimport) double __cdecl y0(double _X); 
#line 985
__declspec(dllimport) double __cdecl y1(double _X); 
#line 986
__declspec(dllimport) double __cdecl yn(int _X, double _Y); 
#line 994 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_math.h"
}
#line 992
#pragma warning(pop)
#line 994
__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 55
_calloc_base(size_t _Count, size_t _Size); 
#line 61
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 62
calloc(size_t _Count, size_t _Size); 
#line 68
__declspec(dllimport) int __cdecl _callnewh(size_t _Size); 
#line 73
__declspec(dllimport) __declspec(allocator) void *__cdecl 
#line 74
_expand(void * _Block, size_t _Size); 
#line 79
__declspec(dllimport) void __cdecl 
#line 80
_free_base(void * _Block); 
#line 84
__declspec(dllimport) void __cdecl 
#line 85
free(void * _Block); 
#line 90
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 91
_malloc_base(size_t _Size); 
#line 96
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 97
malloc(size_t _Size); 
#line 102
__declspec(dllimport) size_t __cdecl 
#line 103
_msize_base(void * _Block); 
#line 108
__declspec(dllimport) size_t __cdecl 
#line 109
_msize(void * _Block); 
#line 114
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 115
_realloc_base(void * _Block, size_t _Size); 
#line 121
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 122
realloc(void * _Block, size_t _Size); 
#line 128
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 129
_recalloc_base(void * _Block, size_t _Count, size_t _Size); 
#line 136
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 137
_recalloc(void * _Block, size_t _Count, size_t _Size); 
#line 143
__declspec(dllimport) void __cdecl 
#line 144
_aligned_free(void * _Block); 
#line 149
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 150
_aligned_malloc(size_t _Size, size_t _Alignment); 
#line 156
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 157
_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset); 
#line 164
__declspec(dllimport) size_t __cdecl 
#line 165
_aligned_msize(void * _Block, size_t _Alignment, size_t _Offset); 
#line 172
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 173
_aligned_offset_realloc(void * _Block, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 181
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 182
_aligned_offset_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset); 
#line 191
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 192
_aligned_realloc(void * _Block, size_t _Size, size_t _Alignment); 
#line 199
__declspec(dllimport) __declspec(allocator) __declspec(restrict) void *__cdecl 
#line 200
_aligned_recalloc(void * _Block, size_t _Count, size_t _Size, size_t _Alignment); 
#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_malloc.h"
}__pragma( pack ( pop )) 
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
typedef int (__cdecl *_CoreCrtSecureSearchSortCompareFunction)(void *, const void *, const void *); 
#line 20
typedef int (__cdecl *_CoreCrtNonSecureSearchSortCompareFunction)(const void *, const void *); 
#line 26
__declspec(dllimport) void *__cdecl bsearch_s(const void * _Key, const void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 35
__declspec(dllimport) void __cdecl qsort_s(void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
__declspec(dllimport) void *__cdecl bsearch(const void * _Key, const void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 56
__declspec(dllimport) void __cdecl qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 64
__declspec(dllimport) void *__cdecl _lfind_s(const void * _Key, const void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 74
__declspec(dllimport) void *__cdecl _lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 83
__declspec(dllimport) void *__cdecl _lsearch_s(const void * _Key, void * _Base, unsigned * _NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void * _Context); 
#line 93
__declspec(dllimport) void *__cdecl _lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
__declspec(dllimport) void *__cdecl lfind(const void * _Key, const void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 200
__declspec(dllimport) void *__cdecl lsearch(const void * _Key, void * _Base, unsigned * _NumOfElements, unsigned _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction); 
#line 212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_search.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 50
__declspec(dllimport) errno_t __cdecl _itow_s(int _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 57
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) __wchar_t *__cdecl _itow(int _Value, __wchar_t * _Buffer, int _Radix); 
#line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) errno_t __cdecl _ltow_s(long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 80
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) __wchar_t *__cdecl _ltow(long _Value, __wchar_t * _Buffer, int _Radix); 
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) errno_t __cdecl _ultow_s(unsigned long _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 102
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) __wchar_t *__cdecl _ultow(unsigned long _Value, __wchar_t * _Buffer, int _Radix); 
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) double __cdecl wcstod(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 123
__declspec(dllimport) double __cdecl _wcstod_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 130
__declspec(dllimport) long __cdecl wcstol(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 137
__declspec(dllimport) long __cdecl _wcstol_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 145
__declspec(dllimport) __int64 __cdecl wcstoll(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 152
__declspec(dllimport) __int64 __cdecl _wcstoll_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 160
__declspec(dllimport) unsigned long __cdecl wcstoul(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 167
__declspec(dllimport) unsigned long __cdecl _wcstoul_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 175
__declspec(dllimport) unsigned __int64 __cdecl wcstoull(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 182
__declspec(dllimport) unsigned __int64 __cdecl _wcstoull_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 190
__declspec(dllimport) long double __cdecl wcstold(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 196
__declspec(dllimport) long double __cdecl _wcstold_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 203
__declspec(dllimport) float __cdecl wcstof(const __wchar_t * _String, __wchar_t ** _EndPtr); 
#line 209
__declspec(dllimport) float __cdecl _wcstof_l(const __wchar_t * _String, __wchar_t ** _EndPtr, _locale_t _Locale); 
#line 216
__declspec(dllimport) double __cdecl _wtof(const __wchar_t * _String); 
#line 221
__declspec(dllimport) double __cdecl _wtof_l(const __wchar_t * _String, _locale_t _Locale); 
#line 227
__declspec(dllimport) int __cdecl _wtoi(const __wchar_t * _String); 
#line 232
__declspec(dllimport) int __cdecl _wtoi_l(const __wchar_t * _String, _locale_t _Locale); 
#line 238
__declspec(dllimport) long __cdecl _wtol(const __wchar_t * _String); 
#line 243
__declspec(dllimport) long __cdecl _wtol_l(const __wchar_t * _String, _locale_t _Locale); 
#line 249
__declspec(dllimport) __int64 __cdecl _wtoll(const __wchar_t * _String); 
#line 254
__declspec(dllimport) __int64 __cdecl _wtoll_l(const __wchar_t * _String, _locale_t _Locale); 
#line 260
__declspec(dllimport) errno_t __cdecl _i64tow_s(__int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 268
__declspec(dllimport) __wchar_t *__cdecl _i64tow(__int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 275
__declspec(dllimport) errno_t __cdecl _ui64tow_s(unsigned __int64 _Value, __wchar_t * _Buffer, size_t _BufferCount, int _Radix); 
#line 283
__declspec(dllimport) __wchar_t *__cdecl _ui64tow(unsigned __int64 _Value, __wchar_t * _Buffer, int _Radix); 
#line 290
__declspec(dllimport) __int64 __cdecl _wtoi64(const __wchar_t * _String); 
#line 295
__declspec(dllimport) __int64 __cdecl _wtoi64_l(const __wchar_t * _String, _locale_t _Locale); 
#line 301
__declspec(dllimport) __int64 __cdecl _wcstoi64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 308
__declspec(dllimport) __int64 __cdecl _wcstoi64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 316
__declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix); 
#line 323
__declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * _String, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 335
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wfullpath(__wchar_t * _Buffer, const __wchar_t * _Path, size_t _BufferCount); 
#line 344
__declspec(dllimport) errno_t __cdecl _wmakepath_s(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 353
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Drive, wchar_t const * _Dir, wchar_t const * _Filename, wchar_t const * _Ext ) throw ( ) { return _wmakepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) void __cdecl _wmakepath(__wchar_t * _Buffer, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
#pragma warning(pop)
#line 375
__declspec(dllimport) void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 380
__declspec(dllimport) void __cdecl _wsplitpath(const __wchar_t * _FullPath, __wchar_t * _Drive, __wchar_t * _Dir, __wchar_t * _Filename, __wchar_t * _Ext); 
#line 388
__declspec(dllimport) errno_t __cdecl _wsplitpath_s(const __wchar_t * _FullPath, __wchar_t * _Drive, size_t _DriveCount, __wchar_t * _Dir, size_t _DirCount, __wchar_t * _Filename, size_t _FilenameCount, __wchar_t * _Ext, size_t _ExtCount); 
#line 400
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( wchar_t const * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) errno_t __cdecl _wdupenv_s(__wchar_t ** _Buffer, size_t * _BufferCount, const __wchar_t * _VarName); 
#line 418
__declspec(dllimport) __wchar_t *__cdecl _wgetenv(const __wchar_t * _VarName); 
#line 424
__declspec(dllimport) errno_t __cdecl _wgetenv_s(size_t * _RequiredCount, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _VarName); 
#line 431
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _RequiredCount, wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _VarName ) throw ( ) { return _wgetenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) int __cdecl _wputenv(const __wchar_t * _EnvString); 
#line 445
__declspec(dllimport) errno_t __cdecl _wputenv_s(const __wchar_t * _Name, const __wchar_t * _Value); 
#line 450
__declspec(dllimport) errno_t __cdecl _wsearchenv_s(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _Buffer, size_t _BufferCount); 
#line 457
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( wchar_t const * _Filename, wchar_t const * _VarName, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _VarName, _ResultPath, _Size ); }}
#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) void __cdecl _wsearchenv(const __wchar_t * _Filename, const __wchar_t * _VarName, __wchar_t * _ResultPath); 
#line 471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
__declspec(dllimport) int __cdecl _wsystem(const __wchar_t * _Command); 
#line 479 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdlib.h"
}__pragma( pack ( pop )) 
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) void __cdecl _swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 52
__declspec(dllimport) __declspec(noreturn) void __cdecl exit(int _Code); 
#line 53
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int _Code); 
#line 54
__declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(int _Code); 
#line 55
__declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(int _Code); 
#line 56
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(); 
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) unsigned __cdecl _set_abort_behavior(unsigned _Flags, unsigned _Mask); 
#line 73
typedef int (__cdecl *_onexit_t)(void); 
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
int __cdecl atexit(void (__cdecl *)(void)); 
#line 141
_onexit_t __cdecl _onexit(_onexit_t _Func); 
#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
int __cdecl at_quick_exit(void (__cdecl *)(void)); 
#line 155
typedef void (__cdecl *_purecall_handler)(void); 
#line 158
typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); 
#line 167
_purecall_handler __cdecl _set_purecall_handler(_purecall_handler _Handler); 
#line 171
_purecall_handler __cdecl _get_purecall_handler(); 
#line 174
__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 178
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); 
#line 180
__declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler); 
#line 184
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(); 
#line 208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl _set_error_mode(int _Mode); 
#line 213
__declspec(dllimport) int *__cdecl _errno(); 
#line 216
__declspec(dllimport) errno_t __cdecl _set_errno(int _Value); 
#line 217
__declspec(dllimport) errno_t __cdecl _get_errno(int * _Value); 
#line 219
__declspec(dllimport) unsigned long *__cdecl __doserrno(); 
#line 222
__declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value); 
#line 223
__declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long * _Value); 
#line 226
__declspec(dllimport) char **__cdecl __sys_errlist(); 
#line 229
__declspec(dllimport) int *__cdecl __sys_nerr(); 
#line 232
__declspec(dllimport) void __cdecl perror(const char * _ErrMsg); 
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) char **__cdecl __p__pgmptr(); 
#line 239
__declspec(dllimport) __wchar_t **__cdecl __p__wpgmptr(); 
#line 240
__declspec(dllimport) int *__cdecl __p__fmode(); 
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _get_pgmptr(char ** _Value); 
#line 258
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(__wchar_t ** _Value); 
#line 260
__declspec(dllimport) errno_t __cdecl _set_fmode(int _Mode); 
#line 262
__declspec(dllimport) errno_t __cdecl _get_fmode(int * _PMode); 
#line 275
typedef 
#line 271
struct _div_t { 
#line 273
int quot; 
#line 274
int rem; 
#line 275
} div_t; 
#line 281
typedef 
#line 277
struct _ldiv_t { 
#line 279
long quot; 
#line 280
long rem; 
#line 281
} ldiv_t; 
#line 287
typedef 
#line 283
struct _lldiv_t { 
#line 285
__int64 quot; 
#line 286
__int64 rem; 
#line 287
} lldiv_t; 
#line 289
int __cdecl abs(int _Number); 
#line 290
long __cdecl labs(long _Number); 
#line 291
__int64 __cdecl llabs(__int64 _Number); 
#line 292
__int64 __cdecl _abs64(__int64 _Number); 
#line 294
unsigned short __cdecl _byteswap_ushort(unsigned short _Number); 
#line 295
unsigned long __cdecl _byteswap_ulong(unsigned long _Number); 
#line 296
unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Number); 
#line 298
__declspec(dllimport) div_t __cdecl div(int _Numerator, int _Denominator); 
#line 299
__declspec(dllimport) ldiv_t __cdecl ldiv(long _Numerator, long _Denominator); 
#line 300
__declspec(dllimport) lldiv_t __cdecl lldiv(__int64 _Numerator, __int64 _Denominator); 
#line 304
#pragma warning (push)
#pragma warning (disable:6540)
#line 307
unsigned __cdecl _rotl(unsigned _Value, int _Shift); 
#line 313
unsigned long __cdecl _lrotl(unsigned long _Value, int _Shift); 
#line 318
unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift); 
#line 323
unsigned __cdecl _rotr(unsigned _Value, int _Shift); 
#line 329
unsigned long __cdecl _lrotr(unsigned long _Value, int _Shift); 
#line 334
unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift); 
#line 339
#pragma warning (pop)
#line 346
__declspec(dllimport) void __cdecl srand(unsigned _Seed); 
#line 348
__declspec(dllimport) int __cdecl rand(); 
#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
extern "C++" {
#line 359
inline long abs(const long _X) throw() 
#line 360
{ 
#line 361
return labs(_X); 
#line 362
} 
#line 364
inline __int64 abs(const __int64 _X) throw() 
#line 365
{ 
#line 366
return llabs(_X); 
#line 367
} 
#line 369
inline ldiv_t div(const long _A1, const long _A2) throw() 
#line 370
{ 
#line 371
return ldiv(_A1, _A2); 
#line 372
} 
#line 374
inline lldiv_t div(const __int64 _A1, const __int64 _A2) throw() 
#line 375
{ 
#line 376
return lldiv(_A1, _A2); 
#line 377
} 
#line 378
}
#line 390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma pack ( push, 4 )
#line 394
typedef 
#line 392
struct { 
#line 393
unsigned char ld[10]; 
#line 394
} _LDOUBLE; 
#pragma pack ( pop )
#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
typedef 
#line 412
struct { 
#line 413
double x; 
#line 414
} _CRT_DOUBLE; 
#line 419
typedef 
#line 417
struct { 
#line 418
float f; 
#line 419
} _CRT_FLOAT; 
#line 428
typedef 
#line 426
struct { 
#line 427
long double x; 
#line 428
} _LONGDOUBLE; 
#line 432
#pragma pack ( push, 4 )
#line 436
typedef 
#line 434
struct { 
#line 435
unsigned char ld12[12]; 
#line 436
} _LDBL12; 
#pragma pack ( pop )
#line 446
__declspec(dllimport) double __cdecl atof(const char * _String); 
#line 447
__declspec(dllimport) int __cdecl atoi(const char * _String); 
#line 448
__declspec(dllimport) long __cdecl atol(const char * _String); 
#line 449
__declspec(dllimport) __int64 __cdecl atoll(const char * _String); 
#line 450
__declspec(dllimport) __int64 __cdecl _atoi64(const char * _String); 
#line 452
__declspec(dllimport) double __cdecl _atof_l(const char * _String, _locale_t _Locale); 
#line 453
__declspec(dllimport) int __cdecl _atoi_l(const char * _String, _locale_t _Locale); 
#line 454
__declspec(dllimport) long __cdecl _atol_l(const char * _String, _locale_t _Locale); 
#line 455
__declspec(dllimport) __int64 __cdecl _atoll_l(const char * _String, _locale_t _Locale); 
#line 456
__declspec(dllimport) __int64 __cdecl _atoi64_l(const char * _String, _locale_t _Locale); 
#line 458
__declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * _Result, const char * _String); 
#line 459
__declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * _Result, char * _String); 
#line 460
__declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * _Result, char * _String); 
#line 463
__declspec(dllimport) int __cdecl _atoflt_l(_CRT_FLOAT * _Result, const char * _String, _locale_t _Locale); 
#line 470
__declspec(dllimport) int __cdecl _atodbl_l(_CRT_DOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 478
__declspec(dllimport) int __cdecl _atoldbl_l(_LDOUBLE * _Result, char * _String, _locale_t _Locale); 
#line 485
__declspec(dllimport) float __cdecl strtof(const char * _String, char ** _EndPtr); 
#line 491
__declspec(dllimport) float __cdecl _strtof_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 498
__declspec(dllimport) double __cdecl strtod(const char * _String, char ** _EndPtr); 
#line 504
__declspec(dllimport) double __cdecl _strtod_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 511
__declspec(dllimport) long double __cdecl strtold(const char * _String, char ** _EndPtr); 
#line 517
__declspec(dllimport) long double __cdecl _strtold_l(const char * _String, char ** _EndPtr, _locale_t _Locale); 
#line 524
__declspec(dllimport) long __cdecl strtol(const char * _String, char ** _EndPtr, int _Radix); 
#line 531
__declspec(dllimport) long __cdecl _strtol_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 539
__declspec(dllimport) __int64 __cdecl strtoll(const char * _String, char ** _EndPtr, int _Radix); 
#line 546
__declspec(dllimport) __int64 __cdecl _strtoll_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 554
__declspec(dllimport) unsigned long __cdecl strtoul(const char * _String, char ** _EndPtr, int _Radix); 
#line 561
__declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 569
__declspec(dllimport) unsigned __int64 __cdecl strtoull(const char * _String, char ** _EndPtr, int _Radix); 
#line 576
__declspec(dllimport) unsigned __int64 __cdecl _strtoull_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 584
__declspec(dllimport) __int64 __cdecl _strtoi64(const char * _String, char ** _EndPtr, int _Radix); 
#line 591
__declspec(dllimport) __int64 __cdecl _strtoi64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 599
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(const char * _String, char ** _EndPtr, int _Radix); 
#line 606
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); 
#line 622
__declspec(dllimport) errno_t __cdecl _itoa_s(int _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 629
extern "C++" {template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 637 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) char *__cdecl _itoa(int _Value, char * _Buffer, int _Radix); 
#line 646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)
#line 650
__declspec(dllimport) errno_t __cdecl _ltoa_s(long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 657
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 664 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _ltoa(long _Value, char * _Buffer, int _Radix); 
#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _ultoa_s(unsigned long _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 680
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Buffer ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Buffer, _Size, _Radix ); }}
#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(dllimport) char *__cdecl _ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)
#line 699
__declspec(dllimport) errno_t __cdecl _i64toa_s(__int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 708
__declspec(dllimport) char *__cdecl _i64toa(__int64 _Value, char * _Buffer, int _Radix); 
#line 716
__declspec(dllimport) errno_t __cdecl _ui64toa_s(unsigned __int64 _Value, char * _Buffer, size_t _BufferCount, int _Radix); 
#line 724
__declspec(dllimport) char *__cdecl _ui64toa(unsigned __int64 _Value, char * _Buffer, int _Radix); 
#line 744
__declspec(dllimport) errno_t __cdecl _ecvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 753
extern "C++" {template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign ); }}
#line 763 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 772
__declspec(dllimport) errno_t __cdecl _fcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 781
extern "C++" {template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign ); }}
#line 793 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 801
__declspec(dllimport) errno_t __cdecl _gcvt_s(char * _Buffer, size_t _BufferCount, double _Value, int _DigitCount); 
#line 808
extern "C++" {template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Buffer ) [ _Size ], double _Value, int _DigitCount ) throw ( ) { return _gcvt_s ( _Buffer, _Size, _Value, _DigitCount ); }}
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl _gcvt(double _Value, int _DigitCount, char * _Buffer); 
#line 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl ___mb_cur_max_func(); 
#line 849
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale); 
#line 855 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl mblen(const char * _Ch, size_t _MaxCount); 
#line 861
__declspec(dllimport) int __cdecl _mblen_l(const char * _Ch, size_t _MaxCount, _locale_t _Locale); 
#line 869
__declspec(dllimport) size_t __cdecl _mbstrlen(const char * _String); 
#line 875
__declspec(dllimport) size_t __cdecl _mbstrlen_l(const char * _String, _locale_t _Locale); 
#line 882
__declspec(dllimport) size_t __cdecl _mbstrnlen(const char * _String, size_t _MaxCount); 
#line 889
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(const char * _String, size_t _MaxCount, _locale_t _Locale); 
#line 896
__declspec(dllimport) int __cdecl mbtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes); 
#line 903
__declspec(dllimport) int __cdecl _mbtowc_l(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale); 
#line 911
__declspec(dllimport) errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount); 
#line 919
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl mbstowcs(__wchar_t * _Dest, const char * _Source, size_t _MaxCount); 
#line 935 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount, _locale_t _Locale); 
#line 944
extern "C++" {template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], char const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 953 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl _mbstowcs_l(__wchar_t * _Dest, const char * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl wctomb(char * _MbCh, __wchar_t _WCh); 
#line 972
__declspec(dllimport) int __cdecl _wctomb_l(char * _MbCh, __wchar_t _WCh, _locale_t _Locale); 
#line 981
__declspec(dllimport) errno_t __cdecl wctomb_s(int * _SizeConverted, char * _MbCh, rsize_t _SizeInBytes, __wchar_t _WCh); 
#line 991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _wctomb_s_l(int * _SizeConverted, char * _MbCh, size_t _SizeInBytes, __wchar_t _WCh, _locale_t _Locale); 
#line 999
__declspec(dllimport) errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes); 
#line 1007
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }}
#line 1015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl wcstombs(char * _Dest, const __wchar_t * _Source, size_t _MaxCount); 
#line 1023 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes, _locale_t _Locale); 
#line 1032
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], wchar_t const * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }}
#line 1041 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) size_t __cdecl _wcstombs_l(char * _Dest, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); 
#line 1071 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) __declspec(allocator) char *__cdecl _fullpath(char * _Buffer, const char * _Path, size_t _BufferCount); 
#line 1080
__declspec(dllimport) errno_t __cdecl _makepath_s(char * _Buffer, size_t _BufferCount, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1089
extern "C++" {template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Buffer ) [ _Size ], char const * _Drive, char const * _Dir, char const * _Filename, char const * _Ext ) throw ( ) { return _makepath_s ( _Buffer, _Size, _Drive, _Dir, _Filename, _Ext ); }}
#line 1098 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__declspec(dllimport) void __cdecl _makepath(char * _Buffer, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); 
#line 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(pop)
#line 1112
__declspec(dllimport) void __cdecl _splitpath(const char * _FullPath, char * _Drive, char * _Dir, char * _Filename, char * _Ext); 
#line 1121
__declspec(dllimport) errno_t __cdecl _splitpath_s(const char * _FullPath, char * _Drive, size_t _DriveCount, char * _Dir, size_t _DirCount, char * _Filename, size_t _FilenameCount, char * _Ext, size_t _ExtCount); 
#line 1133
extern "C++" {template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( char const * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }}
#line 1139
__declspec(dllimport) errno_t __cdecl getenv_s(size_t * _RequiredCount, char * _Buffer, rsize_t _BufferCount, const char * _VarName); 
#line 1151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) int *__cdecl __p___argc(); 
#line 1152
__declspec(dllimport) char ***__cdecl __p___argv(); 
#line 1153
__declspec(dllimport) __wchar_t ***__cdecl __p___wargv(); 
#line 1165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) char ***__cdecl __p__environ(); 
#line 1166
__declspec(dllimport) __wchar_t ***__cdecl __p__wenviron(); 
#line 1191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) char *__cdecl getenv(const char * _VarName); 
#line 1195
extern "C++" {template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _RequiredCount, char ( & _Buffer ) [ _Size ], char const * _VarName ) throw ( ) { return getenv_s ( _RequiredCount, _Buffer, _Size, _VarName ); }}
#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) errno_t __cdecl _dupenv_s(char ** _Buffer, size_t * _BufferCount, const char * _VarName); 
#line 1218 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) int __cdecl system(const char * _Command); 
#line 1224
#pragma warning (push)
#pragma warning (disable:6540)
#line 1228
__declspec(dllimport) int __cdecl _putenv(const char * _EnvString); 
#line 1233
__declspec(dllimport) errno_t __cdecl _putenv_s(const char * _Name, const char * _Value); 
#line 1238
#pragma warning (pop)
#line 1240
__declspec(dllimport) errno_t __cdecl _searchenv_s(const char * _Filename, const char * _VarName, char * _Buffer, size_t _BufferCount); 
#line 1247
extern "C++" {template < size_t _Size > inline errno_t __cdecl _searchenv_s ( char const * _Filename, char const * _VarName, char ( & _Buffer ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _VarName, _Buffer, _Size ); }}
#line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(dllimport) void __cdecl _searchenv(const char * _Filename, const char * _VarName, char * _Buffer); 
#line 1262 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) 
#line 1263
__declspec(dllimport) void __cdecl _seterrormode(int _Mode); 
#line 1267
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) 
#line 1268
__declspec(dllimport) void __cdecl _beep(unsigned _Frequency, unsigned _Duration); 
#line 1273
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) 
#line 1274
__declspec(dllimport) void __cdecl _sleep(unsigned long _Duration); 
#line 1296 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
#line 1300
__declspec(dllimport) char *__cdecl ecvt(double _Value, int _DigitCount, int * _PtDec, int * _PtSign); 
#line 1308
__declspec(dllimport) char *__cdecl fcvt(double _Value, int _FractionalDigitCount, int * _PtDec, int * _PtSign); 
#line 1316
__declspec(dllimport) char *__cdecl gcvt(double _Value, int _DigitCount, char * _DstBuf); 
#line 1323
__declspec(dllimport) char *__cdecl itoa(int _Value, char * _Buffer, int _Radix); 
#line 1330
__declspec(dllimport) char *__cdecl ltoa(long _Value, char * _Buffer, int _Radix); 
#line 1338
__declspec(dllimport) void __cdecl swab(char * _Buf1, char * _Buf2, int _SizeInBytes); 
#line 1345
__declspec(dllimport) char *__cdecl ultoa(unsigned long _Value, char * _Buffer, int _Radix); 
#line 1354
__declspec(dllimport) int __cdecl putenv(const char * _EnvString); 
#line 1358
#pragma warning(pop)
#line 1360
_onexit_t __cdecl onexit(_onexit_t _Func); 
#line 1366 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdlib.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
extern "C++" {
#line 15
#pragma pack ( push, 8 )
#line 17
#pragma warning(push)
#pragma warning(disable: 4985)
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
namespace std { 
#line 51
struct nothrow_t { 
#line 53
explicit nothrow_t() = default;
#line 55 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
}; 
#line 60
extern const nothrow_t nothrow; 
#line 62 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
}
#line 66 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
__declspec(allocator) void *__cdecl operator new(size_t _Size); 
#line 71
__declspec(allocator) void *__cdecl operator new(size_t _Size, const std::nothrow_t &) noexcept; 
#line 77
__declspec(allocator) void *__cdecl operator new[](size_t _Size); 
#line 82
__declspec(allocator) void *__cdecl operator new[](size_t _Size, const std::nothrow_t &) noexcept; 
#line 87
void __cdecl operator delete(void * _Block) noexcept; 
#line 91
void __cdecl operator delete(void * _Block, const std::nothrow_t &) noexcept; 
#line 96
void __cdecl operator delete[](void * _Block) noexcept; 
#line 100
void __cdecl operator delete[](void * _Block, const std::nothrow_t &) noexcept; 
#line 105
void __cdecl operator delete(void * _Block, size_t _Size) noexcept; 
#line 110
void __cdecl operator delete[](void * _Block, size_t _Size) noexcept; 
#line 178 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
#pragma warning(push)
#pragma warning(disable: 4577)
#pragma warning(disable: 4514)
#line 184
inline void *__cdecl operator new(size_t _Size, void *_Where) noexcept 
#line 185
{ 
#line 186
(void)_Size; 
#line 187
return _Where; 
#line 188
} 
#line 190
inline void __cdecl operator delete(void *, void *) noexcept 
#line 191
{ 
#line 193
} 
#line 199 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
inline void *__cdecl operator new[](size_t _Size, void *
#line 200
_Where) noexcept 
#line 201
{ 
#line 202
(void)_Size; 
#line 203
return _Where; 
#line 204
} 
#line 206
inline void __cdecl operator delete[](void *, void *) noexcept 
#line 207
{ 
#line 208
} 
#line 217 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new.h"
}
#line 210
#pragma warning(pop)
#line 214
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new_debug.h"
extern "C++" {
#line 15
#pragma pack ( push, 8 )
#line 23
__declspec(allocator) void *__cdecl operator new(size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 31
__declspec(allocator) void *__cdecl operator new[](size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 38
void __cdecl operator delete(void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) noexcept; 
#line 45
void __cdecl operator delete[](void * _Block, int _BlockUse, const char * _FileName, int _LineNumber) noexcept; 
#line 58 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_new_debug.h"
}
#line 56
#pragma pack ( pop )
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
typedef void *_HFILE; 
#line 45
typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); 
#line 46
typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); 
#line 52
typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); 
#line 108
typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); 
#line 114
struct _CrtMemBlockHeader; 
#line 123
typedef 
#line 116
struct _CrtMemState { 
#line 118
_CrtMemBlockHeader *pBlockHeader; 
#line 119
size_t lCounts[5]; 
#line 120
size_t lSizes[5]; 
#line 121
size_t lHighWaterCount; 
#line 122
size_t lTotalCount; 
#line 123
} _CrtMemState; 
#line 152
__declspec(dllimport) int *__cdecl __p__crtDbgFlag(); 
#line 153
__declspec(dllimport) long *__cdecl __p__crtBreakAlloc(); 
#line 158
__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(); 
#line 160
__declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(_CRT_ALLOC_HOOK _PfnNewHook); 
#line 164
__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(); 
#line 166
__declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(_CRT_DUMP_CLIENT _PFnNewDump); 
#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
__declspec(dllimport) int __cdecl _CrtCheckMemory(); 
#line 174
typedef void (__cdecl *_CrtDoForAllClientObjectsCallback)(void *, void *); 
#line 176
__declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(_CrtDoForAllClientObjectsCallback _Callback, void * _Context); 
#line 181
__declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(); 
#line 183
__declspec(dllimport) int __cdecl _CrtIsMemoryBlock(const void * _Block, unsigned _Size, long * _RequestNumber, char ** _FileName, int * _LineNumber); 
#line 192
__declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(const void * _Pointer); 
#line 197
__declspec(dllimport) int __cdecl _CrtIsValidPointer(const void * _Pointer, unsigned _Size, int _ReadWrite); 
#line 203
__declspec(dllimport) void __cdecl _CrtMemCheckpoint(_CrtMemState * _State); 
#line 207
__declspec(dllimport) int __cdecl _CrtMemDifference(_CrtMemState * _State, const _CrtMemState * _OldState, const _CrtMemState * _NewState); 
#line 213
__declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(const _CrtMemState * _State); 
#line 217
__declspec(dllimport) void __cdecl _CrtMemDumpStatistics(const _CrtMemState * _State); 
#line 222
__declspec(dllimport) int __cdecl _CrtReportBlockType(const void * _Block); 
#line 226
__declspec(dllimport) long __cdecl _CrtSetBreakAlloc(long _NewValue); 
#line 230
__declspec(dllimport) int __cdecl _CrtSetDbgFlag(int _NewFlag); 
#line 328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
__declspec(dllimport) void __cdecl _aligned_free_dbg(void * _Block); 
#line 333
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_malloc_dbg(size_t _Size, size_t _Alignment, const char * _FileName, int _LineNumber); 
#line 340
__declspec(dllimport) size_t __cdecl _aligned_msize_dbg(void * _Block, size_t _Alignment, size_t _Offset); 
#line 347
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_offset_malloc_dbg(size_t _Size, size_t _Alignment, size_t _Offset, const char * _FileName, int _LineNumber); 
#line 356
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_offset_realloc_dbg(void * _Block, size_t _Size, size_t _Alignment, size_t _Offset, const char * _FileName, int _LineNumber); 
#line 366
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_offset_recalloc_dbg(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset, const char * _FileName, int _LineNumber); 
#line 377
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_realloc_dbg(void * _Block, size_t _Size, size_t _Alignment, const char * _FileName, int _LineNumber); 
#line 386
__declspec(dllimport) __declspec(allocator) void *__cdecl _aligned_recalloc_dbg(void * _Block, size_t _Count, size_t _Size, size_t _Alignment, const char * _FileName, int _LineNumber); 
#line 396
__declspec(dllimport) __declspec(allocator) void *__cdecl _calloc_dbg(size_t _Count, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 405
__declspec(dllimport) __declspec(allocator) void *__cdecl _expand_dbg(void * _Block, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 413
__declspec(dllimport) void __cdecl _free_dbg(void * _Block, int _BlockUse); 
#line 419
__declspec(dllimport) __declspec(allocator) void *__cdecl _malloc_dbg(size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 426
__declspec(dllimport) size_t __cdecl _msize_dbg(void * _Block, int _BlockUse); 
#line 432
__declspec(dllimport) __declspec(allocator) void *__cdecl _realloc_dbg(void * _Block, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 441
__declspec(dllimport) __declspec(allocator) void *__cdecl _recalloc_dbg(void * _Block, size_t _Count, size_t _Size, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 452
__declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(char ** _PBuffer, size_t * _PBufferSizeInBytes, const char * _VarName, int _BlockType, const char * _FileName, int _LineNumber); 
#line 463
__declspec(dllimport) __declspec(allocator) char *__cdecl _fullpath_dbg(char * _FullPath, const char * _Path, size_t _SizeInBytes, int _BlockType, const char * _FileName, int _LineNumber); 
#line 474
__declspec(dllimport) __declspec(allocator) char *__cdecl _getcwd_dbg(char * _DstBuf, int _SizeInBytes, int _BlockType, const char * _FileName, int _LineNumber); 
#line 485
__declspec(dllimport) __declspec(allocator) char *__cdecl _getdcwd_dbg(int _Drive, char * _DstBuf, int _SizeInBytes, int _BlockType, const char * _FileName, int _LineNumber); 
#line 495
__declspec(dllimport) __declspec(allocator) char *__cdecl _strdup_dbg(const char * _String, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 503
__declspec(dllimport) __declspec(allocator) char *__cdecl _tempnam_dbg(const char * _DirName, const char * _FilePrefix, int _BlockType, const char * _FileName, int _LineNumber); 
#line 513
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wcsdup_dbg(const __wchar_t * _String, int _BlockUse, const char * _FileName, int _LineNumber); 
#line 522
__declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(__wchar_t ** _PBuffer, size_t * _PBufferSizeInWords, const __wchar_t * _VarName, int _BlockType, const char * _FileName, int _LineNumber); 
#line 533
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wfullpath_dbg(__wchar_t * _FullPath, const __wchar_t * _Path, size_t _SizeInWords, int _BlockType, const char * _FileName, int _LineNumber); 
#line 544
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetcwd_dbg(__wchar_t * _DstBuf, int _SizeInWords, int _BlockType, const char * _FileName, int _LineNumber); 
#line 554
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetdcwd_dbg(int _Drive, __wchar_t * _DstBuf, int _SizeInWords, int _BlockType, const char * _FileName, int _LineNumber); 
#line 564
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wtempnam_dbg(const __wchar_t * _DirName, const __wchar_t * _FilePrefix, int _BlockType, const char * _FileName, int _LineNumber); 
#line 607 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
__declspec(dllimport) int __cdecl _CrtDbgReport(int _ReportType, const char * _FileName, int _Linenumber, const char * _ModuleName, const char * _Format, ...); 
#line 615
__declspec(dllimport) int __cdecl _CrtDbgReportW(int _ReportType, const __wchar_t * _FileName, int _LineNumber, const __wchar_t * _ModuleName, const __wchar_t * _Format, ...); 
#line 624
__declspec(dllimport) int __cdecl _VCrtDbgReportA(int _ReportType, void * _ReturnAddress, const char * _FileName, int _LineNumber, const char * _ModuleName, const char * _Format, va_list _ArgList); 
#line 634
__declspec(dllimport) int __cdecl _VCrtDbgReportW(int _ReportType, void * _ReturnAddress, const __wchar_t * _FileName, int _LineNumber, const __wchar_t * _ModuleName, const __wchar_t * _Format, va_list _ArgList); 
#line 644
__declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(size_t _NewDebugFillThreshold); 
#line 648
__declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(); 
#line 650
__declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(int _ReportType, _HFILE _ReportFile); 
#line 655
__declspec(dllimport) int __cdecl _CrtSetReportMode(int _ReportType, int _ReportMode); 
#line 662
extern long _crtAssertBusy; 
#line 664
__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(); 
#line 669
__declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(_CRT_REPORT_HOOK _PFnNewHook); 
#line 673
__declspec(dllimport) int __cdecl _CrtSetReportHook2(int _Mode, _CRT_REPORT_HOOK _PFnNewHook); 
#line 678
__declspec(dllimport) int __cdecl _CrtSetReportHookW2(int _Mode, _CRT_REPORT_HOOKW _PFnNewHook); 
#line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\crtdbg.h"
}__pragma( pack ( pop )) 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 132 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1900")
#line 136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
#line 147 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\use_ansi.h"
#pragma comment(lib, "msvcprtd")
#line 332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
namespace std { 
#line 333
enum _Uninitialized { 
#line 335
_Noinit
#line 336
}; 
#line 339
class __declspec(dllimport) _Lockit { 
#line 360 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
public: __thiscall _Lockit(); 
#line 361
explicit __thiscall _Lockit(int); 
#line 362
__thiscall ~_Lockit() noexcept; 
#line 365 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
static void __cdecl _Lockit_ctor(int); 
#line 366
static void __cdecl _Lockit_dtor(int); 
#line 369
private: static void __cdecl _Lockit_ctor(_Lockit *); 
#line 370
static void __cdecl _Lockit_ctor(_Lockit *, int); 
#line 371
static void __cdecl _Lockit_dtor(_Lockit *); 
#line 374
public: _Lockit(const _Lockit &) = delete;
#line 375
_Lockit &operator=(const _Lockit &) = delete;
#line 378
private: int _Locktype; 
#line 379
}; 
#line 465 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
class __declspec(dllimport) _Init_locks { 
#line 480 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
public: __thiscall _Init_locks(); 
#line 481
__thiscall ~_Init_locks() noexcept; 
#line 485 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
#line 486
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 487
}; 
#line 524 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
}
#line 533 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\yvals.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstdlib"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 19
inline double abs(double _Xx) noexcept 
#line 20
{ 
#line 21
return ::fabs(_Xx); 
#line 22
} 
#line 24
inline float abs(float _Xx) noexcept 
#line 25
{ 
#line 26
return ::fabsf(_Xx); 
#line 27
} 
#line 29
inline long double abs(long double _Xx) noexcept 
#line 30
{ 
#line 31
return ::fabsl(_Xx); 
#line 32
} 
#line 34
namespace std { 
#line 35
using ::size_t;using ::div_t;using ::ldiv_t;
#line 36
using ::abort;using ::abs;using ::atexit;
#line 37
using ::atof;using ::atoi;using ::atol;
#line 38
using ::bsearch;using ::calloc;using ::div;
#line 39
using ::exit;using ::free;
#line 40
using ::labs;using ::ldiv;using ::malloc;
#line 41
using ::mblen;using ::mbstowcs;using ::mbtowc;
#line 42
using ::qsort;using ::rand;using ::realloc;
#line 43
using ::srand;using ::strtod;using ::strtol;
#line 44
using ::strtoul;
#line 45
using ::wcstombs;using ::wctomb;
#line 47
using ::lldiv_t;
#line 50
using ::getenv;
#line 51
using ::system;
#line 54 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstdlib"
using ::atoll;using ::llabs;using ::lldiv;
#line 55
using ::strtof;using ::strtold;
#line 56
using ::strtoll;using ::strtoull;
#line 58
using ::_Exit;using ::at_quick_exit;using ::quick_exit;
#line 59
}
#line 63
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cmath"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
inline double pow(double _Xx, int _Yx) noexcept 
#line 18
{ 
#line 19
if (_Yx == 2) { 
#line 20
return _Xx * _Xx; }  
#line 22
return ::pow(_Xx, static_cast< double>(_Yx)); 
#line 23
} 
#line 25
inline float acos(float _Xx) noexcept 
#line 26
{ 
#line 27
return ::acosf(_Xx); 
#line 28
} 
#line 30
inline float acosh(float _Xx) noexcept 
#line 31
{ 
#line 32
return ::acoshf(_Xx); 
#line 33
} 
#line 35
inline float asin(float _Xx) noexcept 
#line 36
{ 
#line 37
return ::asinf(_Xx); 
#line 38
} 
#line 40
inline float asinh(float _Xx) noexcept 
#line 41
{ 
#line 42
return ::asinhf(_Xx); 
#line 43
} 
#line 45
inline float atan(float _Xx) noexcept 
#line 46
{ 
#line 47
return ::atanf(_Xx); 
#line 48
} 
#line 50
inline float atanh(float _Xx) noexcept 
#line 51
{ 
#line 52
return ::atanhf(_Xx); 
#line 53
} 
#line 55
inline float atan2(float _Yx, float _Xx) noexcept 
#line 56
{ 
#line 57
return ::atan2f(_Yx, _Xx); 
#line 58
} 
#line 60
inline float cbrt(float _Xx) noexcept 
#line 61
{ 
#line 62
return ::cbrtf(_Xx); 
#line 63
} 
#line 65
inline float ceil(float _Xx) noexcept 
#line 66
{ 
#line 67
return ::ceilf(_Xx); 
#line 68
} 
#line 70
inline float copysign(float _Number, float 
#line 71
_Sign) noexcept 
#line 72
{ 
#line 73
return ::copysignf(_Number, _Sign); 
#line 74
} 
#line 76
inline float cos(float _Xx) noexcept 
#line 77
{ 
#line 78
return ::cosf(_Xx); 
#line 79
} 
#line 81
inline float cosh(float _Xx) noexcept 
#line 82
{ 
#line 83
return ::coshf(_Xx); 
#line 84
} 
#line 86
inline float erf(float _Xx) noexcept 
#line 87
{ 
#line 88
return ::erff(_Xx); 
#line 89
} 
#line 91
inline float erfc(float _Xx) noexcept 
#line 92
{ 
#line 93
return ::erfcf(_Xx); 
#line 94
} 
#line 96
inline float exp(float _Xx) noexcept 
#line 97
{ 
#line 98
return ::expf(_Xx); 
#line 99
} 
#line 101
inline float exp2(float _Xx) noexcept 
#line 102
{ 
#line 103
return ::exp2f(_Xx); 
#line 104
} 
#line 106
inline float expm1(float _Xx) noexcept 
#line 107
{ 
#line 108
return ::expm1f(_Xx); 
#line 109
} 
#line 111
inline float fabs(float _Xx) noexcept 
#line 112
{ 
#line 113
return ::fabsf(_Xx); 
#line 114
} 
#line 116
inline float fdim(float _Xx, float _Yx) noexcept 
#line 117
{ 
#line 118
return ::fdimf(_Xx, _Yx); 
#line 119
} 
#line 121
inline float floor(float _Xx) noexcept 
#line 122
{ 
#line 123
return ::floorf(_Xx); 
#line 124
} 
#line 126
inline float fma(float _Xx, float _Yx, float 
#line 127
_Zx) noexcept 
#line 128
{ 
#line 129
return ::fmaf(_Xx, _Yx, _Zx); 
#line 130
} 
#line 132
inline float fmax(float _Xx, float _Yx) noexcept 
#line 133
{ 
#line 134
return ::fmaxf(_Xx, _Yx); 
#line 135
} 
#line 137
inline float fmin(float _Xx, float _Yx) noexcept 
#line 138
{ 
#line 139
return ::fminf(_Xx, _Yx); 
#line 140
} 
#line 142
inline float fmod(float _Xx, float _Yx) noexcept 
#line 143
{ 
#line 144
return ::fmodf(_Xx, _Yx); 
#line 145
} 
#line 147
inline float frexp(float _Xx, int *_Yx) noexcept 
#line 148
{ 
#line 149
return ::frexpf(_Xx, _Yx); 
#line 150
} 
#line 152
inline float hypot(float _Xx, float _Yx) noexcept 
#line 153
{ 
#line 154
return ::hypotf(_Xx, _Yx); 
#line 155
} 
#line 157
inline int ilogb(float _Xx) noexcept 
#line 158
{ 
#line 159
return ::ilogbf(_Xx); 
#line 160
} 
#line 162
inline float ldexp(float _Xx, int _Yx) noexcept 
#line 163
{ 
#line 164
return ::ldexpf(_Xx, _Yx); 
#line 165
} 
#line 167
inline float lgamma(float _Xx) noexcept 
#line 168
{ 
#line 169
return ::lgammaf(_Xx); 
#line 170
} 
#line 172
inline __int64 llrint(float _Xx) noexcept 
#line 173
{ 
#line 174
return ::llrintf(_Xx); 
#line 175
} 
#line 177
inline __int64 llround(float _Xx) noexcept 
#line 178
{ 
#line 179
return ::llroundf(_Xx); 
#line 180
} 
#line 182
inline float log(float _Xx) noexcept 
#line 183
{ 
#line 184
return ::logf(_Xx); 
#line 185
} 
#line 187
inline float log10(float _Xx) noexcept 
#line 188
{ 
#line 189
return ::log10f(_Xx); 
#line 190
} 
#line 192
inline float log1p(float _Xx) noexcept 
#line 193
{ 
#line 194
return ::log1pf(_Xx); 
#line 195
} 
#line 197
inline float log2(float _Xx) noexcept 
#line 198
{ 
#line 199
return ::log2f(_Xx); 
#line 200
} 
#line 202
inline float logb(float _Xx) noexcept 
#line 203
{ 
#line 204
return ::logbf(_Xx); 
#line 205
} 
#line 207
inline long lrint(float _Xx) noexcept 
#line 208
{ 
#line 209
return ::lrintf(_Xx); 
#line 210
} 
#line 212
inline long lround(float _Xx) noexcept 
#line 213
{ 
#line 214
return ::lroundf(_Xx); 
#line 215
} 
#line 217
inline float modf(float _Xx, float *_Yx) noexcept 
#line 218
{ 
#line 219
return ::modff(_Xx, _Yx); 
#line 220
} 
#line 222
inline float nearbyint(float _Xx) noexcept 
#line 223
{ 
#line 224
return ::nearbyintf(_Xx); 
#line 225
} 
#line 227
inline float nextafter(float _Xx, float _Yx) noexcept 
#line 228
{ 
#line 229
return ::nextafterf(_Xx, _Yx); 
#line 230
} 
#line 232
inline float nexttoward(float _Xx, long double 
#line 233
_Yx) noexcept 
#line 234
{ 
#line 235
return ::nexttowardf(_Xx, _Yx); 
#line 236
} 
#line 238
inline float pow(float _Xx, float 
#line 239
_Yx) noexcept 
#line 240
{ 
#line 241
return ::powf(_Xx, _Yx); 
#line 242
} 
#line 244
inline float pow(float _Xx, int _Yx) noexcept 
#line 245
{ 
#line 246
if (_Yx == 2) { 
#line 247
return _Xx * _Xx; }  
#line 249
return ::powf(_Xx, static_cast< float>(_Yx)); 
#line 250
} 
#line 252
inline float remainder(float _Xx, float _Yx) noexcept 
#line 253
{ 
#line 254
return ::remainderf(_Xx, _Yx); 
#line 255
} 
#line 257
inline float remquo(float _Xx, float _Yx, int *
#line 258
_Zx) noexcept 
#line 259
{ 
#line 260
return ::remquof(_Xx, _Yx, _Zx); 
#line 261
} 
#line 263
inline float rint(float _Xx) noexcept 
#line 264
{ 
#line 265
return ::rintf(_Xx); 
#line 266
} 
#line 268
inline float round(float _Xx) noexcept 
#line 269
{ 
#line 270
return ::roundf(_Xx); 
#line 271
} 
#line 273
inline float scalbln(float _Xx, long _Yx) noexcept 
#line 274
{ 
#line 275
return ::scalblnf(_Xx, _Yx); 
#line 276
} 
#line 278
inline float scalbn(float _Xx, int _Yx) noexcept 
#line 279
{ 
#line 280
return ::scalbnf(_Xx, _Yx); 
#line 281
} 
#line 283
inline float sin(float _Xx) noexcept 
#line 284
{ 
#line 285
return ::sinf(_Xx); 
#line 286
} 
#line 288
inline float sinh(float _Xx) noexcept 
#line 289
{ 
#line 290
return ::sinhf(_Xx); 
#line 291
} 
#line 293
inline float sqrt(float _Xx) noexcept 
#line 294
{ 
#line 295
return ::sqrtf(_Xx); 
#line 296
} 
#line 298
inline float tan(float _Xx) noexcept 
#line 299
{ 
#line 300
return ::tanf(_Xx); 
#line 301
} 
#line 303
inline float tanh(float _Xx) noexcept 
#line 304
{ 
#line 305
return ::tanhf(_Xx); 
#line 306
} 
#line 308
inline float tgamma(float _Xx) noexcept 
#line 309
{ 
#line 310
return ::tgammaf(_Xx); 
#line 311
} 
#line 313
inline float trunc(float _Xx) noexcept 
#line 314
{ 
#line 315
return ::truncf(_Xx); 
#line 316
} 
#line 318
inline long double acos(long double _Xx) noexcept 
#line 319
{ 
#line 320
return ::acosl(_Xx); 
#line 321
} 
#line 323
inline long double acosh(long double _Xx) noexcept 
#line 324
{ 
#line 325
return ::acoshl(_Xx); 
#line 326
} 
#line 328
inline long double asin(long double _Xx) noexcept 
#line 329
{ 
#line 330
return ::asinl(_Xx); 
#line 331
} 
#line 333
inline long double asinh(long double _Xx) noexcept 
#line 334
{ 
#line 335
return ::asinhl(_Xx); 
#line 336
} 
#line 338
inline long double atan(long double _Xx) noexcept 
#line 339
{ 
#line 340
return ::atanl(_Xx); 
#line 341
} 
#line 343
inline long double atanh(long double _Xx) noexcept 
#line 344
{ 
#line 345
return ::atanhl(_Xx); 
#line 346
} 
#line 348
inline long double atan2(long double _Yx, long double 
#line 349
_Xx) noexcept 
#line 350
{ 
#line 351
return ::atan2l(_Yx, _Xx); 
#line 352
} 
#line 354
inline long double cbrt(long double _Xx) noexcept 
#line 355
{ 
#line 356
return ::cbrtl(_Xx); 
#line 357
} 
#line 359
inline long double ceil(long double _Xx) noexcept 
#line 360
{ 
#line 361
return ::ceill(_Xx); 
#line 362
} 
#line 364
inline long double copysign(long double _Number, long double 
#line 365
_Sign) noexcept 
#line 366
{ 
#line 367
return ::copysignl(_Number, _Sign); 
#line 368
} 
#line 370
inline long double cos(long double _Xx) noexcept 
#line 371
{ 
#line 372
return ::cosl(_Xx); 
#line 373
} 
#line 375
inline long double cosh(long double _Xx) noexcept 
#line 376
{ 
#line 377
return ::coshl(_Xx); 
#line 378
} 
#line 380
inline long double erf(long double _Xx) noexcept 
#line 381
{ 
#line 382
return ::erfl(_Xx); 
#line 383
} 
#line 385
inline long double erfc(long double _Xx) noexcept 
#line 386
{ 
#line 387
return ::erfcl(_Xx); 
#line 388
} 
#line 390
inline long double exp(long double _Xx) noexcept 
#line 391
{ 
#line 392
return ::expl(_Xx); 
#line 393
} 
#line 395
inline long double exp2(long double _Xx) noexcept 
#line 396
{ 
#line 397
return ::exp2l(_Xx); 
#line 398
} 
#line 400
inline long double expm1(long double _Xx) noexcept 
#line 401
{ 
#line 402
return ::expm1l(_Xx); 
#line 403
} 
#line 405
inline long double fabs(long double _Xx) noexcept 
#line 406
{ 
#line 407
return ::fabsl(_Xx); 
#line 408
} 
#line 410
inline long double fdim(long double _Xx, long double 
#line 411
_Yx) noexcept 
#line 412
{ 
#line 413
return ::fdiml(_Xx, _Yx); 
#line 414
} 
#line 416
inline long double floor(long double _Xx) noexcept 
#line 417
{ 
#line 418
return ::floorl(_Xx); 
#line 419
} 
#line 421
inline long double fma(long double _Xx, long double 
#line 422
_Yx, long double _Zx) noexcept 
#line 423
{ 
#line 424
return ::fmal(_Xx, _Yx, _Zx); 
#line 425
} 
#line 427
inline long double fmax(long double _Xx, long double 
#line 428
_Yx) noexcept 
#line 429
{ 
#line 430
return ::fmaxl(_Xx, _Yx); 
#line 431
} 
#line 433
inline long double fmin(long double _Xx, long double 
#line 434
_Yx) noexcept 
#line 435
{ 
#line 436
return ::fminl(_Xx, _Yx); 
#line 437
} 
#line 439
inline long double fmod(long double _Xx, long double 
#line 440
_Yx) noexcept 
#line 441
{ 
#line 442
return ::fmodl(_Xx, _Yx); 
#line 443
} 
#line 445
inline long double frexp(long double _Xx, int *
#line 446
_Yx) noexcept 
#line 447
{ 
#line 448
return ::frexpl(_Xx, _Yx); 
#line 449
} 
#line 451
inline long double hypot(long double _Xx, long double 
#line 452
_Yx) noexcept 
#line 453
{ 
#line 454
return ::hypotl(_Xx, _Yx); 
#line 455
} 
#line 457
inline int ilogb(long double _Xx) noexcept 
#line 458
{ 
#line 459
return ::ilogbl(_Xx); 
#line 460
} 
#line 462
inline long double ldexp(long double _Xx, int 
#line 463
_Yx) noexcept 
#line 464
{ 
#line 465
return ::ldexpl(_Xx, _Yx); 
#line 466
} 
#line 468
inline long double lgamma(long double _Xx) noexcept 
#line 469
{ 
#line 470
return ::lgammal(_Xx); 
#line 471
} 
#line 473
inline __int64 llrint(long double _Xx) noexcept 
#line 474
{ 
#line 475
return ::llrintl(_Xx); 
#line 476
} 
#line 478
inline __int64 llround(long double _Xx) noexcept 
#line 479
{ 
#line 480
return ::llroundl(_Xx); 
#line 481
} 
#line 483
inline long double log(long double _Xx) noexcept 
#line 484
{ 
#line 485
return ::logl(_Xx); 
#line 486
} 
#line 488
inline long double log10(long double _Xx) noexcept 
#line 489
{ 
#line 490
return ::log10l(_Xx); 
#line 491
} 
#line 493
inline long double log1p(long double _Xx) noexcept 
#line 494
{ 
#line 495
return ::log1pl(_Xx); 
#line 496
} 
#line 498
inline long double log2(long double _Xx) noexcept 
#line 499
{ 
#line 500
return ::log2l(_Xx); 
#line 501
} 
#line 503
inline long double logb(long double _Xx) noexcept 
#line 504
{ 
#line 505
return ::logbl(_Xx); 
#line 506
} 
#line 508
inline long lrint(long double _Xx) noexcept 
#line 509
{ 
#line 510
return ::lrintl(_Xx); 
#line 511
} 
#line 513
inline long lround(long double _Xx) noexcept 
#line 514
{ 
#line 515
return ::lroundl(_Xx); 
#line 516
} 
#line 518
inline long double modf(long double _Xx, long double *
#line 519
_Yx) noexcept 
#line 520
{ 
#line 521
return ::modfl(_Xx, _Yx); 
#line 522
} 
#line 524
inline long double nearbyint(long double _Xx) noexcept 
#line 525
{ 
#line 526
return ::nearbyintl(_Xx); 
#line 527
} 
#line 529
inline long double nextafter(long double _Xx, long double 
#line 530
_Yx) noexcept 
#line 531
{ 
#line 532
return ::nextafterl(_Xx, _Yx); 
#line 533
} 
#line 535
inline long double nexttoward(long double _Xx, long double 
#line 536
_Yx) noexcept 
#line 537
{ 
#line 538
return ::nexttowardl(_Xx, _Yx); 
#line 539
} 
#line 541
inline long double pow(long double _Xx, long double 
#line 542
_Yx) noexcept 
#line 543
{ 
#line 544
return ::powl(_Xx, _Yx); 
#line 545
} 
#line 547
inline long double pow(long double _Xx, int 
#line 548
_Yx) noexcept 
#line 549
{ 
#line 550
if (_Yx == 2) { 
#line 551
return _Xx * _Xx; }  
#line 553
return ::powl(_Xx, static_cast< long double>(_Yx)); 
#line 554
} 
#line 556
inline long double remainder(long double _Xx, long double 
#line 557
_Yx) noexcept 
#line 558
{ 
#line 559
return ::remainderl(_Xx, _Yx); 
#line 560
} 
#line 562
inline long double remquo(long double _Xx, long double 
#line 563
_Yx, int *_Zx) noexcept 
#line 564
{ 
#line 565
return ::remquol(_Xx, _Yx, _Zx); 
#line 566
} 
#line 568
inline long double rint(long double _Xx) noexcept 
#line 569
{ 
#line 570
return ::rintl(_Xx); 
#line 571
} 
#line 573
inline long double round(long double _Xx) noexcept 
#line 574
{ 
#line 575
return ::roundl(_Xx); 
#line 576
} 
#line 578
inline long double scalbln(long double _Xx, long 
#line 579
_Yx) noexcept 
#line 580
{ 
#line 581
return ::scalblnl(_Xx, _Yx); 
#line 582
} 
#line 584
inline long double scalbn(long double _Xx, int 
#line 585
_Yx) noexcept 
#line 586
{ 
#line 587
return ::scalbnl(_Xx, _Yx); 
#line 588
} 
#line 590
inline long double sin(long double _Xx) noexcept 
#line 591
{ 
#line 592
return ::sinl(_Xx); 
#line 593
} 
#line 595
inline long double sinh(long double _Xx) noexcept 
#line 596
{ 
#line 597
return ::sinhl(_Xx); 
#line 598
} 
#line 600
inline long double sqrt(long double _Xx) noexcept 
#line 601
{ 
#line 602
return ::sqrtl(_Xx); 
#line 603
} 
#line 605
inline long double tan(long double _Xx) noexcept 
#line 606
{ 
#line 607
return ::tanl(_Xx); 
#line 608
} 
#line 610
inline long double tanh(long double _Xx) noexcept 
#line 611
{ 
#line 612
return ::tanhl(_Xx); 
#line 613
} 
#line 615
inline long double tgamma(long double _Xx) noexcept 
#line 616
{ 
#line 617
return ::tgammal(_Xx); 
#line 618
} 
#line 620
inline long double trunc(long double _Xx) noexcept 
#line 621
{ 
#line 622
return ::truncl(_Xx); 
#line 623
} 
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xtr1common"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 17
template < class _Ty,
 _Ty _Val >
 struct integral_constant
 {
 static constexpr _Ty value = _Val;

 using value_type = _Ty;
 using type = integral_constant;

 constexpr operator value_type ( ) const noexcept
  {
  return ( value );
  }

  constexpr value_type operator ( ) ( ) const noexcept
  {
  return ( value );
  }
 };
#line 38
template< bool _Val> using bool_constant = integral_constant< bool, _Val> ; 
#line 41
using true_type = bool_constant< true> ; 
#line 42
using false_type = bool_constant< false> ; 
#line 45
template< bool _Test, class 
#line 46
_Ty = void> 
#line 47
struct enable_if { 
#line 49
}; 
#line 51
template< class _Ty> 
#line 52
struct enable_if< true, _Ty>  { 
#line 54
using type = _Ty; 
#line 55
}; 
#line 57
template< bool _Test, class 
#line 58
_Ty = void> using enable_if_t = typename enable_if< _Test, _Ty> ::type; 
#line 62
template< bool _Test, class 
#line 63
_Ty1, class 
#line 64
_Ty2> 
#line 65
struct conditional { 
#line 67
using type = _Ty2; 
#line 68
}; 
#line 70
template< class _Ty1, class 
#line 71
_Ty2> 
#line 72
struct conditional< true, _Ty1, _Ty2>  { 
#line 74
using type = _Ty1; 
#line 75
}; 
#line 77
template< bool _Test, class 
#line 78
_Ty1, class 
#line 79
_Ty2> using conditional_t = typename conditional< _Test, _Ty1, _Ty2> ::type; 
#line 83
template< class _Ty1, class 
#line 84
_Ty2> 
#line 85
struct is_same : public false_type { 
#line 88
}; 
#line 90
template< class _Ty1> 
#line 91
struct is_same< _Ty1, _Ty1>  : public true_type { 
#line 94
}; 
#line 96
template< class _Ty, class 
#line 97
_Uty> constexpr bool 
#line 98
is_same_v = (is_same< _Ty, _Uty> ::value); 
#line 101
template< class _Ty> 
#line 102
struct remove_const { 
#line 104
using type = _Ty; 
#line 105
}; 
#line 107
template< class _Ty> 
#line 108
struct remove_const< const _Ty>  { 
#line 110
using type = _Ty; 
#line 111
}; 
#line 113
template< class _Ty> using remove_const_t = typename remove_const< _Ty> ::type; 
#line 117
template< class _Ty> 
#line 118
struct remove_volatile { 
#line 120
using type = _Ty; 
#line 121
}; 
#line 123
template< class _Ty> 
#line 124
struct remove_volatile< volatile _Ty>  { 
#line 126
using type = _Ty; 
#line 127
}; 
#line 129
template< class _Ty> using remove_volatile_t = typename remove_volatile< _Ty> ::type; 
#line 133
template< class _Ty> 
#line 134
struct remove_cv { 
#line 136
using type = _Ty; 
#line 137
}; 
#line 139
template< class _Ty> 
#line 140
struct remove_cv< const _Ty>  { 
#line 142
using type = _Ty; 
#line 143
}; 
#line 145
template< class _Ty> 
#line 146
struct remove_cv< volatile _Ty>  { 
#line 148
using type = _Ty; 
#line 149
}; 
#line 151
template< class _Ty> 
#line 152
struct remove_cv< const volatile _Ty>  { 
#line 154
using type = _Ty; 
#line 155
}; 
#line 157
template< class _Ty> using remove_cv_t = typename remove_cv< _Ty> ::type; 
#line 161
template< class _Ty> 
#line 162
struct _Is_integral : public false_type { 
#line 165
}; 
#line 168
template<> struct _Is_integral< bool>  : public true_type { 
#line 171
}; 
#line 174
template<> struct _Is_integral< char>  : public true_type { 
#line 177
}; 
#line 180
template<> struct _Is_integral< unsigned char>  : public true_type { 
#line 183
}; 
#line 186
template<> struct _Is_integral< signed char>  : public true_type { 
#line 189
}; 
#line 193
template<> struct _Is_integral< __wchar_t>  : public true_type { 
#line 196
}; 
#line 200 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xtr1common"
template<> struct _Is_integral< char16_t>  : public true_type { 
#line 203
}; 
#line 206
template<> struct _Is_integral< char32_t>  : public true_type { 
#line 209
}; 
#line 212
template<> struct _Is_integral< unsigned short>  : public true_type { 
#line 215
}; 
#line 218
template<> struct _Is_integral< short>  : public true_type { 
#line 221
}; 
#line 224
template<> struct _Is_integral< unsigned>  : public true_type { 
#line 227
}; 
#line 230
template<> struct _Is_integral< int>  : public true_type { 
#line 233
}; 
#line 236
template<> struct _Is_integral< unsigned long>  : public true_type { 
#line 239
}; 
#line 242
template<> struct _Is_integral< long>  : public true_type { 
#line 245
}; 
#line 248
template<> struct _Is_integral< unsigned __int64>  : public true_type { 
#line 251
}; 
#line 254
template<> struct _Is_integral< __int64>  : public true_type { 
#line 257
}; 
#line 260
template< class _Ty> 
#line 261
struct is_integral : public _Is_integral< remove_cv_t< _Ty> > ::type { 
#line 264
}; 
#line 266
template< class _Ty> constexpr bool 
#line 267
is_integral_v = (is_integral< _Ty> ::value); 
#line 270
template< class _Ty> 
#line 271
struct _Is_floating_point : public false_type { 
#line 274
}; 
#line 277
template<> struct _Is_floating_point< float>  : public true_type { 
#line 280
}; 
#line 283
template<> struct _Is_floating_point< double>  : public true_type { 
#line 286
}; 
#line 289
template<> struct _Is_floating_point< long double>  : public true_type { 
#line 292
}; 
#line 295
template< class _Ty> 
#line 296
struct is_floating_point : public _Is_floating_point< remove_cv_t< _Ty> > ::type { 
#line 299
}; 
#line 301
template< class _Ty> constexpr bool 
#line 302
is_floating_point_v = (is_floating_point< _Ty> ::value); 
#line 305
template< class _Ty> 
#line 306
struct is_arithmetic : public bool_constant< is_integral_v< _Ty>  || is_floating_point_v< _Ty> >  { 
#line 310
}; 
#line 312
template< class _Ty> constexpr bool 
#line 313
is_arithmetic_v = (is_arithmetic< _Ty> ::value); 
#line 316
template< class _Ty> 
#line 317
struct remove_reference { 
#line 319
using type = _Ty; 
#line 320
}; 
#line 322
template< class _Ty> 
#line 323
struct remove_reference< _Ty &>  { 
#line 325
using type = _Ty; 
#line 326
}; 
#line 328
template< class _Ty> 
#line 329
struct remove_reference< _Ty &&>  { 
#line 331
using type = _Ty; 
#line 332
}; 
#line 334
template< class _Ty> using remove_reference_t = typename remove_reference< _Ty> ::type; 
#line 337
}
#line 340
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xtgmath.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 19
namespace std { 
#line 20
template< class _Ty1, class 
#line 21
_Ty2> using _Common_float_type_t = conditional_t< is_same_v< _Ty1, long double>  || is_same_v< _Ty2, long double> , long double, conditional_t< is_same_v< _Ty1, float>  && is_same_v< _Ty2, float> , float, double> > ; 
#line 26
}
#line 66
template < class _Ty1,
 class _Ty2,
 class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline
 :: std :: _Common_float_type_t < _Ty1, _Ty2 > pow ( const _Ty1 _Left, const _Ty2 _Right )
 {
 using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >;
 return ( :: pow ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) );
 }
#line 76
extern "C" double __cdecl acos(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double acos ( _Ty _Left ) { return ( :: acos ( static_cast < double > ( _Left ) ) ); }
#line 77
extern "C" double __cdecl asin(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double asin ( _Ty _Left ) { return ( :: asin ( static_cast < double > ( _Left ) ) ); }
#line 78
extern "C" double __cdecl atan(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double atan ( _Ty _Left ) { return ( :: atan ( static_cast < double > ( _Left ) ) ); }
#line 79
extern "C" double __cdecl atan2(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > atan2 ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: atan2 ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 80
extern "C" __declspec(dllimport) double __cdecl ceil(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double ceil ( _Ty _Left ) { return ( :: ceil ( static_cast < double > ( _Left ) ) ); }
#line 81
extern "C" double __cdecl cos(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double cos ( _Ty _Left ) { return ( :: cos ( static_cast < double > ( _Left ) ) ); }
#line 82
extern "C" double __cdecl cosh(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double cosh ( _Ty _Left ) { return ( :: cosh ( static_cast < double > ( _Left ) ) ); }
#line 83
extern "C" double __cdecl exp(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double exp ( _Ty _Left ) { return ( :: exp ( static_cast < double > ( _Left ) ) ); }
#line 85
extern "C" double __cdecl fabs(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double fabs ( _Ty _Left ) { return ( :: fabs ( static_cast < double > ( _Left ) ) ); }
#line 87
extern "C" __declspec(dllimport) double __cdecl floor(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double floor ( _Ty _Left ) { return ( :: floor ( static_cast < double > ( _Left ) ) ); }
#line 88
extern "C" double __cdecl fmod(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmod ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: fmod ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 89
extern "C" __declspec(dllimport) double __cdecl frexp(double, int *); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double frexp ( _Ty _Left, int * _Arg2 ) { return ( :: frexp ( static_cast < double > ( _Left ), _Arg2 ) ); }
#line 90
extern "C" __declspec(dllimport) double __cdecl ldexp(double, int); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double ldexp ( _Ty _Left, int _Arg2 ) { return ( :: ldexp ( static_cast < double > ( _Left ), _Arg2 ) ); }
#line 91
extern "C" double __cdecl log(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double log ( _Ty _Left ) { return ( :: log ( static_cast < double > ( _Left ) ) ); }
#line 92
extern "C" double __cdecl log10(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double log10 ( _Ty _Left ) { return ( :: log10 ( static_cast < double > ( _Left ) ) ); }
#line 95
extern "C" double __cdecl sin(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double sin ( _Ty _Left ) { return ( :: sin ( static_cast < double > ( _Left ) ) ); }
#line 96
extern "C" double __cdecl sinh(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double sinh ( _Ty _Left ) { return ( :: sinh ( static_cast < double > ( _Left ) ) ); }
#line 97
extern "C" double __cdecl sqrt(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double sqrt ( _Ty _Left ) { return ( :: sqrt ( static_cast < double > ( _Left ) ) ); }
#line 98
extern "C" double __cdecl tan(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double tan ( _Ty _Left ) { return ( :: tan ( static_cast < double > ( _Left ) ) ); }
#line 99
extern "C" double __cdecl tanh(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double tanh ( _Ty _Left ) { return ( :: tanh ( static_cast < double > ( _Left ) ) ); }
#line 105
inline float _Fma(float _Left, float _Middle, float _Right) 
#line 106
{ 
#line 107
return ::fmaf(_Left, _Middle, _Right); 
#line 108
} 
#line 110
inline double _Fma(double _Left, double _Middle, double _Right) 
#line 111
{ 
#line 112
return ::fma(_Left, _Middle, _Right); 
#line 113
} 
#line 115
inline long double _Fma(long double _Left, long double _Middle, long double 
#line 116
_Right) 
#line 117
{ 
#line 118
return ::fmal(_Left, _Middle, _Right); 
#line 119
} 
#line 122 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xtgmath.h"
template < class _Ty1,
 class _Ty2,
 class _Ty3,
 class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 >
  && :: std :: is_arithmetic_v < _Ty3 > > > inline
 :: std :: _Common_float_type_t < _Ty1, :: std :: _Common_float_type_t < _Ty2, _Ty3 > >
 fma ( _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right )
 {
 using _Common = :: std :: _Common_float_type_t < _Ty1, :: std :: _Common_float_type_t < _Ty2, _Ty3 >>;














 return ( _Fma ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Middle ), static_cast < _Common > ( _Right ) ) );

 }
#line 151 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xtgmath.h"
inline float _Remquo(float _Left, float _Right, int *_Pquo) 
#line 152
{ 
#line 153
return ::remquof(_Left, _Right, _Pquo); 
#line 154
} 
#line 156
inline double _Remquo(double _Left, double _Right, int *_Pquo) 
#line 157
{ 
#line 158
return ::remquo(_Left, _Right, _Pquo); 
#line 159
} 
#line 161
inline long double _Remquo(long double _Left, long double _Right, int *_Pquo) 
#line 162
{ 
#line 163
return ::remquol(_Left, _Right, _Pquo); 
#line 164
} 
#line 167 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xtgmath.h"
template < class _Ty1,
 class _Ty2,
 class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline
 :: std :: _Common_float_type_t < _Ty1, _Ty2 >
 remquo ( _Ty1 _Left, _Ty2 _Right, int * _Pquo )
 {
 using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >;














 return ( _Remquo ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ), _Pquo ) );

 }
#line 192 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xtgmath.h"
extern "C" __declspec(dllimport) double __cdecl acosh(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double acosh ( _Ty _Left ) { return ( :: acosh ( static_cast < double > ( _Left ) ) ); }
#line 193
extern "C" __declspec(dllimport) double __cdecl asinh(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double asinh ( _Ty _Left ) { return ( :: asinh ( static_cast < double > ( _Left ) ) ); }
#line 194
extern "C" __declspec(dllimport) double __cdecl atanh(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double atanh ( _Ty _Left ) { return ( :: atanh ( static_cast < double > ( _Left ) ) ); }
#line 195
extern "C" __declspec(dllimport) double __cdecl cbrt(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double cbrt ( _Ty _Left ) { return ( :: cbrt ( static_cast < double > ( _Left ) ) ); }
#line 196
extern "C" __declspec(dllimport) double __cdecl copysign(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > copysign ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: copysign ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 197
extern "C" __declspec(dllimport) double __cdecl erf(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double erf ( _Ty _Left ) { return ( :: erf ( static_cast < double > ( _Left ) ) ); }
#line 198
extern "C" __declspec(dllimport) double __cdecl erfc(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double erfc ( _Ty _Left ) { return ( :: erfc ( static_cast < double > ( _Left ) ) ); }
#line 199
extern "C" __declspec(dllimport) double __cdecl expm1(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double expm1 ( _Ty _Left ) { return ( :: expm1 ( static_cast < double > ( _Left ) ) ); }
#line 200
extern "C" __declspec(dllimport) double __cdecl exp2(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double exp2 ( _Ty _Left ) { return ( :: exp2 ( static_cast < double > ( _Left ) ) ); }
#line 201
extern "C" __declspec(dllimport) double __cdecl fdim(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > fdim ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: fdim ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 203
extern "C" __declspec(dllimport) double __cdecl fmax(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmax ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: fmax ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 204
extern "C" __declspec(dllimport) double __cdecl fmin(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > fmin ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: fmin ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 205
extern "C" __declspec(dllimport) double __cdecl hypot(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > hypot ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: hypot ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 206
extern "C" __declspec(dllimport) int __cdecl ilogb(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline int ilogb ( _Ty _Left ) { return ( :: ilogb ( static_cast < double > ( _Left ) ) ); }
#line 207
extern "C" __declspec(dllimport) double __cdecl lgamma(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double lgamma ( _Ty _Left ) { return ( :: lgamma ( static_cast < double > ( _Left ) ) ); }
#line 208
extern "C" __declspec(dllimport) __int64 __cdecl llrint(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline long long llrint ( _Ty _Left ) { return ( :: llrint ( static_cast < double > ( _Left ) ) ); }
#line 209
extern "C" __declspec(dllimport) __int64 __cdecl llround(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline long long llround ( _Ty _Left ) { return ( :: llround ( static_cast < double > ( _Left ) ) ); }
#line 210
extern "C" __declspec(dllimport) double __cdecl log1p(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double log1p ( _Ty _Left ) { return ( :: log1p ( static_cast < double > ( _Left ) ) ); }
#line 211
extern "C" __declspec(dllimport) double __cdecl log2(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double log2 ( _Ty _Left ) { return ( :: log2 ( static_cast < double > ( _Left ) ) ); }
#line 212
extern "C" __declspec(dllimport) double __cdecl logb(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double logb ( _Ty _Left ) { return ( :: logb ( static_cast < double > ( _Left ) ) ); }
#line 213
extern "C" __declspec(dllimport) long __cdecl lrint(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline long lrint ( _Ty _Left ) { return ( :: lrint ( static_cast < double > ( _Left ) ) ); }
#line 214
extern "C" __declspec(dllimport) long __cdecl lround(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline long lround ( _Ty _Left ) { return ( :: lround ( static_cast < double > ( _Left ) ) ); }
#line 215
extern "C" __declspec(dllimport) double __cdecl nearbyint(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double nearbyint ( _Ty _Left ) { return ( :: nearbyint ( static_cast < double > ( _Left ) ) ); }
#line 216
extern "C" __declspec(dllimport) double __cdecl nextafter(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > nextafter ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: nextafter ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 217
extern "C" __declspec(dllimport) double __cdecl nexttoward(double, long double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double nexttoward ( _Ty _Left, long double _Arg2 ) { return ( :: nexttoward ( static_cast < double > ( _Left ), _Arg2 ) ); }
#line 218
extern "C" __declspec(dllimport) double __cdecl remainder(double, double); template < class _Ty1, class _Ty2, class = :: std :: enable_if_t < :: std :: is_arithmetic_v < _Ty1 > && :: std :: is_arithmetic_v < _Ty2 > > > inline :: std :: _Common_float_type_t < _Ty1, _Ty2 > remainder ( _Ty1 _Left, _Ty2 _Right ) { using _Common = :: std :: _Common_float_type_t < _Ty1, _Ty2 >; return ( :: remainder ( static_cast < _Common > ( _Left ), static_cast < _Common > ( _Right ) ) ); }
#line 220
extern "C" __declspec(dllimport) double __cdecl rint(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double rint ( _Ty _Left ) { return ( :: rint ( static_cast < double > ( _Left ) ) ); }
#line 221
extern "C" __declspec(dllimport) double __cdecl round(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double round ( _Ty _Left ) { return ( :: round ( static_cast < double > ( _Left ) ) ); }
#line 222
extern "C" __declspec(dllimport) double __cdecl scalbln(double, long); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double scalbln ( _Ty _Left, long _Arg2 ) { return ( :: scalbln ( static_cast < double > ( _Left ), _Arg2 ) ); }
#line 223
extern "C" __declspec(dllimport) double __cdecl scalbn(double, int); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double scalbn ( _Ty _Left, int _Arg2 ) { return ( :: scalbn ( static_cast < double > ( _Left ), _Arg2 ) ); }
#line 224
extern "C" __declspec(dllimport) double __cdecl tgamma(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double tgamma ( _Ty _Left ) { return ( :: tgamma ( static_cast < double > ( _Left ) ) ); }
#line 225
extern "C" __declspec(dllimport) double __cdecl trunc(double); template < class _Ty, class = :: std :: enable_if_t < :: std :: is_integral_v < _Ty > > > inline double trunc ( _Ty _Left ) { return ( :: trunc ( static_cast < double > ( _Left ) ) ); }
#line 237
#pragma warning(pop)
#pragma pack ( pop )
#line 627 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cmath"
namespace std { 
#line 628
using ::abs;using ::acos;using ::asin;
#line 629
using ::atan;using ::atan2;using ::ceil;
#line 630
using ::cos;using ::cosh;using ::exp;
#line 631
using ::fabs;using ::floor;using ::fmod;
#line 632
using ::frexp;using ::ldexp;using ::log;
#line 633
using ::log10;using ::modf;using ::pow;
#line 634
using ::sin;using ::sinh;using ::sqrt;
#line 635
using ::tan;using ::tanh;
#line 637
using ::acosf;using ::asinf;
#line 638
using ::atanf;using ::atan2f;using ::ceilf;
#line 639
using ::cosf;using ::coshf;using ::expf;
#line 640
using ::fabsf;using ::floorf;using ::fmodf;
#line 641
using ::frexpf;using ::ldexpf;using ::logf;
#line 642
using ::log10f;using ::modff;using ::powf;
#line 643
using ::sinf;using ::sinhf;using ::sqrtf;
#line 644
using ::tanf;using ::tanhf;
#line 646
using ::acosl;using ::asinl;
#line 647
using ::atanl;using ::atan2l;using ::ceill;
#line 648
using ::cosl;using ::coshl;using ::expl;
#line 649
using ::fabsl;using ::floorl;using ::fmodl;
#line 650
using ::frexpl;using ::ldexpl;using ::logl;
#line 651
using ::log10l;using ::modfl;using ::powl;
#line 652
using ::sinl;using ::sinhl;using ::sqrtl;
#line 653
using ::tanl;using ::tanhl;
#line 655
using ::float_t;using ::double_t;
#line 657
using ::acosh;using ::asinh;using ::atanh;
#line 658
using ::cbrt;using ::erf;using ::erfc;
#line 659
using ::expm1;using ::exp2;
#line 660
using ::hypot;using ::ilogb;using ::lgamma;
#line 661
using ::log1p;using ::log2;using ::logb;
#line 662
using ::llrint;using ::lrint;using ::nearbyint;
#line 663
using ::rint;using ::llround;using ::lround;
#line 664
using ::fdim;using ::fma;using ::fmax;using ::fmin;
#line 665
using ::round;using ::trunc;
#line 666
using ::remainder;using ::remquo;
#line 667
using ::copysign;using ::nan;using ::nextafter;
#line 668
using ::scalbn;using ::scalbln;
#line 669
using ::nexttoward;using ::tgamma;
#line 671
using ::acoshf;using ::asinhf;using ::atanhf;
#line 672
using ::cbrtf;using ::erff;using ::erfcf;
#line 673
using ::expm1f;using ::exp2f;
#line 674
using ::hypotf;using ::ilogbf;using ::lgammaf;
#line 675
using ::log1pf;using ::log2f;using ::logbf;
#line 676
using ::llrintf;using ::lrintf;using ::nearbyintf;
#line 677
using ::rintf;using ::llroundf;using ::lroundf;
#line 678
using ::fdimf;using ::fmaf;using ::fmaxf;using ::fminf;
#line 679
using ::roundf;using ::truncf;
#line 680
using ::remainderf;using ::remquof;
#line 681
using ::copysignf;using ::nanf;
#line 682
using ::nextafterf;using ::scalbnf;using ::scalblnf;
#line 683
using ::nexttowardf;using ::tgammaf;
#line 685
using ::acoshl;using ::asinhl;using ::atanhl;
#line 686
using ::cbrtl;using ::erfl;using ::erfcl;
#line 687
using ::expm1l;using ::exp2l;
#line 688
using ::hypotl;using ::ilogbl;using ::lgammal;
#line 689
using ::log1pl;using ::log2l;using ::logbl;
#line 690
using ::llrintl;using ::lrintl;using ::nearbyintl;
#line 691
using ::rintl;using ::llroundl;using ::lroundl;
#line 692
using ::fdiml;using ::fmal;using ::fmaxl;using ::fminl;
#line 693
using ::roundl;using ::truncl;
#line 694
using ::remainderl;using ::remquol;
#line 695
using ::copysignl;using ::nanl;
#line 696
using ::nextafterl;using ::scalbnl;using ::scalblnl;
#line 697
using ::nexttowardl;using ::tgammal;
#line 699
using ::fpclassify;using ::signbit;
#line 700
using ::isfinite;using ::isinf;
#line 701
using ::isnan;using ::isnormal;
#line 702
using ::isgreater;using ::isgreaterequal;
#line 703
using ::isless;using ::islessequal;
#line 704
using ::islessgreater;using ::isunordered;
#line 705
}
#line 1183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cmath"
#pragma warning(pop)
#pragma pack ( pop )
#line 9097 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl _hypot(double x, double y); 
#line 9098
extern "C" __declspec(dllimport) float __cdecl _hypotf(float x, float y); 
#line 9108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline bool signbit(long double) throw(); 
#line 9109
extern "C" __declspec(dllimport) int _ldsign(long double); 
#line 9152 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline bool signbit(double) throw(); 
#line 9153
extern "C" __declspec(dllimport) int _dsign(double); 
#line 9197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline bool signbit(float) throw(); 
#line 9198
extern "C" __declspec(dllimport) int _fdsign(float); 
#line 9206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isinf(long double a); 
#line 9241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isinf(double a); 
#line 9279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isinf(float a); 
#line 9286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isnan(long double a); 
#line 9319 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isnan(double a); 
#line 9355 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isnan(float a); 
#line 9362 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isfinite(long double a); 
#line 9399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isfinite(double a); 
#line 9435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static __inline bool isfinite(float a); 
#line 9443 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
template< class T> extern T _Pow_int(T, int) throw(); 
#line 9444
extern inline __int64 abs(__int64) throw(); 
#line 9519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline long __cdecl abs(long) throw(); 
#line 9523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline float __cdecl abs(float) throw(); 
#line 9524
extern inline double __cdecl abs(double) throw(); 
#line 9525
extern inline float __cdecl fabs(float) throw(); 
#line 9526
extern inline float __cdecl ceil(float) throw(); 
#line 9527
extern inline float __cdecl floor(float) throw(); 
#line 9528
extern inline float __cdecl sqrt(float) throw(); 
#line 9529
extern inline float __cdecl pow(float, float) throw(); 
#line 9554 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline float __cdecl pow(float, int) throw(); 
#line 9555
extern inline double __cdecl pow(double, int) throw(); 
#line 9558 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline float __cdecl log(float) throw(); 
#line 9559
extern inline float __cdecl log10(float) throw(); 
#line 9560
extern inline float __cdecl fmod(float, float) throw(); 
#line 9561
extern inline float __cdecl modf(float, float *) throw(); 
#line 9562
extern inline float __cdecl exp(float) throw(); 
#line 9563
extern inline float __cdecl frexp(float, int *) throw(); 
#line 9564
extern inline float __cdecl ldexp(float, int) throw(); 
#line 9565
extern inline float __cdecl asin(float) throw(); 
#line 9566
extern inline float __cdecl sin(float) throw(); 
#line 9567
extern inline float __cdecl sinh(float) throw(); 
#line 9568
extern inline float __cdecl acos(float) throw(); 
#line 9569
extern inline float __cdecl cos(float) throw(); 
#line 9570
extern inline float __cdecl cosh(float) throw(); 
#line 9571
extern inline float __cdecl atan(float) throw(); 
#line 9572
extern inline float __cdecl atan2(float, float) throw(); 
#line 9573
extern inline float __cdecl tan(float) throw(); 
#line 9574
extern inline float __cdecl tanh(float) throw(); 
#line 9794 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
extern inline float __cdecl logb(float) throw(); 
#line 9795
extern inline int __cdecl ilogb(float) throw(); 
#line 9796
extern float __cdecl scalbn(float, float) throw(); 
#line 9797
extern inline float __cdecl scalbln(float, long) throw(); 
#line 9798
extern inline float __cdecl exp2(float) throw(); 
#line 9799
extern inline float __cdecl expm1(float) throw(); 
#line 9800
extern inline float __cdecl log2(float) throw(); 
#line 9801
extern inline float __cdecl log1p(float) throw(); 
#line 9802
extern inline float __cdecl acosh(float) throw(); 
#line 9803
extern inline float __cdecl asinh(float) throw(); 
#line 9804
extern inline float __cdecl atanh(float) throw(); 
#line 9805
extern inline float __cdecl hypot(float, float) throw(); 
#line 9806
extern inline float __cdecl cbrt(float) throw(); 
#line 9807
extern inline float __cdecl erf(float) throw(); 
#line 9808
extern inline float __cdecl erfc(float) throw(); 
#line 9809
extern inline float __cdecl lgamma(float) throw(); 
#line 9810
extern inline float __cdecl tgamma(float) throw(); 
#line 9811
extern inline float __cdecl copysign(float, float) throw(); 
#line 9812
extern inline float __cdecl nextafter(float, float) throw(); 
#line 9813
extern inline float __cdecl remainder(float, float) throw(); 
#line 9814
extern inline float __cdecl remquo(float, float, int *) throw(); 
#line 9815
extern inline float __cdecl round(float) throw(); 
#line 9816
extern inline long __cdecl lround(float) throw(); 
#line 9817
extern inline __int64 __cdecl llround(float) throw(); 
#line 9818
extern inline float __cdecl trunc(float) throw(); 
#line 9819
extern inline float __cdecl rint(float) throw(); 
#line 9820
extern inline long __cdecl lrint(float) throw(); 
#line 9821
extern inline __int64 __cdecl llrint(float) throw(); 
#line 9822
extern inline float __cdecl nearbyint(float) throw(); 
#line 9823
extern inline float __cdecl fdim(float, float) throw(); 
#line 9824
extern inline float __cdecl fma(float, float, float) throw(); 
#line 9825
extern inline float __cdecl fmax(float, float) throw(); 
#line 9826
extern inline float __cdecl fmin(float, float) throw(); 
#line 9829 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.h"
static inline float exp10(float a); 
#line 9831
static inline float rsqrt(float a); 
#line 9833
static inline float rcbrt(float a); 
#line 9835
static inline float sinpi(float a); 
#line 9837
static inline float cospi(float a); 
#line 9839
static inline void sincospi(float a, float * sptr, float * cptr); 
#line 9841
static inline void sincos(float a, float * sptr, float * cptr); 
#line 9843
static inline float j0(float a); 
#line 9845
static inline float j1(float a); 
#line 9847
static inline float jn(int n, float a); 
#line 9849
static inline float y0(float a); 
#line 9851
static inline float y1(float a); 
#line 9853
static inline float yn(int n, float a); 
#line 9855
static inline float cyl_bessel_i0(float a); 
#line 9857
static inline float cyl_bessel_i1(float a); 
#line 9859
static inline float erfinv(float a); 
#line 9861
static inline float erfcinv(float a); 
#line 9863
static inline float normcdfinv(float a); 
#line 9865
static inline float normcdf(float a); 
#line 9867
static inline float erfcx(float a); 
#line 9869
static inline double copysign(double a, float b); 
#line 9871
static inline double copysign(float a, double b); 
#line 9873
static inline unsigned min(unsigned a, unsigned b); 
#line 9875
static inline unsigned min(int a, unsigned b); 
#line 9877
static inline unsigned min(unsigned a, int b); 
#line 9879
static inline long min(long a, long b); 
#line 9881
static inline unsigned long min(unsigned long a, unsigned long b); 
#line 9883
static inline unsigned long min(long a, unsigned long b); 
#line 9885
static inline unsigned long min(unsigned long a, long b); 
#line 9887
static inline __int64 min(__int64 a, __int64 b); 
#line 9889
static inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b); 
#line 9891
static inline unsigned __int64 min(__int64 a, unsigned __int64 b); 
#line 9893
static inline unsigned __int64 min(unsigned __int64 a, __int64 b); 
#line 9895
static inline float min(float a, float b); 
#line 9897
static inline double min(double a, double b); 
#line 9899
static inline double min(float a, double b); 
#line 9901
static inline double min(double a, float b); 
#line 9903
static inline unsigned max(unsigned a, unsigned b); 
#line 9905
static inline unsigned max(int a, unsigned b); 
#line 9907
static inline unsigned max(unsigned a, int b); 
#line 9909
static inline long max(long a, long b); 
#line 9911
static inline unsigned long max(unsigned long a, unsigned long b); 
#line 9913
static inline unsigned long max(long a, unsigned long b); 
#line 9915
static inline unsigned long max(unsigned long a, long b); 
#line 9917
static inline __int64 max(__int64 a, __int64 b); 
#line 9919
static inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b); 
#line 9921
static inline unsigned __int64 max(__int64 a, unsigned __int64 b); 
#line 9923
static inline unsigned __int64 max(unsigned __int64 a, __int64 b); 
#line 9925
static inline float max(float a, float b); 
#line 9927
static inline double max(double a, double b); 
#line 9929
static inline double max(float a, double b); 
#line 9931
static inline double max(double a, float b); 
#line 422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isinf(long double a) 
#line 423
{ 
#line 427 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isinf< long double> (a); 
#line 429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 438 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isinf(double a) 
#line 439
{ 
#line 443 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isinf< double> (a); 
#line 445 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 454 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isinf(float a) 
#line 455
{ 
#line 459 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isinf< float> (a); 
#line 461 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 470 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isnan(long double a) 
#line 471
{ 
#line 475 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isnan< long double> (a); 
#line 477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isnan(double a) 
#line 487
{ 
#line 491 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isnan< double> (a); 
#line 493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 502 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isnan(float a) 
#line 503
{ 
#line 507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isnan< float> (a); 
#line 509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(long double a) 
#line 519
{ 
#line 523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isfinite< long double> (a); 
#line 525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 534 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(double a) 
#line 535
{ 
#line 539 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isfinite< double> (a); 
#line 541 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static __inline bool isfinite(float a) 
#line 551
{ 
#line 555 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return isfinite< float> (a); 
#line 557 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
} 
#line 745 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static inline float exp10(float a) 
#line 746
{ 
#line 747
return exp10f(a); 
#line 748
} 
#line 750
static inline float rsqrt(float a) 
#line 751
{ 
#line 752
return rsqrtf(a); 
#line 753
} 
#line 755
static inline float rcbrt(float a) 
#line 756
{ 
#line 757
return rcbrtf(a); 
#line 758
} 
#line 760
static inline float sinpi(float a) 
#line 761
{ 
#line 762
return sinpif(a); 
#line 763
} 
#line 765
static inline float cospi(float a) 
#line 766
{ 
#line 767
return cospif(a); 
#line 768
} 
#line 770
static inline void sincospi(float a, float *sptr, float *cptr) 
#line 771
{ 
#line 772
sincospif(a, sptr, cptr); 
#line 773
} 
#line 775
static inline void sincos(float a, float *sptr, float *cptr) 
#line 776
{ 
#line 777
sincosf(a, sptr, cptr); 
#line 778
} 
#line 780
static inline float j0(float a) 
#line 781
{ 
#line 782
return j0f(a); 
#line 783
} 
#line 785
static inline float j1(float a) 
#line 786
{ 
#line 787
return j1f(a); 
#line 788
} 
#line 790
static inline float jn(int n, float a) 
#line 791
{ 
#line 792
return jnf(n, a); 
#line 793
} 
#line 795
static inline float y0(float a) 
#line 796
{ 
#line 797
return y0f(a); 
#line 798
} 
#line 800
static inline float y1(float a) 
#line 801
{ 
#line 802
return y1f(a); 
#line 803
} 
#line 805
static inline float yn(int n, float a) 
#line 806
{ 
#line 807
return ynf(n, a); 
#line 808
} 
#line 810
static inline float cyl_bessel_i0(float a) 
#line 811
{ 
#line 812
return cyl_bessel_i0f(a); 
#line 813
} 
#line 815
static inline float cyl_bessel_i1(float a) 
#line 816
{ 
#line 817
return cyl_bessel_i1f(a); 
#line 818
} 
#line 820
static inline float erfinv(float a) 
#line 821
{ 
#line 822
return erfinvf(a); 
#line 823
} 
#line 825
static inline float erfcinv(float a) 
#line 826
{ 
#line 827
return erfcinvf(a); 
#line 828
} 
#line 830
static inline float normcdfinv(float a) 
#line 831
{ 
#line 832
return normcdfinvf(a); 
#line 833
} 
#line 835
static inline float normcdf(float a) 
#line 836
{ 
#line 837
return normcdff(a); 
#line 838
} 
#line 840
static inline float erfcx(float a) 
#line 841
{ 
#line 842
return erfcxf(a); 
#line 843
} 
#line 845
static inline double copysign(double a, float b) 
#line 846
{ 
#line 847
return copysign(a, (double)b); 
#line 848
} 
#line 850
static inline double copysign(float a, double b) 
#line 851
{ 
#line 852
return copysign((double)a, b); 
#line 853
} 
#line 855
static inline unsigned min(unsigned a, unsigned b) 
#line 856
{ 
#line 857
return umin(a, b); 
#line 858
} 
#line 860
static inline unsigned min(int a, unsigned b) 
#line 861
{ 
#line 862
return umin((unsigned)a, b); 
#line 863
} 
#line 865
static inline unsigned min(unsigned a, int b) 
#line 866
{ 
#line 867
return umin(a, (unsigned)b); 
#line 868
} 
#line 870
static inline long min(long a, long b) 
#line 871
{ 
#line 874
#pragma warning (disable: 4127)
#line 877 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 879
#pragma warning (default: 4127)
#line 881 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (long)min((int)a, (int)b); 
#line 882
} else { 
#line 883
return (long)llmin((__int64)a, (__int64)b); 
#line 884
}  
#line 885
} 
#line 887
static inline unsigned long min(unsigned long a, unsigned long b) 
#line 888
{ 
#line 890
#pragma warning (disable: 4127)
#line 892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 894
#pragma warning (default: 4127)
#line 896 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 897
} else { 
#line 898
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 899
}  
#line 900
} 
#line 902
static inline unsigned long min(long a, unsigned long b) 
#line 903
{ 
#line 905
#pragma warning (disable: 4127)
#line 907 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 909
#pragma warning (default: 4127)
#line 911 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 912
} else { 
#line 913
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 914
}  
#line 915
} 
#line 917
static inline unsigned long min(unsigned long a, long b) 
#line 918
{ 
#line 920
#pragma warning (disable: 4127)
#line 922 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 924
#pragma warning (default: 4127)
#line 926 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 927
} else { 
#line 928
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 929
}  
#line 930
} 
#line 932
static inline __int64 min(__int64 a, __int64 b) 
#line 933
{ 
#line 934
return llmin(a, b); 
#line 935
} 
#line 937
static inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b) 
#line 938
{ 
#line 939
return ullmin(a, b); 
#line 940
} 
#line 942
static inline unsigned __int64 min(__int64 a, unsigned __int64 b) 
#line 943
{ 
#line 944
return ullmin((unsigned __int64)a, b); 
#line 945
} 
#line 947
static inline unsigned __int64 min(unsigned __int64 a, __int64 b) 
#line 948
{ 
#line 949
return ullmin(a, (unsigned __int64)b); 
#line 950
} 
#line 952
static inline float min(float a, float b) 
#line 953
{ 
#line 954
return fminf(a, b); 
#line 955
} 
#line 957
static inline double min(double a, double b) 
#line 958
{ 
#line 959
return fmin(a, b); 
#line 960
} 
#line 962
static inline double min(float a, double b) 
#line 963
{ 
#line 964
return fmin((double)a, b); 
#line 965
} 
#line 967
static inline double min(double a, float b) 
#line 968
{ 
#line 969
return fmin(a, (double)b); 
#line 970
} 
#line 972
static inline unsigned max(unsigned a, unsigned b) 
#line 973
{ 
#line 974
return umax(a, b); 
#line 975
} 
#line 977
static inline unsigned max(int a, unsigned b) 
#line 978
{ 
#line 979
return umax((unsigned)a, b); 
#line 980
} 
#line 982
static inline unsigned max(unsigned a, int b) 
#line 983
{ 
#line 984
return umax(a, (unsigned)b); 
#line 985
} 
#line 987
static inline long max(long a, long b) 
#line 988
{ 
#line 991
#pragma warning (disable: 4127)
#line 993 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 995
#pragma warning (default: 4127)
#line 997 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (long)max((int)a, (int)b); 
#line 998
} else { 
#line 999
return (long)llmax((__int64)a, (__int64)b); 
#line 1000
}  
#line 1001
} 
#line 1003
static inline unsigned long max(unsigned long a, unsigned long b) 
#line 1004
{ 
#line 1006
#pragma warning (disable: 4127)
#line 1008 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1010
#pragma warning (default: 4127)
#line 1012 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 1013
} else { 
#line 1014
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 1015
}  
#line 1016
} 
#line 1018
static inline unsigned long max(long a, unsigned long b) 
#line 1019
{ 
#line 1021
#pragma warning (disable: 4127)
#line 1023 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1025
#pragma warning (default: 4127)
#line 1027 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 1028
} else { 
#line 1029
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 1030
}  
#line 1031
} 
#line 1033
static inline unsigned long max(unsigned long a, long b) 
#line 1034
{ 
#line 1036
#pragma warning (disable: 4127)
#line 1038 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 1040
#pragma warning (default: 4127)
#line 1042 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 1043
} else { 
#line 1044
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 1045
}  
#line 1046
} 
#line 1048
static inline __int64 max(__int64 a, __int64 b) 
#line 1049
{ 
#line 1050
return llmax(a, b); 
#line 1051
} 
#line 1053
static inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b) 
#line 1054
{ 
#line 1055
return ullmax(a, b); 
#line 1056
} 
#line 1058
static inline unsigned __int64 max(__int64 a, unsigned __int64 b) 
#line 1059
{ 
#line 1060
return ullmax((unsigned __int64)a, b); 
#line 1061
} 
#line 1063
static inline unsigned __int64 max(unsigned __int64 a, __int64 b) 
#line 1064
{ 
#line 1065
return ullmax(a, (unsigned __int64)b); 
#line 1066
} 
#line 1068
static inline float max(float a, float b) 
#line 1069
{ 
#line 1070
return fmaxf(a, b); 
#line 1071
} 
#line 1073
static inline double max(double a, double b) 
#line 1074
{ 
#line 1075
return fmax(a, b); 
#line 1076
} 
#line 1078
static inline double max(float a, double b) 
#line 1079
{ 
#line 1080
return fmax((double)a, b); 
#line 1081
} 
#line 1083
static inline double max(double a, float b) 
#line 1084
{ 
#line 1085
return fmax(a, (double)b); 
#line 1086
} 
#line 1092
#pragma warning(disable : 4211)
#line 1097 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\math_functions.hpp"
static inline int min(int a, int b) 
#line 1098
{ 
#line 1099
return (a < b) ? a : b; 
#line 1100
} 
#line 1102
static inline unsigned umin(unsigned a, unsigned b) 
#line 1103
{ 
#line 1104
return (a < b) ? a : b; 
#line 1105
} 
#line 1107
static inline __int64 llmin(__int64 a, __int64 b) 
#line 1108
{ 
#line 1109
return (a < b) ? a : b; 
#line 1110
} 
#line 1112
static inline unsigned __int64 ullmin(unsigned __int64 a, unsigned __int64 
#line 1113
b) 
#line 1114
{ 
#line 1115
return (a < b) ? a : b; 
#line 1116
} 
#line 1118
static inline int max(int a, int b) 
#line 1119
{ 
#line 1120
return (a > b) ? a : b; 
#line 1121
} 
#line 1123
static inline unsigned umax(unsigned a, unsigned b) 
#line 1124
{ 
#line 1125
return (a > b) ? a : b; 
#line 1126
} 
#line 1128
static inline __int64 llmax(__int64 a, __int64 b) 
#line 1129
{ 
#line 1130
return (a > b) ? a : b; 
#line 1131
} 
#line 1133
static inline unsigned __int64 ullmax(unsigned __int64 a, unsigned __int64 
#line 1134
b) 
#line 1135
{ 
#line 1136
return (a > b) ? a : b; 
#line 1137
} 
#line 1140
#pragma warning(default: 4211)
#line 74 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_surface_types.h"
template< class T, int dim = 1> 
#line 75
struct surface : public surfaceReference { 
#line 78
surface() 
#line 79
{ 
#line 80
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 81
} 
#line 83
surface(::cudaChannelFormatDesc desc) 
#line 84
{ 
#line 85
(channelDesc) = desc; 
#line 86
} 
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_surface_types.h"
}; 
#line 90
template< int dim> 
#line 91
struct surface< void, dim>  : public surfaceReference { 
#line 94
surface() 
#line 95
{ 
#line 96
(channelDesc) = cudaCreateChannelDesc< void> (); 
#line 97
} 
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_surface_types.h"
}; 
#line 74 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
#line 75
struct texture : public textureReference { 
#line 78
texture(int norm = 0, ::cudaTextureFilterMode 
#line 79
fMode = cudaFilterModePoint, ::cudaTextureAddressMode 
#line 80
aMode = cudaAddressModeClamp) 
#line 81
{ 
#line 82
(normalized) = norm; 
#line 83
(filterMode) = fMode; 
#line 84
((addressMode)[0]) = aMode; 
#line 85
((addressMode)[1]) = aMode; 
#line 86
((addressMode)[2]) = aMode; 
#line 87
(channelDesc) = cudaCreateChannelDesc< T> (); 
#line 88
(sRGB) = 0; 
#line 89
} 
#line 91
texture(int norm, ::cudaTextureFilterMode 
#line 92
fMode, ::cudaTextureAddressMode 
#line 93
aMode, ::cudaChannelFormatDesc 
#line 94
desc) 
#line 95
{ 
#line 96
(normalized) = norm; 
#line 97
(filterMode) = fMode; 
#line 98
((addressMode)[0]) = aMode; 
#line 99
((addressMode)[1]) = aMode; 
#line 100
((addressMode)[2]) = aMode; 
#line 101
(channelDesc) = desc; 
#line 102
(sRGB) = 0; 
#line 103
} 
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_texture_types.h"
}; 
#line 89 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt/device_functions.h"
extern "C" {
#line 3217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt/device_functions.h"
}
#line 3225
static __inline int mulhi(int a, int b); 
#line 3227
static __inline unsigned mulhi(unsigned a, unsigned b); 
#line 3229
static __inline unsigned mulhi(int a, unsigned b); 
#line 3231
static __inline unsigned mulhi(unsigned a, int b); 
#line 3233
static __inline __int64 mul64hi(__int64 a, __int64 b); 
#line 3235
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b); 
#line 3237
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b); 
#line 3239
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b); 
#line 3241
static __inline int float_as_int(float a); 
#line 3243
static __inline float int_as_float(int a); 
#line 3245
static __inline unsigned float_as_uint(float a); 
#line 3247
static __inline float uint_as_float(unsigned a); 
#line 3249
static __inline float saturate(float a); 
#line 3251
static __inline int mul24(int a, int b); 
#line 3253
static __inline unsigned umul24(unsigned a, unsigned b); 
#line 3255
static __inline int float2int(float a, cudaRoundMode mode = cudaRoundZero); 
#line 3257
static __inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero); 
#line 3259
static __inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 3261
static __inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline int mulhi(int a, int b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 91
{ 
#line 92
return __mulhi(a, b); 
#line 93
} 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(unsigned a, unsigned b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 96
{ 
#line 97
return __umulhi(a, b); 
#line 98
} 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(int a, unsigned b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 101
{ 
#line 102
return __umulhi((unsigned)a, b); 
#line 103
} 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned mulhi(unsigned a, int b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 106
{ 
#line 107
return __umulhi(a, (unsigned)b); 
#line 108
} 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline __int64 mul64hi(__int64 a, __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 111
{ 
#line 112
return __mul64hi(a, b); 
#line 113
} 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 116
{ 
#line 117
return __umul64hi(a, b); 
#line 118
} 
#endif
#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 121
{ 
#line 122
return __umul64hi((unsigned __int64)a, b); 
#line 123
} 
#endif
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 126
{ 
#line 127
return __umul64hi(a, (unsigned __int64)b); 
#line 128
} 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline int float_as_int(float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 131
{ 
#line 132
return __float_as_int(a); 
#line 133
} 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline float int_as_float(int a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 136
{ 
#line 137
return __int_as_float(a); 
#line 138
} 
#endif
#line 140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned float_as_uint(float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 141
{ 
#line 142
return __float_as_uint(a); 
#line 143
} 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline float uint_as_float(unsigned a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 146
{ 
#line 147
return __uint_as_float(a); 
#line 148
} 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline float saturate(float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 150
{ 
#line 151
return __saturatef(a); 
#line 152
} 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline int mul24(int a, int b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 155
{ 
#line 156
return __mul24(a, b); 
#line 157
} 
#endif
#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned umul24(unsigned a, unsigned b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 160
{ 
#line 161
return __umul24(a, b); 
#line 162
} 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline int float2int(float a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 165
{ 
#line 166
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
#line 170
} 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline unsigned float2uint(float a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 173
{ 
#line 174
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
#line 178
} 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline float int2float(int a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 181
{ 
#line 182
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
#line 186
} 
#endif
#line 188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_functions.hpp"
static __inline float uint2float(unsigned a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 189
{ 
#line 190
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
#line 194
} 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicAdd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicAdd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicSub(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicSub(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicExch(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicExch(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline float atomicExch(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicMin(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 120
{ } 
#endif
#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicMin(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 122
{ } 
#endif
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicMax(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicMax(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicInc(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicDec(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicAnd(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicAnd(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicOr(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicOr(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicXor(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicXor(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline int atomicCAS(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 146
{ } 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
extern "C" {
#line 180
}
#line 189
static __inline unsigned __int64 atomicAdd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicExch(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicCAS(unsigned __int64 *address, unsigned __int64 compare, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
__declspec(deprecated("__any() is deprecated in favor of __any_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool any(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 195
{ } 
#endif
#line 197 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_atomic_functions.h"
__declspec(deprecated("__all() is deprecated in favor of __all_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to suppr" "ess this warning).")) static __inline bool all(bool cond) {int volatile ___ = 1;(void)cond;::exit(___);}
#if 0
#line 197
{ } 
#endif
#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.h"
extern "C" {
#line 1139
}
#line 1147
static __inline double fma(double a, double b, double c, cudaRoundMode mode); 
#line 1149
static __inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1151
static __inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1153
static __inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1155
static __inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1157
static __inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1159
static __inline __int64 double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1161
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1163
static __inline double ll2double(__int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1165
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1167
static __inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 1169
static __inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 1171
static __inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double fma(double a, double b, double c, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;::exit(___);}
#if 0
#line 94
{ 
#line 95
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
#line 99
} 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double dmul(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 102
{ 
#line 103
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
#line 107
} 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double dadd(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 110
{ 
#line 111
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
#line 115
} 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double dsub(double a, double b, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)b;(void)mode;::exit(___);}
#if 0
#line 118
{ 
#line 119
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
#line 123
} 
#endif
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline int double2int(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 126
{ 
#line 127
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
#line 131
} 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline unsigned double2uint(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 134
{ 
#line 135
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
#line 139
} 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline __int64 double2ll(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 142
{ 
#line 143
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
#line 147
} 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 150
{ 
#line 151
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
#line 155
} 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double ll2double(__int64 a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 158
{ 
#line 159
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
#line 163
} 
#endif
#line 165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 166
{ 
#line 167
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
#line 171
} 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double int2double(int a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 174
{ 
#line 175
return (double)a; 
#line 176
} 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double uint2double(unsigned a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 179
{ 
#line 180
return (double)a; 
#line 181
} 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\device_double_functions.hpp"
static __inline double float2double(float a, cudaRoundMode mode) {int volatile ___ = 1;(void)a;(void)mode;::exit(___);}
#if 0
#line 184
{ 
#line 185
return (double)a; 
#line 186
} 
#endif
#line 89 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_atomic_functions.h"
static __inline float atomicAdd(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMin(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMax(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicAnd(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicOr(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicXor(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMin(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicMax(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicAnd(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 114
{ } 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicOr(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_atomic_functions.h"
static __inline unsigned __int64 atomicXor(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 303 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 303
{ } 
#endif
#line 306 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 306
{ } 
#endif
#line 309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAdd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 309
{ } 
#endif
#line 312 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 312
{ } 
#endif
#line 315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAdd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 315
{ } 
#endif
#line 318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 318
{ } 
#endif
#line 321 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAdd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 321
{ } 
#endif
#line 324 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 324
{ } 
#endif
#line 327 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicAdd_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 327
{ } 
#endif
#line 330 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_block(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 330
{ } 
#endif
#line 333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline double atomicAdd_system(double *address, double val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 333
{ } 
#endif
#line 336 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 336
{ } 
#endif
#line 339 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicSub_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 339
{ } 
#endif
#line 342 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 342
{ } 
#endif
#line 345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicSub_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 345
{ } 
#endif
#line 348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 348
{ } 
#endif
#line 351 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicExch_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 351
{ } 
#endif
#line 354 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 354
{ } 
#endif
#line 357 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicExch_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 357
{ } 
#endif
#line 360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 360
{ } 
#endif
#line 363 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicExch_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 363
{ } 
#endif
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_block(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 366
{ } 
#endif
#line 369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline float atomicExch_system(float *address, float val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 369
{ } 
#endif
#line 372 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 372
{ } 
#endif
#line 375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMin_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 375
{ } 
#endif
#line 378 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 378
{ } 
#endif
#line 381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMin_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 381
{ } 
#endif
#line 384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 384
{ } 
#endif
#line 387 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMin_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 387
{ } 
#endif
#line 390 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 390
{ } 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMin_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 393
{ } 
#endif
#line 396 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 396
{ } 
#endif
#line 399 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicMax_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 399
{ } 
#endif
#line 402 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 402
{ } 
#endif
#line 405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicMax_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 405
{ } 
#endif
#line 408 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 408
{ } 
#endif
#line 411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicMax_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 411
{ } 
#endif
#line 414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 414
{ } 
#endif
#line 417 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicMax_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 417
{ } 
#endif
#line 420 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 420
{ } 
#endif
#line 423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicInc_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 423
{ } 
#endif
#line 426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 426
{ } 
#endif
#line 429 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicDec_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 429
{ } 
#endif
#line 432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_block(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 432
{ } 
#endif
#line 435 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicCAS_system(int *address, int compare, int val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 435
{ } 
#endif
#line 438 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_block(unsigned *address, unsigned compare, unsigned 
#line 439
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 439
{ } 
#endif
#line 442 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicCAS_system(unsigned *address, unsigned compare, unsigned 
#line 443
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 443
{ } 
#endif
#line 446 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_block(unsigned __int64 *address, unsigned __int64 
#line 447
compare, unsigned __int64 
#line 448
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 448
{ } 
#endif
#line 451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicCAS_system(unsigned __int64 *address, unsigned __int64 
#line 452
compare, unsigned __int64 
#line 453
val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 453
{ } 
#endif
#line 456 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 456
{ } 
#endif
#line 459 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicAnd_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 459
{ } 
#endif
#line 462 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 462
{ } 
#endif
#line 465 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicAnd_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 465
{ } 
#endif
#line 468 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 468
{ } 
#endif
#line 471 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicAnd_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 471
{ } 
#endif
#line 474 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 474
{ } 
#endif
#line 477 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicAnd_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 477
{ } 
#endif
#line 480 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 480
{ } 
#endif
#line 483 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicOr_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 483
{ } 
#endif
#line 486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 486
{ } 
#endif
#line 489 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicOr_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 489
{ } 
#endif
#line 492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 492
{ } 
#endif
#line 495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicOr_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 495
{ } 
#endif
#line 498 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 498
{ } 
#endif
#line 501 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicOr_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 501
{ } 
#endif
#line 504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_block(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 504
{ } 
#endif
#line 507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline int atomicXor_system(int *address, int val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 507
{ } 
#endif
#line 510 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_block(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 510
{ } 
#endif
#line 513 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline __int64 atomicXor_system(__int64 *address, __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 513
{ } 
#endif
#line 516 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_block(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 516
{ } 
#endif
#line 519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned atomicXor_system(unsigned *address, unsigned val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 519
{ } 
#endif
#line 522 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_block(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 522
{ } 
#endif
#line 525 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_60_atomic_functions.h"
static __inline unsigned __int64 atomicXor_system(unsigned __int64 *address, unsigned __int64 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 525
{ } 
#endif
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
extern "C" {
#line 1475
}
#line 1482
__declspec(deprecated("__ballot() is deprecated in favor of __ballot_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to" " suppress this warning).")) static __inline unsigned ballot(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1482
{ } 
#endif
#line 1484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
static __inline int syncthreads_count(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1484
{ } 
#endif
#line 1486 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_and(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1486
{ } 
#endif
#line 1488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
static __inline bool syncthreads_or(bool pred) {int volatile ___ = 1;(void)pred;::exit(___);}
#if 0
#line 1488
{ } 
#endif
#line 1493 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
static __inline unsigned __isGlobal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1493
{ } 
#endif
#line 1494 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
static __inline unsigned __isShared(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1494
{ } 
#endif
#line 1495 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
static __inline unsigned __isConstant(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1495
{ } 
#endif
#line 1496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_20_intrinsics.h"
static __inline unsigned __isLocal(const void *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1496
{ } 
#endif
#line 102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __fns(unsigned mask, unsigned base, int offset) {int volatile ___ = 1;(void)mask;(void)base;(void)offset;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync(unsigned id) {int volatile ___ = 1;(void)id;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline void __barrier_sync_count(unsigned id, unsigned cnt) {int volatile ___ = 1;(void)id;(void)cnt;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline void __syncwarp(unsigned mask = 4294967295U) {int volatile ___ = 1;(void)mask;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline int __all_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline int __any_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline int __uni_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __ballot_sync(unsigned mask, int pred) {int volatile ___ = 1;(void)mask;(void)pred;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __activemask() {int volatile ___ = 1;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline int __shfl(int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __shfl(unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 120
{ } 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline int __shfl_up(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 121
{ } 
#endif
#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 122
{ } 
#endif
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline int __shfl_down(int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline int __shfl_xor(int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 125
{ } 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline float __shfl(float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline float __shfl_up(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline float __shfl_down(float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline float __shfl_xor(float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_sync(unsigned mask, int var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_sync(unsigned mask, unsigned var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_up_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_up_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_down_sync(unsigned mask, int var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_down_sync(unsigned mask, unsigned var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 138
{ } 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline int __shfl_xor_sync(unsigned mask, int var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __shfl_xor_sync(unsigned mask, unsigned var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_sync(unsigned mask, float var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_up_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_down_sync(unsigned mask, float var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 143
{ } 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline float __shfl_xor_sync(unsigned mask, float var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned __int64 __shfl(unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline __int64 __shfl(__int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 150 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline __int64 __shfl_up(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 150
{ } 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned __int64 __shfl_up(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 152 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline __int64 __shfl_down(__int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 152
{ } 
#endif
#line 153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned __int64 __shfl_down(unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline __int64 __shfl_xor(__int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned __int64 __shfl_xor(unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 155
{ } 
#endif
#line 156 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline double __shfl(double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 156
{ } 
#endif
#line 157 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline double __shfl_up(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 157
{ } 
#endif
#line 158 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline double __shfl_down(double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 158
{ } 
#endif
#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline double __shfl_xor(double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_sync(unsigned mask, __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 162
{ } 
#endif
#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_sync(unsigned mask, unsigned __int64 var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 163
{ } 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_up_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_up_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_down_sync(unsigned mask, __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 166
{ } 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_down_sync(unsigned mask, unsigned __int64 var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 167
{ } 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline __int64 __shfl_xor_sync(unsigned mask, __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 168
{ } 
#endif
#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned __int64 __shfl_xor_sync(unsigned mask, unsigned __int64 var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_sync(unsigned mask, double var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_up_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_down_sync(unsigned mask, double var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline double __shfl_xor_sync(unsigned mask, double var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline long __shfl(long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline long __shfl_up(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 179
{ } 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline long __shfl_down(long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 181
{ } 
#endif
#line 182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline long __shfl_xor(long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_sync(unsigned mask, long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_sync(unsigned mask, unsigned long var, int srcLane, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)srcLane;(void)width;::exit(___);}
#if 0
#line 188
{ } 
#endif
#line 189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_up_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_up_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_down_sync(unsigned mask, long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_down_sync(unsigned mask, unsigned long var, unsigned delta, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 192
{ } 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline long __shfl_xor_sync(unsigned mask, long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 193
{ } 
#endif
#line 194 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_30_intrinsics.h"
static __inline unsigned long __shfl_xor_sync(unsigned mask, unsigned long var, int laneMask, int width = 32) {int volatile ___ = 1;(void)mask;(void)var;(void)laneMask;(void)width;::exit(___);}
#if 0
#line 194
{ } 
#endif
#line 87 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 87
{ } 
#endif
#line 88 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 88
{ } 
#endif
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 91 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 91
{ } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 101 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 101
{ } 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 112 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 112
{ } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 115 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 115
{ } 
#endif
#line 116 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 116
{ } 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 117
{ } 
#endif
#line 118 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 118
{ } 
#endif
#line 119 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 119
{ } 
#endif
#line 123 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline long __ldcg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 123
{ } 
#endif
#line 124 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 124
{ } 
#endif
#line 126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char __ldcg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 126
{ } 
#endif
#line 127 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 127
{ } 
#endif
#line 128 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short __ldcg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 128
{ } 
#endif
#line 129 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int __ldcg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 129
{ } 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 130
{ } 
#endif
#line 131 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 131
{ } 
#endif
#line 132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 132
{ } 
#endif
#line 133 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 133
{ } 
#endif
#line 134 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 134
{ } 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 136
{ } 
#endif
#line 137 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 140 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 140
{ } 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 142 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 142
{ } 
#endif
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 143
{ } 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 144
{ } 
#endif
#line 145 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 145
{ } 
#endif
#line 146 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 146
{ } 
#endif
#line 147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 147
{ } 
#endif
#line 148 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 148
{ } 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 149
{ } 
#endif
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float __ldcg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 151
{ } 
#endif
#line 152 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double __ldcg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 152
{ } 
#endif
#line 153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 153
{ } 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 154
{ } 
#endif
#line 155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 155
{ } 
#endif
#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline long __ldca(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 159
{ } 
#endif
#line 160 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldca(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 160
{ } 
#endif
#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char __ldca(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 162
{ } 
#endif
#line 163 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldca(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 163
{ } 
#endif
#line 164 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short __ldca(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 164
{ } 
#endif
#line 165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int __ldca(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 165
{ } 
#endif
#line 166 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldca(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 166
{ } 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldca(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 167
{ } 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldca(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 168
{ } 
#endif
#line 169 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldca(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 169
{ } 
#endif
#line 170 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldca(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 170
{ } 
#endif
#line 171 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldca(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 171
{ } 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldca(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 172
{ } 
#endif
#line 173 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldca(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 173
{ } 
#endif
#line 175 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldca(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 175
{ } 
#endif
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldca(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 176
{ } 
#endif
#line 177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldca(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 177
{ } 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldca(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 178
{ } 
#endif
#line 179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldca(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 179
{ } 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldca(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 180
{ } 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldca(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 181
{ } 
#endif
#line 182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldca(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 182
{ } 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldca(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 183
{ } 
#endif
#line 184 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldca(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 184
{ } 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldca(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 185
{ } 
#endif
#line 187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float __ldca(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 187
{ } 
#endif
#line 188 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double __ldca(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 188
{ } 
#endif
#line 189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldca(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 189
{ } 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldca(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 190
{ } 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldca(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 191
{ } 
#endif
#line 195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline long __ldcs(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 195
{ } 
#endif
#line 196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned long __ldcs(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 196
{ } 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char __ldcs(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 198
{ } 
#endif
#line 199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline signed char __ldcs(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 199
{ } 
#endif
#line 200 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short __ldcs(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 200
{ } 
#endif
#line 201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int __ldcs(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 201
{ } 
#endif
#line 202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline __int64 __ldcs(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 202
{ } 
#endif
#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char2 __ldcs(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 203
{ } 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline char4 __ldcs(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 204
{ } 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short2 __ldcs(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 205
{ } 
#endif
#line 206 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline short4 __ldcs(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 206
{ } 
#endif
#line 207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int2 __ldcs(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 207
{ } 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline int4 __ldcs(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 208
{ } 
#endif
#line 209 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline longlong2 __ldcs(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 209
{ } 
#endif
#line 211 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned char __ldcs(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 211
{ } 
#endif
#line 212 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned short __ldcs(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 212
{ } 
#endif
#line 213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __ldcs(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 213
{ } 
#endif
#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __int64 __ldcs(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 214
{ } 
#endif
#line 215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar2 __ldcs(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 215
{ } 
#endif
#line 216 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uchar4 __ldcs(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 216
{ } 
#endif
#line 217 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort2 __ldcs(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 217
{ } 
#endif
#line 218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ushort4 __ldcs(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 218
{ } 
#endif
#line 219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint2 __ldcs(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 219
{ } 
#endif
#line 220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline uint4 __ldcs(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 220
{ } 
#endif
#line 221 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline ulonglong2 __ldcs(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 221
{ } 
#endif
#line 223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float __ldcs(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 223
{ } 
#endif
#line 224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double __ldcs(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 224
{ } 
#endif
#line 225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float2 __ldcs(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 225
{ } 
#endif
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline float4 __ldcs(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 226
{ } 
#endif
#line 227 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline double2 __ldcs(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 227
{ } 
#endif
#line 244 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 244
{ } 
#endif
#line 256 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 256
{ } 
#endif
#line 269 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 269
{ } 
#endif
#line 281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_32_intrinsics.h"
static __inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) {int volatile ___ = 1;(void)lo;(void)hi;(void)shift;::exit(___);}
#if 0
#line 281
{ } 
#endif
#line 89 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 89
{ } 
#endif
#line 90 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 90
{ } 
#endif
#line 92 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_lo(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 92
{ } 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_lo(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline int __dp2a_hi(short2 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp2a_hi(ushort2 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(int srcA, int srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(unsigned srcA, unsigned srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline int __dp4a(char4 srcA, char4 srcB, int c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 110 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\sm_61_intrinsics.h"
static __inline unsigned __dp4a(uchar4 srcA, uchar4 srcB, unsigned c) {int volatile ___ = 1;(void)srcA;(void)srcB;(void)c;::exit(___);}
#if 0
#line 110
{ } 
#endif
#line 93 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 93
{ } 
#endif
#line 94 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, int value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 94
{ } 
#endif
#line 95 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 95
{ } 
#endif
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, long value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 96
{ } 
#endif
#line 97 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, unsigned __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 97
{ } 
#endif
#line 98 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, __int64 value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 98
{ } 
#endif
#line 99 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, float value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 99
{ } 
#endif
#line 100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_any_sync(unsigned mask, double value) {int volatile ___ = 1;(void)mask;(void)value;::exit(___);}
#if 0
#line 100
{ } 
#endif
#line 102 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 102
{ } 
#endif
#line 103 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, int value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 103
{ } 
#endif
#line 104 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 104
{ } 
#endif
#line 105 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, long value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 105
{ } 
#endif
#line 106 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, unsigned __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 106
{ } 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, __int64 value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 107
{ } 
#endif
#line 108 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, float value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 108
{ } 
#endif
#line 109 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned __match_all_sync(unsigned mask, double value, int *pred) {int volatile ___ = 1;(void)mask;(void)value;(void)pred;::exit(___);}
#if 0
#line 109
{ } 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline void __nanosleep(unsigned ns) {int volatile ___ = 1;(void)ns;::exit(___);}
#if 0
#line 111
{ } 
#endif
#line 113 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt\\sm_70_rt.h"
static __inline unsigned short atomicCAS(unsigned short *address, unsigned short compare, unsigned short val) {int volatile ___ = 1;(void)address;(void)compare;(void)val;::exit(___);}
#if 0
#line 113
{ } 
#endif
#line 114 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 115
surf1Dread(T *res, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;::exit(___);}
#if 0
#line 116
{ 
#line 120
} 
#endif
#line 122 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 123
surf1Dread(::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)mode;::exit(___);}
#if 0
#line 124
{ 
#line 130
} 
#endif
#line 132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 133
surf1Dread(T *res, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;::exit(___);}
#if 0
#line 134
{ 
#line 138
} 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 142
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;::exit(___);}
#if 0
#line 143
{ 
#line 147
} 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 150
surf2Dread(::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 151
{ 
#line 157
} 
#endif
#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 160
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 161
{ 
#line 165
} 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 169
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;::exit(___);}
#if 0
#line 170
{ 
#line 174
} 
#endif
#line 176 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 177
surf3Dread(::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 178
{ 
#line 184
} 
#endif
#line 186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 187
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 188
{ 
#line 192
} 
#endif
#line 196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 197
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 198
{ 
#line 202
} 
#endif
#line 204 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 205
surf1DLayeredread(::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 206
{ 
#line 212
} 
#endif
#line 215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 216
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 217
{ 
#line 221
} 
#endif
#line 224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 225
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 226
{ 
#line 230
} 
#endif
#line 232 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 233
surf2DLayeredread(::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 234
{ 
#line 240
} 
#endif
#line 243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 244
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 245
{ 
#line 249
} 
#endif
#line 252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 253
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;::exit(___);}
#if 0
#line 254
{ 
#line 258
} 
#endif
#line 260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 261
surfCubemapread(::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 262
{ 
#line 269
} 
#endif
#line 271 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 272
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 273
{ 
#line 277
} 
#endif
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 281
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;::exit(___);}
#if 0
#line 282
{ 
#line 286
} 
#endif
#line 288 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 289
surfCubemapLayeredread(::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;::exit(___);}
#if 0
#line 290
{ 
#line 296
} 
#endif
#line 298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 299
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;::exit(___);}
#if 0
#line 300
{ 
#line 304
} 
#endif
#line 307 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 308
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;::exit(___);}
#if 0
#line 309
{ 
#line 313
} 
#endif
#line 315 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 316
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;::exit(___);}
#if 0
#line 317
{ 
#line 321
} 
#endif
#line 325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 326
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;::exit(___);}
#if 0
#line 327
{ 
#line 331
} 
#endif
#line 333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 334
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 335
{ 
#line 339
} 
#endif
#line 342 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 343
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;::exit(___);}
#if 0
#line 344
{ 
#line 348
} 
#endif
#line 350 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 351
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 352
{ 
#line 356
} 
#endif
#line 359 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 360
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 361
{ 
#line 365
} 
#endif
#line 367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 368
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 369
{ 
#line 373
} 
#endif
#line 376 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 377
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;::exit(___);}
#if 0
#line 378
{ 
#line 382
} 
#endif
#line 384 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 385
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 386
{ 
#line 390
} 
#endif
#line 393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 394
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;::exit(___);}
#if 0
#line 395
{ 
#line 399
} 
#endif
#line 401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 402
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 403
{ 
#line 407
} 
#endif
#line 411 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 412
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;::exit(___);}
#if 0
#line 413
{ 
#line 417
} 
#endif
#line 419 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 420
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;::exit(___);}
#if 0
#line 421
{ 
#line 425
} 
#endif
#line 66 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> 
#line 67
struct __nv_tex_rmet_ret { }; 
#line 69
template<> struct __nv_tex_rmet_ret< char>  { typedef char type; }; 
#line 70
template<> struct __nv_tex_rmet_ret< signed char>  { typedef signed char type; }; 
#line 71
template<> struct __nv_tex_rmet_ret< unsigned char>  { typedef unsigned char type; }; 
#line 72
template<> struct __nv_tex_rmet_ret< char1>  { typedef char1 type; }; 
#line 73
template<> struct __nv_tex_rmet_ret< uchar1>  { typedef uchar1 type; }; 
#line 74
template<> struct __nv_tex_rmet_ret< char2>  { typedef char2 type; }; 
#line 75
template<> struct __nv_tex_rmet_ret< uchar2>  { typedef uchar2 type; }; 
#line 76
template<> struct __nv_tex_rmet_ret< char4>  { typedef char4 type; }; 
#line 77
template<> struct __nv_tex_rmet_ret< uchar4>  { typedef uchar4 type; }; 
#line 79
template<> struct __nv_tex_rmet_ret< short>  { typedef short type; }; 
#line 80
template<> struct __nv_tex_rmet_ret< unsigned short>  { typedef unsigned short type; }; 
#line 81
template<> struct __nv_tex_rmet_ret< short1>  { typedef short1 type; }; 
#line 82
template<> struct __nv_tex_rmet_ret< ushort1>  { typedef ushort1 type; }; 
#line 83
template<> struct __nv_tex_rmet_ret< short2>  { typedef short2 type; }; 
#line 84
template<> struct __nv_tex_rmet_ret< ushort2>  { typedef ushort2 type; }; 
#line 85
template<> struct __nv_tex_rmet_ret< short4>  { typedef short4 type; }; 
#line 86
template<> struct __nv_tex_rmet_ret< ushort4>  { typedef ushort4 type; }; 
#line 88
template<> struct __nv_tex_rmet_ret< int>  { typedef int type; }; 
#line 89
template<> struct __nv_tex_rmet_ret< unsigned>  { typedef unsigned type; }; 
#line 90
template<> struct __nv_tex_rmet_ret< int1>  { typedef int1 type; }; 
#line 91
template<> struct __nv_tex_rmet_ret< uint1>  { typedef uint1 type; }; 
#line 92
template<> struct __nv_tex_rmet_ret< int2>  { typedef int2 type; }; 
#line 93
template<> struct __nv_tex_rmet_ret< uint2>  { typedef uint2 type; }; 
#line 94
template<> struct __nv_tex_rmet_ret< int4>  { typedef int4 type; }; 
#line 95
template<> struct __nv_tex_rmet_ret< uint4>  { typedef uint4 type; }; 
#line 98
template<> struct __nv_tex_rmet_ret< long>  { typedef long type; }; 
#line 99
template<> struct __nv_tex_rmet_ret< unsigned long>  { typedef unsigned long type; }; 
#line 100
template<> struct __nv_tex_rmet_ret< long1>  { typedef long1 type; }; 
#line 101
template<> struct __nv_tex_rmet_ret< ulong1>  { typedef ulong1 type; }; 
#line 102
template<> struct __nv_tex_rmet_ret< long2>  { typedef long2 type; }; 
#line 103
template<> struct __nv_tex_rmet_ret< ulong2>  { typedef ulong2 type; }; 
#line 104
template<> struct __nv_tex_rmet_ret< long4>  { typedef long4 type; }; 
#line 105
template<> struct __nv_tex_rmet_ret< ulong4>  { typedef ulong4 type; }; 
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template<> struct __nv_tex_rmet_ret< float>  { typedef float type; }; 
#line 108
template<> struct __nv_tex_rmet_ret< float1>  { typedef float1 type; }; 
#line 109
template<> struct __nv_tex_rmet_ret< float2>  { typedef float2 type; }; 
#line 110
template<> struct __nv_tex_rmet_ret< float4>  { typedef float4 type; }; 
#line 113
template< class T> struct __nv_tex_rmet_cast { typedef T *type; }; 
#line 115
template<> struct __nv_tex_rmet_cast< long>  { typedef int *type; }; 
#line 116
template<> struct __nv_tex_rmet_cast< unsigned long>  { typedef unsigned *type; }; 
#line 117
template<> struct __nv_tex_rmet_cast< long1>  { typedef int1 *type; }; 
#line 118
template<> struct __nv_tex_rmet_cast< ulong1>  { typedef uint1 *type; }; 
#line 119
template<> struct __nv_tex_rmet_cast< long2>  { typedef int2 *type; }; 
#line 120
template<> struct __nv_tex_rmet_cast< ulong2>  { typedef uint2 *type; }; 
#line 121
template<> struct __nv_tex_rmet_cast< long4>  { typedef int4 *type; }; 
#line 122
template<> struct __nv_tex_rmet_cast< ulong4>  { typedef uint4 *type; }; 
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 126
tex1Dfetch(texture< T, 1, cudaReadModeElementType>  t, int x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 127
{ 
#line 133
} 
#endif
#line 135 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> 
#line 136
struct __nv_tex_rmnf_ret { }; 
#line 138
template<> struct __nv_tex_rmnf_ret< char>  { typedef float type; }; 
#line 139
template<> struct __nv_tex_rmnf_ret< signed char>  { typedef float type; }; 
#line 140
template<> struct __nv_tex_rmnf_ret< unsigned char>  { typedef float type; }; 
#line 141
template<> struct __nv_tex_rmnf_ret< short>  { typedef float type; }; 
#line 142
template<> struct __nv_tex_rmnf_ret< unsigned short>  { typedef float type; }; 
#line 143
template<> struct __nv_tex_rmnf_ret< char1>  { typedef float1 type; }; 
#line 144
template<> struct __nv_tex_rmnf_ret< uchar1>  { typedef float1 type; }; 
#line 145
template<> struct __nv_tex_rmnf_ret< short1>  { typedef float1 type; }; 
#line 146
template<> struct __nv_tex_rmnf_ret< ushort1>  { typedef float1 type; }; 
#line 147
template<> struct __nv_tex_rmnf_ret< char2>  { typedef float2 type; }; 
#line 148
template<> struct __nv_tex_rmnf_ret< uchar2>  { typedef float2 type; }; 
#line 149
template<> struct __nv_tex_rmnf_ret< short2>  { typedef float2 type; }; 
#line 150
template<> struct __nv_tex_rmnf_ret< ushort2>  { typedef float2 type; }; 
#line 151
template<> struct __nv_tex_rmnf_ret< char4>  { typedef float4 type; }; 
#line 152
template<> struct __nv_tex_rmnf_ret< uchar4>  { typedef float4 type; }; 
#line 153
template<> struct __nv_tex_rmnf_ret< short4>  { typedef float4 type; }; 
#line 154
template<> struct __nv_tex_rmnf_ret< ushort4>  { typedef float4 type; }; 
#line 156
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 157
tex1Dfetch(texture< T, 1, cudaReadModeNormalizedFloat>  t, int x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 158
{ 
#line 165
} 
#endif
#line 168 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 169
tex1D(texture< T, 1, cudaReadModeElementType>  t, float x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 170
{ 
#line 176
} 
#endif
#line 178 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 179
tex1D(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x) {int volatile ___ = 1;(void)t;(void)x;::exit(___);}
#if 0
#line 180
{ 
#line 187
} 
#endif
#line 191 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 192
tex2D(texture< T, 2, cudaReadModeElementType>  t, float x, float y) {int volatile ___ = 1;(void)t;(void)x;(void)y;::exit(___);}
#if 0
#line 193
{ 
#line 200
} 
#endif
#line 202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 203
tex2D(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y) {int volatile ___ = 1;(void)t;(void)x;(void)y;::exit(___);}
#if 0
#line 204
{ 
#line 211
} 
#endif
#line 215 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 216
tex1DLayered(texture< T, 241, cudaReadModeElementType>  t, float x, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)layer;::exit(___);}
#if 0
#line 217
{ 
#line 223
} 
#endif
#line 225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 226
tex1DLayered(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)layer;::exit(___);}
#if 0
#line 227
{ 
#line 234
} 
#endif
#line 238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 239
tex2DLayered(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 240
{ 
#line 246
} 
#endif
#line 248 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 249
tex2DLayered(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 250
{ 
#line 257
} 
#endif
#line 260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 261
tex3D(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 262
{ 
#line 268
} 
#endif
#line 270 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 271
tex3D(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 272
{ 
#line 279
} 
#endif
#line 282 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 283
texCubemap(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 284
{ 
#line 290
} 
#endif
#line 292 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 293
texCubemap(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 294
{ 
#line 301
} 
#endif
#line 304 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> 
#line 305
struct __nv_tex2dgather_ret { }; 
#line 306
template<> struct __nv_tex2dgather_ret< char>  { typedef char4 type; }; 
#line 307
template<> struct __nv_tex2dgather_ret< signed char>  { typedef char4 type; }; 
#line 308
template<> struct __nv_tex2dgather_ret< char1>  { typedef char4 type; }; 
#line 309
template<> struct __nv_tex2dgather_ret< char2>  { typedef char4 type; }; 
#line 310
template<> struct __nv_tex2dgather_ret< char3>  { typedef char4 type; }; 
#line 311
template<> struct __nv_tex2dgather_ret< char4>  { typedef char4 type; }; 
#line 312
template<> struct __nv_tex2dgather_ret< unsigned char>  { typedef uchar4 type; }; 
#line 313
template<> struct __nv_tex2dgather_ret< uchar1>  { typedef uchar4 type; }; 
#line 314
template<> struct __nv_tex2dgather_ret< uchar2>  { typedef uchar4 type; }; 
#line 315
template<> struct __nv_tex2dgather_ret< uchar3>  { typedef uchar4 type; }; 
#line 316
template<> struct __nv_tex2dgather_ret< uchar4>  { typedef uchar4 type; }; 
#line 318
template<> struct __nv_tex2dgather_ret< short>  { typedef short4 type; }; 
#line 319
template<> struct __nv_tex2dgather_ret< short1>  { typedef short4 type; }; 
#line 320
template<> struct __nv_tex2dgather_ret< short2>  { typedef short4 type; }; 
#line 321
template<> struct __nv_tex2dgather_ret< short3>  { typedef short4 type; }; 
#line 322
template<> struct __nv_tex2dgather_ret< short4>  { typedef short4 type; }; 
#line 323
template<> struct __nv_tex2dgather_ret< unsigned short>  { typedef ushort4 type; }; 
#line 324
template<> struct __nv_tex2dgather_ret< ushort1>  { typedef ushort4 type; }; 
#line 325
template<> struct __nv_tex2dgather_ret< ushort2>  { typedef ushort4 type; }; 
#line 326
template<> struct __nv_tex2dgather_ret< ushort3>  { typedef ushort4 type; }; 
#line 327
template<> struct __nv_tex2dgather_ret< ushort4>  { typedef ushort4 type; }; 
#line 329
template<> struct __nv_tex2dgather_ret< int>  { typedef int4 type; }; 
#line 330
template<> struct __nv_tex2dgather_ret< int1>  { typedef int4 type; }; 
#line 331
template<> struct __nv_tex2dgather_ret< int2>  { typedef int4 type; }; 
#line 332
template<> struct __nv_tex2dgather_ret< int3>  { typedef int4 type; }; 
#line 333
template<> struct __nv_tex2dgather_ret< int4>  { typedef int4 type; }; 
#line 334
template<> struct __nv_tex2dgather_ret< unsigned>  { typedef uint4 type; }; 
#line 335
template<> struct __nv_tex2dgather_ret< uint1>  { typedef uint4 type; }; 
#line 336
template<> struct __nv_tex2dgather_ret< uint2>  { typedef uint4 type; }; 
#line 337
template<> struct __nv_tex2dgather_ret< uint3>  { typedef uint4 type; }; 
#line 338
template<> struct __nv_tex2dgather_ret< uint4>  { typedef uint4 type; }; 
#line 340
template<> struct __nv_tex2dgather_ret< float>  { typedef float4 type; }; 
#line 341
template<> struct __nv_tex2dgather_ret< float1>  { typedef float4 type; }; 
#line 342
template<> struct __nv_tex2dgather_ret< float2>  { typedef float4 type; }; 
#line 343
template<> struct __nv_tex2dgather_ret< float3>  { typedef float4 type; }; 
#line 344
template<> struct __nv_tex2dgather_ret< float4>  { typedef float4 type; }; 
#line 346
template< class T> static __forceinline typename __nv_tex2dgather_ret< T> ::type 
#line 347
tex2Dgather(texture< T, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 348
{ 
#line 355
} 
#endif
#line 358 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> struct __nv_tex2dgather_rmnf_ret { }; 
#line 359
template<> struct __nv_tex2dgather_rmnf_ret< char>  { typedef float4 type; }; 
#line 360
template<> struct __nv_tex2dgather_rmnf_ret< signed char>  { typedef float4 type; }; 
#line 361
template<> struct __nv_tex2dgather_rmnf_ret< unsigned char>  { typedef float4 type; }; 
#line 362
template<> struct __nv_tex2dgather_rmnf_ret< char1>  { typedef float4 type; }; 
#line 363
template<> struct __nv_tex2dgather_rmnf_ret< uchar1>  { typedef float4 type; }; 
#line 364
template<> struct __nv_tex2dgather_rmnf_ret< char2>  { typedef float4 type; }; 
#line 365
template<> struct __nv_tex2dgather_rmnf_ret< uchar2>  { typedef float4 type; }; 
#line 366
template<> struct __nv_tex2dgather_rmnf_ret< char3>  { typedef float4 type; }; 
#line 367
template<> struct __nv_tex2dgather_rmnf_ret< uchar3>  { typedef float4 type; }; 
#line 368
template<> struct __nv_tex2dgather_rmnf_ret< char4>  { typedef float4 type; }; 
#line 369
template<> struct __nv_tex2dgather_rmnf_ret< uchar4>  { typedef float4 type; }; 
#line 370
template<> struct __nv_tex2dgather_rmnf_ret< signed short>  { typedef float4 type; }; 
#line 371
template<> struct __nv_tex2dgather_rmnf_ret< unsigned short>  { typedef float4 type; }; 
#line 372
template<> struct __nv_tex2dgather_rmnf_ret< short1>  { typedef float4 type; }; 
#line 373
template<> struct __nv_tex2dgather_rmnf_ret< ushort1>  { typedef float4 type; }; 
#line 374
template<> struct __nv_tex2dgather_rmnf_ret< short2>  { typedef float4 type; }; 
#line 375
template<> struct __nv_tex2dgather_rmnf_ret< ushort2>  { typedef float4 type; }; 
#line 376
template<> struct __nv_tex2dgather_rmnf_ret< short3>  { typedef float4 type; }; 
#line 377
template<> struct __nv_tex2dgather_rmnf_ret< ushort3>  { typedef float4 type; }; 
#line 378
template<> struct __nv_tex2dgather_rmnf_ret< short4>  { typedef float4 type; }; 
#line 379
template<> struct __nv_tex2dgather_rmnf_ret< ushort4>  { typedef float4 type; }; 
#line 381
template< class T> static __forceinline typename __nv_tex2dgather_rmnf_ret< T> ::type 
#line 382
tex2Dgather(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 383
{ 
#line 390
} 
#endif
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 395
tex1DLod(texture< T, 1, cudaReadModeElementType>  t, float x, float level) {int volatile ___ = 1;(void)t;(void)x;(void)level;::exit(___);}
#if 0
#line 396
{ 
#line 402
} 
#endif
#line 404 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 405
tex1DLod(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float level) {int volatile ___ = 1;(void)t;(void)x;(void)level;::exit(___);}
#if 0
#line 406
{ 
#line 413
} 
#endif
#line 416 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 417
tex2DLod(texture< T, 2, cudaReadModeElementType>  t, float x, float y, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 418
{ 
#line 424
} 
#endif
#line 426 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 427
tex2DLod(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 428
{ 
#line 435
} 
#endif
#line 438 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 439
tex1DLayeredLod(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 440
{ 
#line 446
} 
#endif
#line 448 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 449
tex1DLayeredLod(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 450
{ 
#line 457
} 
#endif
#line 460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 461
tex2DLayeredLod(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 462
{ 
#line 468
} 
#endif
#line 470 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 471
tex2DLayeredLod(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 472
{ 
#line 479
} 
#endif
#line 482 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 483
tex3DLod(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 484
{ 
#line 490
} 
#endif
#line 492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 493
tex3DLod(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 494
{ 
#line 501
} 
#endif
#line 504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 505
texCubemapLod(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 506
{ 
#line 512
} 
#endif
#line 514 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 515
texCubemapLod(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 516
{ 
#line 523
} 
#endif
#line 527 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 528
texCubemapLayered(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 529
{ 
#line 535
} 
#endif
#line 537 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 538
texCubemapLayered(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 539
{ 
#line 546
} 
#endif
#line 550 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 551
texCubemapLayeredLod(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 552
{ 
#line 558
} 
#endif
#line 560 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 561
texCubemapLayeredLod(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 562
{ 
#line 569
} 
#endif
#line 573 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 574
texCubemapGrad(texture< T, 12, cudaReadModeElementType>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 575
{ 
#line 581
} 
#endif
#line 583 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 584
texCubemapGrad(texture< T, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 585
{ 
#line 592
} 
#endif
#line 596 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 597
texCubemapLayeredGrad(texture< T, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 598
{ 
#line 604
} 
#endif
#line 606 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 607
texCubemapLayeredGrad(texture< T, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 608
{ 
#line 615
} 
#endif
#line 619 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 620
tex1DGrad(texture< T, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 621
{ 
#line 627
} 
#endif
#line 629 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 630
tex1DGrad(texture< T, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 631
{ 
#line 638
} 
#endif
#line 642 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 643
tex2DGrad(texture< T, 2, cudaReadModeElementType>  t, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 644
{ 
#line 650
} 
#endif
#line 652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 653
tex2DGrad(texture< T, 2, cudaReadModeNormalizedFloat>  t, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 654
{ 
#line 661
} 
#endif
#line 664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 665
tex1DLayeredGrad(texture< T, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 666
{ 
#line 672
} 
#endif
#line 674 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 675
tex1DLayeredGrad(texture< T, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 676
{ 
#line 683
} 
#endif
#line 686 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 687
tex2DLayeredGrad(texture< T, 242, cudaReadModeElementType>  t, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 688
{ 
#line 694
} 
#endif
#line 696 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 697
tex2DLayeredGrad(texture< T, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 698
{ 
#line 705
} 
#endif
#line 708 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmet_ret< T> ::type 
#line 709
tex3DGrad(texture< T, 3, cudaReadModeElementType>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 710
{ 
#line 716
} 
#endif
#line 718 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_fetch_functions.h"
template< class T> static __forceinline typename __nv_tex_rmnf_ret< T> ::type 
#line 719
tex3DGrad(texture< T, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 720
{ 
#line 727
} 
#endif
#line 60 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> struct __nv_itex_trait { }; 
#line 61
template<> struct __nv_itex_trait< char>  { typedef void type; }; 
#line 62
template<> struct __nv_itex_trait< signed char>  { typedef void type; }; 
#line 63
template<> struct __nv_itex_trait< char1>  { typedef void type; }; 
#line 64
template<> struct __nv_itex_trait< char2>  { typedef void type; }; 
#line 65
template<> struct __nv_itex_trait< char4>  { typedef void type; }; 
#line 66
template<> struct __nv_itex_trait< unsigned char>  { typedef void type; }; 
#line 67
template<> struct __nv_itex_trait< uchar1>  { typedef void type; }; 
#line 68
template<> struct __nv_itex_trait< uchar2>  { typedef void type; }; 
#line 69
template<> struct __nv_itex_trait< uchar4>  { typedef void type; }; 
#line 70
template<> struct __nv_itex_trait< short>  { typedef void type; }; 
#line 71
template<> struct __nv_itex_trait< short1>  { typedef void type; }; 
#line 72
template<> struct __nv_itex_trait< short2>  { typedef void type; }; 
#line 73
template<> struct __nv_itex_trait< short4>  { typedef void type; }; 
#line 74
template<> struct __nv_itex_trait< unsigned short>  { typedef void type; }; 
#line 75
template<> struct __nv_itex_trait< ushort1>  { typedef void type; }; 
#line 76
template<> struct __nv_itex_trait< ushort2>  { typedef void type; }; 
#line 77
template<> struct __nv_itex_trait< ushort4>  { typedef void type; }; 
#line 78
template<> struct __nv_itex_trait< int>  { typedef void type; }; 
#line 79
template<> struct __nv_itex_trait< int1>  { typedef void type; }; 
#line 80
template<> struct __nv_itex_trait< int2>  { typedef void type; }; 
#line 81
template<> struct __nv_itex_trait< int4>  { typedef void type; }; 
#line 82
template<> struct __nv_itex_trait< unsigned>  { typedef void type; }; 
#line 83
template<> struct __nv_itex_trait< uint1>  { typedef void type; }; 
#line 84
template<> struct __nv_itex_trait< uint2>  { typedef void type; }; 
#line 85
template<> struct __nv_itex_trait< uint4>  { typedef void type; }; 
#line 87
template<> struct __nv_itex_trait< long>  { typedef void type; }; 
#line 88
template<> struct __nv_itex_trait< long1>  { typedef void type; }; 
#line 89
template<> struct __nv_itex_trait< long2>  { typedef void type; }; 
#line 90
template<> struct __nv_itex_trait< long4>  { typedef void type; }; 
#line 91
template<> struct __nv_itex_trait< unsigned long>  { typedef void type; }; 
#line 92
template<> struct __nv_itex_trait< ulong1>  { typedef void type; }; 
#line 93
template<> struct __nv_itex_trait< ulong2>  { typedef void type; }; 
#line 94
template<> struct __nv_itex_trait< ulong4>  { typedef void type; }; 
#line 96 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template<> struct __nv_itex_trait< float>  { typedef void type; }; 
#line 97
template<> struct __nv_itex_trait< float1>  { typedef void type; }; 
#line 98
template<> struct __nv_itex_trait< float2>  { typedef void type; }; 
#line 99
template<> struct __nv_itex_trait< float4>  { typedef void type; }; 
#line 103
template< class T> static typename __nv_itex_trait< T> ::type 
#line 104
tex1Dfetch(T *ptr, ::cudaTextureObject_t obj, int x) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;::exit(___);}
#if 0
#line 105
{ 
#line 109
} 
#endif
#line 111 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 112
tex1Dfetch(::cudaTextureObject_t texObject, int x) {int volatile ___ = 1;(void)texObject;(void)x;::exit(___);}
#if 0
#line 113
{ 
#line 119
} 
#endif
#line 121 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 122
tex1D(T *ptr, ::cudaTextureObject_t obj, float x) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;::exit(___);}
#if 0
#line 123
{ 
#line 127
} 
#endif
#line 130 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 131
tex1D(::cudaTextureObject_t texObject, float x) {int volatile ___ = 1;(void)texObject;(void)x;::exit(___);}
#if 0
#line 132
{ 
#line 138
} 
#endif
#line 141 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 142
tex2D(T *ptr, ::cudaTextureObject_t obj, float x, float y) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;::exit(___);}
#if 0
#line 143
{ 
#line 147
} 
#endif
#line 149 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 150
tex2D(::cudaTextureObject_t texObject, float x, float y) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;::exit(___);}
#if 0
#line 151
{ 
#line 157
} 
#endif
#line 159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 160
tex3D(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 161
{ 
#line 165
} 
#endif
#line 167 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 168
tex3D(::cudaTextureObject_t texObject, float x, float y, float z) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 169
{ 
#line 175
} 
#endif
#line 177 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 178
tex1DLayered(T *ptr, ::cudaTextureObject_t obj, float x, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;::exit(___);}
#if 0
#line 179
{ 
#line 183
} 
#endif
#line 185 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 186
tex1DLayered(::cudaTextureObject_t texObject, float x, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;::exit(___);}
#if 0
#line 187
{ 
#line 193
} 
#endif
#line 195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 196
tex2DLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 197
{ 
#line 201
} 
#endif
#line 203 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 204
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;::exit(___);}
#if 0
#line 205
{ 
#line 211
} 
#endif
#line 214 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 215
texCubemap(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 216
{ 
#line 220
} 
#endif
#line 223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 224
texCubemap(::cudaTextureObject_t texObject, float x, float y, float z) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;::exit(___);}
#if 0
#line 225
{ 
#line 231
} 
#endif
#line 234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 235
texCubemapLayered(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 236
{ 
#line 240
} 
#endif
#line 242 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 243
texCubemapLayered(::cudaTextureObject_t texObject, float x, float y, float z, int layer) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;::exit(___);}
#if 0
#line 244
{ 
#line 250
} 
#endif
#line 252 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 253
tex2Dgather(T *ptr, ::cudaTextureObject_t obj, float x, float y, int comp = 0) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 254
{ 
#line 258
} 
#endif
#line 260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 261
tex2Dgather(::cudaTextureObject_t to, float x, float y, int comp = 0) {int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;::exit(___);}
#if 0
#line 262
{ 
#line 268
} 
#endif
#line 272 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 273
tex1DLod(T *ptr, ::cudaTextureObject_t obj, float x, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)level;::exit(___);}
#if 0
#line 274
{ 
#line 278
} 
#endif
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 281
tex1DLod(::cudaTextureObject_t texObject, float x, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)level;::exit(___);}
#if 0
#line 282
{ 
#line 288
} 
#endif
#line 291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 292
tex2DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 293
{ 
#line 297
} 
#endif
#line 299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 300
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;::exit(___);}
#if 0
#line 301
{ 
#line 307
} 
#endif
#line 310 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 311
tex3DLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 312
{ 
#line 316
} 
#endif
#line 318 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 319
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 320
{ 
#line 326
} 
#endif
#line 329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 330
tex1DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 331
{ 
#line 335
} 
#endif
#line 337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 338
tex1DLayeredLod(::cudaTextureObject_t texObject, float x, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;::exit(___);}
#if 0
#line 339
{ 
#line 345
} 
#endif
#line 348 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 349
tex2DLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 350
{ 
#line 354
} 
#endif
#line 356 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 357
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;::exit(___);}
#if 0
#line 358
{ 
#line 364
} 
#endif
#line 367 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 368
texCubemapLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 369
{ 
#line 373
} 
#endif
#line 375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 376
texCubemapLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;::exit(___);}
#if 0
#line 377
{ 
#line 383
} 
#endif
#line 386 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 387
texCubemapGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 388
{ 
#line 392
} 
#endif
#line 394 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 395
texCubemapGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 396
{ 
#line 402
} 
#endif
#line 404 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 405
texCubemapLayeredLod(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 406
{ 
#line 410
} 
#endif
#line 412 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 413
texCubemapLayeredLod(::cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;::exit(___);}
#if 0
#line 414
{ 
#line 420
} 
#endif
#line 422 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 423
tex1DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 424
{ 
#line 428
} 
#endif
#line 430 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 431
tex1DGrad(::cudaTextureObject_t texObject, float x, float dPdx, float dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 432
{ 
#line 438
} 
#endif
#line 441 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 442
tex2DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 443
{ 
#line 448
} 
#endif
#line 450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 451
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 452
{ 
#line 458
} 
#endif
#line 461 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 462
tex3DGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 463
{ 
#line 467
} 
#endif
#line 469 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 470
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 471
{ 
#line 477
} 
#endif
#line 480 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 481
tex1DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 482
{ 
#line 486
} 
#endif
#line 488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 489
tex1DLayeredGrad(::cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 490
{ 
#line 496
} 
#endif
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 500
tex2DLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 501
{ 
#line 505
} 
#endif
#line 507 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 508
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 509
{ 
#line 515
} 
#endif
#line 518 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static typename __nv_itex_trait< T> ::type 
#line 519
texCubemapLayeredGrad(T *ptr, ::cudaTextureObject_t obj, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 520
{ 
#line 524
} 
#endif
#line 526 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\texture_indirect_functions.h"
template< class T> static T 
#line 527
texCubemapLayeredGrad(::cudaTextureObject_t texObject, float x, float y, float z, int layer, ::float4 dPdx, ::float4 dPdy) {int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)dPdx;(void)dPdy;::exit(___);}
#if 0
#line 528
{ 
#line 534
} 
#endif
#line 59 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> struct __nv_isurf_trait { }; 
#line 60
template<> struct __nv_isurf_trait< char>  { typedef void type; }; 
#line 61
template<> struct __nv_isurf_trait< signed char>  { typedef void type; }; 
#line 62
template<> struct __nv_isurf_trait< char1>  { typedef void type; }; 
#line 63
template<> struct __nv_isurf_trait< unsigned char>  { typedef void type; }; 
#line 64
template<> struct __nv_isurf_trait< uchar1>  { typedef void type; }; 
#line 65
template<> struct __nv_isurf_trait< short>  { typedef void type; }; 
#line 66
template<> struct __nv_isurf_trait< short1>  { typedef void type; }; 
#line 67
template<> struct __nv_isurf_trait< unsigned short>  { typedef void type; }; 
#line 68
template<> struct __nv_isurf_trait< ushort1>  { typedef void type; }; 
#line 69
template<> struct __nv_isurf_trait< int>  { typedef void type; }; 
#line 70
template<> struct __nv_isurf_trait< int1>  { typedef void type; }; 
#line 71
template<> struct __nv_isurf_trait< unsigned>  { typedef void type; }; 
#line 72
template<> struct __nv_isurf_trait< uint1>  { typedef void type; }; 
#line 73
template<> struct __nv_isurf_trait< __int64>  { typedef void type; }; 
#line 74
template<> struct __nv_isurf_trait< longlong1>  { typedef void type; }; 
#line 75
template<> struct __nv_isurf_trait< unsigned __int64>  { typedef void type; }; 
#line 76
template<> struct __nv_isurf_trait< ulonglong1>  { typedef void type; }; 
#line 77
template<> struct __nv_isurf_trait< float>  { typedef void type; }; 
#line 78
template<> struct __nv_isurf_trait< float1>  { typedef void type; }; 
#line 80
template<> struct __nv_isurf_trait< char2>  { typedef void type; }; 
#line 81
template<> struct __nv_isurf_trait< uchar2>  { typedef void type; }; 
#line 82
template<> struct __nv_isurf_trait< short2>  { typedef void type; }; 
#line 83
template<> struct __nv_isurf_trait< ushort2>  { typedef void type; }; 
#line 84
template<> struct __nv_isurf_trait< int2>  { typedef void type; }; 
#line 85
template<> struct __nv_isurf_trait< uint2>  { typedef void type; }; 
#line 86
template<> struct __nv_isurf_trait< longlong2>  { typedef void type; }; 
#line 87
template<> struct __nv_isurf_trait< ulonglong2>  { typedef void type; }; 
#line 88
template<> struct __nv_isurf_trait< float2>  { typedef void type; }; 
#line 90
template<> struct __nv_isurf_trait< char4>  { typedef void type; }; 
#line 91
template<> struct __nv_isurf_trait< uchar4>  { typedef void type; }; 
#line 92
template<> struct __nv_isurf_trait< short4>  { typedef void type; }; 
#line 93
template<> struct __nv_isurf_trait< ushort4>  { typedef void type; }; 
#line 94
template<> struct __nv_isurf_trait< int4>  { typedef void type; }; 
#line 95
template<> struct __nv_isurf_trait< uint4>  { typedef void type; }; 
#line 96
template<> struct __nv_isurf_trait< float4>  { typedef void type; }; 
#line 99
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 100
surf1Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)mode;::exit(___);}
#if 0
#line 101
{ 
#line 105
} 
#endif
#line 107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 108
surf1Dread(::cudaSurfaceObject_t surfObject, int x, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;::exit(___);}
#if 0
#line 109
{ 
#line 115
} 
#endif
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 118
surf2Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 119
{ 
#line 123
} 
#endif
#line 125 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 126
surf2Dread(::cudaSurfaceObject_t surfObject, int x, int y, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;::exit(___);}
#if 0
#line 127
{ 
#line 133
} 
#endif
#line 136 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 137
surf3Dread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 138
{ 
#line 142
} 
#endif
#line 144 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 145
surf3Dread(::cudaSurfaceObject_t surfObject, int x, int y, int z, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;::exit(___);}
#if 0
#line 146
{ 
#line 152
} 
#endif
#line 154 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 155
surf1DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 156
{ 
#line 160
} 
#endif
#line 162 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 163
surf1DLayeredread(::cudaSurfaceObject_t surfObject, int x, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;::exit(___);}
#if 0
#line 164
{ 
#line 170
} 
#endif
#line 172 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 173
surf2DLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 174
{ 
#line 178
} 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 181
surf2DLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;::exit(___);}
#if 0
#line 182
{ 
#line 188
} 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 191
surfCubemapread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 192
{ 
#line 196
} 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 199
surfCubemapread(::cudaSurfaceObject_t surfObject, int x, int y, int face, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;::exit(___);}
#if 0
#line 200
{ 
#line 206
} 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 209
surfCubemapLayeredread(T *ptr, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)ptr;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;::exit(___);}
#if 0
#line 210
{ 
#line 214
} 
#endif
#line 216 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static T 
#line 217
surfCubemapLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layerface, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;::exit(___);}
#if 0
#line 218
{ 
#line 224
} 
#endif
#line 226 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 227
surf1Dwrite(T val, ::cudaSurfaceObject_t obj, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)mode;::exit(___);}
#if 0
#line 228
{ 
#line 232
} 
#endif
#line 234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 235
surf2Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)mode;::exit(___);}
#if 0
#line 236
{ 
#line 240
} 
#endif
#line 242 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 243
surf3Dwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)z;(void)mode;::exit(___);}
#if 0
#line 244
{ 
#line 248
} 
#endif
#line 250 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 251
surf1DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)layer;(void)mode;::exit(___);}
#if 0
#line 252
{ 
#line 256
} 
#endif
#line 258 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 259
surf2DLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layer;(void)mode;::exit(___);}
#if 0
#line 260
{ 
#line 264
} 
#endif
#line 266 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 267
surfCubemapwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)face;(void)mode;::exit(___);}
#if 0
#line 268
{ 
#line 272
} 
#endif
#line 274 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\surface_indirect_functions.h"
template< class T> static typename __nv_isurf_trait< T> ::type 
#line 275
surfCubemapLayeredwrite(T val, ::cudaSurfaceObject_t obj, int x, int y, int layerface, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) {int volatile ___ = 1;(void)val;(void)obj;(void)x;(void)y;(void)layerface;(void)mode;::exit(___);}
#if 0
#line 276
{ 
#line 280
} 
#endif
#line 3296 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\crt/device_functions.h"
extern "C" unsigned __stdcall __cudaPushCallConfiguration(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, CUstream_st * stream = 0); 
#line 68 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_launch_parameters.h"
extern "C" {
#line 71 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\device_launch_parameters.h"
extern const uint3 __device_builtin_variable_threadIdx; 
#line 72
extern const uint3 __device_builtin_variable_blockIdx; 
#line 73
extern const dim3 __device_builtin_variable_blockDim; 
#line 74
extern const dim3 __device_builtin_variable_gridDim; 
#line 75
extern const int __device_builtin_variable_warpSize; 
#line 80
}
#line 199 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 200
cudaLaunchKernel(const T *
#line 201
func, ::dim3 
#line 202
gridDim, ::dim3 
#line 203
blockDim, void **
#line 204
args, ::size_t 
#line 205
sharedMem = 0, ::cudaStream_t 
#line 206
stream = 0) 
#line 208
{ 
#line 209
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 210
} 
#line 261
template< class T> static __inline ::cudaError_t 
#line 262
cudaLaunchCooperativeKernel(const T *
#line 263
func, ::dim3 
#line 264
gridDim, ::dim3 
#line 265
blockDim, void **
#line 266
args, ::size_t 
#line 267
sharedMem = 0, ::cudaStream_t 
#line 268
stream = 0) 
#line 270
{ 
#line 271
return ::cudaLaunchCooperativeKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 272
} 
#line 305
static __inline cudaError_t cudaEventCreate(cudaEvent_t *
#line 306
event, unsigned 
#line 307
flags) 
#line 309
{ 
#line 310
return ::cudaEventCreateWithFlags(event, flags); 
#line 311
} 
#line 370
static __inline cudaError_t cudaMallocHost(void **
#line 371
ptr, size_t 
#line 372
size, unsigned 
#line 373
flags) 
#line 375
{ 
#line 376
return ::cudaHostAlloc(ptr, size, flags); 
#line 377
} 
#line 379
template< class T> static __inline ::cudaError_t 
#line 380
cudaHostAlloc(T **
#line 381
ptr, ::size_t 
#line 382
size, unsigned 
#line 383
flags) 
#line 385
{ 
#line 386
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
#line 387
} 
#line 389
template< class T> static __inline ::cudaError_t 
#line 390
cudaHostGetDevicePointer(T **
#line 391
pDevice, void *
#line 392
pHost, unsigned 
#line 393
flags) 
#line 395
{ 
#line 396
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
#line 397
} 
#line 499
template< class T> static __inline ::cudaError_t 
#line 500
cudaMallocManaged(T **
#line 501
devPtr, ::size_t 
#line 502
size, unsigned 
#line 503
flags = 1) 
#line 505
{ 
#line 506
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
#line 507
} 
#line 589
template< class T> static __inline ::cudaError_t 
#line 590
cudaStreamAttachMemAsync(::cudaStream_t 
#line 591
stream, T *
#line 592
devPtr, ::size_t 
#line 593
length = 0, unsigned 
#line 594
flags = 4) 
#line 596
{ 
#line 597
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
#line 598
} 
#line 600
template< class T> __inline ::cudaError_t 
#line 601
cudaMalloc(T **
#line 602
devPtr, ::size_t 
#line 603
size) 
#line 605
{ 
#line 606
return ::cudaMalloc((void **)((void *)devPtr), size); 
#line 607
} 
#line 609
template< class T> static __inline ::cudaError_t 
#line 610
cudaMallocHost(T **
#line 611
ptr, ::size_t 
#line 612
size, unsigned 
#line 613
flags = 0) 
#line 615
{ 
#line 616
return cudaMallocHost((void **)((void *)ptr), size, flags); 
#line 617
} 
#line 619
template< class T> static __inline ::cudaError_t 
#line 620
cudaMallocPitch(T **
#line 621
devPtr, ::size_t *
#line 622
pitch, ::size_t 
#line 623
width, ::size_t 
#line 624
height) 
#line 626
{ 
#line 627
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
#line 628
} 
#line 667
template< class T> static __inline ::cudaError_t 
#line 668
cudaMemcpyToSymbol(const T &
#line 669
symbol, const void *
#line 670
src, ::size_t 
#line 671
count, ::size_t 
#line 672
offset = 0, ::cudaMemcpyKind 
#line 673
kind = cudaMemcpyHostToDevice) 
#line 675
{ 
#line 676
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
#line 677
} 
#line 721
template< class T> static __inline ::cudaError_t 
#line 722
cudaMemcpyToSymbolAsync(const T &
#line 723
symbol, const void *
#line 724
src, ::size_t 
#line 725
count, ::size_t 
#line 726
offset = 0, ::cudaMemcpyKind 
#line 727
kind = cudaMemcpyHostToDevice, ::cudaStream_t 
#line 728
stream = 0) 
#line 730
{ 
#line 731
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
#line 732
} 
#line 769
template< class T> static __inline ::cudaError_t 
#line 770
cudaMemcpyFromSymbol(void *
#line 771
dst, const T &
#line 772
symbol, ::size_t 
#line 773
count, ::size_t 
#line 774
offset = 0, ::cudaMemcpyKind 
#line 775
kind = cudaMemcpyDeviceToHost) 
#line 777
{ 
#line 778
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
#line 779
} 
#line 823
template< class T> static __inline ::cudaError_t 
#line 824
cudaMemcpyFromSymbolAsync(void *
#line 825
dst, const T &
#line 826
symbol, ::size_t 
#line 827
count, ::size_t 
#line 828
offset = 0, ::cudaMemcpyKind 
#line 829
kind = cudaMemcpyDeviceToHost, ::cudaStream_t 
#line 830
stream = 0) 
#line 832
{ 
#line 833
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
#line 834
} 
#line 859
template< class T> static __inline ::cudaError_t 
#line 860
cudaGetSymbolAddress(void **
#line 861
devPtr, const T &
#line 862
symbol) 
#line 864
{ 
#line 865
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
#line 866
} 
#line 891
template< class T> static __inline ::cudaError_t 
#line 892
cudaGetSymbolSize(::size_t *
#line 893
size, const T &
#line 894
symbol) 
#line 896
{ 
#line 897
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
#line 898
} 
#line 935
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 936
cudaBindTexture(::size_t *
#line 937
offset, const texture< T, dim, readMode>  &
#line 938
tex, const void *
#line 939
devPtr, const ::cudaChannelFormatDesc &
#line 940
desc, ::size_t 
#line 941
size = 4294967295U) 
#line 943
{ 
#line 944
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
#line 945
} 
#line 981
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 982
cudaBindTexture(::size_t *
#line 983
offset, const texture< T, dim, readMode>  &
#line 984
tex, const void *
#line 985
devPtr, ::size_t 
#line 986
size = 4294967295U) 
#line 988
{ 
#line 989
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
#line 990
} 
#line 1038
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1039
cudaBindTexture2D(::size_t *
#line 1040
offset, const texture< T, dim, readMode>  &
#line 1041
tex, const void *
#line 1042
devPtr, const ::cudaChannelFormatDesc &
#line 1043
desc, ::size_t 
#line 1044
width, ::size_t 
#line 1045
height, ::size_t 
#line 1046
pitch) 
#line 1048
{ 
#line 1049
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
#line 1050
} 
#line 1097
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1098
cudaBindTexture2D(::size_t *
#line 1099
offset, const texture< T, dim, readMode>  &
#line 1100
tex, const void *
#line 1101
devPtr, ::size_t 
#line 1102
width, ::size_t 
#line 1103
height, ::size_t 
#line 1104
pitch) 
#line 1106
{ 
#line 1107
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
#line 1108
} 
#line 1140
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1141
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1142
tex, ::cudaArray_const_t 
#line 1143
array, const ::cudaChannelFormatDesc &
#line 1144
desc) 
#line 1146
{ 
#line 1147
return ::cudaBindTextureToArray(&tex, array, &desc); 
#line 1148
} 
#line 1179
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1180
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1181
tex, ::cudaArray_const_t 
#line 1182
array) 
#line 1184
{ 
#line 1185
::cudaChannelFormatDesc desc; 
#line 1186
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 1188
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
#line 1189
} 
#line 1221
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1222
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1223
tex, ::cudaMipmappedArray_const_t 
#line 1224
mipmappedArray, const ::cudaChannelFormatDesc &
#line 1225
desc) 
#line 1227
{ 
#line 1228
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
#line 1229
} 
#line 1260
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1261
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1262
tex, ::cudaMipmappedArray_const_t 
#line 1263
mipmappedArray) 
#line 1265
{ 
#line 1266
::cudaChannelFormatDesc desc; 
#line 1267
::cudaArray_t levelArray; 
#line 1268
::cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
#line 1270
if (err != (cudaSuccess)) { 
#line 1271
return err; 
#line 1272
}  
#line 1273
err = ::cudaGetChannelDesc(&desc, levelArray); 
#line 1275
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
#line 1276
} 
#line 1303
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1304
cudaUnbindTexture(const texture< T, dim, readMode>  &
#line 1305
tex) 
#line 1307
{ 
#line 1308
return ::cudaUnbindTexture(&tex); 
#line 1309
} 
#line 1339
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1340
cudaGetTextureAlignmentOffset(::size_t *
#line 1341
offset, const texture< T, dim, readMode>  &
#line 1342
tex) 
#line 1344
{ 
#line 1345
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
#line 1346
} 
#line 1391
template< class T> static __inline ::cudaError_t 
#line 1392
cudaFuncSetCacheConfig(T *
#line 1393
func, ::cudaFuncCache 
#line 1394
cacheConfig) 
#line 1396
{ 
#line 1397
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
#line 1398
} 
#line 1400
template< class T> static __inline ::cudaError_t 
#line 1401
cudaFuncSetSharedMemConfig(T *
#line 1402
func, ::cudaSharedMemConfig 
#line 1403
config) 
#line 1405
{ 
#line 1406
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
#line 1407
} 
#line 1436
template< class T> __inline ::cudaError_t 
#line 1437
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
#line 1438
numBlocks, T 
#line 1439
func, int 
#line 1440
blockSize, ::size_t 
#line 1441
dynamicSMemSize) 
#line 1442
{ 
#line 1443
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
#line 1444
} 
#line 1487
template< class T> __inline ::cudaError_t 
#line 1488
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
#line 1489
numBlocks, T 
#line 1490
func, int 
#line 1491
blockSize, ::size_t 
#line 1492
dynamicSMemSize, unsigned 
#line 1493
flags) 
#line 1494
{ 
#line 1495
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
#line 1496
} 
#line 1501
class __cudaOccupancyB2DHelper { 
#line 1502
size_t n; 
#line 1504
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
#line 1505
size_t operator()(int) 
#line 1506
{ 
#line 1507
return n; 
#line 1508
} 
#line 1509
}; 
#line 1556
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 1557
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
#line 1558
minGridSize, int *
#line 1559
blockSize, T 
#line 1560
func, UnaryFunction 
#line 1561
blockSizeToDynamicSMemSize, int 
#line 1562
blockSizeLimit = 0, unsigned 
#line 1563
flags = 0) 
#line 1564
{ 
#line 1565
::cudaError_t status; 
#line 1568
int device; 
#line 1569
::cudaFuncAttributes attr; 
#line 1572
int maxThreadsPerMultiProcessor; 
#line 1573
int warpSize; 
#line 1574
int devMaxThreadsPerBlock; 
#line 1575
int multiProcessorCount; 
#line 1576
int funcMaxThreadsPerBlock; 
#line 1577
int occupancyLimit; 
#line 1578
int granularity; 
#line 1581
int maxBlockSize = 0; 
#line 1582
int numBlocks = 0; 
#line 1583
int maxOccupancy = 0; 
#line 1586
int blockSizeToTryAligned; 
#line 1587
int blockSizeToTry; 
#line 1588
int blockSizeLimitAligned; 
#line 1589
int occupancyInBlocks; 
#line 1590
int occupancyInThreads; 
#line 1591
::size_t dynamicSMemSize; 
#line 1597
if (((!minGridSize) || (!blockSize)) || (!func)) { 
#line 1598
return cudaErrorInvalidValue; 
#line 1599
}  
#line 1605
status = ::cudaGetDevice(&device); 
#line 1606
if (status != (cudaSuccess)) { 
#line 1607
return status; 
#line 1608
}  
#line 1610
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
#line 1614
if (status != (cudaSuccess)) { 
#line 1615
return status; 
#line 1616
}  
#line 1618
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
#line 1622
if (status != (cudaSuccess)) { 
#line 1623
return status; 
#line 1624
}  
#line 1626
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
#line 1630
if (status != (cudaSuccess)) { 
#line 1631
return status; 
#line 1632
}  
#line 1634
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
#line 1638
if (status != (cudaSuccess)) { 
#line 1639
return status; 
#line 1640
}  
#line 1642
status = cudaFuncGetAttributes(&attr, func); 
#line 1643
if (status != (cudaSuccess)) { 
#line 1644
return status; 
#line 1645
}  
#line 1647
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
#line 1653
occupancyLimit = maxThreadsPerMultiProcessor; 
#line 1654
granularity = warpSize; 
#line 1656
if (blockSizeLimit == 0) { 
#line 1657
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1658
}  
#line 1660
if (devMaxThreadsPerBlock < blockSizeLimit) { 
#line 1661
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1662
}  
#line 1664
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
#line 1665
blockSizeLimit = funcMaxThreadsPerBlock; 
#line 1666
}  
#line 1668
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
#line 1670
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
#line 1674
if (blockSizeLimit < blockSizeToTryAligned) { 
#line 1675
blockSizeToTry = blockSizeLimit; 
#line 1676
} else { 
#line 1677
blockSizeToTry = blockSizeToTryAligned; 
#line 1678
}  
#line 1680
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
#line 1682
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
#line 1689
if (status != (cudaSuccess)) { 
#line 1690
return status; 
#line 1691
}  
#line 1693
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
#line 1695
if (occupancyInThreads > maxOccupancy) { 
#line 1696
maxBlockSize = blockSizeToTry; 
#line 1697
numBlocks = occupancyInBlocks; 
#line 1698
maxOccupancy = occupancyInThreads; 
#line 1699
}  
#line 1703
if (occupancyLimit == maxOccupancy) { 
#line 1704
break; 
#line 1705
}  
#line 1706
}  
#line 1714
(*minGridSize) = (numBlocks * multiProcessorCount); 
#line 1715
(*blockSize) = maxBlockSize; 
#line 1717
return status; 
#line 1718
} 
#line 1751
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 1752
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
#line 1753
minGridSize, int *
#line 1754
blockSize, T 
#line 1755
func, UnaryFunction 
#line 1756
blockSizeToDynamicSMemSize, int 
#line 1757
blockSizeLimit = 0) 
#line 1758
{ 
#line 1759
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
#line 1760
} 
#line 1796
template< class T> static __inline ::cudaError_t 
#line 1797
cudaOccupancyMaxPotentialBlockSize(int *
#line 1798
minGridSize, int *
#line 1799
blockSize, T 
#line 1800
func, ::size_t 
#line 1801
dynamicSMemSize = 0, int 
#line 1802
blockSizeLimit = 0) 
#line 1803
{ 
#line 1804
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
#line 1805
} 
#line 1855
template< class T> static __inline ::cudaError_t 
#line 1856
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
#line 1857
minGridSize, int *
#line 1858
blockSize, T 
#line 1859
func, ::size_t 
#line 1860
dynamicSMemSize = 0, int 
#line 1861
blockSizeLimit = 0, unsigned 
#line 1862
flags = 0) 
#line 1863
{ 
#line 1864
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
#line 1865
} 
#line 1896
template< class T> __inline ::cudaError_t 
#line 1897
cudaFuncGetAttributes(::cudaFuncAttributes *
#line 1898
attr, T *
#line 1899
entry) 
#line 1901
{ 
#line 1902
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
#line 1903
} 
#line 1941
template< class T> static __inline ::cudaError_t 
#line 1942
cudaFuncSetAttribute(T *
#line 1943
entry, ::cudaFuncAttribute 
#line 1944
attr, int 
#line 1945
value) 
#line 1947
{ 
#line 1948
return ::cudaFuncSetAttribute((const void *)entry, attr, value); 
#line 1949
} 
#line 1973
template< class T, int dim> 
#line 1974
__declspec(deprecated) static __inline ::cudaError_t cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1975
surf, ::cudaArray_const_t 
#line 1976
array, const ::cudaChannelFormatDesc &
#line 1977
desc) 
#line 1979
{ 
#line 1980
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
#line 1981
} 
#line 2004
template< class T, int dim> 
#line 2005
__declspec(deprecated) static __inline ::cudaError_t cudaBindSurfaceToArray(const surface< T, dim>  &
#line 2006
surf, ::cudaArray_const_t 
#line 2007
array) 
#line 2009
{ 
#line 2010
::cudaChannelFormatDesc desc; 
#line 2011
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 2013
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
#line 2014
} 
#line 2028 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_runtime.h"
#pragma warning(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 68 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_printf_options() 
#line 86
{ 
#line 87
static unsigned __int64 _OptionsStorage; 
#line 88
return &_OptionsStorage; 
#line 89
} 
#line 95
__declspec(noinline) __inline unsigned __int64 *__cdecl __local_stdio_scanf_options() 
#line 96
{ 
#line 97
static unsigned __int64 _OptionsStorage; 
#line 98
return &_OptionsStorage; 
#line 99
} 
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_stdio_config.h"
}__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 28
typedef 
#line 25
struct _iobuf { 
#line 27
void *_Placeholder; 
#line 28
} FILE; 
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) FILE *__cdecl __acrt_iob_func(unsigned _Ix); 
#line 48
__declspec(dllimport) wint_t __cdecl fgetwc(FILE * _Stream); 
#line 53
__declspec(dllimport) wint_t __cdecl _fgetwchar(); 
#line 56
__declspec(dllimport) wint_t __cdecl fputwc(__wchar_t _Character, FILE * _Stream); 
#line 61
__declspec(dllimport) wint_t __cdecl _fputwchar(__wchar_t _Character); 
#line 66
__declspec(dllimport) wint_t __cdecl getwc(FILE * _Stream); 
#line 71
__declspec(dllimport) wint_t __cdecl getwchar(); 
#line 76
__declspec(dllimport) __wchar_t *__cdecl fgetws(__wchar_t * _Buffer, int _BufferCount, FILE * _Stream); 
#line 83
__declspec(dllimport) int __cdecl fputws(const __wchar_t * _Buffer, FILE * _Stream); 
#line 90
__declspec(dllimport) __wchar_t *__cdecl _getws_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 95
extern "C++" {template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _getws_s ( _Buffer, _Size ); }}
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) wint_t __cdecl putwc(__wchar_t _Character, FILE * _Stream); 
#line 108
__declspec(dllimport) wint_t __cdecl putwchar(__wchar_t _Character); 
#line 113
__declspec(dllimport) int __cdecl _putws(const __wchar_t * _Buffer); 
#line 118
__declspec(dllimport) wint_t __cdecl ungetwc(wint_t _Character, FILE * _Stream); 
#line 124
__declspec(dllimport) FILE *__cdecl _wfdopen(int _FileHandle, const __wchar_t * _Mode); 
#line 130
__declspec(dllimport) FILE *__cdecl _wfopen(const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 136
__declspec(dllimport) errno_t __cdecl _wfopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode); 
#line 144
__declspec(dllimport) FILE *__cdecl _wfreopen(const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 151
__declspec(dllimport) errno_t __cdecl _wfreopen_s(FILE ** _Stream, const __wchar_t * _FileName, const __wchar_t * _Mode, FILE * _OldStream); 
#line 159
__declspec(dllimport) FILE *__cdecl _wfsopen(const __wchar_t * _FileName, const __wchar_t * _Mode, int _ShFlag); 
#line 165
__declspec(dllimport) void __cdecl _wperror(const __wchar_t * _ErrorMessage); 
#line 172
__declspec(dllimport) FILE *__cdecl _wpopen(const __wchar_t * _Command, const __wchar_t * _Mode); 
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl _wremove(const __wchar_t * _FileName); 
#line 187
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wtempnam(const __wchar_t * _Directory, const __wchar_t * _FilePrefix); 
#line 196
__declspec(dllimport) errno_t __cdecl _wtmpnam_s(__wchar_t * _Buffer, size_t _BufferCount); 
#line 201
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }}
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) __wchar_t *__cdecl _wtmpnam(__wchar_t * _Buffer); 
#line 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) wint_t __cdecl _fgetwc_nolock(FILE * _Stream); 
#line 226
__declspec(dllimport) wint_t __cdecl _fputwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 232
__declspec(dllimport) wint_t __cdecl _getwc_nolock(FILE * _Stream); 
#line 237
__declspec(dllimport) wint_t __cdecl _putwc_nolock(__wchar_t _Character, FILE * _Stream); 
#line 243
__declspec(dllimport) wint_t __cdecl _ungetwc_nolock(wint_t _Character, FILE * _Stream); 
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfwprintf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 278
__declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 287
__declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 296
__inline int __cdecl _vfwprintf_l(FILE *const 
#line 297
_Stream, const __wchar_t *const 
#line 298
_Format, const _locale_t 
#line 299
_Locale, va_list 
#line 300
_ArgList) 
#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 306
return __stdio_common_vfwprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 307
} 
#line 311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf(FILE *const 
#line 312
_Stream, const __wchar_t *const 
#line 313
_Format, va_list 
#line 314
_ArgList) 
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 320
return _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 321
} 
#line 325 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_s_l(FILE *const 
#line 326
_Stream, const __wchar_t *const 
#line 327
_Format, const _locale_t 
#line 328
_Locale, va_list 
#line 329
_ArgList) 
#line 334 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 335
return __stdio_common_vfwprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 336
} 
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwprintf_s(FILE *const 
#line 343
_Stream, const __wchar_t *const 
#line 344
_Format, va_list 
#line 345
_ArgList) 
#line 350 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 351
return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 352
} 
#line 358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p_l(FILE *const 
#line 359
_Stream, const __wchar_t *const 
#line 360
_Format, const _locale_t 
#line 361
_Locale, va_list 
#line 362
_ArgList) 
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 368
return __stdio_common_vfwprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 369
} 
#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwprintf_p(FILE *const 
#line 374
_Stream, const __wchar_t *const 
#line 375
_Format, va_list 
#line 376
_ArgList) 
#line 381 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 382
return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 383
} 
#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_l(const __wchar_t *const 
#line 388
_Format, const _locale_t 
#line 389
_Locale, va_list 
#line 390
_ArgList) 
#line 395 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 396
return _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 397
} 
#line 401 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf(const __wchar_t *const 
#line 402
_Format, va_list 
#line 403
_ArgList) 
#line 408 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 409
return _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 410
} 
#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_s_l(const __wchar_t *const 
#line 415
_Format, const _locale_t 
#line 416
_Locale, va_list 
#line 417
_ArgList) 
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 423
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 424
} 
#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwprintf_s(const __wchar_t *const 
#line 431
_Format, va_list 
#line 432
_ArgList) 
#line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 438
return _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 439
} 
#line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p_l(const __wchar_t *const 
#line 446
_Format, const _locale_t 
#line 447
_Locale, va_list 
#line 448
_ArgList) 
#line 453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 454
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 455
} 
#line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwprintf_p(const __wchar_t *const 
#line 460
_Format, va_list 
#line 461
_ArgList) 
#line 466 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 467
return _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 468
} 
#line 472 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_l(FILE *const 
#line 473
_Stream, const __wchar_t *const 
#line 474
_Format, const _locale_t 
#line 475
_Locale, ...) 
#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 481
int _Result; 
#line 482
va_list _ArgList; 
#line 483
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 484
_Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 485
(void)(_ArgList = ((va_list)0)); 
#line 486
return _Result; 
#line 487
} 
#line 491 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf(FILE *const 
#line 492
_Stream, const __wchar_t *const 
#line 493
_Format, ...) 
#line 498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 499
int _Result; 
#line 500
va_list _ArgList; 
#line 501
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 502
_Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList); 
#line 503
(void)(_ArgList = ((va_list)0)); 
#line 504
return _Result; 
#line 505
} 
#line 509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_s_l(FILE *const 
#line 510
_Stream, const __wchar_t *const 
#line 511
_Format, const _locale_t 
#line 512
_Locale, ...) 
#line 517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 518
int _Result; 
#line 519
va_list _ArgList; 
#line 520
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 521
_Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 522
(void)(_ArgList = ((va_list)0)); 
#line 523
return _Result; 
#line 524
} 
#line 530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwprintf_s(FILE *const 
#line 531
_Stream, const __wchar_t *const 
#line 532
_Format, ...) 
#line 537 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 538
int _Result; 
#line 539
va_list _ArgList; 
#line 540
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 541
_Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 542
(void)(_ArgList = ((va_list)0)); 
#line 543
return _Result; 
#line 544
} 
#line 550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p_l(FILE *const 
#line 551
_Stream, const __wchar_t *const 
#line 552
_Format, const _locale_t 
#line 553
_Locale, ...) 
#line 558 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 559
int _Result; 
#line 560
va_list _ArgList; 
#line 561
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 562
_Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 563
(void)(_ArgList = ((va_list)0)); 
#line 564
return _Result; 
#line 565
} 
#line 569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwprintf_p(FILE *const 
#line 570
_Stream, const __wchar_t *const 
#line 571
_Format, ...) 
#line 576 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 577
int _Result; 
#line 578
va_list _ArgList; 
#line 579
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 580
_Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 581
(void)(_ArgList = ((va_list)0)); 
#line 582
return _Result; 
#line 583
} 
#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_l(const __wchar_t *const 
#line 588
_Format, const _locale_t 
#line 589
_Locale, ...) 
#line 594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 595
int _Result; 
#line 596
va_list _ArgList; 
#line 597
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 598
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 599
(void)(_ArgList = ((va_list)0)); 
#line 600
return _Result; 
#line 601
} 
#line 605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf(const __wchar_t *const 
#line 606
_Format, ...) 
#line 611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 612
int _Result; 
#line 613
va_list _ArgList; 
#line 614
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 615
_Result = _vfwprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 616
(void)(_ArgList = ((va_list)0)); 
#line 617
return _Result; 
#line 618
} 
#line 622 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_s_l(const __wchar_t *const 
#line 623
_Format, const _locale_t 
#line 624
_Locale, ...) 
#line 629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 630
int _Result; 
#line 631
va_list _ArgList; 
#line 632
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 633
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 634
(void)(_ArgList = ((va_list)0)); 
#line 635
return _Result; 
#line 636
} 
#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wprintf_s(const __wchar_t *const 
#line 643
_Format, ...) 
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 649
int _Result; 
#line 650
va_list _ArgList; 
#line 651
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 652
_Result = _vfwprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 653
(void)(_ArgList = ((va_list)0)); 
#line 654
return _Result; 
#line 655
} 
#line 661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p_l(const __wchar_t *const 
#line 662
_Format, const _locale_t 
#line 663
_Locale, ...) 
#line 668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 669
int _Result; 
#line 670
va_list _ArgList; 
#line 671
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 672
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 673
(void)(_ArgList = ((va_list)0)); 
#line 674
return _Result; 
#line 675
} 
#line 679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wprintf_p(const __wchar_t *const 
#line 680
_Format, ...) 
#line 685 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 686
int _Result; 
#line 687
va_list _ArgList; 
#line 688
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 689
_Result = _vfwprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 690
(void)(_ArgList = ((va_list)0)); 
#line 691
return _Result; 
#line 692
} 
#line 702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfwscanf(unsigned __int64 _Options, FILE * _Stream, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 711
__inline int __cdecl _vfwscanf_l(FILE *const 
#line 712
_Stream, const __wchar_t *const 
#line 713
_Format, const _locale_t 
#line 714
_Locale, va_list 
#line 715
_ArgList) 
#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 721
return __stdio_common_vfwscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 724
} 
#line 728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf(FILE *const 
#line 729
_Stream, const __wchar_t *const 
#line 730
_Format, va_list 
#line 731
_ArgList) 
#line 736 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 737
return _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 738
} 
#line 742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vfwscanf_s_l(FILE *const 
#line 743
_Stream, const __wchar_t *const 
#line 744
_Format, const _locale_t 
#line 745
_Locale, va_list 
#line 746
_ArgList) 
#line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 752
return __stdio_common_vfwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 755
} 
#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vfwscanf_s(FILE *const 
#line 762
_Stream, const __wchar_t *const 
#line 763
_Format, va_list 
#line 764
_ArgList) 
#line 769 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 770
return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 771
} 
#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_l(const __wchar_t *const 
#line 777
_Format, const _locale_t 
#line 778
_Locale, va_list 
#line 779
_ArgList) 
#line 784 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 785
return _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 786
} 
#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf(const __wchar_t *const 
#line 791
_Format, va_list 
#line 792
_ArgList) 
#line 797 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 798
return _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 799
} 
#line 803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vwscanf_s_l(const __wchar_t *const 
#line 804
_Format, const _locale_t 
#line 805
_Locale, va_list 
#line 806
_ArgList) 
#line 811 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 812
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 813
} 
#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vwscanf_s(const __wchar_t *const 
#line 820
_Format, va_list 
#line 821
_ArgList) 
#line 826 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 827
return _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 828
} 
#line 834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_l(FILE *const 
#line 835
_Stream, const __wchar_t *const 
#line 836
_Format, const _locale_t 
#line 837
_Locale, ...) 
#line 842 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 843
int _Result; 
#line 844
va_list _ArgList; 
#line 845
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 846
_Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 847
(void)(_ArgList = ((va_list)0)); 
#line 848
return _Result; 
#line 849
} 
#line 853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf(FILE *const 
#line 854
_Stream, const __wchar_t *const 
#line 855
_Format, ...) 
#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 861
int _Result; 
#line 862
va_list _ArgList; 
#line 863
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 864
_Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList); 
#line 865
(void)(_ArgList = ((va_list)0)); 
#line 866
return _Result; 
#line 867
} 
#line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _fwscanf_s_l(FILE *const 
#line 872
_Stream, const __wchar_t *const 
#line 873
_Format, const _locale_t 
#line 874
_Locale, ...) 
#line 879 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 880
int _Result; 
#line 881
va_list _ArgList; 
#line 882
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 883
_Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 884
(void)(_ArgList = ((va_list)0)); 
#line 885
return _Result; 
#line 886
} 
#line 892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl fwscanf_s(FILE *const 
#line 893
_Stream, const __wchar_t *const 
#line 894
_Format, ...) 
#line 899 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 900
int _Result; 
#line 901
va_list _ArgList; 
#line 902
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 903
_Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 904
(void)(_ArgList = ((va_list)0)); 
#line 905
return _Result; 
#line 906
} 
#line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_l(const __wchar_t *const 
#line 913
_Format, const _locale_t 
#line 914
_Locale, ...) 
#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 920
int _Result; 
#line 921
va_list _ArgList; 
#line 922
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 923
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 924
(void)(_ArgList = ((va_list)0)); 
#line 925
return _Result; 
#line 926
} 
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf(const __wchar_t *const 
#line 931
_Format, ...) 
#line 936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 937
int _Result; 
#line 938
va_list _ArgList; 
#line 939
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 940
_Result = _vfwscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 941
(void)(_ArgList = ((va_list)0)); 
#line 942
return _Result; 
#line 943
} 
#line 947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _wscanf_s_l(const __wchar_t *const 
#line 948
_Format, const _locale_t 
#line 949
_Locale, ...) 
#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 955
int _Result; 
#line 956
va_list _ArgList; 
#line 957
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 958
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 959
(void)(_ArgList = ((va_list)0)); 
#line 960
return _Result; 
#line 961
} 
#line 967 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl wscanf_s(const __wchar_t *const 
#line 968
_Format, ...) 
#line 973 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 974
int _Result; 
#line 975
va_list _ArgList; 
#line 976
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 977
_Result = _vfwscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 978
(void)(_ArgList = ((va_list)0)); 
#line 979
return _Result; 
#line 980
} 
#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vswprintf(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1014
__declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1025
__declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1037
__declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(unsigned __int64 _Options, __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1048
__inline int __cdecl _vsnwprintf_l(__wchar_t *const 
#line 1049
_Buffer, const size_t 
#line 1050
_BufferCount, const __wchar_t *const 
#line 1051
_Format, const _locale_t 
#line 1052
_Locale, va_list 
#line 1053
_ArgList) 
#line 1058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1059
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1063
return (_Result < 0) ? -1 : _Result; 
#line 1064
} 
#line 1067 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4793)
#line 1072
__inline int __cdecl _vsnwprintf_s_l(__wchar_t *const 
#line 1073
_Buffer, const size_t 
#line 1074
_BufferCount, const size_t 
#line 1075
_MaxCount, const __wchar_t *const 
#line 1076
_Format, const _locale_t 
#line 1077
_Locale, va_list 
#line 1078
_ArgList) 
#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1084
const int _Result = __stdio_common_vsnwprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1088
return (_Result < 0) ? -1 : _Result; 
#line 1089
} 
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwprintf_s(__wchar_t *const 
#line 1095
_Buffer, const size_t 
#line 1096
_BufferCount, const size_t 
#line 1097
_MaxCount, const __wchar_t *const 
#line 1098
_Format, va_list 
#line 1099
_ArgList) 
#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1105
return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1106
} 
#line 1109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, ...); __inline int __cdecl _vsnwprintf(__wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, va_list _Args); 
#line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1122
__inline int __cdecl _vsnwprintf(__wchar_t *
#line 1123
_Buffer, size_t 
#line 1124
_BufferCount, const __wchar_t *
#line 1125
_Format, va_list 
#line 1126
_ArgList) 
#line 1131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 1139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, va_list _ArgList ) throw ( ) { return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c_l(__wchar_t *const 
#line 1151
_Buffer, const size_t 
#line 1152
_BufferCount, const __wchar_t *const 
#line 1153
_Format, const _locale_t 
#line 1154
_Locale, va_list 
#line 1155
_ArgList) 
#line 1160 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1161
const int _Result = __stdio_common_vswprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1165
return (_Result < 0) ? -1 : _Result; 
#line 1166
} 
#line 1171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_c(__wchar_t *const 
#line 1172
_Buffer, const size_t 
#line 1173
_BufferCount, const __wchar_t *const 
#line 1174
_Format, va_list 
#line 1175
_ArgList) 
#line 1180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1181
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1182
} 
#line 1187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_l(__wchar_t *const 
#line 1188
_Buffer, const size_t 
#line 1189
_BufferCount, const __wchar_t *const 
#line 1190
_Format, const _locale_t 
#line 1191
_Locale, va_list 
#line 1192
_ArgList) 
#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
} 
#line 1207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __vswprintf_l(__wchar_t *const 
#line 1208
_Buffer, const __wchar_t *const 
#line 1209
_Format, const _locale_t 
#line 1210
_Locale, va_list 
#line 1211
_ArgList) 
#line 1216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1217
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1218
} 
#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf(__wchar_t *const 
#line 1224
_Buffer, const __wchar_t *const 
#line 1225
_Format, va_list 
#line 1226
_ArgList) 
#line 1231 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1232
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#line 1233
} 
#line 1238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf(__wchar_t *const 
#line 1239
_Buffer, const size_t 
#line 1240
_BufferCount, const __wchar_t *const 
#line 1241
_Format, va_list 
#line 1242
_ArgList) 
#line 1247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1248
return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1249
} 
#line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_s_l(__wchar_t *const 
#line 1255
_Buffer, const size_t 
#line 1256
_BufferCount, const __wchar_t *const 
#line 1257
_Format, const _locale_t 
#line 1258
_Locale, va_list 
#line 1259
_ArgList) 
#line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1265
const int _Result = __stdio_common_vswprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1269
return (_Result < 0) ? -1 : _Result; 
#line 1270
} 
#line 1276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswprintf_s(__wchar_t *const 
#line 1277
_Buffer, const size_t 
#line 1278
_BufferCount, const __wchar_t *const 
#line 1279
_Format, va_list 
#line 1280
_ArgList) 
#line 1285 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1286
return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1287
} 
#line 1292 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p_l(__wchar_t *const 
#line 1303
_Buffer, const size_t 
#line 1304
_BufferCount, const __wchar_t *const 
#line 1305
_Format, const _locale_t 
#line 1306
_Locale, va_list 
#line 1307
_ArgList) 
#line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1313
const int _Result = __stdio_common_vswprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1317
return (_Result < 0) ? -1 : _Result; 
#line 1318
} 
#line 1323 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswprintf_p(__wchar_t *const 
#line 1324
_Buffer, const size_t 
#line 1325
_BufferCount, const __wchar_t *const 
#line 1326
_Format, va_list 
#line 1327
_ArgList) 
#line 1332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1333
return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1334
} 
#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_l(const __wchar_t *const 
#line 1340
_Format, const _locale_t 
#line 1341
_Locale, va_list 
#line 1342
_ArgList) 
#line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1348
const int _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1352
return (_Result < 0) ? -1 : _Result; 
#line 1353
} 
#line 1358 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf(const __wchar_t *const 
#line 1359
_Format, va_list 
#line 1360
_ArgList) 
#line 1365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1366
return _vscwprintf_l(_Format, 0, _ArgList); 
#line 1367
} 
#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p_l(const __wchar_t *const 
#line 1373
_Format, const _locale_t 
#line 1374
_Locale, va_list 
#line 1375
_ArgList) 
#line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1381
const int _Result = __stdio_common_vswprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1385
return (_Result < 0) ? -1 : _Result; 
#line 1386
} 
#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vscwprintf_p(const __wchar_t *const 
#line 1392
_Format, va_list 
#line 1393
_ArgList) 
#line 1398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1399
return _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1400
} 
#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl __swprintf_l(__wchar_t *const 
#line 1406
_Buffer, const __wchar_t *const 
#line 1407
_Format, const _locale_t 
#line 1408
_Locale, ...) 
#line 1413 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1414
int _Result; 
#line 1415
va_list _ArgList; 
#line 1416
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1417
_Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 1418
(void)(_ArgList = ((va_list)0)); 
#line 1419
return _Result; 
#line 1420
} 
#line 1425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_l(__wchar_t *const 
#line 1426
_Buffer, const size_t 
#line 1427
_BufferCount, const __wchar_t *const 
#line 1428
_Format, const _locale_t 
#line 1429
_Locale, ...) 
#line 1434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1435
int _Result; 
#line 1436
va_list _ArgList; 
#line 1437
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1438
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1439
(void)(_ArgList = ((va_list)0)); 
#line 1440
return _Result; 
#line 1441
} 
#line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t *const 
#line 1447
_Buffer, const __wchar_t *const 
#line 1448
_Format, ...) 
#line 1453 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1454
int _Result; 
#line 1455
va_list _ArgList; 
#line 1456
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1457
_Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList); 
#line 1458
(void)(_ArgList = ((va_list)0)); 
#line 1459
return _Result; 
#line 1460
} 
#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf(__wchar_t *const 
#line 1466
_Buffer, const size_t 
#line 1467
_BufferCount, const __wchar_t *const 
#line 1468
_Format, ...) 
#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1474
int _Result; 
#line 1475
va_list _ArgList; 
#line 1476
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1477
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1478
(void)(_ArgList = ((va_list)0)); 
#line 1479
return _Result; 
#line 1480
} 
#line 1483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#line 1486
#pragma warning(disable:4793 4996)
#line 1488
__inline int __cdecl __swprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, ...); __inline int __cdecl __vswprintf_l(__wchar_t * _Buffer, const __wchar_t * _Format, _locale_t _Locale, va_list _Args); 
#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf(__wchar_t * _Buffer, const __wchar_t * _Format, ...); __inline int __cdecl _vswprintf(__wchar_t * _Buffer, const __wchar_t * _Format, va_list _Args); 
#line 1504 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1508
__inline int __cdecl _swprintf_s_l(__wchar_t *const 
#line 1509
_Buffer, const size_t 
#line 1510
_BufferCount, const __wchar_t *const 
#line 1511
_Format, const _locale_t 
#line 1512
_Locale, ...) 
#line 1517 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1518
int _Result; 
#line 1519
va_list _ArgList; 
#line 1520
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1521
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1522
(void)(_ArgList = ((va_list)0)); 
#line 1523
return _Result; 
#line 1524
} 
#line 1530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swprintf_s(__wchar_t *const 
#line 1531
_Buffer, const size_t 
#line 1532
_BufferCount, const __wchar_t *const 
#line 1533
_Format, ...) 
#line 1538 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1539
int _Result; 
#line 1540
va_list _ArgList; 
#line 1541
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1542
_Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1543
(void)(_ArgList = ((va_list)0)); 
#line 1544
return _Result; 
#line 1545
} 
#line 1550 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vswprintf_s ( _Buffer, _Size, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p_l(__wchar_t *const 
#line 1560
_Buffer, const size_t 
#line 1561
_BufferCount, const __wchar_t *const 
#line 1562
_Format, const _locale_t 
#line 1563
_Locale, ...) 
#line 1568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1569
int _Result; 
#line 1570
va_list _ArgList; 
#line 1571
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1572
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1573
(void)(_ArgList = ((va_list)0)); 
#line 1574
return _Result; 
#line 1575
} 
#line 1580 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_p(__wchar_t *const 
#line 1581
_Buffer, const size_t 
#line 1582
_BufferCount, const __wchar_t *const 
#line 1583
_Format, ...) 
#line 1588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1589
int _Result; 
#line 1590
va_list _ArgList; 
#line 1591
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1592
_Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1593
(void)(_ArgList = ((va_list)0)); 
#line 1594
return _Result; 
#line 1595
} 
#line 1600 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c_l(__wchar_t *const 
#line 1601
_Buffer, const size_t 
#line 1602
_BufferCount, const __wchar_t *const 
#line 1603
_Format, const _locale_t 
#line 1604
_Locale, ...) 
#line 1609 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1610
int _Result; 
#line 1611
va_list _ArgList; 
#line 1612
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1613
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1614
(void)(_ArgList = ((va_list)0)); 
#line 1615
return _Result; 
#line 1616
} 
#line 1621 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swprintf_c(__wchar_t *const 
#line 1622
_Buffer, const size_t 
#line 1623
_BufferCount, const __wchar_t *const 
#line 1624
_Format, ...) 
#line 1629 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1630
int _Result; 
#line 1631
va_list _ArgList; 
#line 1632
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1633
_Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1634
(void)(_ArgList = ((va_list)0)); 
#line 1635
return _Result; 
#line 1636
} 
#line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_l(__wchar_t *const 
#line 1642
_Buffer, const size_t 
#line 1643
_BufferCount, const __wchar_t *const 
#line 1644
_Format, const _locale_t 
#line 1645
_Locale, ...) 
#line 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1651
int _Result; 
#line 1652
va_list _ArgList; 
#line 1653
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1655
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 1660
(void)(_ArgList = ((va_list)0)); 
#line 1661
return _Result; 
#line 1662
} 
#line 1667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf(__wchar_t *
#line 1668
_Buffer, size_t 
#line 1669
_BufferCount, const __wchar_t *
#line 1670
_Format, ...) 
#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1676
int _Result; 
#line 1677
va_list _ArgList; 
#line 1678
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1680
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
#line 1685
(void)(_ArgList = ((va_list)0)); 
#line 1686
return _Result; 
#line 1687
} 
#line 1692 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s_l(__wchar_t *const 
#line 1693
_Buffer, const size_t 
#line 1694
_BufferCount, const size_t 
#line 1695
_MaxCount, const __wchar_t *const 
#line 1696
_Format, const _locale_t 
#line 1697
_Locale, ...) 
#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1703
int _Result; 
#line 1704
va_list _ArgList; 
#line 1705
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1706
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1707
(void)(_ArgList = ((va_list)0)); 
#line 1708
return _Result; 
#line 1709
} 
#line 1714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwprintf_s(__wchar_t *const 
#line 1715
_Buffer, const size_t 
#line 1716
_BufferCount, const size_t 
#line 1717
_MaxCount, const __wchar_t *const 
#line 1718
_Format, ...) 
#line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1724
int _Result; 
#line 1725
va_list _ArgList; 
#line 1726
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1727
_Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1728
(void)(_ArgList = ((va_list)0)); 
#line 1729
return _Result; 
#line 1730
} 
#line 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Buffer ) [ _Size ], size_t _BufferCount, wchar_t const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnwprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_l(const __wchar_t *const 
#line 1743
_Format, const _locale_t 
#line 1744
_Locale, ...) 
#line 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1750
int _Result; 
#line 1751
va_list _ArgList; 
#line 1752
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1753
_Result = _vscwprintf_l(_Format, _Locale, _ArgList); 
#line 1754
(void)(_ArgList = ((va_list)0)); 
#line 1755
return _Result; 
#line 1756
} 
#line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf(const __wchar_t *const 
#line 1762
_Format, ...) 
#line 1767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1768
int _Result; 
#line 1769
va_list _ArgList; 
#line 1770
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1771
_Result = _vscwprintf_l(_Format, 0, _ArgList); 
#line 1772
(void)(_ArgList = ((va_list)0)); 
#line 1773
return _Result; 
#line 1774
} 
#line 1779 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p_l(const __wchar_t *const 
#line 1780
_Format, const _locale_t 
#line 1781
_Locale, ...) 
#line 1786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1787
int _Result; 
#line 1788
va_list _ArgList; 
#line 1789
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1790
_Result = _vscwprintf_p_l(_Format, _Locale, _ArgList); 
#line 1791
(void)(_ArgList = ((va_list)0)); 
#line 1792
return _Result; 
#line 1793
} 
#line 1798 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _scwprintf_p(const __wchar_t *const 
#line 1799
_Format, ...) 
#line 1804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1805
int _Result; 
#line 1806
va_list _ArgList; 
#line 1807
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1808
_Result = _vscwprintf_p_l(_Format, 0, _ArgList); 
#line 1809
(void)(_ArgList = ((va_list)0)); 
#line 1810
return _Result; 
#line 1811
} 
#line 1816 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(push)
#pragma warning(disable: 4141 4412 4793 4996 6054)
#line 1822
extern "C++" 
#line 1821
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1822
swprintf(__wchar_t *const 
#line 1823
_Buffer, const __wchar_t *const 
#line 1824
_Format, ...) throw() 
#line 1826
{ 
#line 1827
int _Result; 
#line 1828
va_list _ArgList; 
#line 1829
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#pragma warning(suppress: 28719)
_Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1832
(void)(_ArgList = ((va_list)0)); 
#line 1833
return _Result; 
#line 1834
} 
#line 1837
extern "C++" 
#line 1836
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1837
vswprintf(__wchar_t *const 
#line 1838
_Buffer, const __wchar_t *const 
#line 1839
_Format, va_list 
#line 1840
_ArgList) throw() 
#line 1842
{ 
#pragma warning(suppress: 28719)
return vswprintf(_Buffer, 2147483647, _Format, _ArgList); 
#line 1845
} 
#line 1848
extern "C++" 
#line 1847
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int 
#line 1848
_swprintf_l(__wchar_t *const 
#line 1849
_Buffer, const __wchar_t *const 
#line 1850
_Format, const _locale_t 
#line 1851
_Locale, ...) throw() 
#line 1853
{ 
#line 1854
int _Result; 
#line 1855
va_list _ArgList; 
#line 1856
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1857
_Result = _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1858
(void)(_ArgList = ((va_list)0)); 
#line 1859
return _Result; 
#line 1860
} 
#line 1863
extern "C++" 
#line 1862
__declspec(deprecated("function has been changed to conform with the ISO C standard, adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) inline int __cdecl 
#line 1863
_vswprintf_l(__wchar_t *const 
#line 1864
_Buffer, const __wchar_t *const 
#line 1865
_Format, const _locale_t 
#line 1866
_Locale, va_list 
#line 1867
_ArgList) throw() 
#line 1869
{ 
#line 1870
return _vswprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1871
} 
#line 1875 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
#pragma warning(pop)
#line 1892 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vswscanf(unsigned __int64 _Options, const __wchar_t * _Buffer, size_t _BufferCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1903
__inline int __cdecl _vswscanf_l(const __wchar_t *const 
#line 1904
_Buffer, const __wchar_t *const 
#line 1905
_Format, const _locale_t 
#line 1906
_Locale, va_list 
#line 1907
_ArgList) 
#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1913
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1916
} 
#line 1921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf(const __wchar_t *
#line 1922
_Buffer, const __wchar_t *
#line 1923
_Format, va_list 
#line 1924
_ArgList) 
#line 1929 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1930
return _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 1931
} 
#line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vswscanf_s_l(const __wchar_t *const 
#line 1937
_Buffer, const __wchar_t *const 
#line 1938
_Format, const _locale_t 
#line 1939
_Locale, va_list 
#line 1940
_ArgList) 
#line 1945 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1946
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 1949
} 
#line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl vswscanf_s(const __wchar_t *const 
#line 1957
_Buffer, const __wchar_t *const 
#line 1958
_Format, va_list 
#line 1959
_ArgList) 
#line 1964 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1965
return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 1966
} 
#line 1971 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vswscanf_s ( wchar_t ( & _Buffer ) [ _Size ], wchar_t const * _Format, va_list _ArgList ) throw ( ) { return vswscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1981 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_l(const __wchar_t *const 
#line 1982
_Buffer, const size_t 
#line 1983
_BufferCount, const __wchar_t *const 
#line 1984
_Format, const _locale_t 
#line 1985
_Locale, va_list 
#line 1986
_ArgList) 
#line 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 1992
return __stdio_common_vswscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1995
} 
#line 2000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _vsnwscanf_s_l(const __wchar_t *const 
#line 2001
_Buffer, const size_t 
#line 2002
_BufferCount, const __wchar_t *const 
#line 2003
_Format, const _locale_t 
#line 2004
_Locale, va_list 
#line 2005
_ArgList) 
#line 2010 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2011
return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2014
} 
#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_l(const __wchar_t *const 
#line 2020
_Buffer, const __wchar_t *const 
#line 2021
_Format, _locale_t 
#line 2022
_Locale, ...) 
#line 2027 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2028
int _Result; 
#line 2029
va_list _ArgList; 
#line 2030
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2031
_Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2032
(void)(_ArgList = ((va_list)0)); 
#line 2033
return _Result; 
#line 2034
} 
#line 2039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf(const __wchar_t *const 
#line 2040
_Buffer, const __wchar_t *const 
#line 2041
_Format, ...) 
#line 2046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2047
int _Result; 
#line 2048
va_list _ArgList; 
#line 2049
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2050
_Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2051
(void)(_ArgList = ((va_list)0)); 
#line 2052
return _Result; 
#line 2053
} 
#line 2058 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _swscanf_s_l(const __wchar_t *const 
#line 2059
_Buffer, const __wchar_t *const 
#line 2060
_Format, const _locale_t 
#line 2061
_Locale, ...) 
#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2067
int _Result; 
#line 2068
va_list _ArgList; 
#line 2069
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2070
_Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2071
(void)(_ArgList = ((va_list)0)); 
#line 2072
return _Result; 
#line 2073
} 
#line 2080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl swscanf_s(const __wchar_t *const 
#line 2081
_Buffer, const __wchar_t *const 
#line 2082
_Format, ...) 
#line 2087 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2088
int _Result; 
#line 2089
va_list _ArgList; 
#line 2090
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2091
_Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2092
(void)(_ArgList = ((va_list)0)); 
#line 2093
return _Result; 
#line 2094
} 
#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_l(const __wchar_t *const 
#line 2102
_Buffer, const size_t 
#line 2103
_BufferCount, const __wchar_t *const 
#line 2104
_Format, const _locale_t 
#line 2105
_Locale, ...) 
#line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2111
int _Result; 
#line 2112
va_list _ArgList; 
#line 2113
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2115
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 2120
(void)(_ArgList = ((va_list)0)); 
#line 2121
return _Result; 
#line 2122
} 
#line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf(const __wchar_t *const 
#line 2128
_Buffer, const size_t 
#line 2129
_BufferCount, const __wchar_t *const 
#line 2130
_Format, ...) 
#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2136
int _Result; 
#line 2137
va_list _ArgList; 
#line 2138
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2140
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
#line 2145
(void)(_ArgList = ((va_list)0)); 
#line 2146
return _Result; 
#line 2147
} 
#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s_l(const __wchar_t *const 
#line 2153
_Buffer, const size_t 
#line 2154
_BufferCount, const __wchar_t *const 
#line 2155
_Format, const _locale_t 
#line 2156
_Locale, ...) 
#line 2161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2162
int _Result; 
#line 2163
va_list _ArgList; 
#line 2164
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2165
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2166
(void)(_ArgList = ((va_list)0)); 
#line 2167
return _Result; 
#line 2168
} 
#line 2173 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
__inline int __cdecl _snwscanf_s(const __wchar_t *const 
#line 2174
_Buffer, const size_t 
#line 2175
_BufferCount, const __wchar_t *const 
#line 2176
_Format, ...) 
#line 2181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
{ 
#line 2182
int _Result; 
#line 2183
va_list _ArgList; 
#line 2184
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2185
_Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2186
(void)(_ArgList = ((va_list)0)); 
#line 2187
return _Result; 
#line 2188
} 
#line 2198 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wstdio.h"
}__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
typedef __int64 fpos_t; 
#line 76
__declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(FILE * _Stream, char *** _Base, char *** _Pointer, int ** _Count); 
#line 92
__declspec(dllimport) errno_t __cdecl clearerr_s(FILE * _Stream); 
#line 97
__declspec(dllimport) errno_t __cdecl fopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode); 
#line 105
__declspec(dllimport) size_t __cdecl fread_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 114
__declspec(dllimport) errno_t __cdecl freopen_s(FILE ** _Stream, const char * _FileName, const char * _Mode, FILE * _OldStream); 
#line 122
__declspec(dllimport) char *__cdecl gets_s(char * _Buffer, rsize_t _Size); 
#line 128
__declspec(dllimport) errno_t __cdecl tmpfile_s(FILE ** _Stream); 
#line 134
__declspec(dllimport) errno_t __cdecl tmpnam_s(char * _Buffer, rsize_t _Size); 
#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) void __cdecl clearerr(FILE * _Stream); 
#line 147
__declspec(dllimport) int __cdecl fclose(FILE * _Stream); 
#line 152
__declspec(dllimport) int __cdecl _fcloseall(); 
#line 155
__declspec(dllimport) FILE *__cdecl _fdopen(int _FileHandle, const char * _Mode); 
#line 161
__declspec(dllimport) int __cdecl feof(FILE * _Stream); 
#line 166
__declspec(dllimport) int __cdecl ferror(FILE * _Stream); 
#line 171
__declspec(dllimport) int __cdecl fflush(FILE * _Stream); 
#line 177
__declspec(dllimport) int __cdecl fgetc(FILE * _Stream); 
#line 182
__declspec(dllimport) int __cdecl _fgetchar(); 
#line 186
__declspec(dllimport) int __cdecl fgetpos(FILE * _Stream, fpos_t * _Position); 
#line 193
__declspec(dllimport) char *__cdecl fgets(char * _Buffer, int _MaxCount, FILE * _Stream); 
#line 200
__declspec(dllimport) int __cdecl _fileno(FILE * _Stream); 
#line 205
__declspec(dllimport) int __cdecl _flushall(); 
#line 208
__declspec(dllimport) FILE *__cdecl fopen(const char * _FileName, const char * _Mode); 
#line 216
__declspec(dllimport) int __cdecl fputc(int _Character, FILE * _Stream); 
#line 222
__declspec(dllimport) int __cdecl _fputchar(int _Character); 
#line 228
__declspec(dllimport) int __cdecl fputs(const char * _Buffer, FILE * _Stream); 
#line 234
__declspec(dllimport) size_t __cdecl fread(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 243
__declspec(dllimport) FILE *__cdecl freopen(const char * _FileName, const char * _Mode, FILE * _Stream); 
#line 250
__declspec(dllimport) FILE *__cdecl _fsopen(const char * _FileName, const char * _Mode, int _ShFlag); 
#line 258
__declspec(dllimport) int __cdecl fsetpos(FILE * _Stream, const fpos_t * _Position); 
#line 265
__declspec(dllimport) int __cdecl fseek(FILE * _Stream, long _Offset, int _Origin); 
#line 273
__declspec(dllimport) int __cdecl _fseeki64(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 281
__declspec(dllimport) long __cdecl ftell(FILE * _Stream); 
#line 287
__declspec(dllimport) __int64 __cdecl _ftelli64(FILE * _Stream); 
#line 292
__declspec(dllimport) size_t __cdecl fwrite(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 301
__declspec(dllimport) int __cdecl getc(FILE * _Stream); 
#line 306
__declspec(dllimport) int __cdecl getchar(); 
#line 309
__declspec(dllimport) int __cdecl _getmaxstdio(); 
#line 311
extern "C++" {template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }}
#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl _getw(FILE * _Stream); 
#line 320
__declspec(dllimport) void __cdecl perror(const char * _ErrorMessage); 
#line 328
__declspec(dllimport) int __cdecl _pclose(FILE * _Stream); 
#line 333
__declspec(dllimport) FILE *__cdecl _popen(const char * _Command, const char * _Mode); 
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl putc(int _Character, FILE * _Stream); 
#line 348
__declspec(dllimport) int __cdecl putchar(int _Character); 
#line 353
__declspec(dllimport) int __cdecl puts(const char * _Buffer); 
#line 359
__declspec(dllimport) int __cdecl _putw(int _Word, FILE * _Stream); 
#line 364
__declspec(dllimport) int __cdecl remove(const char * _FileName); 
#line 369
__declspec(dllimport) int __cdecl rename(const char * _OldFileName, const char * _NewFileName); 
#line 374
__declspec(dllimport) int __cdecl _unlink(const char * _FileName); 
#line 381
__declspec(dllimport) int __cdecl unlink(const char * _FileName); 
#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) void __cdecl rewind(FILE * _Stream); 
#line 392
__declspec(dllimport) int __cdecl _rmtmp(); 
#line 395
__declspec(dllimport) void __cdecl setbuf(FILE * _Stream, char * _Buffer); 
#line 401
__declspec(dllimport) int __cdecl _setmaxstdio(int _Maximum); 
#line 407
__declspec(dllimport) int __cdecl setvbuf(FILE * _Stream, char * _Buffer, int _Mode, size_t _Size); 
#line 420 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) __declspec(allocator) char *__cdecl _tempnam(const char * _DirectoryName, const char * _FilePrefix); 
#line 430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) FILE *__cdecl tmpfile(); 
#line 432
extern "C++" {template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buffer, _Size ); }}
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 28726)
__declspec(dllimport) char *__cdecl tmpnam(char * _Buffer); 
#line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 449
__declspec(dllimport) int __cdecl ungetc(int _Character, FILE * _Stream); 
#line 461
__declspec(dllimport) void __cdecl _lock_file(FILE * _Stream); 
#line 465
__declspec(dllimport) void __cdecl _unlock_file(FILE * _Stream); 
#line 471
__declspec(dllimport) int __cdecl _fclose_nolock(FILE * _Stream); 
#line 477
__declspec(dllimport) int __cdecl _fflush_nolock(FILE * _Stream); 
#line 483
__declspec(dllimport) int __cdecl _fgetc_nolock(FILE * _Stream); 
#line 489
__declspec(dllimport) int __cdecl _fputc_nolock(int _Character, FILE * _Stream); 
#line 495
__declspec(dllimport) size_t __cdecl _fread_nolock(void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 504
__declspec(dllimport) size_t __cdecl _fread_nolock_s(void * _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 513
__declspec(dllimport) int __cdecl _fseek_nolock(FILE * _Stream, long _Offset, int _Origin); 
#line 520
__declspec(dllimport) int __cdecl _fseeki64_nolock(FILE * _Stream, __int64 _Offset, int _Origin); 
#line 527
__declspec(dllimport) long __cdecl _ftell_nolock(FILE * _Stream); 
#line 532
__declspec(dllimport) __int64 __cdecl _ftelli64_nolock(FILE * _Stream); 
#line 537
__declspec(dllimport) size_t __cdecl _fwrite_nolock(const void * _Buffer, size_t _ElementSize, size_t _ElementCount, FILE * _Stream); 
#line 545
__declspec(dllimport) int __cdecl _getc_nolock(FILE * _Stream); 
#line 550
__declspec(dllimport) int __cdecl _putc_nolock(int _Character, FILE * _Stream); 
#line 556
__declspec(dllimport) int __cdecl _ungetc_nolock(int _Character, FILE * _Stream); 
#line 587 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int *__cdecl __p__commode(); 
#line 607 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfprintf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 615
__declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 624
__declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 633
__inline int __cdecl _vfprintf_l(FILE *const 
#line 634
_Stream, const char *const 
#line 635
_Format, const _locale_t 
#line 636
_Locale, va_list 
#line 637
_ArgList) 
#line 642 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 643
return __stdio_common_vfprintf(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 644
} 
#line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf(FILE *const 
#line 649
_Stream, const char *const 
#line 650
_Format, va_list 
#line 651
_ArgList) 
#line 656 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 657
return _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 658
} 
#line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_s_l(FILE *const 
#line 663
_Stream, const char *const 
#line 664
_Format, const _locale_t 
#line 665
_Locale, va_list 
#line 666
_ArgList) 
#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 672
return __stdio_common_vfprintf_s(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 673
} 
#line 679 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vfprintf_s(FILE *const 
#line 680
_Stream, const char *const 
#line 681
_Format, va_list 
#line 682
_ArgList) 
#line 687 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 688
return _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 689
} 
#line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p_l(FILE *const 
#line 696
_Stream, const char *const 
#line 697
_Format, const _locale_t 
#line 698
_Locale, va_list 
#line 699
_ArgList) 
#line 704 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 705
return __stdio_common_vfprintf_p(*__local_stdio_printf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 706
} 
#line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vfprintf_p(FILE *const 
#line 711
_Stream, const char *const 
#line 712
_Format, va_list 
#line 713
_ArgList) 
#line 718 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 719
return _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 720
} 
#line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_l(const char *const 
#line 725
_Format, const _locale_t 
#line 726
_Locale, va_list 
#line 727
_ArgList) 
#line 732 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 733
return _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 734
} 
#line 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf(const char *const 
#line 739
_Format, va_list 
#line 740
_ArgList) 
#line 745 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 746
return _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 747
} 
#line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_s_l(const char *const 
#line 752
_Format, const _locale_t 
#line 753
_Locale, va_list 
#line 754
_ArgList) 
#line 759 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 760
return _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 761
} 
#line 767 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vprintf_s(const char *const 
#line 768
_Format, va_list 
#line 769
_ArgList) 
#line 774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 775
return _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 776
} 
#line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p_l(const char *const 
#line 783
_Format, const _locale_t 
#line 784
_Locale, va_list 
#line 785
_ArgList) 
#line 790 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 791
return _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 792
} 
#line 796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vprintf_p(const char *const 
#line 797
_Format, va_list 
#line 798
_ArgList) 
#line 803 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 804
return _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 805
} 
#line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_l(FILE *const 
#line 810
_Stream, const char *const 
#line 811
_Format, const _locale_t 
#line 812
_Locale, ...) 
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 818
int _Result; 
#line 819
va_list _ArgList; 
#line 820
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 821
_Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList); 
#line 822
(void)(_ArgList = ((va_list)0)); 
#line 823
return _Result; 
#line 824
} 
#line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf(FILE *const 
#line 829
_Stream, const char *const 
#line 830
_Format, ...) 
#line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 836
int _Result; 
#line 837
va_list _ArgList; 
#line 838
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 839
_Result = _vfprintf_l(_Stream, _Format, 0, _ArgList); 
#line 840
(void)(_ArgList = ((va_list)0)); 
#line 841
return _Result; 
#line 842
} 
#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl _set_printf_count_output(int _Value); 
#line 849
__declspec(dllimport) int __cdecl _get_printf_count_output(); 
#line 852
__inline int __cdecl _fprintf_s_l(FILE *const 
#line 853
_Stream, const char *const 
#line 854
_Format, const _locale_t 
#line 855
_Locale, ...) 
#line 860 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 861
int _Result; 
#line 862
va_list _ArgList; 
#line 863
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 864
_Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 865
(void)(_ArgList = ((va_list)0)); 
#line 866
return _Result; 
#line 867
} 
#line 873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl fprintf_s(FILE *const 
#line 874
_Stream, const char *const 
#line 875
_Format, ...) 
#line 880 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 881
int _Result; 
#line 882
va_list _ArgList; 
#line 883
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 884
_Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList); 
#line 885
(void)(_ArgList = ((va_list)0)); 
#line 886
return _Result; 
#line 887
} 
#line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p_l(FILE *const 
#line 894
_Stream, const char *const 
#line 895
_Format, const _locale_t 
#line 896
_Locale, ...) 
#line 901 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 902
int _Result; 
#line 903
va_list _ArgList; 
#line 904
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 905
_Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList); 
#line 906
(void)(_ArgList = ((va_list)0)); 
#line 907
return _Result; 
#line 908
} 
#line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _fprintf_p(FILE *const 
#line 913
_Stream, const char *const 
#line 914
_Format, ...) 
#line 919 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 920
int _Result; 
#line 921
va_list _ArgList; 
#line 922
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 923
_Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList); 
#line 924
(void)(_ArgList = ((va_list)0)); 
#line 925
return _Result; 
#line 926
} 
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_l(const char *const 
#line 931
_Format, const _locale_t 
#line 932
_Locale, ...) 
#line 937 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 938
int _Result; 
#line 939
va_list _ArgList; 
#line 940
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 941
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 942
(void)(_ArgList = ((va_list)0)); 
#line 943
return _Result; 
#line 944
} 
#line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl printf(const char *const 
#line 949
_Format, ...) 
#line 954 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 955
int _Result; 
#line 956
va_list _ArgList; 
#line 957
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 958
_Result = _vfprintf_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 959
(void)(_ArgList = ((va_list)0)); 
#line 960
return _Result; 
#line 961
} 
#line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_s_l(const char *const 
#line 966
_Format, const _locale_t 
#line 967
_Locale, ...) 
#line 972 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 973
int _Result; 
#line 974
va_list _ArgList; 
#line 975
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 976
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 977
(void)(_ArgList = ((va_list)0)); 
#line 978
return _Result; 
#line 979
} 
#line 985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl printf_s(const char *const 
#line 986
_Format, ...) 
#line 991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 992
int _Result; 
#line 993
va_list _ArgList; 
#line 994
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 995
_Result = _vfprintf_s_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 996
(void)(_ArgList = ((va_list)0)); 
#line 997
return _Result; 
#line 998
} 
#line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p_l(const char *const 
#line 1005
_Format, const _locale_t 
#line 1006
_Locale, ...) 
#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1012
int _Result; 
#line 1013
va_list _ArgList; 
#line 1014
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1015
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, _Locale, _ArgList); 
#line 1016
(void)(_ArgList = ((va_list)0)); 
#line 1017
return _Result; 
#line 1018
} 
#line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _printf_p(const char *const 
#line 1023
_Format, ...) 
#line 1028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1029
int _Result; 
#line 1030
va_list _ArgList; 
#line 1031
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1032
_Result = _vfprintf_p_l(__acrt_iob_func(1), _Format, 0, _ArgList); 
#line 1033
(void)(_ArgList = ((va_list)0)); 
#line 1034
return _Result; 
#line 1035
} 
#line 1044 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vfscanf(unsigned __int64 _Options, FILE * _Stream, const char * _Format, _locale_t _Locale, va_list _Arglist); 
#line 1053
__inline int __cdecl _vfscanf_l(FILE *const 
#line 1054
_Stream, const char *const 
#line 1055
_Format, const _locale_t 
#line 1056
_Locale, va_list 
#line 1057
_ArgList) 
#line 1062 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1063
return __stdio_common_vfscanf(*__local_stdio_scanf_options(), _Stream, _Format, _Locale, _ArgList); 
#line 1066
} 
#line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf(FILE *const 
#line 1071
_Stream, const char *const 
#line 1072
_Format, va_list 
#line 1073
_ArgList) 
#line 1078 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1079
return _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1080
} 
#line 1084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vfscanf_s_l(FILE *const 
#line 1085
_Stream, const char *const 
#line 1086
_Format, const _locale_t 
#line 1087
_Locale, va_list 
#line 1088
_ArgList) 
#line 1093 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1094
return __stdio_common_vfscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Stream, _Format, _Locale, _ArgList); 
#line 1097
} 
#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vfscanf_s(FILE *const 
#line 1105
_Stream, const char *const 
#line 1106
_Format, va_list 
#line 1107
_ArgList) 
#line 1112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1113
return _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1114
} 
#line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_l(const char *const 
#line 1121
_Format, const _locale_t 
#line 1122
_Locale, va_list 
#line 1123
_ArgList) 
#line 1128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1129
return _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1130
} 
#line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf(const char *const 
#line 1135
_Format, va_list 
#line 1136
_ArgList) 
#line 1141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1142
return _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1143
} 
#line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vscanf_s_l(const char *const 
#line 1148
_Format, const _locale_t 
#line 1149
_Locale, va_list 
#line 1150
_ArgList) 
#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1156
return _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1157
} 
#line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vscanf_s(const char *const 
#line 1164
_Format, va_list 
#line 1165
_ArgList) 
#line 1170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1171
return _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1172
} 
#line 1178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_l(FILE *const 
#line 1179
_Stream, const char *const 
#line 1180
_Format, const _locale_t 
#line 1181
_Locale, ...) 
#line 1186 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1187
int _Result; 
#line 1188
va_list _ArgList; 
#line 1189
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1190
_Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList); 
#line 1191
(void)(_ArgList = ((va_list)0)); 
#line 1192
return _Result; 
#line 1193
} 
#line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf(FILE *const 
#line 1198
_Stream, const char *const 
#line 1199
_Format, ...) 
#line 1204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1205
int _Result; 
#line 1206
va_list _ArgList; 
#line 1207
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1208
_Result = _vfscanf_l(_Stream, _Format, 0, _ArgList); 
#line 1209
(void)(_ArgList = ((va_list)0)); 
#line 1210
return _Result; 
#line 1211
} 
#line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _fscanf_s_l(FILE *const 
#line 1216
_Stream, const char *const 
#line 1217
_Format, const _locale_t 
#line 1218
_Locale, ...) 
#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1224
int _Result; 
#line 1225
va_list _ArgList; 
#line 1226
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1227
_Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList); 
#line 1228
(void)(_ArgList = ((va_list)0)); 
#line 1229
return _Result; 
#line 1230
} 
#line 1236 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl fscanf_s(FILE *const 
#line 1237
_Stream, const char *const 
#line 1238
_Format, ...) 
#line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1244
int _Result; 
#line 1245
va_list _ArgList; 
#line 1246
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1247
_Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList); 
#line 1248
(void)(_ArgList = ((va_list)0)); 
#line 1249
return _Result; 
#line 1250
} 
#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_l(const char *const 
#line 1257
_Format, const _locale_t 
#line 1258
_Locale, ...) 
#line 1263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1264
int _Result; 
#line 1265
va_list _ArgList; 
#line 1266
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1267
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1268
(void)(_ArgList = ((va_list)0)); 
#line 1269
return _Result; 
#line 1270
} 
#line 1274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl scanf(const char *const 
#line 1275
_Format, ...) 
#line 1280 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1281
int _Result; 
#line 1282
va_list _ArgList; 
#line 1283
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1284
_Result = _vfscanf_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1285
(void)(_ArgList = ((va_list)0)); 
#line 1286
return _Result; 
#line 1287
} 
#line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _scanf_s_l(const char *const 
#line 1292
_Format, const _locale_t 
#line 1293
_Locale, ...) 
#line 1298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1299
int _Result; 
#line 1300
va_list _ArgList; 
#line 1301
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1302
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, _Locale, _ArgList); 
#line 1303
(void)(_ArgList = ((va_list)0)); 
#line 1304
return _Result; 
#line 1305
} 
#line 1311 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl scanf_s(const char *const 
#line 1312
_Format, ...) 
#line 1317 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1318
int _Result; 
#line 1319
va_list _ArgList; 
#line 1320
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1321
_Result = _vfscanf_s_l(__acrt_iob_func(0), _Format, 0, _ArgList); 
#line 1322
(void)(_ArgList = ((va_list)0)); 
#line 1323
return _Result; 
#line 1324
} 
#line 1337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vsprintf(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1347
__declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1357
__declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1368
__declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(unsigned __int64 _Options, char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 1379
__inline int __cdecl _vsnprintf_l(char *const 
#line 1380
_Buffer, const size_t 
#line 1381
_BufferCount, const char *const 
#line 1382
_Format, const _locale_t 
#line 1383
_Locale, va_list 
#line 1384
_ArgList) 
#line 1389 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1390
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1394
return (_Result < 0) ? -1 : _Result; 
#line 1395
} 
#line 1400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf(char *const 
#line 1401
_Buffer, const size_t 
#line 1402
_BufferCount, const char *const 
#line 1403
_Format, va_list 
#line 1404
_ArgList) 
#line 1409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 1430 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf(char *const 
#line 1431
_Buffer, const size_t 
#line 1432
_BufferCount, const char *const 
#line 1433
_Format, va_list 
#line 1434
_ArgList) 
#line 1439 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1440
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1444
return (_Result < 0) ? -1 : _Result; 
#line 1445
} 
#line 1450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_l(char *const 
#line 1451
_Buffer, const char *const 
#line 1452
_Format, const _locale_t 
#line 1453
_Locale, va_list 
#line 1454
_ArgList) 
#line 1459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#pragma warning(pop)
} 
#line 1469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf(char *const 
#line 1470
_Buffer, const char *const 
#line 1471
_Format, va_list 
#line 1472
_ArgList) 
#line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vsnprintf_l(_Buffer, (size_t)(-1), _Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 1487 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_s_l(char *const 
#line 1488
_Buffer, const size_t 
#line 1489
_BufferCount, const char *const 
#line 1490
_Format, const _locale_t 
#line 1491
_Locale, va_list 
#line 1492
_ArgList) 
#line 1497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1498
const int _Result = __stdio_common_vsprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1502
return (_Result < 0) ? -1 : _Result; 
#line 1503
} 
#line 1510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vsprintf_s(char *const 
#line 1511
_Buffer, const size_t 
#line 1512
_BufferCount, const char *const 
#line 1513
_Format, va_list 
#line 1514
_ArgList) 
#line 1519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1520
return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1521
} 
#line 1524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 1536 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p_l(char *const 
#line 1537
_Buffer, const size_t 
#line 1538
_BufferCount, const char *const 
#line 1539
_Format, const _locale_t 
#line 1540
_Locale, va_list 
#line 1541
_ArgList) 
#line 1546 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1547
const int _Result = __stdio_common_vsprintf_p(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1551
return (_Result < 0) ? -1 : _Result; 
#line 1552
} 
#line 1557 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsprintf_p(char *const 
#line 1558
_Buffer, const size_t 
#line 1559
_BufferCount, const char *const 
#line 1560
_Format, va_list 
#line 1561
_ArgList) 
#line 1566 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1567
return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1568
} 
#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s_l(char *const 
#line 1574
_Buffer, const size_t 
#line 1575
_BufferCount, const size_t 
#line 1576
_MaxCount, const char *const 
#line 1577
_Format, const _locale_t 
#line 1578
_Locale, va_list 
#line 1579
_ArgList) 
#line 1584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1585
const int _Result = __stdio_common_vsnprintf_s(*__local_stdio_printf_options(), _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 1589
return (_Result < 0) ? -1 : _Result; 
#line 1590
} 
#line 1595 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_s(char *const 
#line 1596
_Buffer, const size_t 
#line 1597
_BufferCount, const size_t 
#line 1598
_MaxCount, const char *const 
#line 1599
_Format, va_list 
#line 1600
_ArgList) 
#line 1605 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1606
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1607
} 
#line 1610 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vsnprintf_s(char *const 
#line 1624
_Buffer, const size_t 
#line 1625
_BufferCount, const size_t 
#line 1626
_MaxCount, const char *const 
#line 1627
_Format, va_list 
#line 1628
_ArgList) 
#line 1633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1634
return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 1635
} 
#line 1638 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, va_list _ArgList ) throw ( ) { return vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }}
#line 1650 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_l(const char *const 
#line 1651
_Format, const _locale_t 
#line 1652
_Locale, va_list 
#line 1653
_ArgList) 
#line 1658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1659
const int _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1663
return (_Result < 0) ? -1 : _Result; 
#line 1664
} 
#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf(const char *const 
#line 1669
_Format, va_list 
#line 1670
_ArgList) 
#line 1675 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1676
return _vscprintf_l(_Format, 0, _ArgList); 
#line 1677
} 
#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p_l(const char *const 
#line 1682
_Format, const _locale_t 
#line 1683
_Locale, va_list 
#line 1684
_ArgList) 
#line 1689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1690
const int _Result = __stdio_common_vsprintf_p((*__local_stdio_printf_options()) | (1Ui64 << 1), 0, 0, _Format, _Locale, _ArgList); 
#line 1694
return (_Result < 0) ? -1 : _Result; 
#line 1695
} 
#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vscprintf_p(const char *const 
#line 1700
_Format, va_list 
#line 1701
_ArgList) 
#line 1706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1707
return _vscprintf_p_l(_Format, 0, _ArgList); 
#line 1708
} 
#line 1712 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c_l(char *const 
#line 1713
_Buffer, const size_t 
#line 1714
_BufferCount, const char *const 
#line 1715
_Format, const _locale_t 
#line 1716
_Locale, va_list 
#line 1717
_ArgList) 
#line 1722 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1723
const int _Result = __stdio_common_vsprintf(*__local_stdio_printf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1727
return (_Result < 0) ? -1 : _Result; 
#line 1728
} 
#line 1733 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsnprintf_c(char *const 
#line 1734
_Buffer, const size_t 
#line 1735
_BufferCount, const char *const 
#line 1736
_Format, va_list 
#line 1737
_ArgList) 
#line 1742 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1743
return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1744
} 
#line 1749 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_l(char *const 
#line 1750
_Buffer, const char *const 
#line 1751
_Format, const _locale_t 
#line 1752
_Locale, ...) 
#line 1757 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1758
int _Result; 
#line 1759
va_list _ArgList; 
#line 1760
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1762
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 1767
(void)(_ArgList = ((va_list)0)); 
#line 1768
return _Result; 
#line 1769
} 
#line 1774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf(char *const 
#line 1775
_Buffer, const char *const 
#line 1776
_Format, ...) 
#line 1781 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1782
int _Result; 
#line 1783
va_list _ArgList; 
#line 1784
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1786
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList); 
#pragma warning(pop)
#line 1791
(void)(_ArgList = ((va_list)0)); 
#line 1792
return _Result; 
#line 1793
} 
#line 1796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 4996)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
__inline int __cdecl sprintf(char * _Buffer, const char * _Format, ...); __inline int __cdecl vsprintf(char * _Buffer, const char * _Format, va_list _Args); 
#line 1806 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 1810
__inline int __cdecl _sprintf_s_l(char *const 
#line 1811
_Buffer, const size_t 
#line 1812
_BufferCount, const char *const 
#line 1813
_Format, const _locale_t 
#line 1814
_Locale, ...) 
#line 1819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1820
int _Result; 
#line 1821
va_list _ArgList; 
#line 1822
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1823
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1824
(void)(_ArgList = ((va_list)0)); 
#line 1825
return _Result; 
#line 1826
} 
#line 1833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl sprintf_s(char *const 
#line 1834
_Buffer, const size_t 
#line 1835
_BufferCount, const char *const 
#line 1836
_Format, ...) 
#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1842
int _Result; 
#line 1843
va_list _ArgList; 
#line 1844
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1845
_Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1846
(void)(_ArgList = ((va_list)0)); 
#line 1847
return _Result; 
#line 1848
} 
#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Buffer ) [ _Size ], char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return vsprintf_s ( _Buffer, _Size, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p_l(char *const 
#line 1863
_Buffer, const size_t 
#line 1864
_BufferCount, const char *const 
#line 1865
_Format, const _locale_t 
#line 1866
_Locale, ...) 
#line 1871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1872
int _Result; 
#line 1873
va_list _ArgList; 
#line 1874
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1875
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 1876
(void)(_ArgList = ((va_list)0)); 
#line 1877
return _Result; 
#line 1878
} 
#line 1883 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _sprintf_p(char *const 
#line 1884
_Buffer, const size_t 
#line 1885
_BufferCount, const char *const 
#line 1886
_Format, ...) 
#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1892
int _Result; 
#line 1893
va_list _ArgList; 
#line 1894
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 1895
_Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 1896
(void)(_ArgList = ((va_list)0)); 
#line 1897
return _Result; 
#line 1898
} 
#line 1903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_l(char *const 
#line 1904
_Buffer, const size_t 
#line 1905
_BufferCount, const char *const 
#line 1906
_Format, const _locale_t 
#line 1907
_Locale, ...) 
#line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1913
int _Result; 
#line 1914
va_list _ArgList; 
#line 1915
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 1917
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 1922
(void)(_ArgList = ((va_list)0)); 
#line 1923
return _Result; 
#line 1924
} 
#line 1940 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl snprintf(char *const 
#line 1941
_Buffer, const size_t 
#line 1942
_BufferCount, const char *const 
#line 1943
_Format, ...) 
#line 1948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1949
int _Result; 
#line 1950
va_list _ArgList; 
#line 1951
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#pragma warning(suppress:28719)
_Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1954
(void)(_ArgList = ((va_list)0)); 
#line 1955
return _Result; 
#line 1956
} 
#line 1961 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char *const 
#line 1962
_Buffer, const size_t 
#line 1963
_BufferCount, const char *const 
#line 1964
_Format, ...) 
#line 1969 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 1970
int _Result; 
#line 1971
va_list _ArgList; 
#line 1972
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#pragma warning(suppress:28719)
_Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList); 
#line 1975
(void)(_ArgList = ((va_list)0)); 
#line 1976
return _Result; 
#line 1977
} 
#line 1980 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf(char * _Buffer, size_t _BufferCount, const char * _Format, ...); __inline int __cdecl _vsnprintf(char * _Buffer, size_t _BufferCount, const char * _Format, va_list _Args); 
#line 1991 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c_l(char *const 
#line 1992
_Buffer, const size_t 
#line 1993
_BufferCount, const char *const 
#line 1994
_Format, const _locale_t 
#line 1995
_Locale, ...) 
#line 2000 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2001
int _Result; 
#line 2002
va_list _ArgList; 
#line 2003
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2004
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2005
(void)(_ArgList = ((va_list)0)); 
#line 2006
return _Result; 
#line 2007
} 
#line 2012 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_c(char *const 
#line 2013
_Buffer, const size_t 
#line 2014
_BufferCount, const char *const 
#line 2015
_Format, ...) 
#line 2020 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2021
int _Result; 
#line 2022
va_list _ArgList; 
#line 2023
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2024
_Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2025
(void)(_ArgList = ((va_list)0)); 
#line 2026
return _Result; 
#line 2027
} 
#line 2032 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s_l(char *const 
#line 2033
_Buffer, const size_t 
#line 2034
_BufferCount, const size_t 
#line 2035
_MaxCount, const char *const 
#line 2036
_Format, const _locale_t 
#line 2037
_Locale, ...) 
#line 2042 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2043
int _Result; 
#line 2044
va_list _ArgList; 
#line 2045
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2046
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList); 
#line 2047
(void)(_ArgList = ((va_list)0)); 
#line 2048
return _Result; 
#line 2049
} 
#line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snprintf_s(char *const 
#line 2055
_Buffer, const size_t 
#line 2056
_BufferCount, const size_t 
#line 2057
_MaxCount, const char *const 
#line 2058
_Format, ...) 
#line 2063 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2064
int _Result; 
#line 2065
va_list _ArgList; 
#line 2066
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2067
_Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList); 
#line 2068
(void)(_ArgList = ((va_list)0)); 
#line 2069
return _Result; 
#line 2070
} 
#line 2073 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
extern "C++" {__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Buffer ) [ _Size ], size_t _BufferCount, char const * _Format, ... ) throw ( ) { va_list _ArgList; ( ( void ) ( __vcrt_assert_va_start_is_not_reference < decltype ( _Format ) > ( ), ( ( void ) ( __va_start ( & _ArgList, _Format ) ) ) ) ); return _vsnprintf_s ( _Buffer, _Size, _BufferCount, _Format, _ArgList ); }__pragma( warning(pop)) }
#line 2082 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_l(const char *const 
#line 2083
_Format, const _locale_t 
#line 2084
_Locale, ...) 
#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2090
int _Result; 
#line 2091
va_list _ArgList; 
#line 2092
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2093
_Result = _vscprintf_l(_Format, _Locale, _ArgList); 
#line 2094
(void)(_ArgList = ((va_list)0)); 
#line 2095
return _Result; 
#line 2096
} 
#line 2100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf(const char *const 
#line 2101
_Format, ...) 
#line 2106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2107
int _Result; 
#line 2108
va_list _ArgList; 
#line 2109
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2110
_Result = _vscprintf_l(_Format, 0, _ArgList); 
#line 2111
(void)(_ArgList = ((va_list)0)); 
#line 2112
return _Result; 
#line 2113
} 
#line 2117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p_l(const char *const 
#line 2118
_Format, const _locale_t 
#line 2119
_Locale, ...) 
#line 2124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2125
int _Result; 
#line 2126
va_list _ArgList; 
#line 2127
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2128
_Result = _vscprintf_p_l(_Format, _Locale, _ArgList); 
#line 2129
(void)(_ArgList = ((va_list)0)); 
#line 2130
return _Result; 
#line 2131
} 
#line 2135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _scprintf_p(const char *const 
#line 2136
_Format, ...) 
#line 2141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2142
int _Result; 
#line 2143
va_list _ArgList; 
#line 2144
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2145
_Result = _vscprintf_p(_Format, _ArgList); 
#line 2146
(void)(_ArgList = ((va_list)0)); 
#line 2147
return _Result; 
#line 2148
} 
#line 2156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl __stdio_common_vsscanf(unsigned __int64 _Options, const char * _Buffer, size_t _BufferCount, const char * _Format, _locale_t _Locale, va_list _ArgList); 
#line 2166
__inline int __cdecl _vsscanf_l(const char *const 
#line 2167
_Buffer, const char *const 
#line 2168
_Format, const _locale_t 
#line 2169
_Locale, va_list 
#line 2170
_ArgList) 
#line 2175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2176
return __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2179
} 
#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl vsscanf(const char *const 
#line 2184
_Buffer, const char *const 
#line 2185
_Format, va_list 
#line 2186
_ArgList) 
#line 2191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2192
return _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2193
} 
#line 2197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _vsscanf_s_l(const char *const 
#line 2198
_Buffer, const char *const 
#line 2199
_Format, const _locale_t 
#line 2200
_Locale, va_list 
#line 2201
_ArgList) 
#line 2206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2207
return __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, (size_t)(-1), _Format, _Locale, _ArgList); 
#line 2210
} 
#line 2215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable:6530)
#line 2219
__inline int __cdecl vsscanf_s(const char *const 
#line 2220
_Buffer, const char *const 
#line 2221
_Format, va_list 
#line 2222
_ArgList) 
#line 2227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2228
return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList); 
#line 2229
} 
#line 2232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
extern "C++" {template < size_t _Size > inline int __cdecl vsscanf_s ( char const ( & _Buffer ) [ _Size ], char const * _Format, va_list _ArgList ) throw ( ) { return vsscanf_s ( _Buffer, _Size, _Format, _ArgList ); }}
#line 2239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_l(const char *const 
#line 2245
_Buffer, const char *const 
#line 2246
_Format, const _locale_t 
#line 2247
_Locale, ...) 
#line 2252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2253
int _Result; 
#line 2254
va_list _ArgList; 
#line 2255
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2256
_Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2257
(void)(_ArgList = ((va_list)0)); 
#line 2258
return _Result; 
#line 2259
} 
#line 2263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf(const char *const 
#line 2264
_Buffer, const char *const 
#line 2265
_Format, ...) 
#line 2270 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2271
int _Result; 
#line 2272
va_list _ArgList; 
#line 2273
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2274
_Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList); 
#line 2275
(void)(_ArgList = ((va_list)0)); 
#line 2276
return _Result; 
#line 2277
} 
#line 2281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _sscanf_s_l(const char *const 
#line 2282
_Buffer, const char *const 
#line 2283
_Format, const _locale_t 
#line 2284
_Locale, ...) 
#line 2289 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2290
int _Result; 
#line 2291
va_list _ArgList; 
#line 2292
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2293
_Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList); 
#line 2294
(void)(_ArgList = ((va_list)0)); 
#line 2295
return _Result; 
#line 2296
} 
#line 2302 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl sscanf_s(const char *const 
#line 2303
_Buffer, const char *const 
#line 2304
_Format, ...) 
#line 2309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2310
int _Result; 
#line 2311
va_list _ArgList; 
#line 2312
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2314
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = vsscanf_s(_Buffer, _Format, _ArgList); 
#pragma warning(pop)
#line 2319
(void)(_ArgList = ((va_list)0)); 
#line 2320
return _Result; 
#line 2321
} 
#line 2326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(push)
#pragma warning(disable:6530)
#line 2330
__inline int __cdecl _snscanf_l(const char *const 
#line 2331
_Buffer, const size_t 
#line 2332
_BufferCount, const char *const 
#line 2333
_Format, const _locale_t 
#line 2334
_Locale, ...) 
#line 2339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2340
int _Result; 
#line 2341
va_list _ArgList; 
#line 2342
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2344
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2348
(void)(_ArgList = ((va_list)0)); 
#line 2349
return _Result; 
#line 2350
} 
#line 2354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf(const char *const 
#line 2355
_Buffer, const size_t 
#line 2356
_BufferCount, const char *const 
#line 2357
_Format, ...) 
#line 2362 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2363
int _Result; 
#line 2364
va_list _ArgList; 
#line 2365
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2367
_Result = __stdio_common_vsscanf(*__local_stdio_scanf_options(), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2371
(void)(_ArgList = ((va_list)0)); 
#line 2372
return _Result; 
#line 2373
} 
#line 2378 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s_l(const char *const 
#line 2379
_Buffer, const size_t 
#line 2380
_BufferCount, const char *const 
#line 2381
_Format, const _locale_t 
#line 2382
_Locale, ...) 
#line 2387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2388
int _Result; 
#line 2389
va_list _ArgList; 
#line 2390
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 2392
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, _Locale, _ArgList); 
#line 2396
(void)(_ArgList = ((va_list)0)); 
#line 2397
return _Result; 
#line 2398
} 
#line 2402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__inline int __cdecl _snscanf_s(const char *const 
#line 2403
_Buffer, const size_t 
#line 2404
_BufferCount, const char *const 
#line 2405
_Format, ...) 
#line 2410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
{ 
#line 2411
int _Result; 
#line 2412
va_list _ArgList; 
#line 2413
(void)((__vcrt_assert_va_start_is_not_reference< const char *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 2415
_Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Buffer, _BufferCount, _Format, 0, _ArgList); 
#line 2419
(void)(_ArgList = ((va_list)0)); 
#line 2420
return _Result; 
#line 2421
} 
#line 2424 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
#pragma warning(pop)
#line 2447 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) char *__cdecl tempnam(const char * _Directory, const char * _FilePrefix); 
#line 2456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
__declspec(dllimport) int __cdecl fcloseall(); 
#line 2457
__declspec(dllimport) FILE *__cdecl fdopen(int _FileHandle, const char * _Format); 
#line 2458
__declspec(dllimport) int __cdecl fgetchar(); 
#line 2459
__declspec(dllimport) int __cdecl fileno(FILE * _Stream); 
#line 2460
__declspec(dllimport) int __cdecl flushall(); 
#line 2461
__declspec(dllimport) int __cdecl fputchar(int _Ch); 
#line 2462
__declspec(dllimport) int __cdecl getw(FILE * _Stream); 
#line 2463
__declspec(dllimport) int __cdecl putw(int _Ch, FILE * _Stream); 
#line 2464
__declspec(dllimport) int __cdecl rmtmp(); 
#line 2471 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\stdio.h"
}__pragma( pack ( pop )) 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstdio"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 29
namespace std { 
#pragma warning(push)
#pragma warning(disable: 4995)
#line 33
using ::FILE;using ::_Mbstatet;
#line 35
using ::fpos_t;
#line 36
using ::clearerr;using ::fclose;using ::feof;
#line 37
using ::ferror;using ::fflush;using ::fgetc;
#line 38
using ::fgetpos;using ::fgets;using ::fopen;
#line 39
using ::fprintf;using ::fputc;using ::fputs;
#line 40
using ::fread;using ::freopen;using ::fscanf;
#line 41
using ::fseek;using ::fsetpos;using ::ftell;
#line 42
using ::fwrite;using ::getc;using ::getchar;
#line 43
using ::perror;
#line 44
using ::putc;using ::putchar;
#line 45
using ::printf;using ::puts;using ::remove;
#line 46
using ::rename;using ::rewind;using ::scanf;
#line 47
using ::setbuf;using ::setvbuf;using ::sprintf;
#line 48
using ::sscanf;using ::tmpfile;using ::tmpnam;
#line 49
using ::ungetc;using ::vfprintf;using ::vprintf;
#line 50
using ::vsprintf;
#line 52
using ::snprintf;using ::vsnprintf;
#line 53
using ::vfscanf;using ::vscanf;using ::vsscanf;
#line 55
#pragma warning(pop)
}
#line 60
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstring"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
namespace std { 
#pragma warning(push)
#pragma warning(disable: 4995)
#line 21
using ::memchr;using ::memcmp;
#line 22
using ::memcpy;using ::memmove;using ::memset;
#line 23
using ::strcat;using ::strchr;using ::strcmp;
#line 24
using ::strcoll;using ::strcpy;using ::strcspn;
#line 25
using ::strerror;using ::strlen;using ::strncat;
#line 26
using ::strncmp;using ::strncpy;using ::strpbrk;
#line 27
using ::strrchr;using ::strspn;using ::strstr;
#line 28
using ::strtok;using ::strxfrm;
#line 30
#pragma warning(pop)
}
#line 35
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstddef"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
namespace std { 
#line 18
using ::ptrdiff_t;
#line 19
typedef double max_align_t; 
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstddef"
}
#line 101
using std::max_align_t;
#line 105
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\initializer_list"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 17
template < class _Elem >
 class initializer_list
 {
public :
 typedef _Elem value_type;
 typedef const _Elem & reference;
 typedef const _Elem & const_reference;
 typedef size_t size_type;

 typedef const _Elem * iterator;
 typedef const _Elem * const_iterator;

 constexpr initializer_list ( ) noexcept
  : _First ( nullptr ), _Last ( nullptr )
  {
  }

 constexpr initializer_list ( const _Elem * _First_arg,
  const _Elem * _Last_arg ) noexcept
  : _First ( _First_arg ), _Last ( _Last_arg )
  {
  }

  constexpr const _Elem * begin ( ) const noexcept
  {
  return ( _First );
  }

  constexpr const _Elem * end ( ) const noexcept
  {
  return ( _Last );
  }

  constexpr size_t size ( ) const noexcept
  {
  return ( static_cast < size_t > ( _Last - _First ) );
  }

private :
 const _Elem * _First;
 const _Elem * _Last;
 };
#line 61
template < class _Elem >
  constexpr const _Elem * begin ( initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . begin ( ) );
 }
#line 68
template < class _Elem >
  constexpr const _Elem * end ( initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . end ( ) );
 }
#line 73
}
#line 76
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstddef"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 18
namespace std { 
#line 20
template< class > constexpr bool 
#line 22
_Always_false = false; 
#line 27
template< class _Arg, class 
#line 28
_Result> 
#line 29
struct unary_function { 
#line 31
typedef _Arg argument_type; 
#line 32
typedef _Result result_type; 
#line 33
}; 
#line 36
template< class _Arg1, class 
#line 37
_Arg2, class 
#line 38
_Result> 
#line 39
struct binary_function { 
#line 41
typedef _Arg1 first_argument_type; 
#line 42
typedef _Arg2 second_argument_type; 
#line 43
typedef _Result result_type; 
#line 44
}; 
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstddef"
template < class _Ty = void >
 struct plus
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef _Ty result_type;

 constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left + _Right );
  }
 };
#line 62
template < class _Ty = void >
 struct minus
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef _Ty result_type;

 constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left - _Right );
  }
 };
#line 76
template < class _Ty = void >
 struct multiplies
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef _Ty result_type;

 constexpr _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left * _Right );
  }
 };
#line 90
template < class _Ty = void >
 struct equal_to
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left == _Right );
  }
 };
#line 104
template < class _Ty = void >
 struct not_equal_to
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left != _Right );
  }
 };
#line 118
template < class _Ty = void >
 struct greater
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left > _Right );
  }
 };
#line 132
template < class _Ty = void >
 struct less
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left < _Right );
  }
 };
#line 146
template < class _Ty = void >
 struct greater_equal
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left >= _Right );
  }
 };
#line 160
template < class _Ty = void >
 struct less_equal
 {
  typedef _Ty first_argument_type;
  typedef _Ty second_argument_type;
  typedef bool result_type;

 constexpr bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left <= _Right );
  }
 };
#line 175
template<> struct plus< void>  { 
#line 177
typedef int is_transparent; 
#line 179
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   + static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   + static_cast < _Ty2 && > ( _Right ) );
  }
#line 188
}; 
#line 192
template<> struct minus< void>  { 
#line 194
typedef int is_transparent; 
#line 196
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   - static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   - static_cast < _Ty2 && > ( _Right ) );
  }
#line 205
}; 
#line 209
template<> struct multiplies< void>  { 
#line 211
typedef int is_transparent; 
#line 213
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   * static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   * static_cast < _Ty2 && > ( _Right ) );
  }
#line 222
}; 
#line 226
template<> struct equal_to<>  { 
#line 228
typedef int is_transparent; 
#line 230
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   == static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   == static_cast < _Ty2 && > ( _Right ) );
  }
#line 239
}; 
#line 243
template<> struct not_equal_to< void>  { 
#line 245
typedef int is_transparent; 
#line 247
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   != static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   != static_cast < _Ty2 && > ( _Right ) );
  }
#line 256
}; 
#line 260
template<> struct greater< void>  { 
#line 262
typedef int is_transparent; 
#line 264
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   > static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   > static_cast < _Ty2 && > ( _Right ) );
  }
#line 273
}; 
#line 277
template<> struct less<>  { 
#line 279
typedef int is_transparent; 
#line 281
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   < static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   < static_cast < _Ty2 && > ( _Right ) );
  }
#line 290
}; 
#line 294
template<> struct greater_equal< void>  { 
#line 296
typedef int is_transparent; 
#line 298
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   >= static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   >= static_cast < _Ty2 && > ( _Right ) );
  }
#line 307
}; 
#line 311
template<> struct less_equal< void>  { 
#line 313
typedef int is_transparent; 
#line 315
template < class _Ty1,
  class _Ty2 >
  constexpr auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   <= static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   <= static_cast < _Ty2 && > ( _Right ) );
  }
#line 324
}; 
#line 327
template < class _Ty >
  constexpr _Ty * addressof ( _Ty & _Val ) noexcept
 {
 return ( __builtin_addressof ( _Val ) );
 }
#line 333
template < class _Ty >
 const _Ty * addressof ( const _Ty && ) = delete;
#line 337
template < class _Ptrty > inline
 auto _Unfancy ( _Ptrty _Ptr )
 {
 return ( :: std :: addressof ( * _Ptr ) );
 }
#line 343
template < class _Ty > inline
 _Ty * _Unfancy ( _Ty * _Ptr )
 {
 return ( _Ptr );
 }
#line 348
}
#line 498 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstddef"
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
#pragma warning(disable: 4180)
#line 17
namespace std { 
#line 19
template < class _Ty,
 _Ty ... _Vals >
 struct integer_sequence
 {
 static_assert ( is_integral_v < _Ty >,
  "integer_sequence<T, I...> requires T to be an integral type." );

 using value_type = _Ty;

  static constexpr size_t size ( ) noexcept
  {
  return ( sizeof ... ( _Vals ) );
  }
 };
#line 35
template< class _Ty, _Ty 
#line 36
_Size> using make_integer_sequence = __make_integer_seq< integer_sequence, _Ty, _Size> ; 
#line 39
template< size_t ..._Vals> using index_sequence = integer_sequence< unsigned __int64, _Vals...> ; 
#line 42
template< size_t _Size> using make_index_sequence = make_integer_sequence< unsigned __int64, _Size> ; 
#line 45
template< class ..._Types> using index_sequence_for = make_index_sequence< sizeof...(_Types)> ; 
#line 49
template< bool _First_value, class 
#line 50
_First, class ...
#line 51
_Rest> 
#line 52
struct _Conjunction { 
#line 54
using type = _First; 
#line 55
}; 
#line 57
template< class _True, class 
#line 58
_Next, class ...
#line 59
_Rest> 
#line 60
struct _Conjunction< true, _True, _Next, _Rest...>  { 
#line 62
using type = typename std::_Conjunction< _Next::value, _Next, _Rest...> ::type; 
#line 63
}; 
#line 65
template< class ..._Traits> 
#line 66
struct conjunction : public true_type { 
#line 69
}; 
#line 71
template< class _First, class ...
#line 72
_Rest> 
#line 73
struct conjunction< _First, _Rest...>  : public _Conjunction< _First::value, _First, _Rest...> ::type { 
#line 77
}; 
#line 79
template< class ..._Traits> constexpr bool 
#line 80
conjunction_v = (conjunction< _Traits...> ::value); 
#line 83
template< bool _First_value, class 
#line 84
_First, class ...
#line 85
_Rest> 
#line 86
struct _Disjunction { 
#line 88
using type = _First; 
#line 89
}; 
#line 91
template< class _False, class 
#line 92
_Next, class ...
#line 93
_Rest> 
#line 94
struct _Disjunction< false, _False, _Next, _Rest...>  { 
#line 96
using type = typename std::_Disjunction< _Next::value, _Next, _Rest...> ::type; 
#line 97
}; 
#line 99
template< class ..._Traits> 
#line 100
struct disjunction : public false_type { 
#line 103
}; 
#line 105
template< class _First, class ...
#line 106
_Rest> 
#line 107
struct disjunction< _First, _Rest...>  : public _Disjunction< _First::value, _First, _Rest...> ::type { 
#line 111
}; 
#line 113
template< class ..._Traits> constexpr bool 
#line 114
disjunction_v = (disjunction< _Traits...> ::value); 
#line 117
template< class _Trait> 
#line 118
struct negation : public bool_constant< !(static_cast< bool>(_Trait::value))>  { 
#line 121
}; 
#line 123
template< class _Trait> constexpr bool 
#line 124
negation_v = (negation< _Trait> ::value); 
#line 127
template< class _Ty, class ...
#line 128
_Types> constexpr bool 
#line 129
_Is_any_of_v = disjunction_v< is_same< _Ty, _Types> ...> ; 
#line 132
template< class ..._Types> 
#line 133
struct _Arg_types { 
#line 135
}; 
#line 137
template< class _Ty1> 
#line 138
struct _Arg_types< _Ty1>  { 
#line 140
typedef _Ty1 argument_type; 
#line 141
}; 
#line 143
template< class _Ty1, class 
#line 144
_Ty2> 
#line 145
struct _Arg_types< _Ty1, _Ty2>  { 
#line 147
typedef _Ty1 first_argument_type; 
#line 148
typedef _Ty2 second_argument_type; 
#line 149
}; 
#line 152
template< class _Ty> 
#line 153
struct _Is_function { 
#line 155
using _Bool_type = false_type; 
#line 156
}; 
#line 168
template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...)>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...)>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) volatile>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) volatile>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const volatile>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const volatile>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) volatile &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) volatile &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const volatile &>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) volatile &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __cdecl (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret __vectorcall (_Types ...) const volatile &&>  : public _Arg_types< _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; }; 
#line 180
template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...)>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) volatile>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const volatile>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) &>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const &>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) volatile &>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const volatile &>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) &&>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const &&>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) volatile &&>  { using _Bool_type = true_type; typedef _Ret result_type; }; template< class _Ret, class ..._Types> struct _Is_function< _Ret (_Types ..., ...) const volatile &&>  { using _Bool_type = true_type; typedef _Ret result_type; }; 
#line 183
template< class _Ty> 
#line 184
struct is_function : public _Is_function< _Ty> ::_Bool_type { 
#line 187
}; 
#line 189
template< class _Ty> constexpr bool 
#line 190
is_function_v = (is_function< _Ty> ::value); 
#line 193
template< class _Ty> 
#line 194
struct _Is_memfunptr { 
#line 196
using _Bool_type = false_type; 
#line 197
}; 
#line 212
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< !std::is_same_v< int, int &&> , _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...)>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< !std::is_same_v< int &, int &&> , _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< true, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< !std::is_same_v< int &&, int &&> , _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) &&>  : public _Arg_types< _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const &&>  : public _Arg_types< const _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) volatile &&>  : public _Arg_types< volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__vectorcall _Arg0::*)(_Types ...) const volatile &&>  : public _Arg_types< const volatile _Arg0 *, _Types...>  { using _Bool_type = std::true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false, _Ret (_Types ...)> ; }; 
#line 227
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...)>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< is_integral_v< double> > ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile &&>  { using _Bool_type = true_type; typedef _Ret result_type; using _Class_type = _Arg0; using _Guide_type = enable_if< false> ; }; 
#line 231
template< class _Ty> 
#line 232
struct is_void : public false_type { 
#line 235
}; 
#line 244
template<> struct is_void< void>  : public true_type { }; template<> struct is_void< const void>  : public true_type { }; template<> struct is_void< volatile void>  : public true_type { }; template<> struct is_void< const volatile void>  : public true_type { }; 
#line 247
template< class _Ty> constexpr bool 
#line 248
is_void_v = (is_void< _Ty> ::value); 
#line 251
template< class ..._Types> using void_t = void; 
#line 256
template< class _Ty> 
#line 257
struct add_const { 
#line 259
using type = const _Ty; 
#line 260
}; 
#line 262
template< class _Ty> using add_const_t = const _Ty; 
#line 266
template< class _Ty> 
#line 267
struct add_volatile { 
#line 269
using type = volatile _Ty; 
#line 270
}; 
#line 272
template< class _Ty> using add_volatile_t = volatile _Ty; 
#line 276
template< class _Ty> 
#line 277
struct add_cv { 
#line 279
using type = const volatile _Ty; 
#line 280
}; 
#line 282
template< class _Ty> using add_cv_t = const volatile _Ty; 
#line 286
template< class _Ty, class 
#line 287
 = void> 
#line 288
struct _Add_reference { 
#line 290
using _Lvalue = _Ty; 
#line 291
using _Rvalue = _Ty; 
#line 292
}; 
#line 294
template< class _Ty> 
#line 295
struct _Add_reference< _Ty, void_t< _Ty &> >  { 
#line 297
using _Lvalue = _Ty &; 
#line 298
using _Rvalue = _Ty &&; 
#line 299
}; 
#line 302
template< class _Ty> 
#line 303
struct add_lvalue_reference { 
#line 305
using type = typename _Add_reference< _Ty> ::_Lvalue; 
#line 306
}; 
#line 308
template< class _Ty> using add_lvalue_reference_t = typename _Add_reference< _Ty> ::_Lvalue; 
#line 312
template< class _Ty> 
#line 313
struct add_rvalue_reference { 
#line 315
using type = typename _Add_reference< _Ty> ::_Rvalue; 
#line 316
}; 
#line 318
template< class _Ty> using add_rvalue_reference_t = typename _Add_reference< _Ty> ::_Rvalue; 
#line 322
template< class _Ty> add_rvalue_reference_t< _Ty>  declval() noexcept; 
#line 326
template< class _Ty> 
#line 327
struct remove_extent { 
#line 329
using type = _Ty; 
#line 330
}; 
#line 332
template< class _Ty, size_t _Ix> 
#line 333
struct remove_extent< _Ty [_Ix]>  { 
#line 335
using type = _Ty; 
#line 336
}; 
#line 338
template< class _Ty> 
#line 339
struct remove_extent< _Ty []>  { 
#line 341
using type = _Ty; 
#line 342
}; 
#line 344
template< class _Ty> using remove_extent_t = typename remove_extent< _Ty> ::type; 
#line 348
template< class _Ty> 
#line 349
struct remove_all_extents { 
#line 351
using type = _Ty; 
#line 352
}; 
#line 354
template< class _Ty, size_t _Ix> 
#line 355
struct remove_all_extents< _Ty [_Ix]>  { 
#line 357
using type = typename std::remove_all_extents< _Ty> ::type; 
#line 358
}; 
#line 360
template< class _Ty> 
#line 361
struct remove_all_extents< _Ty []>  { 
#line 363
using type = typename std::remove_all_extents< _Ty> ::type; 
#line 364
}; 
#line 366
template< class _Ty> using remove_all_extents_t = typename remove_all_extents< _Ty> ::type; 
#line 370
template< class _Ty> 
#line 371
struct remove_pointer { 
#line 373
using type = _Ty; 
#line 374
}; 
#line 383
template< class _Ty> struct remove_pointer< _Ty *>  { using type = _Ty; }; template< class _Ty> struct remove_pointer< _Ty *const>  { using type = _Ty; }; template< class _Ty> struct remove_pointer< _Ty *volatile>  { using type = _Ty; }; template< class _Ty> struct remove_pointer< _Ty *const volatile>  { using type = _Ty; }; 
#line 386
template< class _Ty> using remove_pointer_t = typename remove_pointer< _Ty> ::type; 
#line 390
template< class _Ty, class 
#line 391
 = void> 
#line 392
struct _Add_pointer { 
#line 394
using type = _Ty; 
#line 395
}; 
#line 397
template< class _Ty> 
#line 398
struct _Add_pointer< _Ty, void_t< remove_reference_t< _Ty>  *> >  { 
#line 400
using type = remove_reference_t< _Ty>  *; 
#line 401
}; 
#line 403
template< class _Ty> 
#line 404
struct add_pointer { 
#line 406
using type = typename _Add_pointer< _Ty> ::type; 
#line 407
}; 
#line 409
template< class _Ty> using add_pointer_t = typename _Add_pointer< _Ty> ::type; 
#line 414
template< class _Ty> 
#line 415
struct is_array : public false_type { 
#line 418
}; 
#line 420
template< class _Ty, size_t _Nx> 
#line 421
struct is_array< _Ty [_Nx]>  : public true_type { 
#line 424
}; 
#line 426
template< class _Ty> 
#line 427
struct is_array< _Ty []>  : public true_type { 
#line 430
}; 
#line 432
template< class _Ty> constexpr bool 
#line 433
is_array_v = (is_array< _Ty> ::value); 
#line 436
template< class _Ty> 
#line 437
struct is_lvalue_reference : public false_type { 
#line 440
}; 
#line 442
template< class _Ty> 
#line 443
struct is_lvalue_reference< _Ty &>  : public true_type { 
#line 446
}; 
#line 448
template< class _Ty> constexpr bool 
#line 449
is_lvalue_reference_v = (is_lvalue_reference< _Ty> ::value); 
#line 452
template< class _Ty> 
#line 453
struct is_rvalue_reference : public false_type { 
#line 456
}; 
#line 458
template< class _Ty> 
#line 459
struct is_rvalue_reference< _Ty &&>  : public true_type { 
#line 462
}; 
#line 464
template< class _Ty> constexpr bool 
#line 465
is_rvalue_reference_v = (is_rvalue_reference< _Ty> ::value); 
#line 468
template< class _Ty> 
#line 469
struct is_reference : public false_type { 
#line 472
}; 
#line 474
template< class _Ty> 
#line 475
struct is_reference< _Ty &>  : public true_type { 
#line 478
}; 
#line 480
template< class _Ty> 
#line 481
struct is_reference< _Ty &&>  : public true_type { 
#line 484
}; 
#line 486
template< class _Ty> constexpr bool 
#line 487
is_reference_v = (is_reference< _Ty> ::value); 
#line 490
template< class _Ty, bool 
#line 491
_Pmf = _Is_memfunptr< _Ty> ::_Bool_type::value> 
#line 492
struct _Is_member_object_pointer : public false_type { 
#line 495
}; 
#line 497
template< class _Ty1, class 
#line 498
_Ty2> 
#line 499
struct _Is_member_object_pointer< _Ty1 _Ty2::*, false>  : public true_type { 
#line 502
using _Class_type = _Ty2; 
#line 503
}; 
#line 505
template< class _Ty> 
#line 506
struct is_member_object_pointer : public _Is_member_object_pointer< remove_cv_t< _Ty> > ::type { 
#line 509
}; 
#line 511
template< class _Ty> constexpr bool 
#line 512
is_member_object_pointer_v = (is_member_object_pointer< _Ty> ::value); 
#line 515
template< class _Ty> 
#line 516
struct is_member_function_pointer : public _Is_memfunptr< remove_cv_t< _Ty> > ::_Bool_type { 
#line 519
}; 
#line 521
template< class _Ty> constexpr bool 
#line 522
is_member_function_pointer_v = (is_member_function_pointer< _Ty> ::value); 
#line 525
template< class _Ty> 
#line 526
struct is_pointer : public false_type { 
#line 529
}; 
#line 531
template< class _Ty> 
#line 532
struct is_pointer< _Ty *>  : public true_type { 
#line 535
}; 
#line 537
template< class _Ty> 
#line 538
struct is_pointer< _Ty *const>  : public true_type { 
#line 541
}; 
#line 543
template< class _Ty> 
#line 544
struct is_pointer< _Ty *volatile>  : public true_type { 
#line 547
}; 
#line 549
template< class _Ty> 
#line 550
struct is_pointer< _Ty *const volatile>  : public true_type { 
#line 553
}; 
#line 555
template< class _Ty> constexpr bool 
#line 556
is_pointer_v = (is_pointer< _Ty> ::value); 
#line 559
template< class _Ty> 
#line 560
struct is_null_pointer : public bool_constant< is_same_v< remove_cv_t< _Ty> , std::nullptr_t> >  { 
#line 563
}; 
#line 565
template< class _Ty> constexpr bool 
#line 566
is_null_pointer_v = is_same_v< remove_cv_t< _Ty> , std::nullptr_t> ; 
#line 569
template< class _Ty> 
#line 570
struct is_union : public bool_constant< __is_union(_Ty)>  { 
#line 573
}; 
#line 575
template< class _Ty> constexpr bool 
#line 576
is_union_v = __is_union(_Ty); 
#line 579
template< class _Ty> 
#line 580
struct is_class : public bool_constant< __is_class(_Ty)>  { 
#line 583
}; 
#line 585
template< class _Ty> constexpr bool 
#line 586
is_class_v = __is_class(_Ty); 
#line 589
template< class _Ty> 
#line 590
struct is_fundamental : public bool_constant< (is_arithmetic_v< _Ty>  || is_void_v< _Ty> ) || is_null_pointer_v< _Ty> >  { 
#line 595
}; 
#line 597
template< class _Ty> constexpr bool 
#line 598
is_fundamental_v = (is_fundamental< _Ty> ::value); 
#line 601
template< class _Ty> 
#line 602
struct is_object : public bool_constant< ((!is_function_v< _Ty> ) && (!is_reference_v< _Ty> )) && (!is_void_v< _Ty> )>  { 
#line 607
}; 
#line 609
template< class _Ty> constexpr bool 
#line 610
is_object_v = (is_object< _Ty> ::value); 
#line 613
template< class _From, class 
#line 614
_To> 
#line 615
struct is_convertible : public bool_constant< __is_convertible_to(_From, _To)>  { 
#line 618
}; 
#line 620
template< class _From, class 
#line 621
_To> constexpr bool 
#line 622
is_convertible_v = __is_convertible_to(_From, _To); 
#line 625
template< class _Ty> 
#line 626
struct is_enum : public bool_constant< __is_enum(_Ty)>  { 
#line 629
}; 
#line 631
template< class _Ty> constexpr bool 
#line 632
is_enum_v = __is_enum(_Ty); 
#line 635
template< class _Ty> 
#line 636
struct is_compound : public bool_constant< !is_fundamental_v< _Ty> >  { 
#line 639
}; 
#line 641
template< class _Ty> constexpr bool 
#line 642
is_compound_v = (is_compound< _Ty> ::value); 
#line 645
template< class _Ty> 
#line 646
struct is_member_pointer : public bool_constant< is_member_object_pointer_v< _Ty>  || is_member_function_pointer_v< _Ty> >  { 
#line 650
}; 
#line 652
template< class _Ty> constexpr bool 
#line 653
is_member_pointer_v = (is_member_pointer< _Ty> ::value); 
#line 656
template< class _Ty> 
#line 657
struct is_scalar : public bool_constant< (((is_arithmetic_v< _Ty>  || is_enum_v< _Ty> ) || is_pointer_v< _Ty> ) || is_member_pointer_v< _Ty> ) || is_null_pointer_v< _Ty> >  { 
#line 664
}; 
#line 666
template< class _Ty> constexpr bool 
#line 667
is_scalar_v = (is_scalar< _Ty> ::value); 
#line 670
template< class _Ty> 
#line 671
struct is_const : public false_type { 
#line 674
}; 
#line 676
template< class _Ty> 
#line 677
struct is_const< const _Ty>  : public true_type { 
#line 680
}; 
#line 682
template< class _Ty> constexpr bool 
#line 683
is_const_v = (is_const< _Ty> ::value); 
#line 686
template< class _Ty> 
#line 687
struct is_volatile : public false_type { 
#line 690
}; 
#line 692
template< class _Ty> 
#line 693
struct is_volatile< volatile _Ty>  : public true_type { 
#line 696
}; 
#line 698
template< class _Ty> constexpr bool 
#line 699
is_volatile_v = (is_volatile< _Ty> ::value); 
#line 702
template< class _Ty> 
#line 703
struct is_pod : public bool_constant< __is_pod(_Ty)>  { 
#line 706
}; 
#line 708
template< class _Ty> constexpr bool 
#line 709
is_pod_v = __is_pod(_Ty); 
#line 712
template< class _Ty> 
#line 713
struct is_empty : public bool_constant< __is_empty(_Ty)>  { 
#line 716
}; 
#line 718
template< class _Ty> constexpr bool 
#line 719
is_empty_v = __is_empty(_Ty); 
#line 722
template< class _Ty> 
#line 723
struct is_polymorphic : public bool_constant< __is_polymorphic(_Ty)>  { 
#line 726
}; 
#line 728
template< class _Ty> constexpr bool 
#line 729
is_polymorphic_v = __is_polymorphic(_Ty); 
#line 732
template< class _Ty> 
#line 733
struct is_abstract : public bool_constant< __is_abstract(_Ty)>  { 
#line 736
}; 
#line 738
template< class _Ty> constexpr bool 
#line 739
is_abstract_v = __is_abstract(_Ty); 
#line 742
template< class _Ty> 
#line 743
struct is_final : public bool_constant< __is_final(_Ty)>  { 
#line 746
}; 
#line 748
template< class _Ty> constexpr bool 
#line 749
is_final_v = __is_final(_Ty); 
#line 752
template< class _Ty> 
#line 753
struct is_standard_layout : public bool_constant< __is_standard_layout(_Ty)>  { 
#line 756
}; 
#line 758
template< class _Ty> constexpr bool 
#line 759
is_standard_layout_v = __is_standard_layout(_Ty); 
#line 762
template< class _Ty> 
#line 763
struct is_literal_type : public bool_constant< __is_literal_type(_Ty)>  { 
#line 766
}; 
#line 768
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> constexpr bool 
#line 771
is_literal_type_v = __is_literal_type(_Ty); 
#pragma warning(pop)
#line 775
template< class _Ty> 
#line 776
struct is_trivial : public bool_constant< __is_trivial(_Ty)>  { 
#line 779
}; 
#line 781
template< class _Ty> constexpr bool 
#line 782
is_trivial_v = __is_trivial(_Ty); 
#line 785
template< class _Ty> 
#line 786
struct is_trivially_copyable : public bool_constant< __is_trivially_copyable(_Ty)>  { 
#line 789
}; 
#line 791
template< class _Ty> constexpr bool 
#line 792
is_trivially_copyable_v = __is_trivially_copyable(_Ty); 
#line 795
template< class _Ty> 
#line 796
struct has_virtual_destructor : public bool_constant< __has_virtual_destructor(_Ty)>  { 
#line 799
}; 
#line 801
template< class _Ty> constexpr bool 
#line 802
has_virtual_destructor_v = __has_virtual_destructor(_Ty); 
#line 828 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
template< class _Ty, class ...
#line 829
_Args> 
#line 830
struct is_constructible : public bool_constant< __is_constructible(_Ty, _Args...)>  { 
#line 833
}; 
#line 835
template< class _Ty, class ...
#line 836
_Args> constexpr bool 
#line 837
is_constructible_v = __is_constructible(_Ty, _Args...); 
#line 840
template< class _Ty> 
#line 841
struct is_copy_constructible : public bool_constant< __is_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 844
}; 
#line 846
template< class _Ty> constexpr bool 
#line 847
is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 850
template< class _Ty> 
#line 851
struct is_default_constructible : public bool_constant< __is_constructible(_Ty)>  { 
#line 854
}; 
#line 856
template< class _Ty> constexpr bool 
#line 857
is_default_constructible_v = __is_constructible(_Ty); 
#line 860
template< class _Ty, class 
#line 861
 = void> 
#line 862
struct _Is_implicitly_default_constructible : public false_type { 
#line 865
}; 
#line 867
template< class _Ty> void _Implicitly_default_construct(const _Ty &); 
#line 870
template< class _Ty> 
#line 871
struct _Is_implicitly_default_constructible< _Ty, void_t< decltype((_Implicitly_default_construct< _Ty> ({})))> >  : public true_type { 
#line 874
}; 
#line 877
template< class _Ty> 
#line 878
struct is_move_constructible : public bool_constant< __is_constructible(_Ty, _Ty)>  { 
#line 881
}; 
#line 883
template< class _Ty> constexpr bool 
#line 884
is_move_constructible_v = __is_constructible(_Ty, _Ty); 
#line 887
template< class _To, class 
#line 888
_From> 
#line 889
struct is_assignable : public bool_constant< __is_assignable(_To, _From)>  { 
#line 892
}; 
#line 894
template< class _To, class 
#line 895
_From> constexpr bool 
#line 896
is_assignable_v = __is_assignable(_To, _From); 
#line 899
template< class _Ty> 
#line 900
struct is_copy_assignable : public bool_constant< __is_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 903
}; 
#line 905
template< class _Ty> constexpr bool 
#line 906
is_copy_assignable_v = __is_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 910
template< class _Ty> 
#line 911
struct is_move_assignable : public bool_constant< __is_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 914
}; 
#line 916
template< class _Ty> constexpr bool 
#line 917
is_move_assignable_v = __is_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 920
template< class _Ty> 
#line 921
struct is_destructible : public bool_constant< __is_destructible(_Ty)>  { 
#line 924
}; 
#line 926
template< class _Ty> constexpr bool 
#line 927
is_destructible_v = __is_destructible(_Ty); 
#line 931
template< class _Ty, class ...
#line 932
_Args> 
#line 933
struct is_trivially_constructible : public bool_constant< __is_trivially_constructible(_Ty, _Args...)>  { 
#line 936
}; 
#line 938
template< class _Ty, class ...
#line 939
_Args> constexpr bool 
#line 940
is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...); 
#line 943
template< class _Ty> 
#line 944
struct is_trivially_copy_constructible : public bool_constant< __is_trivially_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 947
}; 
#line 949
template< class _Ty> constexpr bool 
#line 950
is_trivially_copy_constructible_v = __is_trivially_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 954
template< class _Ty> 
#line 955
struct is_trivially_default_constructible : public bool_constant< __is_trivially_constructible(_Ty)>  { 
#line 958
}; 
#line 960
template< class _Ty> constexpr bool 
#line 961
is_trivially_default_constructible_v = __is_trivially_constructible(_Ty); 
#line 964
template< class _Ty> 
#line 965
struct is_trivially_move_constructible : public bool_constant< __is_trivially_constructible(_Ty, _Ty)>  { 
#line 968
}; 
#line 970
template< class _Ty> constexpr bool 
#line 971
is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty); 
#line 974
template< class _To, class 
#line 975
_From> 
#line 976
struct is_trivially_assignable : public bool_constant< __is_trivially_assignable(_To, _From)>  { 
#line 979
}; 
#line 981
template< class _To, class 
#line 982
_From> constexpr bool 
#line 983
is_trivially_assignable_v = __is_trivially_assignable(_To, _From); 
#line 986
template< class _Ty> 
#line 987
struct is_trivially_copy_assignable : public bool_constant< __is_trivially_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 990
}; 
#line 992
template< class _Ty> constexpr bool 
#line 993
is_trivially_copy_assignable_v = __is_trivially_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 997
template< class _Ty> 
#line 998
struct is_trivially_move_assignable : public bool_constant< __is_trivially_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 1001
}; 
#line 1003
template< class _Ty> constexpr bool 
#line 1004
is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 1008
template< class _Ty> 
#line 1009
struct is_trivially_destructible : public bool_constant< __is_trivially_destructible(_Ty)>  { 
#line 1012
}; 
#line 1014
template< class _Ty> constexpr bool 
#line 1015
is_trivially_destructible_v = __is_trivially_destructible(_Ty); 
#line 1019
template< class _Ty, class ...
#line 1020
_Args> 
#line 1021
struct is_nothrow_constructible : public bool_constant< __is_nothrow_constructible(_Ty, _Args...)>  { 
#line 1024
}; 
#line 1026
template< class _Ty, class ...
#line 1027
_Args> constexpr bool 
#line 1028
is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...); 
#line 1031
template< class _Ty> 
#line 1032
struct is_nothrow_copy_constructible : public bool_constant< __is_nothrow_constructible(_Ty, add_lvalue_reference_t< const _Ty> )>  { 
#line 1035
}; 
#line 1037
template< class _Ty> constexpr bool 
#line 1038
is_nothrow_copy_constructible_v = __is_nothrow_constructible(_Ty, add_lvalue_reference_t< const _Ty> ); 
#line 1042
template< class _Ty> 
#line 1043
struct is_nothrow_default_constructible : public bool_constant< __is_nothrow_constructible(_Ty)>  { 
#line 1046
}; 
#line 1048
template< class _Ty> constexpr bool 
#line 1049
is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty); 
#line 1052
template< class _Ty> 
#line 1053
struct is_nothrow_move_constructible : public bool_constant< __is_nothrow_constructible(_Ty, _Ty)>  { 
#line 1056
}; 
#line 1058
template< class _Ty> constexpr bool 
#line 1059
is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty); 
#line 1062
template< class _To, class 
#line 1063
_From> 
#line 1064
struct is_nothrow_assignable : public bool_constant< __is_nothrow_assignable(_To, _From)>  { 
#line 1067
}; 
#line 1069
template< class _To, class 
#line 1070
_From> constexpr bool 
#line 1071
is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From); 
#line 1074
template< class _Ty> 
#line 1075
struct is_nothrow_copy_assignable : public bool_constant< __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> )>  { 
#line 1078
}; 
#line 1080
template< class _Ty> constexpr bool 
#line 1081
is_nothrow_copy_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< const _Ty> ); 
#line 1085
template< class _Ty> 
#line 1086
struct is_nothrow_move_assignable : public bool_constant< __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , _Ty)>  { 
#line 1089
}; 
#line 1091
template< class _Ty> constexpr bool 
#line 1092
is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t< _Ty> , _Ty); 
#line 1095
template< class _Ty> 
#line 1096
struct is_nothrow_destructible : public bool_constant< __is_nothrow_destructible(_Ty)>  { 
#line 1099
}; 
#line 1101
template< class _Ty> constexpr bool 
#line 1102
is_nothrow_destructible_v = __is_nothrow_destructible(_Ty); 
#line 1105
#pragma warning(push)
#pragma warning(disable: 4296)
template< class _Ty, bool 
#line 1108
 = is_integral_v< _Ty> > 
#line 1109
struct _Sign_base { 
#line 1111
using _Uty = remove_cv_t< _Ty> ; 
#line 1112
using _Signed = bool_constant< (((remove_cv_t< _Ty> )(-1)) < ((remove_cv_t< _Ty> )0))> ; 
#line 1113
using _Unsigned = bool_constant< (((remove_cv_t< _Ty> )0) < ((remove_cv_t< _Ty> )(-1)))> ; 
#line 1114
}; 
#pragma warning(pop)
#line 1117
template< class _Ty> 
#line 1118
struct _Sign_base< _Ty, false>  { 
#line 1121
using _Signed = typename is_floating_point< _Ty> ::type; 
#line 1122
using _Unsigned = false_type; 
#line 1123
}; 
#line 1125
template< class _Ty> 
#line 1126
struct is_signed : public _Sign_base< _Ty> ::_Signed { 
#line 1129
}; 
#line 1131
template< class _Ty> constexpr bool 
#line 1132
is_signed_v = (is_signed< _Ty> ::value); 
#line 1135
template< class _Ty> 
#line 1136
struct is_unsigned : public _Sign_base< _Ty> ::_Unsigned { 
#line 1139
}; 
#line 1141
template< class _Ty> constexpr bool 
#line 1142
is_unsigned_v = (is_unsigned< _Ty> ::value); 
#line 1145
template< class _Ty> using _Is_nonbool_integral = bool_constant< is_integral_v< _Ty>  && (!is_same_v< remove_cv_t< _Ty> , bool> )> ; 
#line 1151
template< class _Ty> 
#line 1152
struct _Change_sign { 
#line 1154
static_assert((_Is_nonbool_integral< _Ty> ::value || is_enum_v< _Ty> ), "make_signed<T>/make_unsigned<T> require that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool ty" "pe.");
#line 1158
using _Signed = conditional_t< _Is_any_of_v< _Ty, long, unsigned long> , long, conditional_t< sizeof(_Ty) == (1), signed char, conditional_t< sizeof(_Ty) == (2), short, conditional_t< sizeof(_Ty) == (4), int, __int64> > > > ; 
#line 1166
using _Unsigned = conditional_t< _Is_any_of_v< _Ty, long, unsigned long> , unsigned long, conditional_t< sizeof(_Ty) == (1), unsigned char, conditional_t< sizeof(_Ty) == (2), unsigned short, conditional_t< sizeof(_Ty) == (4), unsigned, unsigned __int64> > > > ; 
#line 1173
}; 
#line 1175
template< class _Ty> 
#line 1176
struct _Change_sign< const _Ty>  { 
#line 1178
using _Signed = const typename std::_Change_sign< _Ty> ::_Signed; 
#line 1179
using _Unsigned = const typename std::_Change_sign< _Ty> ::_Unsigned; 
#line 1180
}; 
#line 1182
template< class _Ty> 
#line 1183
struct _Change_sign< volatile _Ty>  { 
#line 1185
using _Signed = volatile typename std::_Change_sign< _Ty> ::_Signed; 
#line 1186
using _Unsigned = volatile typename std::_Change_sign< _Ty> ::_Unsigned; 
#line 1187
}; 
#line 1189
template< class _Ty> 
#line 1190
struct _Change_sign< const volatile _Ty>  { 
#line 1192
using _Signed = const volatile typename std::_Change_sign< _Ty> ::_Signed; 
#line 1193
using _Unsigned = const volatile typename std::_Change_sign< _Ty> ::_Unsigned; 
#line 1194
}; 
#line 1197
template< class _Ty> 
#line 1198
struct make_signed { 
#line 1200
using type = typename _Change_sign< _Ty> ::_Signed; 
#line 1201
}; 
#line 1203
template< class _Ty> using make_signed_t = typename make_signed< _Ty> ::type; 
#line 1207
template< class _Ty> 
#line 1208
struct make_unsigned { 
#line 1210
using type = typename _Change_sign< _Ty> ::_Unsigned; 
#line 1211
}; 
#line 1213
template< class _Ty> using make_unsigned_t = typename make_unsigned< _Ty> ::type; 
#line 1217
template < class _Rep >
 constexpr make_unsigned_t < _Rep > _Unsigned_value ( _Rep _Val )
 {
 return ( static_cast < make_unsigned_t < _Rep >> ( _Val ) );
 }
#line 1224
template< class _Ty> 
#line 1225
struct alignment_of : public integral_constant< unsigned __int64, __alignof(_Ty)>  { 
#line 1228
}; 
#line 1230
template< class _Ty> constexpr size_t 
#line 1231
alignment_of_v = __alignof(_Ty); 
#line 1238
template< class _Ty, size_t 
#line 1239
_Len> 
#line 1240
union _Align_type { 
#line 1242
_Ty _Val; 
#line 1243
char _Pad[_Len]; 
#line 1244
}; 
#line 1246
template< size_t _Len, size_t 
#line 1247
_Align, class 
#line 1248
_Ty, bool 
#line 1249
_Ok> struct _Aligned; 
#line 1252
template< size_t _Len, size_t 
#line 1253
_Align, class 
#line 1254
_Ty> 
#line 1255
struct _Aligned< _Len, _Align, _Ty, true>  { 
#line 1257
using type = _Align_type< _Ty, _Len> ; 
#line 1258
}; 
#line 1260
template< size_t _Len, size_t 
#line 1261
_Align> 
#line 1262
struct _Aligned< _Len, _Align, double, false>  { 
#line 1271
static_assert((_Always_false< std::_Aligned< _Len, _Align, double, false> > ), "You\'ve instantiated std::aligned_storage<Len, Align> with an extended alignment (in other words, Align > alignof(max_align_t))." " Before VS 2017 15.8, the member type would non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fi" "xed to handle this correctly, but the fix inherently changes layout and breaks binary compatibility (*only* for uses of aligned_" "storage with extended alignments). Please define either (1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand " "this message and that you actually want a type with an extended alignment, or (2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence t" "his message and get the old non-conformant behavior.");
#line 1283 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
using type = _Align_type< double, _Len> ; 
#line 1285 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
}; 
#line 1287
template< size_t _Len, size_t 
#line 1288
_Align> 
#line 1289
struct _Aligned< _Len, _Align, int, false>  { 
#line 1291
using type = typename std::_Aligned< _Len, _Align, double, _Align <= __alignof(double)> ::type; 
#line 1292
}; 
#line 1294
template< size_t _Len, size_t 
#line 1295
_Align> 
#line 1296
struct _Aligned< _Len, _Align, short, false>  { 
#line 1298
using type = typename std::_Aligned< _Len, _Align, int, _Align <= __alignof(int)> ::type; 
#line 1299
}; 
#line 1301
template< size_t _Len, size_t 
#line 1302
_Align> 
#line 1303
struct _Aligned< _Len, _Align, char, false>  { 
#line 1305
using type = typename std::_Aligned< _Len, _Align, short, _Align <= __alignof(short)> ::type; 
#line 1306
}; 
#line 1308
template< size_t _Len, size_t 
#line 1309
_Align = 8Ui64> 
#line 1310
struct aligned_storage { 
#line 1312
using type = typename _Aligned< _Len, _Align, char, _Align <= __alignof(char)> ::type; 
#line 1313
}; 
#line 1318
template< size_t _Len, size_t 
#line 1319
_Align = 8Ui64> using aligned_storage_t = typename aligned_storage< _Len, _Align> ::type; 
#line 1323
template< size_t ..._Vals> struct _Maximum; 
#line 1327
template<> struct _Maximum< >  : public integral_constant< unsigned __int64, 0Ui64>  { 
#line 1330
}; 
#line 1332
template< size_t _Val> 
#line 1333
struct _Maximum< _Val>  : public integral_constant< unsigned __int64, _Val>  { 
#line 1336
}; 
#line 1338
template< size_t _First, size_t 
#line 1339
_Second, size_t ...
#line 1340
_Rest> 
#line 1341
struct _Maximum< _First, _Second, _Rest...>  : public std::_Maximum< (((_First) < _Second) ? _Second : _First), _Rest...> ::type { 
#line 1344
}; 
#line 1346
template< size_t _Len, class ...
#line 1347
_Types> 
#line 1348
struct aligned_union { 
#line 1350
static constexpr size_t _Max_len = (_Maximum< _Len, sizeof(_Types)...> ::value); 
#line 1351
static constexpr size_t alignment_value = (_Maximum< __alignof(_Types)...> ::value); 
#line 1352
using type = aligned_storage_t< _Max_len, alignment_value> ; 
#line 1353
}; 
#line 1355
template< size_t _Len, class ...
#line 1356
_Types> using aligned_union_t = typename aligned_union< _Len, _Types...> ::type; 
#line 1360
template< class _Ty> 
#line 1361
struct underlying_type { 
#line 1363
using type = __underlying_type(_Ty); 
#line 1364
}; 
#line 1366
template< class _Ty> using underlying_type_t = typename underlying_type< _Ty> ::type; 
#line 1370
template< class _Ty> 
#line 1371
struct rank : public integral_constant< unsigned __int64, 0Ui64>  { 
#line 1374
}; 
#line 1376
template< class _Ty, size_t _Ix> 
#line 1377
struct rank< _Ty [_Ix]>  : public integral_constant< unsigned __int64, std::rank< _Ty> ::value + 1>  { 
#line 1380
}; 
#line 1382
template< class _Ty> 
#line 1383
struct rank< _Ty []>  : public integral_constant< unsigned __int64, std::rank< _Ty> ::value + 1>  { 
#line 1386
}; 
#line 1388
template< class _Ty> constexpr size_t 
#line 1389
rank_v = (rank< _Ty> ::value); 
#line 1392
template< class _Ty, unsigned _Nx> 
#line 1393
struct _Extent : public integral_constant< unsigned __int64, 0Ui64>  { 
#line 1396
}; 
#line 1398
template< class _Ty, size_t _Ix> 
#line 1399
struct _Extent< _Ty [_Ix], 0>  : public integral_constant< unsigned __int64, _Ix>  { 
#line 1402
}; 
#line 1404
template< class _Ty, unsigned _Nx, size_t _Ix> 
#line 1405
struct _Extent< _Ty [_Ix], _Nx>  : public std::_Extent< _Ty, _Nx - (1)>  { 
#line 1408
}; 
#line 1410
template< class _Ty, unsigned _Nx> 
#line 1411
struct _Extent< _Ty [], _Nx>  : public std::_Extent< _Ty, _Nx - (1)>  { 
#line 1414
}; 
#line 1416
template< class _Ty, unsigned _Nx = 0U> 
#line 1417
struct extent : public _Extent< _Ty, _Nx>  { 
#line 1420
}; 
#line 1422
template< class _Ty, unsigned 
#line 1423
_Ix = 0U> constexpr size_t 
#line 1424
extent_v = (extent< _Ty, _Ix> ::value); 
#line 1427
template< class _Base, class 
#line 1428
_Derived> 
#line 1429
struct is_base_of : public bool_constant< __is_base_of(_Base, _Derived)>  { 
#line 1432
}; 
#line 1434
template< class _Base, class 
#line 1435
_Derived> constexpr bool 
#line 1436
is_base_of_v = __is_base_of(_Base, _Derived); 
#line 1439
template< class _Ty> 
#line 1440
struct decay { 
#line 1442
using _Ty1 = remove_reference_t< _Ty> ; 
#line 1444
using type = conditional_t< is_array_v< remove_reference_t< _Ty> > , add_pointer_t< remove_extent_t< remove_reference_t< _Ty> > > , conditional_t< is_function_v< remove_reference_t< _Ty> > , add_pointer_t< remove_reference_t< _Ty> > , remove_cv_t< remove_reference_t< _Ty> > > > ; 
#line 1449
}; 
#line 1451
template< class _Ty> using decay_t = typename decay< _Ty> ::type; 
#line 1455
template< class _Ty1, class 
#line 1456
_Ty2, class 
#line 1457
 = void> 
#line 1458
struct _Decayed_cond_oper { 
#line 1460
}; 
#line 1462
template< class _Ty1, class 
#line 1463
_Ty2> 
#line 1464
struct _Decayed_cond_oper< _Ty1, _Ty2, void_t< decltype((false ? std::declval< _Ty1> () : std::declval< _Ty2> ()))> >  { 
#line 1466
using type = decay_t< decltype((false ? std::declval< _Ty1> () : std::declval< _Ty2> ()))> ; 
#line 1467
}; 
#line 1469
template< class ..._Ty> struct common_type; 
#line 1472
template< class ..._Ty> using common_type_t = typename common_type< _Ty...> ::type; 
#line 1476
template<> struct common_type< >  { 
#line 1478
}; 
#line 1480
template< class _Ty1> 
#line 1481
struct common_type< _Ty1>  : public std::common_type< _Ty1, _Ty1>  { 
#line 1484
}; 
#line 1486
template< class _Ty1, class 
#line 1487
_Ty2, class 
#line 1488
_Decayed1 = decay_t< _Ty1> , class 
#line 1489
_Decayed2 = decay_t< _Ty2> > 
#line 1490
struct _Common_type2 : public common_type< _Decayed1, _Decayed2>  { 
#line 1493
}; 
#line 1495
template< class _Ty1, class 
#line 1496
_Ty2> 
#line 1497
struct _Common_type2< _Ty1, _Ty2, _Ty1, _Ty2>  : public _Decayed_cond_oper< _Ty1, _Ty2>  { 
#line 1500
}; 
#line 1502
template< class _Ty1, class 
#line 1503
_Ty2> 
#line 1504
struct common_type< _Ty1, _Ty2>  : public _Common_type2< _Ty1, _Ty2>  { 
#line 1507
}; 
#line 1509
template< class _Void, class 
#line 1510
_Ty1, class 
#line 1511
_Ty2, class ...
#line 1512
_Rest> 
#line 1513
struct _Common_type3 { 
#line 1515
}; 
#line 1517
template< class _Ty1, class 
#line 1518
_Ty2, class ...
#line 1519
_Rest> 
#line 1520
struct _Common_type3< void_t< common_type_t< _Ty1, _Ty2> > , _Ty1, _Ty2, _Rest...>  : public common_type< common_type_t< _Ty1, _Ty2> , _Rest...>  { 
#line 1523
}; 
#line 1525
template< class _Ty1, class 
#line 1526
_Ty2, class ...
#line 1527
_Rest> 
#line 1528
struct common_type< _Ty1, _Ty2, _Rest...>  : public _Common_type3< void, _Ty1, _Ty2, _Rest...>  { 
#line 1531
}; 
#line 1535
template < class _Ty >
 struct [ [ deprecated ( "warning STL4003: The non-Standard std::identity struct is deprecated and will be REMOVED. You can define _SILENCE_IDENTITY_STRUC" "T_DEPRECATION_WARNING to acknowledge that you have received this warning." ) ] ] identity
 {
 using type = _Ty;

 const _Ty & operator ( ) ( const _Ty & _Left ) const
  {
  return ( _Left );
  }
 };
#line 1548 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
template< class _Ty> 
#line 1549
struct _Identity { 
#line 1551
using type = _Ty; 
#line 1552
}; 
#line 1553
template< class _Ty> using _Identity_t = typename _Identity< _Ty> ::type; 
#line 1557
template< class _Type, 
#line 1558
template< class ...>  class _Template> constexpr bool 
#line 1559
_Is_specialization_v = false; 
#line 1560
template< template< class ...>  class _Template, class ...
#line 1561
_Types> constexpr bool 
#line 1562
_Is_specialization_v< _Template< _Types...> , _Template>  = true; 
#line 1564
template< class _Type, 
#line 1565
template< class ...>  class _Template> 
#line 1566
struct _Is_specialization : public bool_constant< _Is_specialization_v< _Type, _Template> >  { 
#line 1568
}; 
#line 1571
template< class _Ty> constexpr _Ty &&
#line 1572
forward(remove_reference_t< _Ty>  &_Arg) noexcept 
#line 1573
{ 
#line 1574
return static_cast< _Ty &&>(_Arg); 
#line 1575
} 
#line 1577
template< class _Ty> constexpr _Ty &&
#line 1578
forward(remove_reference_t< _Ty>  &&_Arg) noexcept 
#line 1579
{ 
#line 1580
static_assert((!is_lvalue_reference_v< _Ty> ), "bad forward call");
#line 1581
return static_cast< _Ty &&>(_Arg); 
#line 1582
} 
#line 1585
template< class _Ty> constexpr remove_reference_t< _Ty>  &&
#line 1587
move(_Ty &&_Arg) noexcept 
#line 1588
{ 
#line 1589
return static_cast< remove_reference_t< _Ty>  &&>(_Arg); 
#line 1590
} 
#line 1593
template < class _Ty >
  constexpr conditional_t < ! is_nothrow_move_constructible_v < _Ty > && is_copy_constructible_v < _Ty >,
  const _Ty &, _Ty && >
 move_if_noexcept ( _Ty & _Arg ) noexcept
 {
 return ( :: std :: move ( _Arg ) );
 }
#line 1601
template < class _Ty >
 class reference_wrapper;
#line 1771
template< class _Callable, class ...
#line 1772
_Types> struct _Invoker; 
#line 1775
template < class _Callable,
 class ... _Types > inline
 auto invoke ( _Callable && _Obj, _Types && ... _Args )
 noexcept ( noexcept ( _Invoker < _Callable, _Types ... > :: _Call ( :: std :: forward < _Callable > ( _Obj ), :: std :: forward < _Types > ( _Args ) ... ) ) )

 -> decltype ( _Invoker < _Callable, _Types ... > :: _Call (
  :: std :: forward < _Callable > ( _Obj ), :: std :: forward < _Types > ( _Args ) ... ) );
#line 1783 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
struct _Unforced { 
#line 1785
}; 
#line 1788
template< class _To> void _Implicitly_convert_to(_To) noexcept; 
#line 1791
template< class _From, class 
#line 1792
_To, bool 
#line 1793
 = is_convertible_v< _From, _To> > 
#line 1794
struct _Is_nothrow_convertible : public bool_constant< noexcept(_Implicitly_convert_to< _To> (std::declval< _From> ()))>  { 
#line 1797
}; 
#line 1799
template< class _From, class 
#line 1800
_To> 
#line 1801
struct _Is_nothrow_convertible< _From, _To, false>  : public false_type { 
#line 1804
}; 
#line 1806
template< class _Void, class ...
#line 1807
_Types> 
#line 1808
struct _Invoke_traits { 
#line 1810
using _Is_invocable = false_type; 
#line 1811
using _Is_nothrow_invocable = false_type; 
#line 1812
template< class _Rx> using _Is_invocable_r = false_type; 
#line 1814
template< class _Rx> using _Is_nothrow_invocable_r = false_type; 
#line 1816
}; 
#line 1818
template< class ..._Types> 
#line 1819
struct _Invoke_traits< void_t< decltype((std::invoke(std::declval< _Types> ()...)))> , _Types...>  { 
#line 1821
using type = decltype((std::invoke(std::declval< _Types> ()...))); 
#line 1822
using _Is_invocable = true_type; 
#line 1823
using _Is_nothrow_invocable = bool_constant< noexcept(std::invoke(std::declval< _Types> ()...))> ; 
#line 1824
template< class _Rx> using _Is_invocable_r = bool_constant< disjunction_v< is_void< _Rx> , is_convertible< type, _Rx> > > ; 
#line 1826
template< class _Rx> using _Is_nothrow_invocable_r = bool_constant< conjunction_v< bool_constant< noexcept(std::invoke(std::declval< _Types> ()...))> , disjunction< is_void< _Rx> , _Is_nothrow_convertible< type, _Rx> > > > ; 
#line 1830
}; 
#line 1833
template< class _Fty> 
#line 1834
struct result_of { 
#line 1836
static_assert((_Always_false< _Fty> ), "result_of<CallableType> is invalid; use result_of<CallableType(zero or more argument types)> instead.");
#line 1839
}; 
#line 1849
template< class _Callable, class ..._Args> struct result_of< _Callable __cdecl (_Args ...)>  : public _Invoke_traits< void, _Callable, _Args...>  { }; template< class _Callable, class ..._Args> struct result_of< _Callable __vectorcall (_Args ...)>  : public _Invoke_traits< void, _Callable, _Args...>  { }; 
#line 1852
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> using result_of_t = typename result_of< _Ty> ::type; 
#line 1856
#pragma warning(pop)
#line 1858
template< class _Callable, class ...
#line 1859
_Args> using _Invoke_result_t = typename _Invoke_traits< void, _Callable, _Args...> ::type; 
#line 1862
template< class _Rx, class 
#line 1863
_Callable, class ...
#line 1864
_Args> using _Is_invocable_r_ = typename _Invoke_traits< void, _Callable, _Args...> ::template _Is_invocable_r< _Rx> ; 
#line 1867
template< class _Rx, class 
#line 1868
_Callable, class ...
#line 1869
_Args> 
#line 1870
struct _Is_invocable_r : public _Is_invocable_r_< _Rx, _Callable, _Args...>  { 
#line 1873
}; 
#line 1945 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
template< class _Ty, class 
#line 1946
 = void> 
#line 1947
struct _Weak_result_type { 
#line 1949
}; 
#line 1951
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> 
#line 1954
struct _Weak_result_type< _Ty, void_t< typename _Ty::result_type> >  { 
#line 1957
typedef typename _Ty::result_type result_type; 
#line 1958
}; 
#pragma warning(pop)
#line 1961
template< class _Ty, class 
#line 1962
 = void> 
#line 1963
struct _Weak_argument_type : public _Weak_result_type< _Ty>  { 
#line 1966
}; 
#line 1968
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> 
#line 1971
struct _Weak_argument_type< _Ty, void_t< typename _Ty::argument_type> >  : public _Weak_result_type< _Ty>  { 
#line 1975
typedef typename _Ty::argument_type argument_type; 
#line 1976
}; 
#pragma warning(pop)
#line 1979
template< class _Ty, class 
#line 1980
 = void> 
#line 1981
struct _Weak_binary_args : public _Weak_argument_type< _Ty>  { 
#line 1984
}; 
#line 1986
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> 
#line 1989
struct _Weak_binary_args< _Ty, void_t< typename _Ty::first_argument_type, typename _Ty::second_argument_type> >  : public _Weak_argument_type< _Ty>  { 
#line 1994
typedef typename _Ty::first_argument_type first_argument_type; 
#line 1995
typedef typename _Ty::second_argument_type second_argument_type; 
#line 1996
}; 
#pragma warning(pop)
#line 1999
template< class _Ty> 
#line 2000
struct _Weak_types { 
#line 2002
using _Is_f_or_pf = _Is_function< remove_pointer_t< _Ty> > ; 
#line 2003
using _Is_pmf = _Is_memfunptr< remove_cv_t< _Ty> > ; 
#line 2004
using type = conditional_t< _Is_function< remove_pointer_t< _Ty> > ::_Bool_type::value, _Is_function< remove_pointer_t< _Ty> > , conditional_t< _Is_memfunptr< remove_cv_t< _Ty> > ::_Bool_type::value, _Is_memfunptr< remove_cv_t< _Ty> > , _Weak_binary_args< _Ty> > > ; 
#line 2007
}; 
#line 2010
template< class _Ty> void _Refwrap_ctor_fun(_Identity_t< _Ty &> ) noexcept; 
#line 2012
template < class _Ty >
 void _Refwrap_ctor_fun ( _Identity_t < _Ty && > ) = delete;
#line 2015
struct _Unique_tag_refwrap_has_ctor_from { 
#line 2017
}; 
#line 2019
template< class _Ty, class 
#line 2020
_Uty, class 
#line 2021
 = void> 
#line 2022
struct _Refwrap_has_ctor_from : public false_type { 
#line 2025
}; 
#line 2027
template< class _Ty, class 
#line 2028
_Uty> 
#line 2029
struct _Refwrap_has_ctor_from< _Ty, _Uty, void_t< _Unique_tag_refwrap_has_ctor_from, decltype((_Refwrap_ctor_fun< _Ty> (std::declval< _Uty> ())))> >  : public true_type { 
#line 2034
}; 
#line 2036
template < class _Ty >
 class reference_wrapper
  : public _Weak_types < _Ty > :: type
 {
public :
 static_assert ( is_object_v < _Ty > || is_function_v < _Ty >,
  "reference_wrapper<T> requires T to be an object type or a function type." );

 using type = _Ty;

 template < class _Uty,
  enable_if_t < conjunction_v <
   negation < is_same < remove_cv_t < remove_reference_t < _Uty >>, reference_wrapper >>,
   _Refwrap_has_ctor_from < _Ty, _Uty >>, int > = 0 >
  reference_wrapper ( _Uty && _Val )
   noexcept ( noexcept ( _Refwrap_ctor_fun < _Ty > ( :: std :: declval < _Uty > ( ) ) ) )
   {
   _Ty & _Ref = :: std :: forward < _Uty > ( _Val );
   _Ptr = :: std :: addressof ( _Ref );
   }

 operator _Ty & ( ) const noexcept
  {
  return ( * _Ptr );
  }

  _Ty & get ( ) const noexcept
  {
  return ( * _Ptr );
  }

 template < class ... _Types >
  auto operator ( ) ( _Types && ... _Args ) const
  -> decltype ( :: std :: invoke ( get ( ), :: std :: forward < _Types > ( _Args ) ... ) )
  {
  return ( :: std :: invoke ( get ( ), :: std :: forward < _Types > ( _Args ) ... ) );
  }

private :
 _Ty * _Ptr;
 };
#line 2085 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
template < class _Ty >
  inline reference_wrapper < _Ty > ref ( _Ty & _Val ) noexcept
 {
 return ( reference_wrapper < _Ty > ( _Val ) );
 }
#line 2091
template < class _Ty >
 void ref ( const _Ty && ) = delete;
#line 2094
template < class _Ty >
  inline reference_wrapper < _Ty > ref ( reference_wrapper < _Ty > _Val ) noexcept
 {
 return ( :: std :: ref ( _Val . get ( ) ) );
 }
#line 2100
template < class _Ty >
  inline reference_wrapper < const _Ty > cref ( const _Ty & _Val ) noexcept
 {
 return ( reference_wrapper < const _Ty > ( _Val ) );
 }
#line 2106
template < class _Ty >
 void cref ( const _Ty && ) = delete;
#line 2109
template < class _Ty >
  inline reference_wrapper < const _Ty > cref ( reference_wrapper < _Ty > _Val ) noexcept
 {
 return ( :: std :: cref ( _Val . get ( ) ) );
 }
#line 2116
template< class _Ty> struct _Is_swappable; 
#line 2120
template< class _Ty> struct _Is_nothrow_swappable; 
#line 2129 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
template < class _Ty,
 class = void > inline

 void swap ( _Ty &, _Ty & )
  noexcept ( is_nothrow_move_constructible_v < _Ty > && is_nothrow_move_assignable_v < _Ty > );
#line 2136 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
template < class _Ty,
 size_t _Size,
 class = enable_if_t < _Is_swappable < _Ty > :: value > > inline
 void swap ( _Ty ( & ) [ _Size ], _Ty ( & ) [ _Size ] )
  noexcept ( _Is_nothrow_swappable < _Ty > :: value );
#line 2143
template< class _Ty1, class 
#line 2144
_Ty2, class 
#line 2145
 = void> 
#line 2146
struct _Swappable_with_helper : public false_type { 
#line 2149
}; 
#line 2151
template< class _Ty1, class 
#line 2152
_Ty2> 
#line 2153
struct _Swappable_with_helper< _Ty1, _Ty2, void_t< decltype((swap(std::declval< _Ty1> (), std::declval< _Ty2> ())))> >  : public true_type { 
#line 2156
}; 
#line 2159
template< class _Ty1, class 
#line 2160
_Ty2> 
#line 2161
struct _Is_swappable_with : public bool_constant< conjunction_v< _Swappable_with_helper< _Ty1, _Ty2> , _Swappable_with_helper< _Ty2, _Ty1> > >  { 
#line 2167
}; 
#line 2170
template< class _Ty> 
#line 2171
struct _Is_swappable : public _Is_swappable_with< add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< _Ty> > ::type { 
#line 2176
}; 
#line 2179
template< class _Ty1, class 
#line 2180
_Ty2> 
#line 2181
struct _Swap_cannot_throw : public bool_constant< noexcept(swap(std::declval< _Ty1> (), std::declval< _Ty2> ())) && noexcept(swap(std::declval< _Ty2> (), std::declval< _Ty1> ()))>  { 
#line 2187
}; 
#line 2190
template< class _Ty1, class 
#line 2191
_Ty2> 
#line 2192
struct _Is_nothrow_swappable_with : public bool_constant< conjunction_v< _Is_swappable_with< _Ty1, _Ty2> , _Swap_cannot_throw< _Ty1, _Ty2> > >  { 
#line 2198
}; 
#line 2201
template< class _Ty> 
#line 2202
struct _Is_nothrow_swappable : public _Is_nothrow_swappable_with< add_lvalue_reference_t< _Ty> , add_lvalue_reference_t< _Ty> > ::type { 
#line 2207
}; 
#line 2258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
namespace _Has_ADL_swap_detail { 
#line 2259
void swap(); 
#line 2261
template< class , class 
#line 2262
 = void> 
#line 2263
struct _Has_ADL_swap : public false_type { 
#line 2265
}; 
#line 2266
template< class _Ty> 
#line 2267
struct _Has_ADL_swap< _Ty, void_t< decltype((swap(std::declval< _Ty &> (), std::declval< _Ty &> ())))> >  : public true_type { 
#line 2269
}; 
#line 2270
}
#line 2271
using _Has_ADL_swap_detail::_Has_ADL_swap;
#line 2273
template< class _Ty> 
#line 2274
struct _Is_trivially_swappable : public bool_constant< conjunction_v< is_trivially_destructible< _Ty> , is_trivially_move_constructible< _Ty> , is_trivially_move_assignable< _Ty> , negation< _Has_ADL_swap_detail::_Has_ADL_swap< _Ty> > > >  { 
#line 2282
}; 
#line 2284
template< class _Ty> constexpr bool 
#line 2285
_Is_trivially_swappable_v = (_Is_trivially_swappable< _Ty> ::value); 
#line 2343
constexpr size_t _FNV_offset_basis = 14695981039346656037Ui64; 
#line 2344
constexpr size_t _FNV_prime = 1099511628211Ui64; 
#line 2350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char *const 
#line 2351
_First, const size_t _Count) noexcept 
#line 2352
{ 
#line 2353
for (size_t _Idx = (0); _Idx < _Count; ++_Idx) 
#line 2354
{ 
#line 2355
_Val ^= (static_cast< size_t>(_First[_Idx])); 
#line 2356
_Val *= _FNV_prime; 
#line 2357
}  
#line 2359
return _Val; 
#line 2360
} 
#line 2362
template < class _Ty >
  inline size_t _Fnv1a_append_range ( const size_t _Val,
  const _Ty * const _First, const _Ty * const _Last ) noexcept
 {
 static_assert ( is_trivial_v < _Ty >, "Only trivial types can be directly hashed." );
 const auto _Firstb = reinterpret_cast < const unsigned char * > ( _First );
 const auto _Lastb = reinterpret_cast < const unsigned char * > ( _Last );
 return ( _Fnv1a_append_bytes ( _Val, _Firstb, static_cast < size_t > ( _Lastb - _Firstb ) ) );
 }
#line 2372
template < class _Kty >
  inline size_t _Fnv1a_append_value ( const size_t _Val, const _Kty & _Keyval ) noexcept
 {
 static_assert ( is_trivial_v < _Kty >, "Only trivial types can be directly hashed." );
 return ( _Fnv1a_append_bytes ( _Val,
  & reinterpret_cast < const unsigned char & > ( _Keyval ), sizeof ( _Kty ) ) );
 }
#line 2381
template < class _Kty >
  inline size_t _Hash_representation ( const _Kty & _Keyval ) noexcept
 {
 return ( _Fnv1a_append_value ( _FNV_offset_basis, _Keyval ) );
 }
#line 2388
template < class _Kty >
  inline size_t _Hash_array_representation (
  const _Kty * const _First, const size_t _Count ) noexcept
 {
 static_assert ( is_trivial_v < _Kty >, "Only trivial types can be directly hashed." );
 return ( _Fnv1a_append_bytes ( _FNV_offset_basis,
  reinterpret_cast < const unsigned char * > ( _First ), _Count * sizeof ( _Kty ) ) );
 }
#line 2398
template < class _Kty >
 struct hash;
#line 2401
template < class _Kty,
 bool _Enabled >
 struct _Conditionally_enabled_hash
 {
  typedef _Kty argument_type;
  typedef size_t result_type;

  size_t operator ( ) ( const _Kty & _Keyval ) const
  noexcept ( noexcept ( hash < _Kty > :: _Do_hash ( _Keyval ) ) )
  {
  return ( hash < _Kty > :: _Do_hash ( _Keyval ) );
  }
 };
#line 2415
template< class _Kty> 
#line 2416
struct _Conditionally_enabled_hash< _Kty, false>  { 
#line 2418
_Conditionally_enabled_hash() = delete;
#line 2419
_Conditionally_enabled_hash(const std::_Conditionally_enabled_hash< _Kty, false>  &) = delete;
#line 2420
_Conditionally_enabled_hash(std::_Conditionally_enabled_hash< _Kty, false>  &&) = delete;
#line 2421
std::_Conditionally_enabled_hash< _Kty, false>  &operator=(const std::_Conditionally_enabled_hash< _Kty, false>  &) = delete;
#line 2422
std::_Conditionally_enabled_hash< _Kty, false>  &operator=(std::_Conditionally_enabled_hash< _Kty, false>  &&) = delete;
#line 2423
}; 
#line 2426
template < class _Kty >
 struct hash
  : _Conditionally_enabled_hash < _Kty, ! is_const_v < _Kty > && ! is_volatile_v < _Kty >
   && ( is_enum_v < _Kty > || is_integral_v < _Kty > || is_pointer_v < _Kty > ) >
 {
 static size_t _Do_hash ( const _Kty & _Keyval ) noexcept
  {
  return ( _Hash_representation ( _Keyval ) );
  }
 };
#line 2438
#pragma pack(8)
template<> 
#line 2438
struct hash< float>  { 
#line 2440
typedef float argument_type; 
#line 2441
typedef size_t result_type; 
#line 2442
size_t operator()(const float _Keyval) const noexcept 
#line 2443
{ 
#line 2444
return _Hash_representation((_Keyval == (0.0F)) ? (0.0F) : _Keyval); 
#line 2445
} 
#line 2446
}; 
#pragma pack()
#line 2449
#pragma pack(8)
template<> 
#line 2449
struct hash< double>  { 
#line 2451
typedef double argument_type; 
#line 2452
typedef size_t result_type; 
#line 2453
size_t operator()(const double _Keyval) const noexcept 
#line 2454
{ 
#line 2455
return _Hash_representation((_Keyval == (0.0)) ? (0.0) : _Keyval); 
#line 2456
} 
#line 2457
}; 
#pragma pack()
#line 2460
#pragma pack(8)
template<> 
#line 2460
struct hash< long double>  { 
#line 2462
typedef long double argument_type; 
#line 2463
typedef size_t result_type; 
#line 2464
size_t operator()(const long double _Keyval) const noexcept 
#line 2465
{ 
#line 2466
return _Hash_representation((_Keyval == (0.0L)) ? (0.0L) : _Keyval); 
#line 2467
} 
#line 2468
}; 
#pragma pack()
#line 2471
#pragma pack(8)
template<> 
#line 2471
struct hash< std::nullptr_t>  { 
#line 2473
typedef nullptr_t argument_type; 
#line 2474
typedef size_t result_type; 
#line 2475
size_t operator()(nullptr_t) const noexcept 
#line 2476
{ 
#line 2477
void *_Null{((void *)0i64)}; 
#line 2478
return _Hash_representation(_Null); 
#line 2479
} 
#line 2480
}; 
#pragma pack()
#line 2483
template< class _Kty, class 
#line 2484
 = void> 
#pragma pack(8)
#line 2485
struct _Is_nothrow_hashable : public false_type { 
#line 2488
}; 
#pragma pack()
template< class _Kty> 
#pragma pack(8)
#line 2491
struct _Is_nothrow_hashable< _Kty, void_t< decltype((hash< _Kty> {}(std::declval< const _Kty &> ())))> >  : public bool_constant< noexcept(hash< _Kty> {}(std::declval< const _Kty &> ()))>  { 
#line 2494
}; 
#pragma pack()
#line 2497
#pragma warning(push)
#pragma warning(disable: 4996)
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 2500
using std::add_const;
#line 2501
using std::add_cv;
#line 2502
using std::add_pointer;
#line 2503
using std::add_volatile;
#line 2504
using std::aligned_storage;
#line 2505
using std::alignment_of;
#line 2506
using std::conditional;
#line 2507
using std::decay;
#line 2508
using std::enable_if;
#line 2509
using std::extent;
#line 2510
using std::false_type;
#line 2511
using std::has_virtual_destructor;
#line 2512
using std::integral_constant;
#line 2513
using std::is_abstract;
#line 2514
using std::is_arithmetic;
#line 2515
using std::is_array;
#line 2516
using std::is_base_of;
#line 2517
using std::is_class;
#line 2518
using std::is_compound;
#line 2519
using std::is_const;
#line 2520
using std::is_convertible;
#line 2521
using std::is_empty;
#line 2522
using std::is_enum;
#line 2523
using std::is_floating_point;
#line 2524
using std::is_function;
#line 2525
using std::is_fundamental;
#line 2526
using std::is_integral;
#line 2527
using std::is_member_function_pointer;
#line 2528
using std::is_member_object_pointer;
#line 2529
using std::is_member_pointer;
#line 2530
using std::is_object;
#line 2531
using std::is_pod;
#line 2532
using std::is_pointer;
#line 2533
using std::is_polymorphic;
#line 2534
using std::is_reference;
#line 2535
using std::is_same;
#line 2536
using std::is_scalar;
#line 2537
using std::is_signed;
#line 2538
using std::is_union;
#line 2539
using std::is_unsigned;
#line 2540
using std::is_void;
#line 2541
using std::is_volatile;
#line 2542
using std::make_signed;
#line 2543
using std::make_unsigned;
#line 2544
using std::rank;
#line 2545
using std::remove_all_extents;
#line 2546
using std::remove_const;
#line 2547
using std::remove_cv;
#line 2548
using std::remove_extent;
#line 2549
using std::remove_pointer;
#line 2550
using std::remove_reference;
#line 2551
using std::remove_volatile;
#line 2552
using std::true_type;
#line 2553
using std::cref;
#line 2554
using std::ref;
#line 2555
using std::reference_wrapper;
#line 2556
using std::result_of;
#line 2557
using std::hash;
#line 2558
}
#pragma warning(pop)
#line 16707566 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
#pragma pack(8)
#line 16707566
struct _Invoker_pmf_object { template < class _Decayed, class _Ty1, class ... _Types2 > static inline auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 ) noexcept ( noexcept ( ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ) ) -> decltype ( ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ) { return ( ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ); }}; 
#pragma pack(8)
#line 16707566
struct _Invoker_pmf_refwrap { template < class _Decayed, class _Ty1, class ... _Types2 > static inline auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 ) noexcept ( noexcept ( ( :: std :: forward < _Ty1 > ( _Arg1 ) . get ( ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ) ) -> decltype ( ( :: std :: forward < _Ty1 > ( _Arg1 ) . get ( ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ) { return ( ( :: std :: forward < _Ty1 > ( _Arg1 ) . get ( ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ); }}; struct _Invoker_pmf_pointer { template < class _Decayed, class _Ty1, class ... _Types2 > static inline auto _Call ( _Decayed _Pmf, _Ty1 && _Arg1, _Types2 && ... _Args2 ) noexcept ( noexcept ( ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ) ) -> decltype ( ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ) { return ( ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmf ) ( :: std :: forward < _Types2 > ( _Args2 ) ... ) ); }}; struct _Invoker_pmd_object { template < class _Decayed, class _Ty1 > static inline auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 ) noexcept ( noexcept ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmd ) ) -> decltype ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmd ) { return ( :: std :: forward < _Ty1 > ( _Arg1 ) .* _Pmd ); }}; struct _Invoker_pmd_refwrap { template < class _Decayed, class _Ty1 > static inline auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 ) noexcept ( noexcept ( :: std :: forward < _Ty1 > ( _Arg1 ) . get ( ) .* _Pmd ) ) -> decltype ( :: std :: forward < _Ty1 > ( _Arg1 ) . get ( ) .* _Pmd ) { return ( :: std :: forward < _Ty1 > ( _Arg1 ) . get ( ) .* _Pmd ); }}; struct _Invoker_pmd_pointer { template < class _Decayed, class _Ty1 > static inline auto _Call ( _Decayed _Pmd, _Ty1 && _Arg1 ) noexcept ( noexcept ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmd ) ) -> decltype ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmd ) { return ( ( * :: std :: forward < _Ty1 > ( _Arg1 ) ) .* _Pmd ); }}; struct _Invoker_functor { template < class _Callable, class ... _Types > static inline auto _Call ( _Callable && _Obj, _Types && ... _Args ) noexcept ( noexcept ( :: std :: forward < _Callable > ( _Obj ) ( :: std :: forward < _Types > ( _Args ) ... ) ) ) -> decltype ( :: std :: forward < _Callable > ( _Obj ) ( :: std :: forward < _Types > ( _Args ) ... ) ) { return ( :: std :: forward < _Callable > ( _Obj ) ( :: std :: forward < _Types > ( _Args ) ... ) ); }}; template< class _Callable, class _Ty1, class _Removed_cvref = remove_cv_t< remove_reference_t< _Callable> > , bool _Is_pmf = is_member_function_pointer_v< _Removed_cvref> , bool _Is_pmd = is_member_object_pointer_v< _Removed_cvref> > struct _Invoker1; template< class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1< _Callable, _Ty1, _Removed_cvref, true, false>  : public conditional_t< is_base_of_v< typename _Is_memfunptr< _Removed_cvref> ::_Class_type, remove_reference_t< _Ty1> > , _Invoker_pmf_object, conditional_t< _Is_specialization_v< remove_cv_t< remove_reference_t< _Ty1> > , reference_wrapper> , _Invoker_pmf_refwrap, _Invoker_pmf_pointer> >  { }; template< class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1< _Callable, _Ty1, _Removed_cvref, false, true>  : public conditional_t< is_base_of_v< typename _Is_member_object_pointer< _Removed_cvref> ::_Class_type, remove_reference_t< _Ty1> > , _Invoker_pmd_object, conditional_t< _Is_specialization_v< remove_cv_t< remove_reference_t< _Ty1> > , reference_wrapper> , _Invoker_pmd_refwrap, _Invoker_pmd_pointer> >  { }; template< class _Callable, class _Ty1, class _Removed_cvref> struct _Invoker1< _Callable, _Ty1, _Removed_cvref, false, false>  : public _Invoker_functor { }; template< class _Callable, class ..._Types> struct _Invoker; template< class _Callable> struct _Invoker< _Callable>  : public _Invoker_functor { }; template< class _Callable, class _Ty1, class ..._Types2> struct _Invoker< _Callable, _Ty1, _Types2...>  : public _Invoker1< _Callable, _Ty1>  { }; template < class _Callable, class ... _Types > inline auto invoke ( _Callable && _Obj, _Types && ... _Args ) noexcept ( noexcept ( _Invoker < _Callable, _Types ... > :: _Call ( :: std :: forward < _Callable > ( _Obj ), :: std :: forward < _Types > ( _Args ) ... ) ) ) -> decltype ( _Invoker < _Callable, _Types ... > :: _Call ( :: std :: forward < _Callable > ( _Obj ), :: std :: forward < _Types > ( _Args ) ... ) ) { return ( _Invoker < _Callable, _Types ... > :: _Call ( :: std :: forward < _Callable > ( _Obj ), :: std :: forward < _Types > ( _Args ) ... ) ); }
#line 16707578 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
template< class _Rx, bool 
#line 16707579
 = is_void_v< _Rx> > 
#pragma pack(8)
#line 16707580
struct _Invoker_ret { 
#line 16707582
}; 
#pragma pack()
template< class _Cv_void> 
#pragma pack(8)
#line 16707585
struct _Invoker_ret< _Cv_void, true>  { 
#line 16707587
template < class ... _Valtys >
  static void _Call ( _Valtys && ... _Vals )



  {



  :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... );



  }
#line 15732481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
}; 
#pragma pack(8)
template< class _Rx> 
#line 15732484
struct _Invoker_ret< _Rx, false>  { 
#line 15732486
template < class ... _Valtys >
  static _Rx _Call ( _Valtys && ... _Vals )



  {



  return ( :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... ) );



  }
#line 15732481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
}; 
#line 15732484
template<> struct _Invoker_ret< _Unforced, false>  { 
#line 15732486
template < class ... _Valtys >
  static auto _Call ( _Valtys && ... _Vals )
  -> decltype ( :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... ) )



  {



  return ( :: std :: invoke ( :: std :: forward < _Valtys > ( _Vals ) ... ) );



  }
#line 15732481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\type_traits"
}; 
#line 15732483
}
#line 15732487
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\exception"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
namespace std { 
#line 19
bool __cdecl uncaught_exception() noexcept; 
#line 20
int __cdecl uncaught_exceptions() noexcept; 
#line 22
}
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
typedef 
#line 40
struct _heapinfo { 
#line 42
int *_pentry; 
#line 43
size_t _size; 
#line 44
int _useflag; 
#line 45
} _HEAPINFO; 
#line 55
void *__cdecl _alloca(size_t _Size); 
#line 61
__declspec(dllimport) intptr_t __cdecl _get_heap_handle(); 
#line 64
__declspec(dllimport) int __cdecl _heapmin(); 
#line 67
__declspec(dllimport) int __cdecl _heapwalk(_HEAPINFO * _EntryInfo); 
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
__declspec(dllimport) int __cdecl _heapchk(); 
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
__declspec(dllimport) int __cdecl _resetstkoflw(); 
#line 86 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
typedef char __static_assert_t[(sizeof(unsigned) <= (16)) != 0]; 
#line 89
#pragma warning(push)
#pragma warning(disable:6540)
#line 92
__inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
#line 93
{ 
#line 94
if (_Ptr) 
#line 95
{ 
#line 96
(*((unsigned *)_Ptr)) = _Marker; 
#line 97
_Ptr = (((char *)_Ptr) + 16); 
#line 98
}  
#line 99
return _Ptr; 
#line 100
} 
#line 102
__inline size_t _MallocaComputeSize(size_t _Size) 
#line 103
{ 
#line 104
size_t _MarkedSize = _Size + (16); 
#line 105
return (_MarkedSize > _Size) ? _MarkedSize : (0); 
#line 106
} 
#line 108
#pragma warning(pop)
#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#pragma warning(push)
#pragma warning(disable: 6014)
__inline void __cdecl _freea(void *_Memory) 
#line 149
{ 
#line 150
unsigned _Marker; 
#line 151
if (_Memory) 
#line 152
{ 
#line 153
_Memory = (((char *)_Memory) - 16); 
#line 154
_Marker = (*((unsigned *)_Memory)); 
#line 155
if (_Marker == (56797)) 
#line 156
{ 
#line 157
free(_Memory); 
#line 158
} else { 
#line 160
if (_Marker != (52428)) 
#line 161
{ 
#line 162
(void)(((!(!(("Corrupted pointer passed to _freea") && (0)))) || (1 != _CrtDbgReportW(2, L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x57\x69\x6e\x64\x6f\x77\x73\x20\x4b" L"\x69\x74\x73\x5c\x31\x30\x5c\x49\x6e\x63\x6c\x75\x64\x65\x5c\x31\x30\x2e\x30\x2e\x31\x37\x37\x36\x33\x2e\x30\x5c\x75\x63\x72\x74" L"\x5c\x6d\x61\x6c\x6c\x6f\x63\x2e\x68", 162, 0, L"\x25\x6c\x73", L"\x28\x22\x43\x6f\x72\x72\x75\x70\x74\x65\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x70\x61\x73\x73\x65\x64\x20\x74\x6f\x20\x5f\x66" L"\x72\x65\x65\x61\x22\x20\x26\x26\x20\x30\x29"))) || (__debugbreak(), 0)); 
#line 163
}  }  
#line 165 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
}  
#line 166
} 
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
}
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
#pragma warning(pop)
#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\malloc.h"
__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 18
typedef void (__cdecl *terminate_handler)(void); 
#line 19
typedef void (__cdecl *terminate_function)(void); 
#line 28
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(); 
#line 29
__declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw(); 
#line 33
__declspec(dllimport) terminate_handler __cdecl set_terminate(terminate_handler _NewTerminateHandler) throw(); 
#line 37
__declspec(dllimport) terminate_handler __cdecl _get_terminate(); 
#line 43 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_terminate.h"
}__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\eh.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 19
typedef void (__cdecl *unexpected_handler)(void); 
#line 20
typedef void (__cdecl *unexpected_function)(void); 
#line 27
struct _EXCEPTION_POINTERS; 
#line 31
__declspec(noreturn) void __cdecl unexpected() noexcept(false); 
#line 35
unexpected_handler __cdecl set_unexpected(unexpected_handler _NewUnexpectedHandler) noexcept; 
#line 39
unexpected_handler __cdecl _get_unexpected() noexcept; 
#line 41
typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 
#line 43
_se_translator_function __cdecl _set_se_translator(_se_translator_function _NewSETranslator); 
#line 49 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\eh.h"
class type_info; 
#line 51
int __cdecl _is_exception_typeof(const type_info & _Type, _EXCEPTION_POINTERS * _ExceptionPtr); 
#line 56
bool __cdecl __uncaught_exception(); 
#line 57
int __cdecl __uncaught_exceptions(); 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\eh.h"
}__pragma( pack ( pop )) 
#line 16 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_exception.h"
#pragma pack ( push, 8 )
#line 19
__pragma( pack ( push, 8 )) extern "C" {
#line 21
struct __std_exception_data { 
#line 23
const char *_What; 
#line 24
bool _DoFree; 
#line 25
}; 
#line 27
void __cdecl __std_exception_copy(const __std_exception_data * _From, __std_exception_data * _To); 
#line 32
void __cdecl __std_exception_destroy(__std_exception_data * _Data); 
#line 36
}__pragma( pack ( pop )) 
#line 40
namespace std { 
#line 42
#pragma warning(push)
#pragma warning(disable: 4577)
class exception { 
#line 48
public: exception() noexcept : _Data() 
#line 50
{ 
#line 51
} 
#line 53
explicit exception(const char *const _Message) noexcept : _Data() 
#line 55
{ 
#line 56
__std_exception_data _InitData = {_Message, true}; 
#line 57
__std_exception_copy(&_InitData, &(_Data)); 
#line 58
} 
#line 60
exception(const char *const _Message, int) noexcept : _Data() 
#line 62
{ 
#line 63
((_Data)._What) = _Message; 
#line 64
} 
#line 66
exception(const exception &_Other) noexcept : _Data() 
#line 68
{ 
#line 69
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 70
} 
#line 72
exception &operator=(const exception &_Other) noexcept 
#line 73
{ 
#line 74
if (this == (&_Other)) 
#line 75
{ 
#line 76
return *this; 
#line 77
}  
#line 79
__std_exception_destroy(&(_Data)); 
#line 80
__std_exception_copy(&(_Other._Data), &(_Data)); 
#line 81
return *this; 
#line 82
} 
#line 84
virtual ~exception() noexcept 
#line 85
{ 
#line 86
__std_exception_destroy(&(_Data)); 
#line 87
} 
#line 89
virtual const char *what() const 
#line 90
{ 
#line 91
return ((_Data)._What) ? (_Data)._What : ("Unknown exception"); 
#line 92
} 
#line 96
private: __std_exception_data _Data; 
#line 97
}; 
#line 99
class bad_exception : public exception { 
#line 104
public: bad_exception() noexcept : exception("bad exception", 1) 
#line 106
{ 
#line 107
} 
#line 108
}; 
#line 110
class bad_alloc : public exception { 
#line 115
public: bad_alloc() noexcept : exception("bad allocation", 1) 
#line 117
{ 
#line 118
} 
#line 122
friend class bad_array_new_length; 
#line 124
private: bad_alloc(const char *const _Message) noexcept : exception(_Message, 1) 
#line 126
{ 
#line 127
} 
#line 128
}; 
#line 130
class bad_array_new_length : public bad_alloc { 
#line 135
public: bad_array_new_length() noexcept : bad_alloc("bad array new length") 
#line 137
{ 
#line 138
} 
#line 139
}; 
#line 141
#pragma warning(pop)
#line 143
}
#line 146 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_exception.h"
#pragma pack ( pop )
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\exception"
namespace std { 
#line 31
using ::terminate;
#line 34
using ::set_terminate;
#line 35
using ::terminate_handler;
#line 37
inline terminate_handler __cdecl get_terminate() noexcept 
#line 38
{ 
#line 39
return _get_terminate(); 
#line 40
} 
#line 44 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\exception"
using ::unexpected;
#line 47
using ::set_unexpected;
#line 48
using ::unexpected_handler;
#line 50
inline unexpected_handler __cdecl get_unexpected() noexcept 
#line 51
{ 
#line 52
return _get_unexpected(); 
#line 53
} 
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\exception"
}
#line 225 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\exception"
void __cdecl __ExceptionPtrCreate(void *); 
#line 226
void __cdecl __ExceptionPtrDestroy(void *); 
#line 227
void __cdecl __ExceptionPtrCopy(void *, const void *); 
#line 228
void __cdecl __ExceptionPtrAssign(void *, const void *); 
#line 229
bool __cdecl __ExceptionPtrCompare(const void *, const void *); 
#line 230
bool __cdecl __ExceptionPtrToBool(const void *); 
#line 231
void __cdecl __ExceptionPtrSwap(void *, void *); 
#line 232
void __cdecl __ExceptionPtrCurrentException(void *); 
#line 233
[[noreturn]] void __cdecl __ExceptionPtrRethrow(const void *); 
#line 234
void __cdecl __ExceptionPtrCopyException(void *, const void *, const void *); 
#line 237
namespace std { 
#line 239
class exception_ptr { 
#line 242
public: exception_ptr() noexcept 
#line 243
{ 
#line 244
__ExceptionPtrCreate(this); 
#line 245
} 
#line 247
exception_ptr(nullptr_t) noexcept 
#line 248
{ 
#line 249
__ExceptionPtrCreate(this); 
#line 250
} 
#line 252
~exception_ptr() noexcept 
#line 253
{ 
#line 254
__ExceptionPtrDestroy(this); 
#line 255
} 
#line 257
exception_ptr(const exception_ptr &_Rhs) noexcept 
#line 258
{ 
#line 259
__ExceptionPtrCopy(this, &_Rhs); 
#line 260
} 
#line 262
exception_ptr &operator=(const exception_ptr &_Rhs) noexcept 
#line 263
{ 
#line 264
__ExceptionPtrAssign(this, &_Rhs); 
#line 265
return *this; 
#line 266
} 
#line 268
exception_ptr &operator=(nullptr_t) noexcept 
#line 269
{ 
#line 270
exception_ptr _Ptr; 
#line 271
__ExceptionPtrAssign(this, &_Ptr); 
#line 272
return *this; 
#line 273
} 
#line 275
explicit operator bool() const noexcept 
#line 276
{ 
#line 277
return __ExceptionPtrToBool(this); 
#line 278
} 
#line 280
[[noreturn]] void _RethrowException() const 
#line 281
{ 
#line 282
__ExceptionPtrRethrow(this); 
#line 283
} 
#line 285
static exception_ptr _Current_exception() noexcept 
#line 286
{ 
#line 287
exception_ptr _Retval; 
#line 288
__ExceptionPtrCurrentException(&_Retval); 
#line 289
return _Retval; 
#line 290
} 
#line 292
static exception_ptr _Copy_exception(void *_Except, const void *_Ptr) 
#line 293
{ 
#line 294
exception_ptr _Retval; 
#line 295
if (!_Ptr) 
#line 296
{ 
#line 298
return _Retval; 
#line 299
}  
#line 300
__ExceptionPtrCopyException(&_Retval, _Except, _Ptr); 
#line 301
return _Retval; 
#line 302
} 
#line 309
private: void *_Data1; 
#line 310
void *_Data2; 
#line 314
}; 
#line 316
inline void swap(exception_ptr &_Lhs, exception_ptr &_Rhs) noexcept 
#line 317
{ 
#line 318
__ExceptionPtrSwap(&_Lhs, &_Rhs); 
#line 319
} 
#line 321
inline bool operator==(const exception_ptr &_Lhs, const exception_ptr &_Rhs) noexcept 
#line 322
{ 
#line 323
return __ExceptionPtrCompare(&_Lhs, &_Rhs); 
#line 324
} 
#line 326
inline bool operator==(nullptr_t, const exception_ptr &_Rhs) noexcept 
#line 327
{ 
#line 328
return !_Rhs; 
#line 329
} 
#line 331
inline bool operator==(const exception_ptr &_Lhs, nullptr_t) noexcept 
#line 332
{ 
#line 333
return !_Lhs; 
#line 334
} 
#line 336
inline bool operator!=(const exception_ptr &_Lhs, const exception_ptr &_Rhs) noexcept 
#line 337
{ 
#line 338
return !((_Lhs == _Rhs)); 
#line 339
} 
#line 341
inline bool operator!=(nullptr_t _Lhs, const exception_ptr &_Rhs) noexcept 
#line 342
{ 
#line 343
return !((_Lhs == _Rhs)); 
#line 344
} 
#line 346
inline bool operator!=(const exception_ptr &_Lhs, nullptr_t _Rhs) noexcept 
#line 347
{ 
#line 348
return !((_Lhs == _Rhs)); 
#line 349
} 
#line 351
inline exception_ptr current_exception() noexcept 
#line 352
{ 
#line 353
return exception_ptr::_Current_exception(); 
#line 354
} 
#line 356
[[noreturn]] inline void rethrow_exception(exception_ptr _Ptr) 
#line 357
{ 
#line 358
_Ptr._RethrowException(); 
#line 359
} 
#line 361
template< class _Ex> void *__GetExceptionInfo(_Ex); 
#line 363
template < class _Ex > exception_ptr make_exception_ptr ( _Ex _Except ) noexcept
 {
 return exception_ptr :: _Copy_exception ( :: std :: addressof ( _Except ), __GetExceptionInfo ( _Except ) );
 }
#line 369
class nested_exception { 
#line 372
public: nested_exception() noexcept : _Exc(::std::current_exception()) 
#line 374
{ 
#line 375
} 
#line 377
nested_exception(const nested_exception &) noexcept = default;
#line 378
nested_exception &operator=(const nested_exception &) noexcept = default;
#line 379
virtual ~nested_exception() noexcept 
#line 380
{ 
#line 381
} 
#line 383
[[noreturn]] void rethrow_nested() const 
#line 384
{ 
#line 385
if ((_Exc)) { 
#line 386
::std::rethrow_exception(_Exc); } else { 
#line 388
::std::terminate(); }  
#line 389
} 
#line 391
exception_ptr nested_ptr() const noexcept 
#line 392
{ 
#line 393
return _Exc; 
#line 394
} 
#line 397
private: exception_ptr _Exc; 
#line 398
}; 
#line 401
template < class _Ty,
 class _Uty >
 struct _With_nested
  : _Uty, nested_exception
 {
 explicit _With_nested ( _Ty && _Arg )
  : _Uty ( :: std :: forward < _Ty > ( _Arg ) ), nested_exception ( )
  {
  }
 };
#line 412
template < class _Ty >
 [ [ noreturn ] ] inline void _Throw_with_nested ( _Ty && _Arg, true_type )
 {
 using _Uty = decay_t < _Ty >;
 using _Glued = _With_nested < _Ty, _Uty >;

 throw _Glued ( :: std :: forward < _Ty > ( _Arg ) );
 }
#line 421
template < class _Ty >
 [ [ noreturn ] ] inline void _Throw_with_nested ( _Ty && _Arg, false_type )
 {
 throw :: std :: forward < _Ty > ( _Arg );
 }
#line 427
template < class _Ty >
 [ [ noreturn ] ] inline void throw_with_nested ( _Ty && _Arg )
 {
 typedef decay_t < _Ty > _Uty;

 bool_constant <
  is_class_v < _Uty >
  && ! is_base_of_v < nested_exception, _Uty >
  && ! is_final_v < _Uty >> _Tag;

 _Throw_with_nested ( :: std :: forward < _Ty > ( _Arg ), _Tag );
 }
#line 442
template < class _Ty > inline
 void _Rethrow_if_nested ( const _Ty * _Ptr, true_type )
 {
 const auto _Nested = dynamic_cast < const nested_exception * > ( _Ptr );

 if ( _Nested )
  _Nested -> rethrow_nested ( );
 }
#line 451
template < class _Ty > inline
 void _Rethrow_if_nested ( const _Ty *, false_type )
 {
 }
#line 456
template < class _Ty > inline
 void rethrow_if_nested ( const _Ty & _Arg )
 {
 bool_constant < is_polymorphic_v < _Ty > && ( ! is_base_of_v < nested_exception, _Ty >
  || is_convertible_v < _Ty *, nested_exception * > ) > _Tag;

 _Rethrow_if_nested ( :: std :: addressof ( _Arg ), _Tag );
 }
#line 469 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\exception"
}
#line 473
#pragma warning(pop)
#pragma pack ( pop )
#line 17 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdint.h"
typedef signed char int8_t; 
#line 18
typedef short int16_t; 
#line 19
typedef int int32_t; 
#line 20
typedef __int64 int64_t; 
#line 21
typedef unsigned char uint8_t; 
#line 22
typedef unsigned short uint16_t; 
#line 23
typedef unsigned uint32_t; 
#line 24
typedef unsigned __int64 uint64_t; 
#line 26
typedef signed char int_least8_t; 
#line 27
typedef short int_least16_t; 
#line 28
typedef int int_least32_t; 
#line 29
typedef __int64 int_least64_t; 
#line 30
typedef unsigned char uint_least8_t; 
#line 31
typedef unsigned short uint_least16_t; 
#line 32
typedef unsigned uint_least32_t; 
#line 33
typedef unsigned __int64 uint_least64_t; 
#line 35
typedef signed char int_fast8_t; 
#line 36
typedef int int_fast16_t; 
#line 37
typedef int int_fast32_t; 
#line 38
typedef __int64 int_fast64_t; 
#line 39
typedef unsigned char uint_fast8_t; 
#line 40
typedef unsigned uint_fast16_t; 
#line 41
typedef unsigned uint_fast32_t; 
#line 42
typedef unsigned __int64 uint_fast64_t; 
#line 44
typedef __int64 intmax_t; 
#line 45
typedef unsigned __int64 uintmax_t; 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstdint"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
namespace std { 
#line 18
using ::int8_t;using ::int16_t;
#line 19
using ::int32_t;using ::int64_t;
#line 20
using ::uint8_t;using ::uint16_t;
#line 21
using ::uint32_t;using ::uint64_t;
#line 23
using ::int_least8_t;using ::int_least16_t;
#line 24
using ::int_least32_t;using ::int_least64_t;
#line 25
using ::uint_least8_t;using ::uint_least16_t;
#line 26
using ::uint_least32_t;using ::uint_least64_t;
#line 28
using ::int_fast8_t;using ::int_fast16_t;
#line 29
using ::int_fast32_t;using ::int_fast64_t;
#line 30
using ::uint_fast8_t;using ::uint_fast16_t;
#line 31
using ::uint_fast32_t;using ::uint_fast64_t;
#line 33
using ::intmax_t;using ::intptr_t;
#line 34
using ::uintmax_t;using ::uintptr_t;
#line 37
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 38
using ::int8_t;using ::int16_t;
#line 39
using ::int32_t;using ::int64_t;
#line 40
using ::uint8_t;using ::uint16_t;
#line 41
using ::uint32_t;using ::uint64_t;
#line 43
using ::int_least8_t;using ::int_least16_t;
#line 44
using ::int_least32_t;using ::int_least64_t;
#line 45
using ::uint_least8_t;using ::uint_least16_t;
#line 46
using ::uint_least32_t;using ::uint_least64_t;
#line 48
using ::int_fast8_t;using ::int_fast16_t;
#line 49
using ::int_fast32_t;using ::int_fast64_t;
#line 50
using ::uint_fast8_t;using ::uint_fast16_t;
#line 51
using ::uint_fast32_t;using ::uint_fast64_t;
#line 53
using ::intmax_t;using ::intptr_t;
#line 54
using ::uintmax_t;using ::uintptr_t;
#line 55
}
#line 57 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cstdint"
}
#line 61
#pragma warning(pop)
#pragma pack ( pop )
#line 7 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ymath.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 16
extern "C" {
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ymath.h"
void __cdecl _Feraise(int); 
#line 41
typedef 
#line 36
union { 
#line 37
unsigned short _Word[8]; 
#line 38
float _Float; 
#line 39
double _Double; 
#line 40
long double _Long_double; 
#line 41
} _Dconst; 
#line 44
double __cdecl _Cosh(double, double); 
#line 45
short __cdecl _Dtest(double *); 
#line 46
double __cdecl _Sinh(double, double); 
#line 48
short __cdecl _Exp(double *, double, short); 
#line 49
__declspec(dllimport) extern _Dconst _Denorm, _Hugeval, _Inf, 
#line 50
_Nan, _Snan; 
#line 53
float __cdecl _FCosh(float, float); 
#line 54
short __cdecl _FDtest(float *); 
#line 55
float __cdecl _FSinh(float, float); 
#line 57
short __cdecl _FExp(float *, float, short); 
#line 58
__declspec(dllimport) extern _Dconst _FDenorm, _FInf, _FNan, _FSnan; 
#line 61
long double __cdecl _LCosh(long double, long double); 
#line 62
short __cdecl _LDtest(long double *); 
#line 63
long double __cdecl _LSinh(long double, long double); 
#line 65
short __cdecl _LExp(long double *, long double, short); 
#line 66
__declspec(dllimport) extern _Dconst _LDenorm, _LInf, _LNan, _LSnan; 
#line 70
}
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ymath.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
__declspec(dllimport) unsigned __cdecl _clearfp(); 
#line 229
#pragma warning(push)
#pragma warning(disable: 4141)
#line 233
__declspec(dllimport) unsigned __cdecl _controlfp(unsigned _NewValue, unsigned _Mask); 
#line 238
#pragma warning(pop)
#line 241
__declspec(dllimport) void __cdecl _set_controlfp(unsigned _NewValue, unsigned _Mask); 
#line 247
__declspec(dllimport) errno_t __cdecl _controlfp_s(unsigned * _CurrentState, unsigned _NewValue, unsigned _Mask); 
#line 254
__declspec(dllimport) unsigned __cdecl _statusfp(); 
#line 257
__declspec(dllimport) void __cdecl _fpreset(); 
#line 273
__declspec(dllimport) unsigned __cdecl _control87(unsigned _NewValue, unsigned _Mask); 
#line 290
__declspec(dllimport) int *__cdecl __fpecode(); 
#line 295
__declspec(dllimport) int __cdecl __fpe_flt_rounds(); 
#line 308
__declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign); 
#line 309
__declspec(dllimport) double __cdecl _chgsign(double _X); 
#line 310
__declspec(dllimport) double __cdecl _scalb(double _X, long _Y); 
#line 311
__declspec(dllimport) double __cdecl _logb(double _X); 
#line 312
__declspec(dllimport) double __cdecl _nextafter(double _X, double _Y); 
#line 313
__declspec(dllimport) int __cdecl _finite(double _X); 
#line 314
__declspec(dllimport) int __cdecl _isnan(double _X); 
#line 315
__declspec(dllimport) int __cdecl _fpclass(double _X); 
#line 318
__declspec(dllimport) float __cdecl _scalbf(float _X, long _Y); 
#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
__declspec(dllimport) void __cdecl fpreset(); 
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\float.h"
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 26
__declspec(dllimport) errno_t __cdecl _cgetws_s(__wchar_t * _Buffer, size_t _BufferCount, size_t * _SizeRead); 
#line 32
extern "C++" {template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _SizeRead ) throw ( ) { return _cgetws_s ( _Buffer, _Size, _SizeRead ); }}
#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__declspec(dllimport) int __cdecl _cputws(const __wchar_t * _Buffer); 
#line 44
__declspec(dllimport) wint_t __cdecl _getwch(); 
#line 45
__declspec(dllimport) wint_t __cdecl _getwche(); 
#line 46
__declspec(dllimport) wint_t __cdecl _putwch(__wchar_t _Character); 
#line 47
__declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _Character); 
#line 49
__declspec(dllimport) wint_t __cdecl _getwch_nolock(); 
#line 50
__declspec(dllimport) wint_t __cdecl _getwche_nolock(); 
#line 51
__declspec(dllimport) wint_t __cdecl _putwch_nolock(__wchar_t _Character); 
#line 52
__declspec(dllimport) wint_t __cdecl _ungetwch_nolock(wint_t _Character); 
#line 62
__declspec(dllimport) int __cdecl __conio_common_vcwprintf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 70
__declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 78
__declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 86
__inline int __cdecl _vcwprintf_l(const __wchar_t *const 
#line 87
_Format, const _locale_t 
#line 88
_Locale, va_list 
#line 89
_ArgList) 
#line 94 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 95
return __conio_common_vcwprintf(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 96
} 
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf(const __wchar_t *const 
#line 101
_Format, va_list 
#line 102
_ArgList) 
#line 107 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 108
return _vcwprintf_l(_Format, 0, _ArgList); 
#line 109
} 
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s_l(const __wchar_t *const 
#line 114
_Format, const _locale_t 
#line 115
_Locale, va_list 
#line 116
_ArgList) 
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 122
return __conio_common_vcwprintf_s(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 123
} 
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_s(const __wchar_t *const 
#line 128
_Format, va_list 
#line 129
_ArgList) 
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 135
return _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 136
} 
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p_l(const __wchar_t *const 
#line 141
_Format, const _locale_t 
#line 142
_Locale, va_list 
#line 143
_ArgList) 
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 149
return __conio_common_vcwprintf_p(*__local_stdio_printf_options(), _Format, _Locale, _ArgList); 
#line 150
} 
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwprintf_p(const __wchar_t *const 
#line 155
_Format, va_list 
#line 156
_ArgList) 
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 162
return _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 163
} 
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_l(const __wchar_t *const 
#line 168
_Format, const _locale_t 
#line 169
_Locale, ...) 
#line 174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 175
int _Result; 
#line 176
va_list _ArgList; 
#line 177
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 178
_Result = _vcwprintf_l(_Format, _Locale, _ArgList); 
#line 179
(void)(_ArgList = ((va_list)0)); 
#line 180
return _Result; 
#line 181
} 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf(const __wchar_t *const 
#line 186
_Format, ...) 
#line 191 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 192
int _Result; 
#line 193
va_list _ArgList; 
#line 194
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 195
_Result = _vcwprintf_l(_Format, 0, _ArgList); 
#line 196
(void)(_ArgList = ((va_list)0)); 
#line 197
return _Result; 
#line 198
} 
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s_l(const __wchar_t *const 
#line 203
_Format, const _locale_t 
#line 204
_Locale, ...) 
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 210
int _Result; 
#line 211
va_list _ArgList; 
#line 212
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 213
_Result = _vcwprintf_s_l(_Format, _Locale, _ArgList); 
#line 214
(void)(_ArgList = ((va_list)0)); 
#line 215
return _Result; 
#line 216
} 
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_s(const __wchar_t *const 
#line 221
_Format, ...) 
#line 226 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 227
int _Result; 
#line 228
va_list _ArgList; 
#line 229
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 230
_Result = _vcwprintf_s_l(_Format, 0, _ArgList); 
#line 231
(void)(_ArgList = ((va_list)0)); 
#line 232
return _Result; 
#line 233
} 
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p_l(const __wchar_t *const 
#line 238
_Format, const _locale_t 
#line 239
_Locale, ...) 
#line 244 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 245
int _Result; 
#line 246
va_list _ArgList; 
#line 247
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 248
_Result = _vcwprintf_p_l(_Format, _Locale, _ArgList); 
#line 249
(void)(_ArgList = ((va_list)0)); 
#line 250
return _Result; 
#line 251
} 
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwprintf_p(const __wchar_t *const 
#line 256
_Format, ...) 
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 262
int _Result; 
#line 263
va_list _ArgList; 
#line 264
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 265
_Result = _vcwprintf_p_l(_Format, 0, _ArgList); 
#line 266
(void)(_ArgList = ((va_list)0)); 
#line 267
return _Result; 
#line 268
} 
#line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__declspec(dllimport) int __cdecl __conio_common_vcwscanf(unsigned __int64 _Options, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); 
#line 287
__inline int __cdecl _vcwscanf_l(const __wchar_t *const 
#line 288
_Format, const _locale_t 
#line 289
_Locale, va_list 
#line 290
_ArgList) 
#line 295 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 296
return __conio_common_vcwscanf(*__local_stdio_scanf_options(), _Format, _Locale, _ArgList); 
#line 299
} 
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf(const __wchar_t *const 
#line 304
_Format, va_list 
#line 305
_ArgList) 
#line 310 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#pragma warning(push)
#pragma warning(disable: 4996)
return _vcwscanf_l(_Format, 0, _ArgList); 
#pragma warning(pop)
} 
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s_l(const __wchar_t *const 
#line 320
_Format, const _locale_t 
#line 321
_Locale, va_list 
#line 322
_ArgList) 
#line 327 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 328
return __conio_common_vcwscanf((*__local_stdio_scanf_options()) | (1Ui64 << 0), _Format, _Locale, _ArgList); 
#line 331
} 
#line 335 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _vcwscanf_s(const __wchar_t *const 
#line 336
_Format, va_list 
#line 337
_ArgList) 
#line 342 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 343
return _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 344
} 
#line 348 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_l(const __wchar_t *const 
#line 349
_Format, const _locale_t 
#line 350
_Locale, ...) 
#line 355 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 356
int _Result; 
#line 357
va_list _ArgList; 
#line 358
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 360
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vcwscanf_l(_Format, _Locale, _ArgList); 
#pragma warning(pop)
#line 365
(void)(_ArgList = ((va_list)0)); 
#line 366
return _Result; 
#line 367
} 
#line 371 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf(const __wchar_t *const 
#line 372
_Format, ...) 
#line 377 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 378
int _Result; 
#line 379
va_list _ArgList; 
#line 380
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 382
#pragma warning(push)
#pragma warning(disable: 4996)
_Result = _vcwscanf_l(_Format, 0, _ArgList); 
#pragma warning(pop)
#line 387
(void)(_ArgList = ((va_list)0)); 
#line 388
return _Result; 
#line 389
} 
#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s_l(const __wchar_t *const 
#line 394
_Format, const _locale_t 
#line 395
_Locale, ...) 
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 401
int _Result; 
#line 402
va_list _ArgList; 
#line 403
(void)((__vcrt_assert_va_start_is_not_reference< __crt_locale_pointers *const> ()), ((void)__va_start(&_ArgList, _Locale))); 
#line 404
_Result = _vcwscanf_s_l(_Format, _Locale, _ArgList); 
#line 405
(void)(_ArgList = ((va_list)0)); 
#line 406
return _Result; 
#line 407
} 
#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
__inline int __cdecl _cwscanf_s(const __wchar_t *const 
#line 412
_Format, ...) 
#line 417 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
{ 
#line 418
int _Result; 
#line 419
va_list _ArgList; 
#line 420
(void)((__vcrt_assert_va_start_is_not_reference< const __wchar_t *const> ()), ((void)__va_start(&_ArgList, _Format))); 
#line 421
_Result = _vcwscanf_s_l(_Format, 0, _ArgList); 
#line 422
(void)(_ArgList = ((va_list)0)); 
#line 423
return _Result; 
#line 424
} 
#line 431 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wconio.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
__declspec(dllimport) const unsigned short *__cdecl __pctype_func(); 
#line 32
__declspec(dllimport) const wctype_t *__cdecl __pwctype_func(); 
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
__declspec(dllimport) int __cdecl iswalnum(wint_t _C); 
#line 64
__declspec(dllimport) int __cdecl iswalpha(wint_t _C); 
#line 65
__declspec(dllimport) int __cdecl iswascii(wint_t _C); 
#line 66
__declspec(dllimport) int __cdecl iswblank(wint_t _C); 
#line 67
__declspec(dllimport) int __cdecl iswcntrl(wint_t _C); 
#line 70
__declspec(dllimport) int __cdecl iswdigit(wint_t _C); 
#line 72
__declspec(dllimport) int __cdecl iswgraph(wint_t _C); 
#line 73
__declspec(dllimport) int __cdecl iswlower(wint_t _C); 
#line 74
__declspec(dllimport) int __cdecl iswprint(wint_t _C); 
#line 75
__declspec(dllimport) int __cdecl iswpunct(wint_t _C); 
#line 76
__declspec(dllimport) int __cdecl iswspace(wint_t _C); 
#line 77
__declspec(dllimport) int __cdecl iswupper(wint_t _C); 
#line 78
__declspec(dllimport) int __cdecl iswxdigit(wint_t _C); 
#line 79
__declspec(dllimport) int __cdecl __iswcsymf(wint_t _C); 
#line 80
__declspec(dllimport) int __cdecl __iswcsym(wint_t _C); 
#line 82
__declspec(dllimport) int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale); 
#line 83
__declspec(dllimport) int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale); 
#line 84
__declspec(dllimport) int __cdecl _iswblank_l(wint_t _C, _locale_t _Locale); 
#line 85
__declspec(dllimport) int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale); 
#line 86
__declspec(dllimport) int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale); 
#line 87
__declspec(dllimport) int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale); 
#line 88
__declspec(dllimport) int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale); 
#line 89
__declspec(dllimport) int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale); 
#line 90
__declspec(dllimport) int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale); 
#line 91
__declspec(dllimport) int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale); 
#line 92
__declspec(dllimport) int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale); 
#line 93
__declspec(dllimport) int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale); 
#line 94
__declspec(dllimport) int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale); 
#line 95
__declspec(dllimport) int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale); 
#line 98
__declspec(dllimport) wint_t __cdecl towupper(wint_t _C); 
#line 99
__declspec(dllimport) wint_t __cdecl towlower(wint_t _C); 
#line 100
__declspec(dllimport) int __cdecl iswctype(wint_t _C, wctype_t _Type); 
#line 102
__declspec(dllimport) wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale); 
#line 103
__declspec(dllimport) wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale); 
#line 104
__declspec(dllimport) int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale); 
#line 108
__declspec(dllimport) int __cdecl isleadbyte(int _C); 
#line 109
__declspec(dllimport) int __cdecl _isleadbyte_l(int _C, _locale_t _Locale); 
#line 111
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instea" "d. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(wint_t _C, wctype_t _Type); 
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wctype.h"
}__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wdirect.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 22
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetcwd(__wchar_t * _DstBuf, int _SizeInWords); 
#line 29
__declspec(dllimport) __declspec(allocator) __wchar_t *__cdecl _wgetdcwd(int _Drive, __wchar_t * _DstBuf, int _SizeInWords); 
#line 41
__declspec(dllimport) int __cdecl _wchdir(const __wchar_t * _Path); 
#line 46
__declspec(dllimport) int __cdecl _wmkdir(const __wchar_t * _Path); 
#line 51
__declspec(dllimport) int __cdecl _wrmdir(const __wchar_t * _Path); 
#line 57
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 17
#pragma warning(push)
#pragma warning(disable:4820)
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
typedef unsigned long _fsize_t; 
#line 36
struct _wfinddata32_t { 
#line 38
unsigned attrib; 
#line 39
__time32_t time_create; 
#line 40
__time32_t time_access; 
#line 41
__time32_t time_write; 
#line 42
_fsize_t size; 
#line 43
__wchar_t name[260]; 
#line 44
}; 
#line 46
struct _wfinddata32i64_t { 
#line 48
unsigned attrib; 
#line 49
__time32_t time_create; 
#line 50
__time32_t time_access; 
#line 51
__time32_t time_write; 
#line 52
__int64 size; 
#line 53
__wchar_t name[260]; 
#line 54
}; 
#line 56
struct _wfinddata64i32_t { 
#line 58
unsigned attrib; 
#line 59
__time64_t time_create; 
#line 60
__time64_t time_access; 
#line 61
__time64_t time_write; 
#line 62
_fsize_t size; 
#line 63
__wchar_t name[260]; 
#line 64
}; 
#line 66
struct _wfinddata64_t { 
#line 68
unsigned attrib; 
#line 69
__time64_t time_create; 
#line 70
__time64_t time_access; 
#line 71
__time64_t time_write; 
#line 72
__int64 size; 
#line 73
__wchar_t name[260]; 
#line 74
}; 
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
__declspec(dllimport) int __cdecl _waccess(const __wchar_t * _FileName, int _AccessMode); 
#line 102
__declspec(dllimport) errno_t __cdecl _waccess_s(const __wchar_t * _FileName, int _AccessMode); 
#line 108
__declspec(dllimport) int __cdecl _wchmod(const __wchar_t * _FileName, int _Mode); 
#line 114
__declspec(dllimport) int __cdecl _wcreat(const __wchar_t * _FileName, int _PermissionMode); 
#line 121
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(const __wchar_t * _FileName, _wfinddata32_t * _FindData); 
#line 128
__declspec(dllimport) int __cdecl _wfindnext32(intptr_t _FindHandle, _wfinddata32_t * _FindData); 
#line 133
__declspec(dllimport) int __cdecl _wunlink(const __wchar_t * _FileName); 
#line 138
__declspec(dllimport) int __cdecl _wrename(const __wchar_t * _OldFileName, const __wchar_t * _NewFileName); 
#line 143
__declspec(dllimport) errno_t __cdecl _wmktemp_s(__wchar_t * _TemplateName, size_t _SizeInWords); 
#line 148
extern "C++" {template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) throw ( ) { return _wmktemp_s ( _TemplateName, _Size ); }}
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
__declspec(dllimport) __wchar_t *__cdecl _wmktemp(__wchar_t * _TemplateName); 
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(const __wchar_t * _FileName, _wfinddata32i64_t * _FindData); 
#line 168
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(const __wchar_t * _FileName, _wfinddata64i32_t * _FindData); 
#line 175
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(const __wchar_t * _FileName, _wfinddata64_t * _FindData); 
#line 182
__declspec(dllimport) int __cdecl _wfindnext32i64(intptr_t _FindHandle, _wfinddata32i64_t * _FindData); 
#line 189
__declspec(dllimport) int __cdecl _wfindnext64i32(intptr_t _FindHandle, _wfinddata64i32_t * _FindData); 
#line 196
__declspec(dllimport) int __cdecl _wfindnext64(intptr_t _FindHandle, _wfinddata64_t * _FindData); 
#line 202
__declspec(dllimport) errno_t __cdecl _wsopen_s(int * _FileHandle, const __wchar_t * _FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag); 
#line 210
__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(const __wchar_t * _FileName, int _OFlag, int _ShFlag, int _PMode, int * _PFileHandle, int _BSecure); 
#line 225
extern "C++" inline int __cdecl _wopen(const __wchar_t *
#line 226
_FileName, int 
#line 227
_OFlag, int 
#line 228
_PMode = 0) 
#line 230
{ 
#line 231
int _FileHandle; 
#line 233
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, 64, _PMode, &_FileHandle, 0); 
#line 234
return (_Result) ? -1 : _FileHandle; 
#line 235
} 
#line 238
extern "C++" inline int __cdecl _wsopen(const __wchar_t *
#line 239
_FileName, int 
#line 240
_OFlag, int 
#line 241
_ShFlag, int 
#line 242
_PMode = 0) 
#line 244
{ 
#line 245
int _FileHandle; 
#line 247
const errno_t _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0); 
#line 248
return (_Result) ? -1 : _FileHandle; 
#line 249
} 
#line 273 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wio.h"
}
#line 270
#pragma warning(pop)
#line 273
__pragma( pack ( pop )) 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 20
__declspec(dllimport) intptr_t __cdecl _wexecl(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 25
__declspec(dllimport) intptr_t __cdecl _wexecle(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 30
__declspec(dllimport) intptr_t __cdecl _wexeclp(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 35
__declspec(dllimport) intptr_t __cdecl _wexeclpe(const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 40
__declspec(dllimport) intptr_t __cdecl _wexecv(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 45
__declspec(dllimport) intptr_t __cdecl _wexecve(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 51
__declspec(dllimport) intptr_t __cdecl _wexecvp(const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 56
__declspec(dllimport) intptr_t __cdecl _wexecvpe(const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 62
__declspec(dllimport) intptr_t __cdecl _wspawnl(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 68
__declspec(dllimport) intptr_t __cdecl _wspawnle(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 74
__declspec(dllimport) intptr_t __cdecl _wspawnlp(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 80
__declspec(dllimport) intptr_t __cdecl _wspawnlpe(int _Mode, const __wchar_t * _FileName, const __wchar_t * _ArgList, ...); 
#line 86
__declspec(dllimport) intptr_t __cdecl _wspawnv(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 92
__declspec(dllimport) intptr_t __cdecl _wspawnve(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 99
__declspec(dllimport) intptr_t __cdecl _wspawnvp(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList); 
#line 105
__declspec(dllimport) intptr_t __cdecl _wspawnvpe(int _Mode, const __wchar_t * _FileName, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); 
#line 112
__declspec(dllimport) int __cdecl _wsystem(const __wchar_t * _Command); 
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\corecrt_wprocess.h"
}__pragma( pack ( pop )) 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
typedef unsigned short _ino_t; 
#line 18
typedef _ino_t ino_t; 
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
typedef unsigned _dev_t; 
#line 30
typedef _dev_t dev_t; 
#line 39 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/types.h"
typedef long _off_t; 
#line 42
typedef _off_t off_t; 
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 16
#pragma warning(push)
#pragma warning(disable: 4820)
#line 25
struct _stat32 { 
#line 27
_dev_t st_dev; 
#line 28
_ino_t st_ino; 
#line 29
unsigned short st_mode; 
#line 30
short st_nlink; 
#line 31
short st_uid; 
#line 32
short st_gid; 
#line 33
_dev_t st_rdev; 
#line 34
_off_t st_size; 
#line 35
__time32_t st_atime; 
#line 36
__time32_t st_mtime; 
#line 37
__time32_t st_ctime; 
#line 38
}; 
#line 40
struct _stat32i64 { 
#line 42
_dev_t st_dev; 
#line 43
_ino_t st_ino; 
#line 44
unsigned short st_mode; 
#line 45
short st_nlink; 
#line 46
short st_uid; 
#line 47
short st_gid; 
#line 48
_dev_t st_rdev; 
#line 49
__int64 st_size; 
#line 50
__time32_t st_atime; 
#line 51
__time32_t st_mtime; 
#line 52
__time32_t st_ctime; 
#line 53
}; 
#line 55
struct _stat64i32 { 
#line 57
_dev_t st_dev; 
#line 58
_ino_t st_ino; 
#line 59
unsigned short st_mode; 
#line 60
short st_nlink; 
#line 61
short st_uid; 
#line 62
short st_gid; 
#line 63
_dev_t st_rdev; 
#line 64
_off_t st_size; 
#line 65
__time64_t st_atime; 
#line 66
__time64_t st_mtime; 
#line 67
__time64_t st_ctime; 
#line 68
}; 
#line 70
struct _stat64 { 
#line 72
_dev_t st_dev; 
#line 73
_ino_t st_ino; 
#line 74
unsigned short st_mode; 
#line 75
short st_nlink; 
#line 76
short st_uid; 
#line 77
short st_gid; 
#line 78
_dev_t st_rdev; 
#line 79
__int64 st_size; 
#line 80
__time64_t st_atime; 
#line 81
__time64_t st_mtime; 
#line 82
__time64_t st_ctime; 
#line 83
}; 
#line 88
struct stat { 
#line 90
_dev_t st_dev; 
#line 91
_ino_t st_ino; 
#line 92
unsigned short st_mode; 
#line 93
short st_nlink; 
#line 94
short st_uid; 
#line 95
short st_gid; 
#line 96
_dev_t st_rdev; 
#line 97
_off_t st_size; 
#line 98
time_t st_atime; 
#line 99
time_t st_mtime; 
#line 100
time_t st_ctime; 
#line 101
}; 
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
__declspec(dllimport) int __cdecl _fstat32(int _FileHandle, struct _stat32 * _Stat); 
#line 160
__declspec(dllimport) int __cdecl _fstat32i64(int _FileHandle, struct _stat32i64 * _Stat); 
#line 165
__declspec(dllimport) int __cdecl _fstat64i32(int _FileHandle, struct _stat64i32 * _Stat); 
#line 170
__declspec(dllimport) int __cdecl _fstat64(int _FileHandle, struct _stat64 * _Stat); 
#line 175
__declspec(dllimport) int __cdecl _stat32(const char * _FileName, struct _stat32 * _Stat); 
#line 180
__declspec(dllimport) int __cdecl _stat32i64(const char * _FileName, struct _stat32i64 * _Stat); 
#line 185
__declspec(dllimport) int __cdecl _stat64i32(const char * _FileName, struct _stat64i32 * _Stat); 
#line 190
__declspec(dllimport) int __cdecl _stat64(const char * _FileName, struct _stat64 * _Stat); 
#line 195
__declspec(dllimport) int __cdecl _wstat32(const __wchar_t * _FileName, struct _stat32 * _Stat); 
#line 200
__declspec(dllimport) int __cdecl _wstat32i64(const __wchar_t * _FileName, struct _stat32i64 * _Stat); 
#line 205
__declspec(dllimport) int __cdecl _wstat64i32(const __wchar_t * _FileName, struct _stat64i32 * _Stat); 
#line 210
__declspec(dllimport) int __cdecl _wstat64(const __wchar_t * _FileName, struct _stat64 * _Stat); 
#line 234
static __inline int __cdecl fstat(const int _FileHandle, struct stat *const _Stat) 
#line 235
{ 
#line 236
typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0]; 
#line 237
return _fstat64i32(_FileHandle, (struct _stat64i32 *)_Stat); 
#line 238
} 
#line 239
static __inline int __cdecl stat(const char *const _FileName, struct stat *const _Stat) 
#line 240
{ 
#line 241
typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0]; 
#line 242
return _stat64i32(_FileName, (struct _stat64i32 *)_Stat); 
#line 243
} 
#line 252 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\sys/stat.h"
}
#line 249
#pragma warning(pop)
#line 252
__pragma( pack ( pop )) 
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 38
typedef __wchar_t _Wint_t; 
#line 45
__declspec(dllimport) __wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); 
#line 51
__declspec(dllimport) _locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); 
#line 58
__declspec(dllimport) wint_t __cdecl btowc(int _Ch); 
#line 62
__declspec(dllimport) size_t __cdecl mbrlen(const char * _Ch, size_t _SizeInBytes, mbstate_t * _State); 
#line 68
__declspec(dllimport) size_t __cdecl mbrtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SizeInBytes, mbstate_t * _State); 
#line 76
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s(size_t * _Retval, __wchar_t * _Dst, size_t _Size, const char ** _PSrc, size_t _N, mbstate_t * _State); 
#line 85
extern "C++" {template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], char const * * _PSource, size_t _Count, mbstate_t * _State ) throw ( ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }}
#line 95 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__declspec(dllimport) size_t __cdecl mbsrtowcs(__wchar_t * _Dest, const char ** _PSrc, size_t _Count, mbstate_t * _State); 
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__declspec(dllimport) errno_t __cdecl wcrtomb_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, __wchar_t _Ch, mbstate_t * _State); 
#line 112
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) throw ( ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }}
#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__declspec(dllimport) size_t __cdecl wcrtomb(char * _Dest, __wchar_t _Source, mbstate_t * _State); 
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__declspec(dllimport) errno_t __cdecl wcsrtombs_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, const __wchar_t ** _Src, size_t _Size, mbstate_t * _State); 
#line 138
extern "C++" {template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t const * * _PSrc, size_t _Count, mbstate_t * _State ) throw ( ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }}
#line 148 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__declspec(dllimport) size_t __cdecl wcsrtombs(char * _Dest, const __wchar_t ** _PSource, size_t _Count, mbstate_t * _State); 
#line 156 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__declspec(dllimport) int __cdecl wctob(wint_t _WCh); 
#line 163
errno_t __cdecl wmemcpy_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 171
errno_t __cdecl wmemmove_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); 
#line 180 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
__inline int __cdecl fwide(FILE *
#line 181
_F, int 
#line 182
_M) 
#line 184
{ 
#line 185
(void)_F; 
#line 186
return _M; 
#line 187
} 
#line 189
__inline int __cdecl mbsinit(const mbstate_t *
#line 190
_P) 
#line 192
{ 
#line 193
return (_P == (0)) || ((_P->_Wchar) == (0)); 
#line 194
} 
#line 196
__inline const __wchar_t *__cdecl wmemchr(const __wchar_t *
#line 197
_S, __wchar_t 
#line 198
_C, size_t 
#line 199
_N) 
#line 201
{ 
#line 202
for (; (0) < _N; (++_S), (--_N)) { 
#line 203
if ((*_S) == _C) { 
#line 204
return (const __wchar_t *)_S; }  }  
#line 206
return 0; 
#line 207
} 
#line 209
__inline int __cdecl wmemcmp(const __wchar_t *
#line 210
_S1, const __wchar_t *
#line 211
_S2, size_t 
#line 212
_N) 
#line 214
{ 
#line 215
for (; (0) < _N; ((++_S1), (++_S2)), (--_N)) { 
#line 216
if ((*_S1) != (*_S2)) { 
#line 217
return ((*_S1) < (*_S2)) ? -1 : 1; }  }  
#line 219
return 0; 
#line 220
} 
#line 225
__inline __wchar_t *__cdecl wmemcpy(__wchar_t *
#line 226
_S1, const __wchar_t *
#line 227
_S2, size_t 
#line 228
_N) 
#line 230
{ 
#pragma warning(push)
#pragma warning(disable : 4995 4996 6386)
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning(pop)
} 
#line 238
__inline __wchar_t *__cdecl wmemmove(__wchar_t *
#line 239
_S1, const __wchar_t *
#line 240
_S2, size_t 
#line 241
_N) 
#line 243
{ 
#pragma warning(push)
#pragma warning(disable : 4996 6386)
return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning(pop)
} 
#line 252
__inline __wchar_t *__cdecl wmemset(__wchar_t *
#line 253
_S, __wchar_t 
#line 254
_C, size_t 
#line 255
_N) 
#line 257
{ 
#line 258
__wchar_t *_Su = _S; 
#line 259
for (; (0) < _N; (++_Su), (--_N)) 
#line 260
{ 
#line 261
(*_Su) = _C; 
#line 262
}  
#line 263
return _S; 
#line 264
} 
#line 268
extern "C++" inline __wchar_t *__cdecl wmemchr(__wchar_t *
#line 269
_S, __wchar_t 
#line 270
_C, size_t 
#line 271
_N) 
#line 273
{ 
#line 274
const __wchar_t *const _SC = _S; 
#line 275
return const_cast< __wchar_t *>(wmemchr(_SC, _C, _N)); 
#line 276
} 
#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\wchar.h"
}__pragma( pack ( pop )) 
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\cwchar"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
extern "C" { typedef mbstate_t _Mbstatet; }
#line 19
namespace std { 
#pragma warning(push)
#pragma warning(disable: 4995)
#line 25
using ::mbstate_t;using ::tm;using ::wint_t;
#line 27
using ::btowc;using ::fgetwc;using ::fgetws;using ::fputwc;
#line 28
using ::fputws;using ::fwide;using ::fwprintf;
#line 29
using ::fwscanf;using ::getwc;using ::getwchar;
#line 30
using ::mbrlen;using ::mbrtowc;using ::mbsrtowcs;
#line 31
using ::mbsinit;using ::putwc;using ::putwchar;
#line 32
using ::swprintf;using ::swscanf;using ::ungetwc;
#line 33
using ::vfwprintf;using ::vswprintf;using ::vwprintf;
#line 34
using ::wcrtomb;using ::wprintf;using ::wscanf;
#line 35
using ::wcsrtombs;using ::wcstol;using ::wcscat;
#line 36
using ::wcschr;using ::wcscmp;using ::wcscoll;
#line 37
using ::wcscpy;using ::wcscspn;using ::wcslen;
#line 38
using ::wcsncat;using ::wcsncmp;using ::wcsncpy;
#line 39
using ::wcspbrk;using ::wcsrchr;using ::wcsspn;
#line 40
using ::wcstod;using ::wcstoul;using ::wcsstr;
#line 41
using ::wcstok;using ::wcsxfrm;using ::wctob;
#line 42
using ::wmemchr;using ::wmemcmp;using ::wmemcpy;
#line 43
using ::wmemmove;using ::wmemset;using ::wcsftime;
#line 45
using ::vfwscanf;using ::vswscanf;using ::vwscanf;
#line 46
using ::wcstof;using ::wcstold;
#line 47
using ::wcstoll;using ::wcstoull;
#line 49
#pragma warning(pop)
}
#line 54
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\limits"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 20
namespace std { 
#line 22
enum float_denorm_style { 
#line 24
denorm_indeterminate = (-1), 
#line 25
denorm_absent = 0, 
#line 26
denorm_present
#line 27
}; 
#line 30
enum float_round_style { 
#line 32
round_indeterminate = (-1), 
#line 33
round_toward_zero = 0, 
#line 34
round_to_nearest, 
#line 35
round_toward_infinity, 
#line 36
round_toward_neg_infinity
#line 37
}; 
#line 40
struct _Num_base { 
#line 42
static constexpr float_denorm_style has_denorm = denorm_absent; 
#line 43
static constexpr bool has_denorm_loss = false; 
#line 44
static constexpr bool has_infinity = false; 
#line 45
static constexpr bool has_quiet_NaN = false; 
#line 46
static constexpr bool has_signaling_NaN = false; 
#line 47
static constexpr bool is_bounded = false; 
#line 48
static constexpr bool is_exact = false; 
#line 49
static constexpr bool is_iec559 = false; 
#line 50
static constexpr bool is_integer = false; 
#line 51
static constexpr bool is_modulo = false; 
#line 52
static constexpr bool is_signed = false; 
#line 53
static constexpr bool is_specialized = false; 
#line 54
static constexpr bool tinyness_before = false; 
#line 55
static constexpr bool traps = false; 
#line 56
static constexpr float_round_style round_style = round_toward_zero; 
#line 57
static constexpr int digits = 0; 
#line 58
static constexpr int digits10 = 0; 
#line 59
static constexpr int max_digits10 = 0; 
#line 60
static constexpr int max_exponent = 0; 
#line 61
static constexpr int max_exponent10 = 0; 
#line 62
static constexpr int min_exponent = 0; 
#line 63
static constexpr int min_exponent10 = 0; 
#line 64
static constexpr int radix = 0; 
#line 65
}; 
#line 68
template < class _Ty >
 class numeric_limits
  : public _Num_base
 {
public :
  static constexpr _Ty ( min ) ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty ( max ) ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty lowest ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty epsilon ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty round_error ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty denorm_min ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty infinity ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty quiet_NaN ( ) noexcept
  {
  return ( _Ty ( ) );
  }

  static constexpr _Ty signaling_NaN ( ) noexcept
  {
  return ( _Ty ( ) );
  }
 };
#line 119
template< class _Ty> 
#line 120
class numeric_limits< const _Ty>  : public std::numeric_limits< _Ty>  { 
#line 123
}; 
#line 125
template< class _Ty> 
#line 126
class numeric_limits< volatile _Ty>  : public std::numeric_limits< _Ty>  { 
#line 129
}; 
#line 131
template< class _Ty> 
#line 132
class numeric_limits< const volatile _Ty>  : public std::numeric_limits< _Ty>  { 
#line 135
}; 
#line 138
struct _Num_int_base : public _Num_base { 
#line 141
static constexpr bool is_bounded = true; 
#line 142
static constexpr bool is_exact = true; 
#line 143
static constexpr bool is_integer = true; 
#line 144
static constexpr bool is_specialized = true; 
#line 145
static constexpr int radix = 2; 
#line 146
}; 
#line 149
struct _Num_float_base : public _Num_base { 
#line 152
static constexpr float_denorm_style has_denorm = denorm_present; 
#line 153
static constexpr bool has_infinity = true; 
#line 154
static constexpr bool has_quiet_NaN = true; 
#line 155
static constexpr bool has_signaling_NaN = true; 
#line 156
static constexpr bool is_bounded = true; 
#line 157
static constexpr bool is_iec559 = true; 
#line 158
static constexpr bool is_signed = true; 
#line 159
static constexpr bool is_specialized = true; 
#line 160
static constexpr float_round_style round_style = round_to_nearest; 
#line 161
static constexpr int radix = 2; 
#line 162
}; 
#line 165
template<> class numeric_limits< char>  : public _Num_int_base { 
#line 169
public: static constexpr char min() noexcept 
#line 170
{ 
#line 171
return -128; 
#line 172
} 
#line 174
static constexpr char max() noexcept 
#line 175
{ 
#line 176
return 127; 
#line 177
} 
#line 179
static constexpr char lowest() noexcept 
#line 180
{ 
#line 181
return min(); 
#line 182
} 
#line 184
static constexpr char epsilon() noexcept 
#line 185
{ 
#line 186
return 0; 
#line 187
} 
#line 189
static constexpr char round_error() noexcept 
#line 190
{ 
#line 191
return 0; 
#line 192
} 
#line 194
static constexpr char denorm_min() noexcept 
#line 195
{ 
#line 196
return 0; 
#line 197
} 
#line 199
static constexpr char infinity() noexcept 
#line 200
{ 
#line 201
return 0; 
#line 202
} 
#line 204
static constexpr char quiet_NaN() noexcept 
#line 205
{ 
#line 206
return 0; 
#line 207
} 
#line 209
static constexpr char signaling_NaN() noexcept 
#line 210
{ 
#line 211
return 0; 
#line 212
} 
#line 214
static constexpr bool is_signed = ((-128) != 0); 
#line 215
static constexpr bool is_modulo = ((-128) == 0); 
#line 216
static constexpr int digits = (8 - ((-128) != 0)); 
#line 217
static constexpr int digits10 = 2; 
#line 218
}; 
#line 221
template<> class numeric_limits< __wchar_t>  : public _Num_int_base { 
#line 225
public: static constexpr __wchar_t min() noexcept 
#line 226
{ 
#line 227
return 0; 
#line 228
} 
#line 230
static constexpr __wchar_t max() noexcept 
#line 231
{ 
#line 232
return 65535; 
#line 233
} 
#line 235
static constexpr __wchar_t lowest() noexcept 
#line 236
{ 
#line 237
return min(); 
#line 238
} 
#line 240
static constexpr __wchar_t epsilon() noexcept 
#line 241
{ 
#line 242
return 0; 
#line 243
} 
#line 245
static constexpr __wchar_t round_error() noexcept 
#line 246
{ 
#line 247
return 0; 
#line 248
} 
#line 250
static constexpr __wchar_t denorm_min() noexcept 
#line 251
{ 
#line 252
return 0; 
#line 253
} 
#line 255
static constexpr __wchar_t infinity() noexcept 
#line 256
{ 
#line 257
return 0; 
#line 258
} 
#line 260
static constexpr __wchar_t quiet_NaN() noexcept 
#line 261
{ 
#line 262
return 0; 
#line 263
} 
#line 265
static constexpr __wchar_t signaling_NaN() noexcept 
#line 266
{ 
#line 267
return 0; 
#line 268
} 
#line 270
static constexpr bool is_modulo = true; 
#line 271
static constexpr int digits = 16; 
#line 272
static constexpr int digits10 = 4; 
#line 273
}; 
#line 276
template<> class numeric_limits< bool>  : public _Num_int_base { 
#line 280
public: static constexpr bool min() noexcept 
#line 281
{ 
#line 282
return false; 
#line 283
} 
#line 285
static constexpr bool max() noexcept 
#line 286
{ 
#line 287
return true; 
#line 288
} 
#line 290
static constexpr bool lowest() noexcept 
#line 291
{ 
#line 292
return min(); 
#line 293
} 
#line 295
static constexpr bool epsilon() noexcept 
#line 296
{ 
#line 297
return 0; 
#line 298
} 
#line 300
static constexpr bool round_error() noexcept 
#line 301
{ 
#line 302
return 0; 
#line 303
} 
#line 305
static constexpr bool denorm_min() noexcept 
#line 306
{ 
#line 307
return 0; 
#line 308
} 
#line 310
static constexpr bool infinity() noexcept 
#line 311
{ 
#line 312
return 0; 
#line 313
} 
#line 315
static constexpr bool quiet_NaN() noexcept 
#line 316
{ 
#line 317
return 0; 
#line 318
} 
#line 320
static constexpr bool signaling_NaN() noexcept 
#line 321
{ 
#line 322
return 0; 
#line 323
} 
#line 325
static constexpr int digits = 1; 
#line 326
}; 
#line 329
template<> class numeric_limits< signed char>  : public _Num_int_base { 
#line 333
public: static constexpr signed char min() noexcept 
#line 334
{ 
#line 335
return -128; 
#line 336
} 
#line 338
static constexpr signed char max() noexcept 
#line 339
{ 
#line 340
return 127; 
#line 341
} 
#line 343
static constexpr signed char lowest() noexcept 
#line 344
{ 
#line 345
return min(); 
#line 346
} 
#line 348
static constexpr signed char epsilon() noexcept 
#line 349
{ 
#line 350
return 0; 
#line 351
} 
#line 353
static constexpr signed char round_error() noexcept 
#line 354
{ 
#line 355
return 0; 
#line 356
} 
#line 358
static constexpr signed char denorm_min() noexcept 
#line 359
{ 
#line 360
return 0; 
#line 361
} 
#line 363
static constexpr signed char infinity() noexcept 
#line 364
{ 
#line 365
return 0; 
#line 366
} 
#line 368
static constexpr signed char quiet_NaN() noexcept 
#line 369
{ 
#line 370
return 0; 
#line 371
} 
#line 373
static constexpr signed char signaling_NaN() noexcept 
#line 374
{ 
#line 375
return 0; 
#line 376
} 
#line 378
static constexpr bool is_signed = true; 
#line 379
static constexpr int digits = 7; 
#line 380
static constexpr int digits10 = 2; 
#line 381
}; 
#line 384
template<> class numeric_limits< unsigned char>  : public _Num_int_base { 
#line 388
public: static constexpr unsigned char min() noexcept 
#line 389
{ 
#line 390
return 0; 
#line 391
} 
#line 393
static constexpr unsigned char max() noexcept 
#line 394
{ 
#line 395
return 255; 
#line 396
} 
#line 398
static constexpr unsigned char lowest() noexcept 
#line 399
{ 
#line 400
return min(); 
#line 401
} 
#line 403
static constexpr unsigned char epsilon() noexcept 
#line 404
{ 
#line 405
return 0; 
#line 406
} 
#line 408
static constexpr unsigned char round_error() noexcept 
#line 409
{ 
#line 410
return 0; 
#line 411
} 
#line 413
static constexpr unsigned char denorm_min() noexcept 
#line 414
{ 
#line 415
return 0; 
#line 416
} 
#line 418
static constexpr unsigned char infinity() noexcept 
#line 419
{ 
#line 420
return 0; 
#line 421
} 
#line 423
static constexpr unsigned char quiet_NaN() noexcept 
#line 424
{ 
#line 425
return 0; 
#line 426
} 
#line 428
static constexpr unsigned char signaling_NaN() noexcept 
#line 429
{ 
#line 430
return 0; 
#line 431
} 
#line 433
static constexpr bool is_modulo = true; 
#line 434
static constexpr int digits = 8; 
#line 435
static constexpr int digits10 = 2; 
#line 436
}; 
#line 439
template<> class numeric_limits< short>  : public _Num_int_base { 
#line 443
public: static constexpr short min() noexcept 
#line 444
{ 
#line 445
return -32768; 
#line 446
} 
#line 448
static constexpr short max() noexcept 
#line 449
{ 
#line 450
return 32767; 
#line 451
} 
#line 453
static constexpr short lowest() noexcept 
#line 454
{ 
#line 455
return min(); 
#line 456
} 
#line 458
static constexpr short epsilon() noexcept 
#line 459
{ 
#line 460
return 0; 
#line 461
} 
#line 463
static constexpr short round_error() noexcept 
#line 464
{ 
#line 465
return 0; 
#line 466
} 
#line 468
static constexpr short denorm_min() noexcept 
#line 469
{ 
#line 470
return 0; 
#line 471
} 
#line 473
static constexpr short infinity() noexcept 
#line 474
{ 
#line 475
return 0; 
#line 476
} 
#line 478
static constexpr short quiet_NaN() noexcept 
#line 479
{ 
#line 480
return 0; 
#line 481
} 
#line 483
static constexpr short signaling_NaN() noexcept 
#line 484
{ 
#line 485
return 0; 
#line 486
} 
#line 488
static constexpr bool is_signed = true; 
#line 489
static constexpr int digits = 15; 
#line 490
static constexpr int digits10 = 4; 
#line 491
}; 
#line 495
template<> class numeric_limits< unsigned short>  : public _Num_int_base { 
#line 499
public: static constexpr unsigned short min() noexcept 
#line 500
{ 
#line 501
return 0; 
#line 502
} 
#line 504
static constexpr unsigned short max() noexcept 
#line 505
{ 
#line 506
return 65535; 
#line 507
} 
#line 509
static constexpr unsigned short lowest() noexcept 
#line 510
{ 
#line 511
return min(); 
#line 512
} 
#line 514
static constexpr unsigned short epsilon() noexcept 
#line 515
{ 
#line 516
return 0; 
#line 517
} 
#line 519
static constexpr unsigned short round_error() noexcept 
#line 520
{ 
#line 521
return 0; 
#line 522
} 
#line 524
static constexpr unsigned short denorm_min() noexcept 
#line 525
{ 
#line 526
return 0; 
#line 527
} 
#line 529
static constexpr unsigned short infinity() noexcept 
#line 530
{ 
#line 531
return 0; 
#line 532
} 
#line 534
static constexpr unsigned short quiet_NaN() noexcept 
#line 535
{ 
#line 536
return 0; 
#line 537
} 
#line 539
static constexpr unsigned short signaling_NaN() noexcept 
#line 540
{ 
#line 541
return 0; 
#line 542
} 
#line 544
static constexpr bool is_modulo = true; 
#line 545
static constexpr int digits = 16; 
#line 546
static constexpr int digits10 = 4; 
#line 547
}; 
#line 551 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\limits"
template<> class numeric_limits< char16_t>  : public _Num_int_base { 
#line 555
public: static constexpr char16_t min() noexcept 
#line 556
{ 
#line 557
return 0; 
#line 558
} 
#line 560
static constexpr char16_t max() noexcept 
#line 561
{ 
#line 562
return 65535; 
#line 563
} 
#line 565
static constexpr char16_t lowest() noexcept 
#line 566
{ 
#line 567
return min(); 
#line 568
} 
#line 570
static constexpr char16_t epsilon() noexcept 
#line 571
{ 
#line 572
return 0; 
#line 573
} 
#line 575
static constexpr char16_t round_error() noexcept 
#line 576
{ 
#line 577
return 0; 
#line 578
} 
#line 580
static constexpr char16_t denorm_min() noexcept 
#line 581
{ 
#line 582
return 0; 
#line 583
} 
#line 585
static constexpr char16_t infinity() noexcept 
#line 586
{ 
#line 587
return 0; 
#line 588
} 
#line 590
static constexpr char16_t quiet_NaN() noexcept 
#line 591
{ 
#line 592
return 0; 
#line 593
} 
#line 595
static constexpr char16_t signaling_NaN() noexcept 
#line 596
{ 
#line 597
return 0; 
#line 598
} 
#line 600
static constexpr bool is_modulo = true; 
#line 601
static constexpr int digits = 16; 
#line 602
static constexpr int digits10 = 4; 
#line 603
}; 
#line 606
template<> class numeric_limits< int>  : public _Num_int_base { 
#line 610
public: static constexpr int min() noexcept 
#line 611
{ 
#line 612
return (-2147483647) - 1; 
#line 613
} 
#line 615
static constexpr int max() noexcept 
#line 616
{ 
#line 617
return 2147483647; 
#line 618
} 
#line 620
static constexpr int lowest() noexcept 
#line 621
{ 
#line 622
return min(); 
#line 623
} 
#line 625
static constexpr int epsilon() noexcept 
#line 626
{ 
#line 627
return 0; 
#line 628
} 
#line 630
static constexpr int round_error() noexcept 
#line 631
{ 
#line 632
return 0; 
#line 633
} 
#line 635
static constexpr int denorm_min() noexcept 
#line 636
{ 
#line 637
return 0; 
#line 638
} 
#line 640
static constexpr int infinity() noexcept 
#line 641
{ 
#line 642
return 0; 
#line 643
} 
#line 645
static constexpr int quiet_NaN() noexcept 
#line 646
{ 
#line 647
return 0; 
#line 648
} 
#line 650
static constexpr int signaling_NaN() noexcept 
#line 651
{ 
#line 652
return 0; 
#line 653
} 
#line 655
static constexpr bool is_signed = true; 
#line 656
static constexpr int digits = 31; 
#line 657
static constexpr int digits10 = 9; 
#line 658
}; 
#line 661
template<> class numeric_limits< unsigned>  : public _Num_int_base { 
#line 665
public: static constexpr unsigned min() noexcept 
#line 666
{ 
#line 667
return 0; 
#line 668
} 
#line 670
static constexpr unsigned max() noexcept 
#line 671
{ 
#line 672
return 4294967295U; 
#line 673
} 
#line 675
static constexpr unsigned lowest() noexcept 
#line 676
{ 
#line 677
return min(); 
#line 678
} 
#line 680
static constexpr unsigned epsilon() noexcept 
#line 681
{ 
#line 682
return 0; 
#line 683
} 
#line 685
static constexpr unsigned round_error() noexcept 
#line 686
{ 
#line 687
return 0; 
#line 688
} 
#line 690
static constexpr unsigned denorm_min() noexcept 
#line 691
{ 
#line 692
return 0; 
#line 693
} 
#line 695
static constexpr unsigned infinity() noexcept 
#line 696
{ 
#line 697
return 0; 
#line 698
} 
#line 700
static constexpr unsigned quiet_NaN() noexcept 
#line 701
{ 
#line 702
return 0; 
#line 703
} 
#line 705
static constexpr unsigned signaling_NaN() noexcept 
#line 706
{ 
#line 707
return 0; 
#line 708
} 
#line 710
static constexpr bool is_modulo = true; 
#line 711
static constexpr int digits = 32; 
#line 712
static constexpr int digits10 = 9; 
#line 713
}; 
#line 716
template<> class numeric_limits< long>  : public _Num_int_base { 
#line 720
public: static constexpr long min() noexcept 
#line 721
{ 
#line 722
return (-2147483647L) - (1); 
#line 723
} 
#line 725
static constexpr long max() noexcept 
#line 726
{ 
#line 727
return 2147483647L; 
#line 728
} 
#line 730
static constexpr long lowest() noexcept 
#line 731
{ 
#line 732
return min(); 
#line 733
} 
#line 735
static constexpr long epsilon() noexcept 
#line 736
{ 
#line 737
return 0; 
#line 738
} 
#line 740
static constexpr long round_error() noexcept 
#line 741
{ 
#line 742
return 0; 
#line 743
} 
#line 745
static constexpr long denorm_min() noexcept 
#line 746
{ 
#line 747
return 0; 
#line 748
} 
#line 750
static constexpr long infinity() noexcept 
#line 751
{ 
#line 752
return 0; 
#line 753
} 
#line 755
static constexpr long quiet_NaN() noexcept 
#line 756
{ 
#line 757
return 0; 
#line 758
} 
#line 760
static constexpr long signaling_NaN() noexcept 
#line 761
{ 
#line 762
return 0; 
#line 763
} 
#line 765
static_assert((sizeof(int) == sizeof(long)), "LLP64 assumption");
#line 766
static constexpr bool is_signed = true; 
#line 767
static constexpr int digits = 31; 
#line 768
static constexpr int digits10 = 9; 
#line 769
}; 
#line 772
template<> class numeric_limits< unsigned long>  : public _Num_int_base { 
#line 776
public: static constexpr unsigned long min() noexcept 
#line 777
{ 
#line 778
return 0; 
#line 779
} 
#line 781
static constexpr unsigned long max() noexcept 
#line 782
{ 
#line 783
return 4294967295UL; 
#line 784
} 
#line 786
static constexpr unsigned long lowest() noexcept 
#line 787
{ 
#line 788
return min(); 
#line 789
} 
#line 791
static constexpr unsigned long epsilon() noexcept 
#line 792
{ 
#line 793
return 0; 
#line 794
} 
#line 796
static constexpr unsigned long round_error() noexcept 
#line 797
{ 
#line 798
return 0; 
#line 799
} 
#line 801
static constexpr unsigned long denorm_min() noexcept 
#line 802
{ 
#line 803
return 0; 
#line 804
} 
#line 806
static constexpr unsigned long infinity() noexcept 
#line 807
{ 
#line 808
return 0; 
#line 809
} 
#line 811
static constexpr unsigned long quiet_NaN() noexcept 
#line 812
{ 
#line 813
return 0; 
#line 814
} 
#line 816
static constexpr unsigned long signaling_NaN() noexcept 
#line 817
{ 
#line 818
return 0; 
#line 819
} 
#line 821
static_assert((sizeof(unsigned) == sizeof(unsigned long)), "LLP64 assumption");
#line 822
static constexpr bool is_modulo = true; 
#line 823
static constexpr int digits = 32; 
#line 824
static constexpr int digits10 = 9; 
#line 825
}; 
#line 828
template<> class numeric_limits< char32_t>  : public _Num_int_base { 
#line 832
public: static constexpr char32_t min() noexcept 
#line 833
{ 
#line 834
return 0; 
#line 835
} 
#line 837
static constexpr char32_t max() noexcept 
#line 838
{ 
#line 839
return 4294967295U; 
#line 840
} 
#line 842
static constexpr char32_t lowest() noexcept 
#line 843
{ 
#line 844
return min(); 
#line 845
} 
#line 847
static constexpr char32_t epsilon() noexcept 
#line 848
{ 
#line 849
return 0; 
#line 850
} 
#line 852
static constexpr char32_t round_error() noexcept 
#line 853
{ 
#line 854
return 0; 
#line 855
} 
#line 857
static constexpr char32_t denorm_min() noexcept 
#line 858
{ 
#line 859
return 0; 
#line 860
} 
#line 862
static constexpr char32_t infinity() noexcept 
#line 863
{ 
#line 864
return 0; 
#line 865
} 
#line 867
static constexpr char32_t quiet_NaN() noexcept 
#line 868
{ 
#line 869
return 0; 
#line 870
} 
#line 872
static constexpr char32_t signaling_NaN() noexcept 
#line 873
{ 
#line 874
return 0; 
#line 875
} 
#line 877
static constexpr bool is_modulo = true; 
#line 878
static constexpr int digits = 32; 
#line 879
static constexpr int digits10 = 9; 
#line 880
}; 
#line 883
template<> class numeric_limits< __int64>  : public _Num_int_base { 
#line 887
public: static constexpr __int64 min() noexcept 
#line 888
{ 
#line 889
return (-9223372036854775807i64) - (1); 
#line 890
} 
#line 892
static constexpr __int64 max() noexcept 
#line 893
{ 
#line 894
return 9223372036854775807i64; 
#line 895
} 
#line 897
static constexpr __int64 lowest() noexcept 
#line 898
{ 
#line 899
return min(); 
#line 900
} 
#line 902
static constexpr __int64 epsilon() noexcept 
#line 903
{ 
#line 904
return 0; 
#line 905
} 
#line 907
static constexpr __int64 round_error() noexcept 
#line 908
{ 
#line 909
return 0; 
#line 910
} 
#line 912
static constexpr __int64 denorm_min() noexcept 
#line 913
{ 
#line 914
return 0; 
#line 915
} 
#line 917
static constexpr __int64 infinity() noexcept 
#line 918
{ 
#line 919
return 0; 
#line 920
} 
#line 922
static constexpr __int64 quiet_NaN() noexcept 
#line 923
{ 
#line 924
return 0; 
#line 925
} 
#line 927
static constexpr __int64 signaling_NaN() noexcept 
#line 928
{ 
#line 929
return 0; 
#line 930
} 
#line 932
static constexpr bool is_signed = true; 
#line 933
static constexpr int digits = 63; 
#line 934
static constexpr int digits10 = 18; 
#line 935
}; 
#line 938
template<> class numeric_limits< unsigned __int64>  : public _Num_int_base { 
#line 942
public: static constexpr unsigned __int64 min() noexcept 
#line 943
{ 
#line 944
return 0; 
#line 945
} 
#line 947
static constexpr unsigned __int64 max() noexcept 
#line 948
{ 
#line 949
return 18446744073709551615Ui64; 
#line 950
} 
#line 952
static constexpr unsigned __int64 lowest() noexcept 
#line 953
{ 
#line 954
return min(); 
#line 955
} 
#line 957
static constexpr unsigned __int64 epsilon() noexcept 
#line 958
{ 
#line 959
return 0; 
#line 960
} 
#line 962
static constexpr unsigned __int64 round_error() noexcept 
#line 963
{ 
#line 964
return 0; 
#line 965
} 
#line 967
static constexpr unsigned __int64 denorm_min() noexcept 
#line 968
{ 
#line 969
return 0; 
#line 970
} 
#line 972
static constexpr unsigned __int64 infinity() noexcept 
#line 973
{ 
#line 974
return 0; 
#line 975
} 
#line 977
static constexpr unsigned __int64 quiet_NaN() noexcept 
#line 978
{ 
#line 979
return 0; 
#line 980
} 
#line 982
static constexpr unsigned __int64 signaling_NaN() noexcept 
#line 983
{ 
#line 984
return 0; 
#line 985
} 
#line 987
static constexpr bool is_modulo = true; 
#line 988
static constexpr int digits = 64; 
#line 989
static constexpr int digits10 = 19; 
#line 990
}; 
#line 993
template<> class numeric_limits< float>  : public _Num_float_base { 
#line 997
public: static constexpr float min() noexcept 
#line 998
{ 
#line 999
return (1.175494351e-38F); 
#line 1000
} 
#line 1002
static constexpr float max() noexcept 
#line 1003
{ 
#line 1004
return (3.402823466e+38F); 
#line 1005
} 
#line 1007
static constexpr float lowest() noexcept 
#line 1008
{ 
#line 1009
return -max(); 
#line 1010
} 
#line 1012
static constexpr float epsilon() noexcept 
#line 1013
{ 
#line 1014
return (1.192092896e-07F); 
#line 1015
} 
#line 1017
static constexpr float round_error() noexcept 
#line 1018
{ 
#line 1019
return (0.5F); 
#line 1020
} 
#line 1022
static constexpr float denorm_min() noexcept 
#line 1023
{ 
#line 1024
return (1.401298464e-45F); 
#line 1025
} 
#line 1027
static constexpr float infinity() noexcept 
#line 1028
{ 
#line 1029
return __builtin_huge_valf(); 
#line 1030
} 
#line 1032
static constexpr float quiet_NaN() noexcept 
#line 1033
{ 
#line 1034
return __builtin_nanf("0"); 
#line 1035
} 
#line 1037
static constexpr float signaling_NaN() noexcept 
#line 1038
{ 
#line 1039
return __builtin_nansf("1"); 
#line 1040
} 
#line 1042
static constexpr int digits = 24; 
#line 1043
static constexpr int digits10 = 6; 
#line 1044
static constexpr int max_digits10 = 9; 
#line 1045
static constexpr int max_exponent = 128; 
#line 1046
static constexpr int max_exponent10 = 38; 
#line 1047
static constexpr int min_exponent = (-125); 
#line 1048
static constexpr int min_exponent10 = (-37); 
#line 1049
}; 
#line 1052
template<> class numeric_limits< double>  : public _Num_float_base { 
#line 1056
public: static constexpr double min() noexcept 
#line 1057
{ 
#line 1058
return (2.225073858507201383e-308); 
#line 1059
} 
#line 1061
static constexpr double max() noexcept 
#line 1062
{ 
#line 1063
return (1.797693134862315708e+308); 
#line 1064
} 
#line 1066
static constexpr double lowest() noexcept 
#line 1067
{ 
#line 1068
return -max(); 
#line 1069
} 
#line 1071
static constexpr double epsilon() noexcept 
#line 1072
{ 
#line 1073
return (2.220446049250313081e-16); 
#line 1074
} 
#line 1076
static constexpr double round_error() noexcept 
#line 1077
{ 
#line 1078
return (0.5); 
#line 1079
} 
#line 1081
static constexpr double denorm_min() noexcept 
#line 1082
{ 
#line 1083
return (4.940656458412465442e-324); 
#line 1084
} 
#line 1086
static constexpr double infinity() noexcept 
#line 1087
{ 
#line 1088
return __builtin_huge_val(); 
#line 1089
} 
#line 1091
static constexpr double quiet_NaN() noexcept 
#line 1092
{ 
#line 1093
return __builtin_nan("0"); 
#line 1094
} 
#line 1096
static constexpr double signaling_NaN() noexcept 
#line 1097
{ 
#line 1098
return __builtin_nans("1"); 
#line 1099
} 
#line 1101
static constexpr int digits = 53; 
#line 1102
static constexpr int digits10 = 15; 
#line 1103
static constexpr int max_digits10 = 17; 
#line 1104
static constexpr int max_exponent = 1024; 
#line 1105
static constexpr int max_exponent10 = 308; 
#line 1106
static constexpr int min_exponent = (-1021); 
#line 1107
static constexpr int min_exponent10 = (-307); 
#line 1108
}; 
#line 1111
template<> class numeric_limits< long double>  : public _Num_float_base { 
#line 1115
public: static constexpr long double min() noexcept 
#line 1116
{ 
#line 1117
return (2.225073858507201383e-308); 
#line 1118
} 
#line 1120
static constexpr long double max() noexcept 
#line 1121
{ 
#line 1122
return (1.797693134862315708e+308); 
#line 1123
} 
#line 1125
static constexpr long double lowest() noexcept 
#line 1126
{ 
#line 1127
return -max(); 
#line 1128
} 
#line 1130
static constexpr long double epsilon() noexcept 
#line 1131
{ 
#line 1132
return (2.220446049250313081e-16); 
#line 1133
} 
#line 1135
static constexpr long double round_error() noexcept 
#line 1136
{ 
#line 1137
return (0.5L); 
#line 1138
} 
#line 1140
static constexpr long double denorm_min() noexcept 
#line 1141
{ 
#line 1142
return (4.940656458412465442e-324); 
#line 1143
} 
#line 1145
static constexpr long double infinity() noexcept 
#line 1146
{ 
#line 1147
return __builtin_huge_val(); 
#line 1148
} 
#line 1150
static constexpr long double quiet_NaN() noexcept 
#line 1151
{ 
#line 1152
return __builtin_nan("0"); 
#line 1153
} 
#line 1155
static constexpr long double signaling_NaN() noexcept 
#line 1156
{ 
#line 1157
return __builtin_nans("1"); 
#line 1158
} 
#line 1160
static constexpr int digits = 53; 
#line 1161
static constexpr int digits10 = 15; 
#line 1162
static constexpr int max_digits10 = 17; 
#line 1163
static constexpr int max_exponent = 1024; 
#line 1164
static constexpr int max_exponent10 = 308; 
#line 1165
static constexpr int min_exponent = (-1021); 
#line 1166
static constexpr int min_exponent10 = (-307); 
#line 1167
}; 
#line 1168
}
#line 1171
#pragma warning(pop)
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\new"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 16
namespace std { 
#line 43 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\new"
typedef void (__cdecl *new_handler)(void); 
#line 47 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\new"
new_handler __cdecl set_new_handler(new_handler) noexcept; 
#line 48
new_handler __cdecl get_new_handler() noexcept; 
#line 49
}
#line 53
#pragma warning(pop)
#pragma pack ( pop )
#line 14 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 21
namespace std { 
#line 23
using streamoff = __int64; 
#line 24
using streamsize = __int64; 
#line 27
template < class _Statetype >
 class fpos
 {
public :
  fpos ( streamoff _Off = 0 )
  : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( )
  {
  }

 fpos ( _Statetype _State, fpos_t _Fileposition )
  : _Myoff ( _Fileposition ), _Fpos ( 0 ), _Mystate ( _State )
  {
  }

  _Statetype state ( ) const
  {
  return ( _Mystate );
  }

 void state ( _Statetype _State )
  {
  _Mystate = _State;
  }

 operator streamoff ( ) const
  {


  return ( _Myoff + _Fpos );
  }


 [ [ deprecated ( "warning STL4019: The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with workarounds for o" "ld versions of Visual C++. It will be removed in a future release, and in this release always returns 0. Please use standards-co" "nforming mechanisms to manipulate fpos, such as conversions to and from streamoff, or an integral type, instead. If you are rece" "iving this message while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use standards-conforming mec" "hanisms, as it does for other compilers. You can define _SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have r" "eceived this warning, or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely." ) ] ] fpos_t seekpos ( ) const noexcept
  {
  return { };
  }


  streamoff operator - ( const fpos & _Right ) const
  {
  return ( static_cast < streamoff > ( * this ) - static_cast < streamoff > ( _Right ) );
  }

 fpos & operator += ( streamoff _Off )
  {
  _Myoff += _Off;
  return ( * this );
  }

 fpos & operator -= ( streamoff _Off )
  {
  _Myoff -= _Off;
  return ( * this );
  }

  fpos operator + ( streamoff _Off ) const
  {
  fpos _Tmp = * this;
  _Tmp += _Off;
  return ( _Tmp );
  }

  fpos operator - ( streamoff _Off ) const
  {
  fpos _Tmp = * this;
  _Tmp -= _Off;
  return ( _Tmp );
  }

  bool operator == ( const fpos & _Right ) const
  {
  return ( static_cast < streamoff > ( * this ) == static_cast < streamoff > ( _Right ) );
  }

 template < class _Int,
  enable_if_t < is_integral_v < _Int >, int > = 0 >
   friend bool operator == ( const fpos & _Left, const _Int _Right )
  {
  return ( static_cast < streamoff > ( _Left ) == _Right );
  }

 template < class _Int,
  enable_if_t < is_integral_v < _Int >, int > = 0 >
   friend bool operator == ( const _Int _Left, const fpos & _Right )
  {
  return ( _Left == static_cast < streamoff > ( _Right ) );
  }

  bool operator != ( const fpos & _Right ) const
  {
  return ( static_cast < streamoff > ( * this ) != static_cast < streamoff > ( _Right ) );
  }

 template < class _Int,
  enable_if_t < is_integral_v < _Int >, int > = 0 >
   friend bool operator != ( const fpos & _Left, const _Int _Right )
  {
  return ( static_cast < streamoff > ( _Left ) != _Right );
  }

 template < class _Int,
  enable_if_t < is_integral_v < _Int >, int > = 0 >
   friend bool operator != ( const _Int _Left, const fpos & _Right )
  {
  return ( _Left != static_cast < streamoff > ( _Right ) );
  }

private :
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };
#line 140 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
using streampos = fpos< _Mbstatet> ; 
#line 141
using wstreampos = streampos; 
#line 144
template < class _Elem,
 class _Int_type >
 struct _Char_traits
 {
 using char_type = _Elem;
 using int_type = _Int_type;
 using pos_type = streampos;
 using off_type = streamoff;
 using state_type = _Mbstatet;

  static inline int compare ( const _Elem * _First1,
    const _Elem * _First2, size_t _Count ) noexcept
  {
  for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 )
   {
   if ( * _First1 != * _First2 )
    {
    return ( * _First1 < * _First2 ? - 1 : + 1 );
    }
   }

  return ( 0 );
  }

  static inline size_t length ( const _Elem * _First ) noexcept
  {
  size_t _Count = 0;
  while ( * _First != _Elem ( ) )
   {
   ++ _Count;
   ++ _First;
   }

  return ( _Count );
  }

 static _Elem * copy ( _Elem * const _First1,
    const _Elem * _First2, size_t _Count ) noexcept
  {
  return ( static_cast < _Elem * > ( :: memcpy ( _First1, _First2, _Count * sizeof ( _Elem ) ) ) );
  }

   static _Elem * _Copy_s (
    _Elem * const _First1, const size_t _Dest_size,
    const _Elem * const _First2, const size_t _Count ) noexcept
  {
  do { if ( _Count <= _Dest_size ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd", 190, 0, "%s", "invalid argument" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x69\x6f\x73\x66\x77\x64", 190, 0 ); } while ( false ); }; } while ( false );
  return ( copy ( _First1, _First2, _Count ) );
  }

  static inline const _Elem * find ( const _Elem * _First,
  size_t _Count, const _Elem & _Ch ) noexcept
  {
  for (; 0 < _Count; -- _Count, ++ _First )
   {
   if ( * _First == _Ch )
    {
    return ( _First );
    }
   }

  return ( nullptr );
  }

 static _Elem * move ( _Elem * const _First1,
    const _Elem * _First2, size_t _Count ) noexcept
  {
  return ( static_cast < _Elem * > ( :: memmove ( _First1, _First2, _Count * sizeof ( _Elem ) ) ) );
  }

 static _Elem * assign ( _Elem * const _First,
  size_t _Count, const _Elem _Ch ) noexcept
  {
  _Elem * _Next = _First;
  for (; 0 < _Count; -- _Count, ++ _Next )
   {
   * _Next = _Ch;
   }

  return ( _First );
  }

 static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept
  {
  _Left = _Right;
  }

  static constexpr bool eq ( const _Elem & _Left, const _Elem & _Right ) noexcept
  {
  return ( _Left == _Right );
  }

  static constexpr bool lt ( const _Elem & _Left, const _Elem & _Right ) noexcept
  {
  return ( _Left < _Right );
  }

  static constexpr _Elem to_char_type ( const int_type & _Meta ) noexcept
  {
  return ( static_cast < _Elem > ( _Meta ) );
  }

  static constexpr int_type to_int_type ( const _Elem & _Ch ) noexcept
  {
  return ( static_cast < int_type > ( _Ch ) );
  }

  static constexpr bool eq_int_type ( const int_type & _Left, const int_type & _Right ) noexcept
  {
  return ( _Left == _Right );
  }

  static constexpr int_type not_eof ( const int_type & _Meta ) noexcept
  {
  return ( _Meta != eof ( ) ? _Meta : ! eof ( ) );
  }

  static constexpr int_type eof ( ) noexcept
  {
  return ( static_cast < int_type > ( ( - 1 ) ) );
  }
 };
#line 268
template < class _Elem >
 struct _WChar_traits
 {
 using char_type = _Elem;
 using int_type = unsigned short;
 using pos_type = streampos;
 using off_type = streamoff;
 using state_type = _Mbstatet;

  static inline int compare ( const _Elem * const _First1,
     const _Elem * const _First2, const size_t _Count ) noexcept
  {










  return ( :: wmemcmp ( reinterpret_cast < const wchar_t * > ( _First1 ),
   reinterpret_cast < const wchar_t * > ( _First2 ), _Count ) );

  }

  static inline size_t length ( const _Elem * _First ) noexcept
  {










  return ( :: wcslen ( reinterpret_cast < const wchar_t * > ( _First ) ) );

  }

 static _Elem * copy ( _Elem * const _First1,
     const _Elem * const _First2, const size_t _Count ) noexcept
  {
  return ( reinterpret_cast < _Elem * > ( :: wmemcpy ( reinterpret_cast < wchar_t * > ( _First1 ),
   reinterpret_cast < const wchar_t * > ( _First2 ), _Count ) ) );
  }

   static _Elem * _Copy_s (
     _Elem * const _First1, const size_t _Size_in_words,
     const _Elem * const _First2, const size_t _Count ) noexcept
  {
  do { if ( _Count <= _Size_in_words ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd", 322, 0, "%s", "invalid argument" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x69\x6f\x73\x66\x77\x64", 322, 0 ); } while ( false ); }; } while ( false );
  return ( copy ( _First1, _First2, _Count ) );
  }

  static inline const _Elem * find ( const _Elem * _First,
   const size_t _Count, const _Elem & _Ch ) noexcept
  {










  return ( reinterpret_cast < const _Elem * > ( :: wmemchr (
   reinterpret_cast < const wchar_t * > ( _First ), _Ch, _Count ) ) );

  }

 static _Elem * move ( _Elem * const _First1,
     const _Elem * const _First2, const size_t _Count ) noexcept
  {
  return ( reinterpret_cast < _Elem * > ( :: wmemmove ( reinterpret_cast < wchar_t * > ( _First1 ),
   reinterpret_cast < const wchar_t * > ( _First2 ), _Count ) ) );
  }

 static _Elem * assign ( _Elem * const _First, size_t _Count, _Elem _Ch )
   noexcept
  {
  return ( reinterpret_cast < _Elem * > ( :: wmemset ( reinterpret_cast < wchar_t * > ( _First ), _Ch, _Count ) ) );
  }

 static inline void assign ( _Elem & _Left, const _Elem & _Right ) noexcept
  {
  _Left = _Right;
  }

  static constexpr bool eq ( const _Elem & _Left, const _Elem & _Right ) noexcept
  {
  return ( _Left == _Right );
  }

  static constexpr bool lt ( const _Elem & _Left, const _Elem & _Right ) noexcept
  {
  return ( _Left < _Right );
  }

  static constexpr _Elem to_char_type ( const int_type & _Meta ) noexcept
  {
  return ( _Meta );
  }

  static constexpr int_type to_int_type ( const _Elem & _Ch ) noexcept
  {
  return ( _Ch );
  }

  static constexpr bool eq_int_type ( const int_type & _Left, const int_type & _Right ) noexcept
  {
  return ( _Left == _Right );
  }

  static constexpr int_type not_eof ( const int_type & _Meta ) noexcept
  {
  return ( _Meta != eof ( ) ? _Meta : static_cast < int_type > ( ! eof ( ) ) );
  }

  static constexpr int_type eof ( ) noexcept
  {
  return ( ( ( wint_t ) ( 65535 ) ) );
  }
 };
#line 399 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
template< class _Elem> 
#line 400
struct char_traits : public _Char_traits< _Elem, long>  { 
#line 403
}; 
#line 407
template<> struct char_traits< char16_t>  : public _WChar_traits< char16_t>  { 
#line 410
}; 
#line 412
using u16streampos = streampos; 
#line 416
template<> struct char_traits< char32_t>  : public _Char_traits< char32_t, unsigned>  { 
#line 419
}; 
#line 421
using u32streampos = streampos; 
#line 425
template<> struct char_traits< __wchar_t>  : public _WChar_traits< __wchar_t>  { 
#line 428
}; 
#line 433
template<> struct char_traits< unsigned short>  : public _WChar_traits< unsigned short>  { 
#line 436
}; 
#line 441 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
template<> struct char_traits< char>  { 
#line 443
using char_type = char; 
#line 444
using int_type = int; 
#line 445
using pos_type = streampos; 
#line 446
using off_type = streamoff; 
#line 447
using state_type = _Mbstatet; 
#line 449
static int compare(const char *const _First1, const char *const 
#line 450
_First2, const size_t _Count) noexcept 
#line 451
{ 
#line 455 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
return ::memcmp(_First1, _First2, _Count); 
#line 457 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
} 
#line 459
static size_t length(const char *const _First) noexcept 
#line 460
{ 
#line 464 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
return ::strlen(_First); 
#line 466 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
} 
#line 468
static char *copy(char *const _First1, const char *const 
#line 469
_First2, const size_t _Count) noexcept 
#line 470
{ 
#line 471
return static_cast< char *>(::memcpy(_First1, _First2, _Count)); 
#line 472
} 
#line 474
static char *_Copy_s(char *const 
#line 475
_First1, const size_t _Size_in_bytes, const char *const 
#line 476
_First2, const size_t _Count) noexcept 
#line 477
{ 
#line 478
do { if (_Count <= _Size_in_bytes) { } else { do { (void)((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd", 478, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x63\x68\x61\x72\x5f\x74\x72\x61\x69\x74\x73\x3c\x63\x68\x61\x72\x3e\x3a\x3a\x5f\x43\x6f\x70\x79\x5f\x73", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x69\x6f\x73\x66\x77\x64", 478, 0); } while (false); }  ; } while (false); 
#line 479
return copy(_First1, _First2, _Count); 
#line 480
} 
#line 482
static const char *find(const char *const _First, const size_t 
#line 483
_Count, const char &_Ch) noexcept 
#line 484
{ 
#line 488 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
return static_cast< const char *>(::memchr(_First, _Ch, _Count)); 
#line 490 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
} 
#line 492
static char *move(char *const _First1, const char *const 
#line 493
_First2, const size_t _Count) noexcept 
#line 494
{ 
#line 495
return static_cast< char *>(::memmove(_First1, _First2, _Count)); 
#line 496
} 
#line 498
static char *assign(char *const _First, const size_t 
#line 499
_Count, const char _Ch) noexcept 
#line 500
{ 
#line 501
return static_cast< char *>(::memset(_First, _Ch, _Count)); 
#line 502
} 
#line 504
static void assign(char &_Left, const char &_Right) noexcept 
#line 505
{ 
#line 506
_Left = _Right; 
#line 507
} 
#line 509
static constexpr bool eq(const char &_Left, const char &_Right) noexcept 
#line 510
{ 
#line 511
return _Left == _Right; 
#line 512
} 
#line 514
static constexpr bool lt(const char &_Left, const char &_Right) noexcept 
#line 515
{ 
#line 516
return (static_cast< unsigned char>(_Left)) < (static_cast< unsigned char>(_Right)); 
#line 517
} 
#line 519
static constexpr char to_char_type(const int_type &_Meta) noexcept 
#line 520
{ 
#line 521
return static_cast< char>(_Meta); 
#line 522
} 
#line 524
static constexpr int_type to_int_type(const char &_Ch) noexcept 
#line 525
{ 
#line 526
return static_cast< unsigned char>(_Ch); 
#line 527
} 
#line 529
static constexpr bool eq_int_type(const int_type &_Left, const int_type &_Right) noexcept 
#line 530
{ 
#line 531
return _Left == _Right; 
#line 532
} 
#line 534
static constexpr int_type not_eof(const int_type &_Meta) noexcept 
#line 535
{ 
#line 536
return (_Meta != eof()) ? _Meta : (!(eof())); 
#line 537
} 
#line 539
static constexpr int_type eof() noexcept 
#line 540
{ 
#line 541
return -1; 
#line 542
} 
#line 543
}; 
#line 546
template < class _Ty >
 class allocator;
#line 548
class ios_base; 
#line 549
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ios;
#line 552
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class istreambuf_iterator;
#line 555
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class ostreambuf_iterator;
#line 558
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_streambuf;
#line 562
#pragma vtordisp(push, 2)
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_istream;
#line 566
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ostream;
#pragma vtordisp(pop)
#line 571
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_iostream;
#line 574
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_stringbuf;
#line 578
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_istringstream;
#line 582
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_ostringstream;
#line 586
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_stringstream;
#line 590
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_filebuf;
#line 593
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ifstream;
#line 596
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ofstream;
#line 599
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_fstream;
#line 604
template < class _Elem,
 class _InIt >
 class num_get;
#line 607
template < class _Elem,
 class _OutIt >
 class num_put;
#line 610
template< class _Elem> class collate; 
#line 615 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
using ios = basic_ios< char, char_traits< char> > ; 
#line 616
using streambuf = basic_streambuf< char, char_traits< char> > ; 
#line 617
using istream = basic_istream< char, char_traits< char> > ; 
#line 618
using ostream = basic_ostream< char, char_traits< char> > ; 
#line 619
using iostream = basic_iostream< char, char_traits< char> > ; 
#line 620
using stringbuf = basic_stringbuf< char, char_traits< char> , allocator< char> > ; 
#line 621
using istringstream = basic_istringstream< char, char_traits< char> , allocator< char> > ; 
#line 622
using ostringstream = basic_ostringstream< char, char_traits< char> , allocator< char> > ; 
#line 623
using stringstream = basic_stringstream< char, char_traits< char> , allocator< char> > ; 
#line 624
using filebuf = basic_filebuf< char, char_traits< char> > ; 
#line 625
using ifstream = basic_ifstream< char, char_traits< char> > ; 
#line 626
using ofstream = basic_ofstream< char, char_traits< char> > ; 
#line 627
using fstream = basic_fstream< char, char_traits< char> > ; 
#line 630
using wios = basic_ios< __wchar_t, char_traits< __wchar_t> > ; 
#line 631
using wstreambuf = basic_streambuf< __wchar_t, char_traits< __wchar_t> > ; 
#line 632
using wistream = basic_istream< __wchar_t, char_traits< __wchar_t> > ; 
#line 633
using wostream = basic_ostream< __wchar_t, char_traits< __wchar_t> > ; 
#line 634
using wiostream = basic_iostream< __wchar_t, char_traits< __wchar_t> > ; 
#line 635
using wstringbuf = basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 636
using wistringstream = basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 637
using wostringstream = basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 638
using wstringstream = basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > ; 
#line 639
using wfilebuf = basic_filebuf< __wchar_t, char_traits< __wchar_t> > ; 
#line 640
using wifstream = basic_ifstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 641
using wofstream = basic_ofstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 642
using wfstream = basic_fstream< __wchar_t, char_traits< __wchar_t> > ; 
#line 650 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\iosfwd"
}
#line 654
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\utility"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
namespace std { 
#line 19
template < class _Ty >

 constexpr const _Ty & _Min_value ( const _Ty & _Left, const _Ty & _Right )
  noexcept ( noexcept ( _Right < _Left ) )
 {
 return ( _Right < _Left ? _Right : _Left );
 }
#line 28
template < class _Ty >

 constexpr const _Ty & _Max_value ( const _Ty & _Left, const _Ty & _Right )
  noexcept ( noexcept ( _Left < _Right ) )
 {
 return ( _Left < _Right ? _Right : _Left );
 }
#line 37
template < class _FwdIt1,
 class _FwdIt2 > inline
 void iter_swap ( _FwdIt1 _Left, _FwdIt2 _Right )
 {
 swap ( * _Left, * _Right );
 }
#line 45
template < class _Ty,
 size_t _Size,
 class > inline
 void swap ( _Ty ( & _Left ) [ _Size ], _Ty ( & _Right ) [ _Size ] )
  noexcept ( _Is_nothrow_swappable < _Ty > :: value )
 {
 if ( & _Left != & _Right )
  {
  _Ty * _First1 = _Left;
  _Ty * _Last1 = _First1 + _Size;
  _Ty * _First2 = _Right;
  for (; _First1 != _Last1; ++ _First1, ++ _First2 )
   :: std :: iter_swap ( _First1, _First2 );
  }
 }
#line 61
template < class _Ty,
 class > inline
 void swap ( _Ty & _Left, _Ty & _Right )
  noexcept ( is_nothrow_move_constructible_v < _Ty > && is_nothrow_move_assignable_v < _Ty > )

 {
 _Ty _Tmp = :: std :: move ( _Left );
 _Left = :: std :: move ( _Right );
 _Right = :: std :: move ( _Tmp );
 }
#line 73 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\utility"
template < class _Ty > inline
 void _Swap_adl ( _Ty & _Left, _Ty & _Right )
  noexcept ( _Is_nothrow_swappable < _Ty > :: value )
 {
 swap ( _Left, _Right );
 }
#line 81
struct piecewise_construct_t { 
#line 83
explicit piecewise_construct_t() = default;
#line 84
}; 
#line 86
constexpr piecewise_construct_t piecewise_construct{}; 
#line 89
template< class ...> class tuple; 
#line 92
template < class _Ty1,
 class _Ty2 >
 struct pair
 {
 using first_type = _Ty1;
 using second_type = _Ty2;

 template < class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  enable_if_t < conjunction_v <
   is_default_constructible < _Uty1 >,
   is_default_constructible < _Uty2 >,
   _Is_implicitly_default_constructible < _Uty1 >,
   _Is_implicitly_default_constructible < _Uty2 >
  >, int > = 0 >
  constexpr pair ( )
   noexcept ( is_nothrow_default_constructible_v < _Uty1 > && is_nothrow_default_constructible_v < _Uty2 > )

  : first ( ), second ( )
  {
  }

 template < class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  enable_if_t < conjunction_v <
   is_default_constructible < _Uty1 >,
   is_default_constructible < _Uty2 >,
   negation < conjunction <
    _Is_implicitly_default_constructible < _Uty1 >,
    _Is_implicitly_default_constructible < _Uty2 >> >
  >, int > = 0 >
  constexpr explicit pair ( )
   noexcept ( is_nothrow_default_constructible_v < _Uty1 > && is_nothrow_default_constructible_v < _Uty2 > )

  : first ( ), second ( )
  {
  }

 template < class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  enable_if_t < conjunction_v <
   is_copy_constructible < _Uty1 >,
   is_copy_constructible < _Uty2 >,
   is_convertible < const _Uty1 &, _Uty1 >,
   is_convertible < const _Uty2 &, _Uty2 >
  >, int > = 0 >
  constexpr pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
   noexcept ( is_nothrow_copy_constructible_v < _Uty1 > && is_nothrow_copy_constructible_v < _Uty2 > )

  : first ( _Val1 ), second ( _Val2 )
  {
  }

 template < class _Uty1 = _Ty1,
  class _Uty2 = _Ty2,
  enable_if_t < conjunction_v <
   is_copy_constructible < _Uty1 >,
   is_copy_constructible < _Uty2 >,
   negation < conjunction <
    is_convertible < const _Uty1 &, _Uty1 >,
    is_convertible < const _Uty2 &, _Uty2 >> >
  >, int > = 0 >
  constexpr explicit pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
   noexcept ( is_nothrow_copy_constructible_v < _Uty1 > && is_nothrow_copy_constructible_v < _Uty2 > )

  : first ( _Val1 ), second ( _Val2 )
  {
  }

 template < class _Other1,
  class _Other2,
  enable_if_t < conjunction_v <
   is_constructible < _Ty1, _Other1 >,
   is_constructible < _Ty2, _Other2 >,
   is_convertible < _Other1, _Ty1 >,
   is_convertible < _Other2, _Ty2 >
  >, int > = 0 >
  constexpr pair ( _Other1 && _Val1, _Other2 && _Val2 )
   noexcept ( is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )

  : first ( :: std :: forward < _Other1 > ( _Val1 ) ),
    second ( :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

 template < class _Other1,
  class _Other2,
  enable_if_t < conjunction_v <
   is_constructible < _Ty1, _Other1 >,
   is_constructible < _Ty2, _Other2 >,
   negation < conjunction <
    is_convertible < _Other1, _Ty1 >,
    is_convertible < _Other2, _Ty2 >> >
  >, int > = 0 >
  constexpr explicit pair ( _Other1 && _Val1, _Other2 && _Val2 )
   noexcept ( is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )

  : first ( :: std :: forward < _Other1 > ( _Val1 ) ),
    second ( :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

 pair ( const pair & ) = default;
 pair ( pair && ) = default;

 template < class _Other1,
  class _Other2,
  enable_if_t < conjunction_v <
   is_constructible < _Ty1, const _Other1 & >,
   is_constructible < _Ty2, const _Other2 & >,
   is_convertible < const _Other1 &, _Ty1 >,
   is_convertible < const _Other2 &, _Ty2 >
  >, int > = 0 >
  constexpr pair ( const pair < _Other1, _Other2 > & _Right )
   noexcept ( is_nothrow_constructible_v < _Ty1, const _Other1 & > && is_nothrow_constructible_v < _Ty2, const _Other2 & > )

  : first ( _Right . first ), second ( _Right . second )
  {
  }

 template < class _Other1,
  class _Other2,
  enable_if_t < conjunction_v <
   is_constructible < _Ty1, const _Other1 & >,
   is_constructible < _Ty2, const _Other2 & >,
   negation < conjunction <
    is_convertible < const _Other1 &, _Ty1 >,
    is_convertible < const _Other2 &, _Ty2 >> >
  >, int > = 0 >
  constexpr explicit pair ( const pair < _Other1, _Other2 > & _Right )
   noexcept ( is_nothrow_constructible_v < _Ty1, const _Other1 & > && is_nothrow_constructible_v < _Ty2, const _Other2 & > )

  : first ( _Right . first ), second ( _Right . second )
  {
  }

 template < class _Other1,
  class _Other2,
  enable_if_t < conjunction_v <
   is_constructible < _Ty1, _Other1 >,
   is_constructible < _Ty2, _Other2 >,
   is_convertible < _Other1, _Ty1 >,
   is_convertible < _Other2, _Ty2 >
  >, int > = 0 >
  constexpr pair ( pair < _Other1, _Other2 > && _Right )
   noexcept ( is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )

  : first ( :: std :: forward < _Other1 > ( _Right . first ) ),
   second ( :: std :: forward < _Other2 > ( _Right . second ) )
  {
  }

 template < class _Other1,
  class _Other2,
  enable_if_t < conjunction_v <
   is_constructible < _Ty1, _Other1 >,
   is_constructible < _Ty2, _Other2 >,
   negation < conjunction <
    is_convertible < _Other1, _Ty1 >,
    is_convertible < _Other2, _Ty2 >> >
  >, int > = 0 >
  constexpr explicit pair ( pair < _Other1, _Other2 > && _Right )
   noexcept ( is_nothrow_constructible_v < _Ty1, _Other1 > && is_nothrow_constructible_v < _Ty2, _Other2 > )

  : first ( :: std :: forward < _Other1 > ( _Right . first ) ),
   second ( :: std :: forward < _Other2 > ( _Right . second ) )
  {
  }

 template < class _Tuple1,
  class _Tuple2,
  size_t ... _Indexes1,
  size_t ... _Indexes2 > inline
  pair ( _Tuple1 & _Val1,
   _Tuple2 & _Val2,
   index_sequence < _Indexes1 ... >,
   index_sequence < _Indexes2 ... > );

 template < class ... _Types1,
  class ... _Types2 > inline
  pair ( piecewise_construct_t,
   tuple < _Types1 ... > _Val1,
   tuple < _Types2 ... > _Val2 );

 pair & operator = ( const volatile pair & ) = delete;

 template < class _Other1 = _Ty1,
  class _Other2 = _Ty2,
  enable_if_t < conjunction_v <
   is_assignable < _Ty1 &, const _Other1 & >,
   is_assignable < _Ty2 &, const _Other2 & >
  >, int > = 0 >
  pair & operator = ( const pair < _Other1, _Other2 > & _Right )
   noexcept ( is_nothrow_assignable_v < _Ty1 &, const _Other1 & > && is_nothrow_assignable_v < _Ty2 &, const _Other2 & > )

  {
  first = _Right . first;
  second = _Right . second;
  return ( * this );
  }

 template < class _Other1 = _Ty1,
  class _Other2 = _Ty2,
  enable_if_t < conjunction_v <
   is_assignable < _Ty1 &, _Other1 >,
   is_assignable < _Ty2 &, _Other2 >
  >, int > = 0 >
  pair & operator = ( pair < _Other1, _Other2 > && _Right )
   noexcept ( is_nothrow_assignable_v < _Ty1 &, _Other1 > && is_nothrow_assignable_v < _Ty2 &, _Other2 > )

  {
  first = :: std :: forward < _Other1 > ( _Right . first );
  second = :: std :: forward < _Other2 > ( _Right . second );
  return ( * this );
  }

 void swap ( pair & _Right )
  noexcept ( _Is_nothrow_swappable < _Ty1 > :: value && _Is_nothrow_swappable < _Ty2 > :: value )

  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Swap_adl ( first, _Right . first );
   _Swap_adl ( second, _Right . second );
   }
  }

 _Ty1 first;
 _Ty2 second;
 };
#line 329 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\utility"
template < class _Ty1,
 class _Ty2,
 class = enable_if_t < _Is_swappable < _Ty1 > :: value && _Is_swappable < _Ty2 > :: value > > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right )
  noexcept ( noexcept ( _Left . swap ( _Right ) ) )
 {
 _Left . swap ( _Right );
 }
#line 338
template < class _Ty1,
 class _Ty2 >
  constexpr bool operator == ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first == _Right . first && _Left . second == _Right . second );
 }
#line 345
template < class _Ty1,
 class _Ty2 >
  constexpr bool operator != ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 352
template < class _Ty1,
 class _Ty2 >
  constexpr bool operator < ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first < _Right . first ||
  ( ! ( _Right . first < _Left . first ) && _Left . second < _Right . second ) );
 }
#line 360
template < class _Ty1,
 class _Ty2 >
  constexpr bool operator > ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 367
template < class _Ty1,
 class _Ty2 >
  constexpr bool operator <= ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 374
template < class _Ty1,
 class _Ty2 >
  constexpr bool operator >= ( const pair < _Ty1, _Ty2 > & _Left, const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 382
template< class _Ty> 
#line 383
struct _Unrefwrap_helper { 
#line 385
using type = _Ty; 
#line 386
}; 
#line 388
template< class _Ty> 
#line 389
struct _Unrefwrap_helper< reference_wrapper< _Ty> >  { 
#line 391
using type = _Ty &; 
#line 392
}; 
#line 395
template< class _Ty> using _Unrefwrap_t = typename _Unrefwrap_helper< decay_t< _Ty> > ::type; 
#line 399
template < class _Ty1,
 class _Ty2 >
  constexpr pair < _Unrefwrap_t < _Ty1 >, _Unrefwrap_t < _Ty2 > >
  make_pair ( _Ty1 && _Val1, _Ty2 && _Val2 )
 {
 using _Mypair = pair < _Unrefwrap_t < _Ty1 >, _Unrefwrap_t < _Ty2 >>;
 return ( _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ), :: std :: forward < _Ty2 > ( _Val2 ) ) );
 }
#line 408
namespace rel_ops { 
#line 410
template < class _Ty >
  inline bool operator != ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 416
template < class _Ty >
  inline bool operator > ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left );
 }
#line 422
template < class _Ty >
  inline bool operator <= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 428
template < class _Ty >
  inline bool operator >= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 433
}
#line 434
}
#line 436
namespace std { 
#line 438
template< class _Tuple> struct tuple_size; 
#line 441
template< class _Tuple, class 
#line 442
 = void> 
#line 443
struct _Tuple_size_sfinae { 
#line 445
}; 
#line 447
template< class _Tuple> 
#line 448
struct _Tuple_size_sfinae< _Tuple, void_t< decltype(tuple_size< _Tuple> ::value)> >  : public integral_constant< unsigned __int64, tuple_size< _Tuple> ::value>  { 
#line 451
}; 
#line 453
template< class _Tuple> 
#line 454
struct tuple_size< const _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { 
#line 457
}; 
#line 459
template< class _Tuple> 
#line 460
struct tuple_size< volatile _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { 
#line 463
}; 
#line 465
template< class _Tuple> 
#line 466
struct tuple_size< const volatile _Tuple>  : public _Tuple_size_sfinae< _Tuple>  { 
#line 469
}; 
#line 471
template< class _Ty> constexpr size_t 
#line 472
tuple_size_v = (tuple_size< _Ty> ::value); 
#line 474
template< size_t _Index, class 
#line 475
_Tuple> struct tuple_element; 
#line 478
template< size_t _Index, class 
#line 479
_Tuple> 
#line 480
struct tuple_element< _Index, const _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 483
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 484
using type = std::add_const_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 485
}; 
#line 487
template< size_t _Index, class 
#line 488
_Tuple> 
#line 489
struct tuple_element< _Index, volatile _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 492
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 493
using type = std::add_volatile_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 494
}; 
#line 496
template< size_t _Index, class 
#line 497
_Tuple> 
#line 498
struct tuple_element< _Index, const volatile _Tuple>  : public std::tuple_element< _Index, _Tuple>  { 
#line 501
using _Mybase = std::tuple_element< _Index, _Tuple> ; 
#line 502
using type = std::add_cv_t< typename std::tuple_element< _Index, _Tuple> ::type> ; 
#line 503
}; 
#line 505
template< size_t _Index, class 
#line 506
_Tuple> using tuple_element_t = typename tuple_element< _Index, _Tuple> ::type; 
#line 510
template< class _Ty, size_t 
#line 511
_Size> class array; 
#line 514
template< class _Ty, size_t 
#line 515
_Size> 
#line 516
struct tuple_size< array< _Ty, _Size> >  : public integral_constant< unsigned __int64, _Size>  { 
#line 519
}; 
#line 521
template< size_t _Idx, class 
#line 522
_Ty, size_t 
#line 523
_Size> 
#line 524
struct tuple_element< _Idx, array< _Ty, _Size> >  { 
#line 526
static_assert((_Idx < _Size), "array index out of bounds");
#line 528
using type = _Ty; 
#line 529
}; 
#line 533
template< class ..._Types> 
#line 534
struct tuple_size< tuple< _Types...> >  : public integral_constant< unsigned __int64, sizeof...(_Types)>  { 
#line 537
}; 
#line 539
template< size_t _Index> 
#line 540
struct tuple_element< _Index, tuple< > >  { 
#line 542
static_assert((_Always_false< integral_constant< unsigned __int64, _Index> > ), "tuple index out of bounds");
#line 544
}; 
#line 546
template< class _This, class ...
#line 547
_Rest> 
#line 548
struct tuple_element< 0, tuple< _This, _Rest...> >  { 
#line 550
using type = _This; 
#line 551
using _Ttype = tuple< _This, _Rest...> ; 
#line 552
}; 
#line 554
template< size_t _Index, class 
#line 555
_This, class ...
#line 556
_Rest> 
#line 557
struct tuple_element< _Index, tuple< _This, _Rest...> >  : public std::tuple_element< _Index - (1), tuple< _Rest...> >  { 
#line 560
}; 
#line 563
template< class _Ty1, class 
#line 564
_Ty2> 
#line 565
struct tuple_size< pair< _Ty1, _Ty2> >  : public integral_constant< unsigned __int64, 2Ui64>  { 
#line 568
}; 
#line 570
template< size_t _Idx, class 
#line 571
_Ty1, class 
#line 572
_Ty2> 
#line 573
struct tuple_element< _Idx, pair< _Ty1, _Ty2> >  { 
#line 575
static_assert((_Idx < (2)), "pair index out of bounds");
#line 577
using type = conditional_t< _Idx == (0), _Ty1, _Ty2> ; 
#line 578
}; 
#line 580
template < class _Ret,
 class _Pair >
 constexpr _Ret _Pair_get ( _Pair & _Pr,
  integral_constant < size_t, 0 > ) noexcept
 {
 return ( _Pr . first );
 }
#line 588
template < class _Ret,
 class _Pair >
 constexpr _Ret _Pair_get ( _Pair & _Pr,
  integral_constant < size_t, 1 > ) noexcept
 {
 return ( _Pr . second );
 }
#line 596
template < size_t _Idx,
 class _Ty1,
 class _Ty2 >
  constexpr tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > &
  get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 using _Rtype = tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &;
 return ( _Pair_get < _Rtype > ( _Pr, integral_constant < size_t, _Idx > ( ) ) );
 }
#line 606
template < class _Ty1,
 class _Ty2 >
  constexpr _Ty1 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 0 > ( _Pr ) );
 }
#line 613
template < class _Ty2,
 class _Ty1 >
  constexpr _Ty2 & get ( pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 1 > ( _Pr ) );
 }
#line 620
template < size_t _Idx,
 class _Ty1,
 class _Ty2 >
  constexpr const tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > &
  get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 using _Ctype = const tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &;
 return ( _Pair_get < _Ctype > ( _Pr, integral_constant < size_t, _Idx > ( ) ) );
 }
#line 630
template < class _Ty1,
 class _Ty2 >
  constexpr const _Ty1 & get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 0 > ( _Pr ) );
 }
#line 637
template < class _Ty2,
 class _Ty1 >
  constexpr const _Ty2 & get ( const pair < _Ty1, _Ty2 > & _Pr ) noexcept
 {
 return ( :: std :: get < 1 > ( _Pr ) );
 }
#line 644
template < size_t _Idx,
 class _Ty1,
 class _Ty2 >
  constexpr tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > &&
  get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 using _RRtype = tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &&;
 return ( :: std :: forward < _RRtype > ( :: std :: get < _Idx > ( _Pr ) ) );
 }
#line 654
template < class _Ty1,
 class _Ty2 >
  constexpr _Ty1 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 return ( :: std :: get < 0 > ( :: std :: move ( _Pr ) ) );
 }
#line 661
template < class _Ty2,
 class _Ty1 >
  constexpr _Ty2 && get ( pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 return ( :: std :: get < 1 > ( :: std :: move ( _Pr ) ) );
 }
#line 668
template < size_t _Idx,
 class _Ty1,
 class _Ty2 >
  constexpr const tuple_element_t < _Idx, pair < _Ty1, _Ty2 > > &&
  get ( const pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 using _RRtype = const tuple_element_t < _Idx, pair < _Ty1, _Ty2 >> &&;
 return ( :: std :: forward < _RRtype > ( :: std :: get < _Idx > ( _Pr ) ) );
 }
#line 678
template < class _Ty1,
 class _Ty2 >
  constexpr const _Ty1 && get ( const pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 return ( :: std :: get < 0 > ( :: std :: move ( _Pr ) ) );
 }
#line 685
template < class _Ty2,
 class _Ty1 >
  constexpr const _Ty2 && get ( const pair < _Ty1, _Ty2 > && _Pr ) noexcept
 {
 return ( :: std :: get < 1 > ( :: std :: move ( _Pr ) ) );
 }
#line 693
template < class _Ty,
 class _Other = _Ty > inline
 _Ty exchange ( _Ty & _Val, _Other && _New_val )
 {
 _Ty _Old_val = :: std :: move ( _Val );
 _Val = :: std :: forward < _Other > ( _New_val );
 return ( _Old_val );
 }
#line 703
template < class _Ty >
  constexpr add_const_t < _Ty > & as_const ( _Ty & _Val ) noexcept
 {
 return ( _Val );
 }
#line 709
template < class _Ty >
 void as_const ( const _Ty && ) = delete;
#line 738 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\utility"
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 739
using std::get;
#line 740
using std::tuple_element;
#line 741
using std::tuple_size;
#line 742
}
#line 745 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\utility"
}
#line 749
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 18
extern "C" {
#line 26
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void * _First, void * _Last) noexcept; 
#line 27
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void * _First, void * _Last) noexcept; 
#line 28
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void * _First, void * _Last) noexcept; 
#line 29
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void * _First, void * _Last) noexcept; 
#line 30
}
#line 33 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
namespace std { 
#line 35
struct _Container_proxy; 
#line 36
struct _Container_base12; 
#line 37
struct _Iterator_base12; 
#line 39
struct _Container_base0 { 
#line 41
void _Orphan_all() noexcept 
#line 42
{ 
#line 43
} 
#line 45
void _Swap_all(_Container_base0 &) noexcept 
#line 46
{ 
#line 47
} 
#line 48
}; 
#line 50
struct _Iterator_base0 { 
#line 52
void _Adopt(const void *) noexcept 
#line 53
{ 
#line 54
} 
#line 56
const _Container_base0 *_Getcont() const noexcept 
#line 57
{ 
#line 58
return nullptr; 
#line 59
} 
#line 61
static constexpr bool _Unwrap_when_unverified = true; 
#line 62
}; 
#line 65
struct _Container_proxy { 
#line 67
_Container_proxy() noexcept : _Mycont((nullptr)), _Myfirstiter((nullptr)) 
#line 69
{ 
#line 70
} 
#line 72
const _Container_base12 *_Mycont; 
#line 73
_Iterator_base12 *_Myfirstiter; 
#line 74
}; 
#line 76
struct _Container_base12 { 
#line 79
_Container_base12() : _Myproxy((nullptr)) 
#line 81
{ 
#line 82
} 
#line 84
_Container_base12(const _Container_base12 &) noexcept : _Myproxy((nullptr)) 
#line 86
{ 
#line 87
} 
#line 89
_Container_base12 &operator=(const _Container_base12 &) noexcept 
#line 90
{ 
#line 91
return *this; 
#line 92
} 
#line 94
_Iterator_base12 **_Getpfirst() const noexcept 
#line 95
{ 
#line 96
return ((_Myproxy) == (nullptr)) ? nullptr : (&((_Myproxy)->_Myfirstiter)); 
#line 97
} 
#line 99
inline void _Orphan_all() noexcept; 
#line 100
inline void _Swap_all(_Container_base12 &) noexcept; 
#line 102
_Container_proxy *_Myproxy; 
#line 103
}; 
#line 105
struct _Iterator_base12 { 
#line 107
_Iterator_base12() noexcept : _Myproxy((nullptr)), _Mynextiter((nullptr)) 
#line 109
{ 
#line 110
} 
#line 112
_Iterator_base12(const _Iterator_base12 &_Right) noexcept : _Myproxy((nullptr)), _Mynextiter((nullptr)) 
#line 114
{ 
#line 115
((*this) = _Right); 
#line 116
} 
#line 118
_Iterator_base12 &operator=(const _Iterator_base12 &_Right) noexcept 
#line 119
{ 
#line 120
if ((_Myproxy) != (_Right._Myproxy)) 
#line 121
{ 
#line 122
if ((_Right._Myproxy) == (nullptr)) 
#line 123
{ 
#line 125
_Lockit _Lock(3); 
#line 126
this->_Orphan_me(); 
#line 128 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
} else 
#line 130
{ 
#line 131
this->_Adopt((_Right._Myproxy)->_Mycont); 
#line 132
}  
#line 133
}  
#line 135
return *this; 
#line 136
} 
#line 138
~_Iterator_base12() noexcept 
#line 139
{ 
#line 141
_Lockit _Lock(3); 
#line 142
this->_Orphan_me(); 
#line 144 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
} 
#line 146
void _Adopt(const _Container_base12 *_Parent) noexcept 
#line 147
{ 
#line 148
if (_Parent == (nullptr)) 
#line 149
{ 
#line 151
_Lockit _Lock(3); 
#line 152
this->_Orphan_me(); 
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
} else 
#line 156
{ 
#line 157
_Container_proxy *_Parent_proxy = _Parent->_Myproxy; 
#line 160
if ((_Myproxy) != _Parent_proxy) 
#line 161
{ 
#line 162
_Lockit _Lock(3); 
#line 163
this->_Orphan_me(); 
#line 164
(_Mynextiter) = (_Parent_proxy->_Myfirstiter); 
#line 165
(_Parent_proxy->_Myfirstiter) = this; 
#line 166
(_Myproxy) = _Parent_proxy; 
#line 167
}  
#line 172 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
}  
#line 173
} 
#line 175
void _Clrcont() noexcept 
#line 176
{ 
#line 177
(_Myproxy) = (nullptr); 
#line 178
} 
#line 180
const _Container_base12 *_Getcont() const noexcept 
#line 181
{ 
#line 182
return ((_Myproxy) == (nullptr)) ? nullptr : ((_Myproxy)->_Mycont); 
#line 183
} 
#line 185
_Iterator_base12 **_Getpnext() noexcept 
#line 186
{ 
#line 187
return &(_Mynextiter); 
#line 188
} 
#line 190
void _Orphan_me() noexcept 
#line 191
{ 
#line 193
if ((_Myproxy) != (nullptr)) 
#line 194
{ 
#line 195
_Iterator_base12 **_Pnext = &((_Myproxy)->_Myfirstiter); 
#line 196
while (((*_Pnext) != (nullptr)) && ((*_Pnext) != this)) { 
#line 197
_Pnext = (&((*_Pnext)->_Mynextiter)); }  
#line 199
do { if (*_Pnext) { } else { do { (void)((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 199, 0, "%s", "ITERATOR LIST CORRUPTED!")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x49\x54\x45\x52\x41\x54\x4f\x52\x20\x4c\x49\x53\x54\x20\x43\x4f\x52\x52\x55\x50\x54\x45\x44\x21\x22", L"\x73\x74\x64\x3a\x3a\x5f\x49\x74\x65\x72\x61\x74\x6f\x72\x5f\x62\x61\x73\x65\x31\x32\x3a\x3a\x5f\x4f\x72\x70\x68\x61\x6e\x5f\x6d" L"\x65", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 199, 0); } while (false); }  ; } while (false); 
#line 200
(*_Pnext) = (_Mynextiter); 
#line 201
(_Myproxy) = (nullptr); 
#line 202
}  
#line 204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
} 
#line 206
static constexpr bool _Unwrap_when_unverified = (2 == 0); 
#line 208
_Container_proxy *_Myproxy; 
#line 209
_Iterator_base12 *_Mynextiter; 
#line 210
}; 
#line 213
inline void _Container_base12::_Orphan_all() noexcept 
#line 214
{ 
#line 216
if ((_Myproxy) != (nullptr)) 
#line 217
{ 
#line 218
_Lockit _Lock(3); 
#line 220
for (_Iterator_base12 **_Pnext = &((_Myproxy)->_Myfirstiter); (*_Pnext) != (nullptr); (*_Pnext) = ((*_Pnext)->_Mynextiter)) { 
#line 222
((*_Pnext)->_Myproxy) = (nullptr); }  
#line 223
((_Myproxy)->_Myfirstiter) = (nullptr); 
#line 224
}  
#line 226 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
} 
#line 228
inline void _Container_base12::_Swap_all(_Container_base12 &_Right) noexcept 
#line 229
{ 
#line 231
_Lockit _Lock(3); 
#line 234 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
_Container_proxy *_Temp = _Myproxy; 
#line 235
(_Myproxy) = (_Right._Myproxy); 
#line 236
(_Right._Myproxy) = _Temp; 
#line 238
if ((_Myproxy) != (nullptr)) { 
#line 239
((_Myproxy)->_Mycont) = ((_Container_base12 *)this); }  
#line 240
if ((_Right._Myproxy) != (nullptr)) { 
#line 241
((_Right._Myproxy)->_Mycont) = ((_Container_base12 *)(&_Right)); }  
#line 242
} 
#line 249 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
using _Container_base = _Container_base12; 
#line 250
using _Iterator_base = _Iterator_base12; 
#line 254 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
struct _Zero_then_variadic_args_t { 
#line 256
}; 
#line 258
struct _One_then_variadic_args_t { 
#line 260
}; 
#line 262
template < class _Ty1,
 class _Ty2,
 bool = is_empty_v < _Ty1 > && ! is_final_v < _Ty1 > >
 class _Compressed_pair
  : private _Ty1
 {
private :
 _Ty2 _Myval2;

 using _Mybase = _Ty1;

public :
 template < class ... _Other2 >
  constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t,
   _Other2 && ... _Val2 )
  : _Ty1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }

 template < class _Other1,
  class ... _Other2 >
  _Compressed_pair ( _One_then_variadic_args_t,
   _Other1 && _Val1, _Other2 && ... _Val2 )
  : _Ty1 ( :: std :: forward < _Other1 > ( _Val1 ) ),
   _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }

 _Ty1 & _Get_first ( ) noexcept
  {
  return ( * this );
  }

 const _Ty1 & _Get_first ( ) const noexcept
  {
  return ( * this );
  }

 _Ty2 & _Get_second ( ) noexcept
  {
  return ( _Myval2 );
  }

 const _Ty2 & _Get_second ( ) const noexcept
  {
  return ( _Myval2 );
  }
 };
#line 311
template < class _Ty1,
 class _Ty2 >
 class _Compressed_pair < _Ty1, _Ty2, false >
 {
private :
 _Ty1 _Myval1;
 _Ty2 _Myval2;

public :
 template < class ... _Other2 >
  constexpr explicit _Compressed_pair ( _Zero_then_variadic_args_t,
   _Other2 && ... _Val2 )
  : _Myval1 ( ), _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }

 template < class _Other1,
  class ... _Other2 >
  _Compressed_pair ( _One_then_variadic_args_t,
   _Other1 && _Val1, _Other2 && ... _Val2 )
  : _Myval1 ( :: std :: forward < _Other1 > ( _Val1 ) ),
   _Myval2 ( :: std :: forward < _Other2 > ( _Val2 ) ... )
  {
  }

 _Ty1 & _Get_first ( ) noexcept
  {
  return ( _Myval1 );
  }

 const _Ty1 & _Get_first ( ) const noexcept
  {
  return ( _Myval1 );
  }

 _Ty2 & _Get_second ( ) noexcept
  {
  return ( _Myval2 );
  }

 const _Ty2 & _Get_second ( ) const noexcept
  {
  return ( _Myval2 );
  }
 };
#line 359
template< class _Fx> 
#line 360
struct _Ref_fn { 
#line 362
template < class ... _Args >
  constexpr decltype ( auto ) operator ( ) ( _Args && ... _Vals )
  {
  return ( _Fn ( :: std :: forward < _Args > ( _Vals ) ... ) );
  }
#line 368
_Fx &_Fn; 
#line 369
}; 
#line 371
template< class _Fn> constexpr bool 
#line 372
_Pass_functor_by_value_v = (sizeof(_Fn) <= sizeof(void *)) && conjunction_v< is_trivially_copy_constructible< _Fn> , is_trivially_destructible< _Fn> > ; 
#line 377
template < class _Fn,
 enable_if_t < _Pass_functor_by_value_v < _Fn >, int > = 0 >
 constexpr _Fn _Pass_fn ( _Fn _Val )
 {
 return ( _Val );
 }
#line 384
template < class _Fn,
 enable_if_t < ! _Pass_functor_by_value_v < _Fn >, int > = 0 >
 constexpr _Ref_fn < _Fn > _Pass_fn ( _Fn & _Val )
 {
 return { _Val };
 }
#line 393
struct input_iterator_tag { 
#line 395
}; 
#line 397
struct output_iterator_tag { 
#line 399
}; 
#line 401
struct forward_iterator_tag : public input_iterator_tag { 
#line 404
}; 
#line 406
struct bidirectional_iterator_tag : public forward_iterator_tag { 
#line 409
}; 
#line 411
struct random_access_iterator_tag : public bidirectional_iterator_tag { 
#line 414
}; 
#line 417
struct _General_ptr_iterator_tag { 
#line 419
}; 
#line 421
struct _Trivially_copyable_ptr_iterator_tag : public _General_ptr_iterator_tag { 
#line 424
}; 
#line 426
struct _Really_trivial_ptr_iterator_tag : public _Trivially_copyable_ptr_iterator_tag { 
#line 429
}; 
#line 432
struct _Unused_parameter { 
#line 434
constexpr _Unused_parameter() noexcept = default;
#line 435
template < class _Ty >
  constexpr _Unused_parameter ( _Ty && ) noexcept { }
#line 437
}; 
#line 440
using _Any_tag = _Unused_parameter; 
#line 443
template< class _Ty> using _Algorithm_int_t = conditional_t< is_integral_v< _Ty> , _Ty, __int64> ; 
#line 447
template< class , class 
#line 448
 = void> 
#line 449
struct _Iterator_traits_base { 
#line 451
}; 
#line 453
template< class _Iter> 
#line 454
struct _Iterator_traits_base< _Iter, void_t< typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type, typename _Iter::pointer, typename _Iter::reference> >  { 
#line 462
using iterator_category = typename _Iter::iterator_category; 
#line 463
using value_type = typename _Iter::value_type; 
#line 464
using difference_type = typename _Iter::difference_type; 
#line 466
using pointer = typename _Iter::pointer; 
#line 467
using reference = typename _Iter::reference; 
#line 468
}; 
#line 470
template< class _Ty, bool 
#line 471
 = is_object_v< _Ty> > 
#line 472
struct _Iterator_traits_pointer_base { 
#line 474
using iterator_category = random_access_iterator_tag; 
#line 475
using value_type = remove_cv_t< _Ty> ; 
#line 476
using difference_type = ptrdiff_t; 
#line 478
using pointer = _Ty *; 
#line 479
using reference = _Ty &; 
#line 480
}; 
#line 482
template< class _Ty> 
#line 483
struct _Iterator_traits_pointer_base< _Ty, false>  { 
#line 486
}; 
#line 488
template< class _Iter> 
#line 489
struct iterator_traits : public _Iterator_traits_base< _Iter>  { 
#line 492
}; 
#line 494
template< class _Ty> 
#line 495
struct iterator_traits< _Ty *>  : public _Iterator_traits_pointer_base< _Ty>  { 
#line 498
}; 
#line 501
template< class _Iter> using _Iter_value_t = typename iterator_traits< _Iter> ::value_type; 
#line 505
template< class _Iter> using _Iter_diff_t = typename iterator_traits< _Iter> ::difference_type; 
#line 509
template< class ..._Iters> using _Common_diff_t = common_type_t< _Iter_diff_t< _Iters> ...> ; 
#line 513
template< class _Iter> using _Iter_cat_t = typename iterator_traits< _Iter> ::iterator_category; 
#line 517
template< class _Ty, class 
#line 518
 = void> constexpr bool 
#line 519
_Is_iterator_v = false; 
#line 521
template< class _Ty> constexpr bool 
#line 522
_Is_iterator_v< _Ty, void_t< _Iter_cat_t< _Ty> > >  = true; 
#line 525
template< class _Ty> 
#line 526
struct _Is_iterator : public bool_constant< _Is_iterator_v< _Ty, void> >  { 
#line 529
}; 
#line 532
template< class _Iter> constexpr bool 
#line 533
_Is_input_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , input_iterator_tag> ; 
#line 536
template< class _Iter> constexpr bool 
#line 537
_Is_fwd_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , forward_iterator_tag> ; 
#line 540
template< class _Iter> constexpr bool 
#line 541
_Is_bidi_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , bidirectional_iterator_tag> ; 
#line 544
template< class _Iter> constexpr bool 
#line 545
_Is_random_iter_v = is_convertible_v< _Iter_cat_t< _Iter> , random_access_iterator_tag> ; 
#line 548
template< class , class 
#line 549
 = void> 
#line 550
struct _Is_checked_helper { 
#line 552
}; 
#line 556
template < class _Ty >
 constexpr void _Verify_range ( const _Ty * const _First, const _Ty * const _Last ) noexcept
 {
 do { if ( _First <= _Last ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 559, 0, "%s", "transposed pointer range" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x74\x72\x61\x6e\x73\x70\x6f\x73\x65\x64\x20\x70\x6f\x69\x6e\x74\x65\x72\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 559, 0 ); } while ( false ); }; } while ( false );
 }
#line 563 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Iter, class 
#line 564
_Sentinel = _Iter, class 
#line 565
 = void> 
#line 566
struct _Range_verifiable : public false_type { 
#line 569
}; 
#line 571
template< class _Iter, class 
#line 572
_Sentinel> 
#line 573
struct _Range_verifiable< _Iter, _Sentinel, void_t< decltype((_Verify_range(std::declval< const _Iter &> (), std::declval< const _Sentinel &> ())))> >  : public true_type { 
#line 577
}; 
#line 579
template< class _Iter, class 
#line 580
_Sentinel = _Iter> constexpr bool 
#line 581
_Range_verifiable_v = (_Range_verifiable< _Iter, _Sentinel> ::value); 
#line 599 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Iter,
 class _Sentinel >
 constexpr void _Adl_verify_range1 ( const _Iter & _First, const _Sentinel & _Last, true_type )
 {
 _Verify_range ( _First, _Last );
 }
#line 606
template < class _Iter,
 class _Sentinel >
 constexpr void _Adl_verify_range1 ( const _Iter &, const _Sentinel &, false_type )
 {
 }
#line 612
template < class _Iter,
 class _Sentinel >
 constexpr void _Adl_verify_range ( const _Iter & _First, const _Sentinel & _Last )
 {
 _Adl_verify_range1 ( _First, _Last, bool_constant < _Range_verifiable_v < _Iter, _Sentinel >> { } );
 }
#line 622 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Iter, class 
#line 623
 = void> 
#line 624
struct _Unwrappable : public false_type { 
#line 627
}; 
#line 629
template< class _Iter> 
#line 630
struct _Unwrappable< _Iter, void_t< decltype(((std::declval< _Iter &> ()._Seek_to((std::declval< const _Iter &> ()._Unwrapped())))))> >  : public true_type { 
#line 634
}; 
#line 636
template< class _Iter> constexpr bool 
#line 637
_Unwrappable_v = (_Unwrappable< _Iter> ::value); 
#line 639
template < class _Iter,
 enable_if_t < _Unwrappable_v < _Iter >, int > = 0 >
  constexpr auto _Get_unwrapped ( const _Iter & _It )
 {
 return ( _It . _Unwrapped ( ) );
 }
#line 646
template < class _Iter,
 enable_if_t < ! _Unwrappable_v < _Iter >, int > = 0 >
  constexpr const _Iter & _Get_unwrapped ( const _Iter & _It )
 {
 return ( _It );
 }
#line 653
template < class _Iter,
 enable_if_t < ! _Unwrappable_v < _Iter >, int > = 0 >
  constexpr const _Iter && _Get_unwrapped ( const _Iter && _It )
 {
 return ( static_cast < const _Iter && > ( _It ) );
 }
#line 660
template < class _Ty >
  constexpr _Ty * _Get_unwrapped ( _Ty * const _Ptr )
 {
 return ( _Ptr );
 }
#line 666
template< class _Iter> using _Unwrapped_t = remove_cv_t< remove_reference_t< decltype((_Get_unwrapped(std::declval< const _Iter &> ())))> > ; 
#line 670
template< class _Iter, class 
#line 671
 = bool> 
#line 672
struct _Do_unwrap_when_unverified : public false_type { 
#line 675
}; 
#line 677
template< class _Iter> 
#line 678
struct _Do_unwrap_when_unverified< _Iter, decltype((static_cast< bool>(_Iter::_Unwrap_when_unverified)))>  : public bool_constant< static_cast< bool>(_Iter::_Unwrap_when_unverified)>  { 
#line 681
}; 
#line 683
template< class _Iter> constexpr bool 
#line 684
_Do_unwrap_when_unverified_v = (_Do_unwrap_when_unverified< _Iter> ::value); 
#line 686
template< class _Iter> constexpr bool 
#line 687
_Unwrappable_for_unverified_v = _Unwrappable_v< _Iter>  && _Do_unwrap_when_unverified_v< _Iter> ; 
#line 690
template < class _Iter,
 enable_if_t < _Unwrappable_for_unverified_v < _Iter >, int > = 0 >
  constexpr auto _Get_unwrapped_unverified ( const _Iter & _It )
 {
 return ( _It . _Unwrapped ( ) );
 }
#line 697
template < class _Iter,
 enable_if_t < ! _Unwrappable_for_unverified_v < _Iter >, int > = 0 >
  constexpr const _Iter & _Get_unwrapped_unverified ( const _Iter & _It )
 {
 return ( _It );
 }
#line 704
template < class _Iter,
 enable_if_t < ! _Unwrappable_for_unverified_v < _Iter >, int > = 0 >
  constexpr const _Iter && _Get_unwrapped_unverified ( const _Iter && _It )
 {
 return ( static_cast < const _Iter && > ( _It ) );
 }
#line 711
template < class _Ty >
  constexpr _Ty * _Get_unwrapped_unverified ( _Ty * const _Ptr )
 {
 return ( _Ptr );
 }
#line 717
template< class _Iter> using _Unwrapped_unverified_t = remove_cv_t< remove_reference_t< decltype((_Get_unwrapped_unverified(std::declval< const _Iter &> ())))> > ; 
#line 722
struct _Distance_unknown { 
#line 724
constexpr _Distance_unknown operator-() const noexcept 
#line 725
{ 
#line 726
return {}; 
#line 727
} 
#line 728
}; 
#line 730
template< class _Diff> constexpr _Diff 
#line 731
_Max_possible_v = (static_cast< _Diff>((static_cast< make_unsigned_t< _Diff> >(-1)) >> 1)); 
#line 733
template< class _Diff> constexpr _Diff 
#line 734
_Min_possible_v = ((-_Max_possible_v< _Diff> ) - 1); 
#line 736
template< class _Iter, class 
#line 737
 = void> 
#line 738
struct _Offset_verifiable : public false_type { 
#line 741
}; 
#line 743
template< class _Iter> 
#line 744
struct _Offset_verifiable< _Iter, void_t< decltype(((std::declval< const _Iter &> ()._Verify_offset(_Iter_diff_t< _Iter> {}))))> >  : public true_type { 
#line 748
}; 
#line 750
template< class _Iter> constexpr bool 
#line 751
_Offset_verifiable_v = (_Offset_verifiable< _Iter> ::value); 
#line 753
template< class _Iter> constexpr bool 
#line 754
_Unwrappable_for_offset_v = _Unwrappable_v< _Iter>  && _Offset_verifiable_v< _Iter> ; 
#line 756
template < class _Iter,
 class _Diff,
 enable_if_t < _Unwrappable_for_offset_v < _Iter > && is_integral_v < _Diff >, int > = 0 >
  constexpr auto _Get_unwrapped_n ( const _Iter & _It, const _Diff _Off )
 {
 using _IDiff = _Iter_diff_t < _Iter >;
 using _CDiff = common_type_t < _Diff, _IDiff >;
 const auto _COff = static_cast < _CDiff > ( _Off );

 do { if ( _COff <= static_cast < _CDiff > ( _Max_possible_v < _IDiff > ) && ( is_unsigned_v < _Diff > || static_cast < _CDiff > ( _Min_possible_v < _IDiff > ) <= _COff ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 767, 0, "%s", "integer overflow" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x74\x65\x67\x65\x72\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 767, 0 ); } while ( false ); }; } while ( false );

 ( void ) _COff;

 _It . _Verify_offset ( static_cast < _IDiff > ( _Off ) );
 return ( _It . _Unwrapped ( ) );
 }
#line 774 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Iter,
 class _Diff,
 enable_if_t < _Unwrappable_for_unverified_v < _Iter >
  && ( ( ! _Unwrappable_for_offset_v < _Iter > && is_integral_v < _Diff > )
   || is_same_v < _Diff, _Distance_unknown > ), int > = 0 >
  constexpr auto _Get_unwrapped_n ( const _Iter & _It, _Diff )
 {
 return ( _It . _Unwrapped ( ) );
 }
#line 784
template < class _Iter,
 class _Diff,
 enable_if_t < ! _Unwrappable_for_unverified_v < _Iter >
  && ( ( ! _Unwrappable_for_offset_v < _Iter > && is_integral_v < _Diff > )
   || is_same_v < _Diff, _Distance_unknown > ), int > = 0 >
  constexpr const _Iter & _Get_unwrapped_n ( const _Iter & _It, _Diff )
 {
 return ( _It );
 }
#line 794
template < class _Iter,
 class _Diff,
 enable_if_t < ! _Unwrappable_for_unverified_v < _Iter >
  && ( ( ! _Unwrappable_for_offset_v < _Iter > && is_integral_v < _Diff > )
   || is_same_v < _Diff, _Distance_unknown > ), int > = 0 >
  constexpr const _Iter && _Get_unwrapped_n ( const _Iter && _It, _Diff )
 {
 return ( static_cast < const _Iter && > ( _It ) );
 }
#line 804
template < class _Ty,
 class _Diff,
 enable_if_t < is_same_v < _Diff, _Distance_unknown > || is_integral_v < _Diff >, int > = 0 >
  constexpr _Ty * _Get_unwrapped_n ( _Ty * const _Src, _Diff )
 {
 return ( _Src );
 }
#line 812
template< class _Iter> using _Unwrapped_n_t = remove_cv_t< remove_reference_t< decltype((_Get_unwrapped_n(std::declval< const _Iter &> (), _Iter_diff_t< _Iter> {})))> > ; 
#line 817
template< class _Iter, class 
#line 818
_UIter, class 
#line 819
 = void> 
#line 820
struct _Wrapped_seekable : public false_type { 
#line 823
}; 
#line 825
template< class _Iter, class 
#line 826
_UIter> 
#line 827
struct _Wrapped_seekable< _Iter, _UIter, void_t< decltype(((std::declval< _Iter &> ()._Seek_to(std::declval< const _UIter &> ()))))> >  : public true_type { 
#line 831
}; 
#line 833
template< class _Iter, class 
#line 834
_UIter> constexpr bool 
#line 835
_Wrapped_seekable_v = (_Wrapped_seekable< _Iter, _UIter> ::value); 
#line 852 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Iter,
 class _UIter,
 enable_if_t < _Wrapped_seekable_v < _Iter, _UIter >, int > = 0 >
 constexpr void _Seek_wrapped ( _Iter & _It, const _UIter & _UIt )
 {
 _It . _Seek_to ( _UIt );
 }
#line 860
template < class _Iter,
 class _UIter,
 enable_if_t < ! _Wrapped_seekable_v < _Iter, _UIter >, int > = 0 >
 constexpr void _Seek_wrapped ( _Iter & _It, const _UIter & _UIt )
 {
 _It = _UIt;
 }
#line 869 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Ty >
 constexpr void _Seek_wrapped ( _Ty * & _It, _Ty * const _UIt )
 {
 _It = _UIt;
 }
#line 906 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< size_t _Value> 
#line 907
struct _Priority_tag : public std::_Priority_tag< _Value - (1)>  { 
#line 910
}; 
#line 913
template<> struct _Priority_tag< 0Ui64>  { 
#line 915
}; 
#line 957 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Checked,
 class _Iter > inline
 _Distance_unknown _Idl_distance1 ( const _Iter &, const _Iter &, input_iterator_tag )
 {
 return { };
 }
#line 964
template < class _Checked,
 class _Iter > inline
 _Iter_diff_t < _Checked > _Idl_distance1 ( const _Iter & _First, const _Iter & _Last, random_access_iterator_tag )
 {
 return ( static_cast < _Iter_diff_t < _Checked >> ( _Last - _First ) );
 }
#line 971
template < class _Checked,
 class _Iter > inline
 auto _Idl_distance ( const _Iter & _First, const _Iter & _Last )
 {
 return ( _Idl_distance1 < _Checked > ( _First, _Last, _Iter_cat_t < _Iter > ( ) ) );
 }
#line 980 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Ty1, class 
#line 981
_Ty2> 
#line 982
struct _Is_same_size : public bool_constant< sizeof(_Ty1) == sizeof(_Ty2)>  { 
#line 985
}; 
#line 988
template< class _Elem, bool 
#line 989
_Is_enum = is_enum_v< _Elem> > 
#line 990
struct _Unwrap_enum { 
#line 992
using type = underlying_type_t< _Elem> ; 
#line 993
}; 
#line 995
template< class _Elem> 
#line 996
struct _Unwrap_enum< _Elem, false>  { 
#line 998
using type = _Elem; 
#line 999
}; 
#line 1001
template< class _Elem> using _Unwrap_enum_t = typename _Unwrap_enum< _Elem> ::type; 
#line 1005
template< class _Ty1, class 
#line 1006
_Ty2> 
#line 1007
struct _Both_or_neither_bool : public bool_constant< is_same_v< bool, _Ty1>  == is_same_v< bool, _Ty2> >  { 
#line 1010
}; 
#line 1013
template< class _Source, class 
#line 1014
_Dest> 
#line 1015
struct _Ptr_cat_helper { 
#line 1017
using _USource = _Unwrap_enum_t< _Source> ; 
#line 1018
using _UDest = _Unwrap_enum_t< _Dest> ; 
#line 1019
using type = conditional_t< conjunction_v< _Is_same_size< _Unwrap_enum_t< _Source> , _Unwrap_enum_t< _Dest> > , is_integral< _Unwrap_enum_t< _Source> > , is_integral< _Unwrap_enum_t< _Dest> > , _Both_or_neither_bool< _Unwrap_enum_t< _Source> , _Unwrap_enum_t< _Dest> > > , _Really_trivial_ptr_iterator_tag, _General_ptr_iterator_tag> ; 
#line 1025
}; 
#line 1027
template< class _Elem> 
#line 1028
struct _Ptr_cat_helper< _Elem, _Elem>  { 
#line 1030
using type = conditional_t< is_trivially_copyable_v< _Elem> , conditional_t< is_trivial_v< _Elem> , _Really_trivial_ptr_iterator_tag, _Trivially_copyable_ptr_iterator_tag> , _General_ptr_iterator_tag> ; 
#line 1036
}; 
#line 1038
template< class _Anything> 
#line 1039
struct _Ptr_cat_helper< _Anything *, const _Anything *>  { 
#line 1041
using type = _Really_trivial_ptr_iterator_tag; 
#line 1042
}; 
#line 1044
template< class _Anything> 
#line 1045
struct _Ptr_cat_helper< _Anything *, volatile _Anything *>  { 
#line 1047
using type = _Really_trivial_ptr_iterator_tag; 
#line 1048
}; 
#line 1050
template< class _Anything> 
#line 1051
struct _Ptr_cat_helper< _Anything *, const volatile _Anything *>  { 
#line 1053
using type = _Really_trivial_ptr_iterator_tag; 
#line 1054
}; 
#line 1056
template < class _Source,
 class _Dest > inline
 _General_ptr_iterator_tag _Ptr_copy_cat ( const _Source &, const _Dest & )
 {
 return { };
 }
#line 1063
template < class _Source,
 class _Dest > inline
 conditional_t < is_trivially_assignable_v < _Dest &, _Source & >,
  typename _Ptr_cat_helper < remove_cv_t < _Source >, remove_cv_t < _Dest > > :: type,
  _General_ptr_iterator_tag >
  _Ptr_copy_cat ( _Source * const &, _Dest * const & )
 {
 return { };
 }
#line 1073
template < class _Source,
 class _Dest > inline
 _General_ptr_iterator_tag _Ptr_move_cat ( const _Source &, const _Dest & )
 {
 return { };
 }
#line 1080
template < class _Source,
 class _Dest > inline
 conditional_t < is_trivially_assignable_v < _Dest &, _Source >,
  typename _Ptr_cat_helper < remove_cv_t < _Source >, remove_cv_t < _Dest > > :: type,
  _General_ptr_iterator_tag >
  _Ptr_move_cat ( _Source * const &, _Dest * const & )
 {
 return { };
 }
#line 1104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Pr,
 class _Ty1,
 class _Ty2 >
 constexpr bool _Debug_lt_pred ( _Pr && _Pred, _Ty1 && _Left, _Ty2 && _Right )
  noexcept ( noexcept ( _Pred ( _Left, _Right ) ) && noexcept ( _Pred ( _Right, _Left ) ) )
 {
 const auto _Result = static_cast < bool > ( _Pred ( _Left, _Right ) );
 if ( _Result )
  {
  do { if ( ! _Pred ( _Right, _Left ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1113, 0, "%s", "invalid comparator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x63\x6f\x6d\x70\x61\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1113, 0 ); } while ( false ); }; } while ( false );
  }

 return ( _Result );
 }
#line 1120
template < class _InIt,
 class _Sentinel,
 class _Pr > inline
 void _Debug_order_unchecked2 ( _InIt, _Sentinel, _Pr &, input_iterator_tag )
 {
 }
#line 1127
template < class _FwdIt,
 class _Sentinel,
 class _Pr > inline
 void _Debug_order_unchecked2 ( _FwdIt _First, _Sentinel _Last, _Pr & _Pred, forward_iterator_tag )
 {
 if ( _First != _Last )
  {
  for ( _FwdIt _Next = _First; ++ _Next != _Last; _First = _Next )
   {
   do { if ( ! _Debug_lt_pred ( _Pred, * _Next, * _First ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1136, 0, "%s", "sequence not ordered" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x73\x65\x71\x75\x65\x6e\x63\x65\x20\x6e\x6f\x74\x20\x6f\x72\x64\x65\x72\x65\x64\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1136, 0 ); } while ( false ); }; } while ( false );
   }
  }
 }
#line 1141
template < class _InIt,
 class _Sentinel,
 class _Pr > inline
 void _Debug_order_unchecked ( _InIt _First, _Sentinel _Last, _Pr && _Pred )
 {
 _Debug_order_unchecked2 ( _First, _Last, _Pred, _Iter_cat_t < _InIt > ( ) );
 }
#line 1150
template < class _InIt,
 class _Pr > inline
 void _Debug_order_set_unchecked2 ( _InIt, _InIt, _Pr &, input_iterator_tag, _Priority_tag < 0 > )
 {
 }
#line 1156
template < class _FwdIt,
 class _Pr > inline
 void _Debug_order_set_unchecked2 ( _FwdIt _First, _FwdIt _Last, _Pr & _Pred, forward_iterator_tag, _Priority_tag < 1 > )
 {
 _Debug_order_unchecked2 ( _First, _Last, _Pred, forward_iterator_tag { } );
 }
#line 1163
template < class _OtherIt,
 class _InIt,
 class _Pr > inline
 void _Debug_order_set_unchecked ( _InIt _First, _InIt _Last, _Pr && _Pred )
 {
 _Debug_order_set_unchecked2 ( _First, _Last, _Pred, _Iter_cat_t < _InIt > ( ),
  _Priority_tag < is_same < _Iter_value_t < _OtherIt >, _Iter_value_t < _InIt >> :: value > ( ) );
 }
#line 1175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt,
 class _Diff >
 inline void _Advance1 ( _InIt & _Where, _Diff _Off, input_iterator_tag )
 {
 do { if ( _Off >= 0 ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1179, 0, "%s", "negative advance of non-bidirectional iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x6e\x65\x67\x61\x74\x69\x76\x65\x20\x61\x64\x76\x61\x6e\x63\x65\x20\x6f\x66\x20\x6e\x6f\x6e\x2d\x62\x69\x64\x69\x72\x65\x63" L"\x74\x69\x6f\x6e\x61\x6c\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1179, 0 ); } while ( false ); }; } while ( false );
 for (; 0 < _Off; -- _Off )
  {
  ++ _Where;
  }
 }
#line 1186
template < class _BidIt,
 class _Diff >
 inline void _Advance1 ( _BidIt & _Where, _Diff _Off, bidirectional_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  {
  ++ _Where;
  }


#pragma warning(suppress: 6294)

 for (; _Off < 0; ++ _Off )
  {
  -- _Where;
  }
 }
#line 1204
template < class _RanIt,
 class _Diff >
 inline void _Advance1 ( _RanIt & _Where, _Diff _Off, random_access_iterator_tag )
 {
 _Where += _Off;
 }
#line 1211
template < class _InIt,
 class _Diff >
 inline void advance ( _InIt & _Where, _Diff _Off )
 {

 _Advance1 ( _Where, _Off, _Iter_cat_t < remove_const_t < _InIt >> ( ) );
 }
#line 1220
template < class _InIt >
 inline _Iter_diff_t < _InIt > _Distance1 ( _InIt _First, _InIt _Last, input_iterator_tag )
 {
 _Iter_diff_t < _InIt > _Off = 0;
 for (; _First != _Last; ++ _First )
  {
  ++ _Off;
  }

 return ( _Off );
 }
#line 1232
template < class _RanIt >
 inline _Iter_diff_t < _RanIt > _Distance1 ( _RanIt _First, _RanIt _Last, random_access_iterator_tag )
 {
 return ( _Last - _First );
 }
#line 1238
template < class _InIt >
  inline _Iter_diff_t < _InIt > distance ( _InIt _First, _InIt _Last )
 {
 return ( _Distance1 ( _First, _Last, _Iter_cat_t < _InIt > ( ) ) );
 }
#line 1245
template < class _InIt >
 constexpr _InIt _Next_iter ( _InIt _First )
 {
 return ( ++ _First );
 }
#line 1252
template < class _InIt >
  inline _InIt next ( _InIt _First, _Iter_diff_t < _InIt > _Off = 1 )
 {
 static_assert ( _Is_input_iter_v < _InIt >, "next requires input iterator" );

 :: std :: advance ( _First, _Off );
 return ( _First );
 }
#line 1262
template < class _BidIt >
 constexpr _BidIt _Prev_iter ( _BidIt _First )
 {
 return ( -- _First );
 }
#line 1269
template < class _BidIt >
  inline _BidIt prev ( _BidIt _First, _Iter_diff_t < _BidIt > _Off = 1 )
 {
 static_assert ( _Is_bidi_iter_v < _BidIt >, "prev requires bidirectional iterator" );

 :: std :: advance ( _First, - _Off );
 return ( _First );
 }
#line 1279
template < class _Ty >
 struct pointer_traits;
#line 1282
template < class _Iterator >
 constexpr _Iterator _Operator_arrow ( _Iterator _Target, true_type )
 {
 return ( _Target );
 }
#line 1288
template < class _Iterator >
 constexpr decltype ( auto ) _Operator_arrow ( _Iterator && _Target, false_type )
 {
 return ( :: std :: forward < _Iterator > ( _Target ) . operator -> ( ) );
 }
#line 1294
template < class _BidIt >
 class reverse_iterator
 {
public :
 using iterator_category = typename iterator_traits < _BidIt > :: iterator_category;
 using value_type = typename iterator_traits < _BidIt > :: value_type;
 using difference_type = typename iterator_traits < _BidIt > :: difference_type;
 using pointer = typename iterator_traits < _BidIt > :: pointer;
 using reference = typename iterator_traits < _BidIt > :: reference;

 using iterator_type = _BidIt;

 inline reverse_iterator ( )
  : current ( )
  {
  }

 inline explicit reverse_iterator ( _BidIt _Right )
  : current ( _Right )
  {
  }

 template < class _Other >
  inline reverse_iterator ( const reverse_iterator < _Other > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 template < class _Other >
  inline reverse_iterator & operator = ( const reverse_iterator < _Other > & _Right )
  {
  current = _Right . base ( );
  return ( * this );
  }

  inline _BidIt base ( ) const
  {
  return ( current );
  }

  inline reference operator * ( ) const
  {
  _BidIt _Tmp = current;
  return ( * -- _Tmp );
  }

  inline pointer operator -> ( ) const
  {
  _BidIt _Tmp = current;
  -- _Tmp;
  return ( _Operator_arrow ( _Tmp, is_pointer < _BidIt > ( ) ) );
  }

 inline reverse_iterator & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 inline reverse_iterator operator ++ ( int )
  {
  reverse_iterator _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 inline reverse_iterator & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 inline reverse_iterator operator -- ( int )
  {
  reverse_iterator _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }



 inline reverse_iterator & operator += ( const difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

  inline reverse_iterator operator + ( const difference_type _Off ) const
  {
  return ( reverse_iterator ( current - _Off ) );
  }

 inline reverse_iterator & operator -= ( const difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

  inline reverse_iterator operator - ( const difference_type _Off ) const
  {
  return ( reverse_iterator ( current + _Off ) );
  }

  inline reference operator [ ] ( const difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 template < class _BidIt2 = _BidIt,
  enable_if_t < _Offset_verifiable_v < _BidIt2 >, int > = 0 >
  constexpr void _Verify_offset ( const difference_type _Off ) const
  {
  do { if ( _Off != _Min_possible_v < difference_type > ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1406, 0, "%s", "integer overflow" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x74\x65\x67\x65\x72\x20\x6f\x76\x65\x72\x66\x6c\x6f\x77\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1406, 0 ); } while ( false ); }; } while ( false );
  current . _Verify_offset ( - _Off );
  }

 template < class _BidIt2 = _BidIt,
  enable_if_t < _Unwrappable_v < _BidIt2 >, int > = 0 >
   constexpr reverse_iterator < _Unwrapped_t < _BidIt2 >> _Unwrapped ( ) const
  {
  return ( static_cast < reverse_iterator < _Unwrapped_t < _BidIt2 >> > ( current . _Unwrapped ( ) ) );
  }

 static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v < _BidIt >;

 template < class _Src,
  enable_if_t < _Wrapped_seekable_v < _BidIt, _Src >, int > = 0 >
  constexpr void _Seek_to ( const reverse_iterator < _Src > & _It )
  {
  current . _Seek_to ( _It . base ( ) );
  }
protected :
 _BidIt current;
 };
#line 1429
template < class _BidIt,
 class _BidIt2,
 enable_if_t < _Range_verifiable_v < _BidIt, _BidIt2 >, int > = 0 >
 constexpr void _Verify_range ( const reverse_iterator < _BidIt > & _First, const reverse_iterator < _BidIt2 > & _Last )
 {

 _Verify_range ( _Last . base ( ), _First . base ( ) );
 }
#line 1438
template < class _BidIt >
  inline reverse_iterator < _BidIt > operator + (
  typename reverse_iterator < _BidIt > :: difference_type _Off,
  const reverse_iterator < _BidIt > & _Right )
 {
 return ( _Right + _Off );
 }
#line 1446
template < class _BidIt1,
 class _BidIt2 >
  inline auto operator - ( const reverse_iterator < _BidIt1 > & _Left,
  const reverse_iterator < _BidIt2 > & _Right )
   -> decltype ( _Right . base ( ) - _Left . base ( ) )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }
#line 1455
template < class _BidIt1,
 class _BidIt2 >
  inline bool operator == ( const reverse_iterator < _BidIt1 > & _Left,
  const reverse_iterator < _BidIt2 > & _Right )
 {
 return ( _Left . base ( ) == _Right . base ( ) );
 }
#line 1463
template < class _BidIt1,
 class _BidIt2 >
  inline bool operator != ( const reverse_iterator < _BidIt1 > & _Left,
  const reverse_iterator < _BidIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1471
template < class _BidIt1,
 class _BidIt2 >
  inline bool operator < ( const reverse_iterator < _BidIt1 > & _Left,
  const reverse_iterator < _BidIt2 > & _Right )
 {
 return ( _Right . base ( ) < _Left . base ( ) );
 }
#line 1479
template < class _BidIt1,
 class _BidIt2 >
  inline bool operator > ( const reverse_iterator < _BidIt1 > & _Left,
  const reverse_iterator < _BidIt2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1487
template < class _BidIt1,
 class _BidIt2 >
  inline bool operator <= ( const reverse_iterator < _BidIt1 > & _Left,
  const reverse_iterator < _BidIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1495
template < class _BidIt1,
 class _BidIt2 >
  inline bool operator >= ( const reverse_iterator < _BidIt1 > & _Left,
  const reverse_iterator < _BidIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1504
template < class _BidIt >
  inline reverse_iterator < _BidIt > make_reverse_iterator ( _BidIt _Iter )
 {
 return ( reverse_iterator < _BidIt > ( _Iter ) );
 }
#line 1511
template < class _Container >
  inline auto begin ( _Container & _Cont ) -> decltype ( _Cont . begin ( ) )
 {
 return ( _Cont . begin ( ) );
 }
#line 1517
template < class _Container >
  inline auto begin ( const _Container & _Cont ) -> decltype ( _Cont . begin ( ) )
 {
 return ( _Cont . begin ( ) );
 }
#line 1523
template < class _Container >
  inline auto end ( _Container & _Cont ) -> decltype ( _Cont . end ( ) )
 {
 return ( _Cont . end ( ) );
 }
#line 1529
template < class _Container >
  inline auto end ( const _Container & _Cont ) -> decltype ( _Cont . end ( ) )
 {
 return ( _Cont . end ( ) );
 }
#line 1535
template < class _Ty,
 size_t _Size >
  constexpr _Ty * begin ( _Ty ( & _Array ) [ _Size ] ) noexcept
 {
 return ( _Array );
 }
#line 1542
template < class _Ty,
 size_t _Size >
  constexpr _Ty * end ( _Ty ( & _Array ) [ _Size ] ) noexcept
 {
 return ( _Array + _Size );
 }
#line 1550
template < class _Container >
  constexpr auto cbegin ( const _Container & _Cont )
  noexcept ( noexcept ( :: std :: begin ( _Cont ) ) )
  -> decltype ( :: std :: begin ( _Cont ) )
 {
 return ( :: std :: begin ( _Cont ) );
 }
#line 1558
template < class _Container >
  constexpr auto cend ( const _Container & _Cont )
  noexcept ( noexcept ( :: std :: end ( _Cont ) ) )
  -> decltype ( :: std :: end ( _Cont ) )
 {
 return ( :: std :: end ( _Cont ) );
 }
#line 1567
template < class _Container >
  inline auto rbegin ( _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) )
 {
 return ( _Cont . rbegin ( ) );
 }
#line 1573
template < class _Container >
  inline auto rbegin ( const _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) )
 {
 return ( _Cont . rbegin ( ) );
 }
#line 1579
template < class _Container >
  inline auto rend ( _Container & _Cont ) -> decltype ( _Cont . rend ( ) )
 {
 return ( _Cont . rend ( ) );
 }
#line 1585
template < class _Container >
  inline auto rend ( const _Container & _Cont ) -> decltype ( _Cont . rend ( ) )
 {
 return ( _Cont . rend ( ) );
 }
#line 1591
template < class _Ty,
 size_t _Size >
  inline reverse_iterator < _Ty * > rbegin ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( reverse_iterator < _Ty * > ( _Array + _Size ) );
 }
#line 1598
template < class _Ty,
 size_t _Size >
  inline reverse_iterator < _Ty * > rend ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( reverse_iterator < _Ty * > ( _Array ) );
 }
#line 1605
template < class _Elem >
  inline reverse_iterator < const _Elem * >
  rbegin ( initializer_list < _Elem > _Ilist )
 {
 return ( reverse_iterator < const _Elem * > ( _Ilist . end ( ) ) );
 }
#line 1612
template < class _Elem >
  inline reverse_iterator < const _Elem * >
  rend ( initializer_list < _Elem > _Ilist )
 {
 return ( reverse_iterator < const _Elem * > ( _Ilist . begin ( ) ) );
 }
#line 1620
template < class _Container >
  inline auto crbegin ( const _Container & _Cont )
  -> decltype ( :: std :: rbegin ( _Cont ) )
 {
 return ( :: std :: rbegin ( _Cont ) );
 }
#line 1627
template < class _Container >
  inline auto crend ( const _Container & _Cont )
  -> decltype ( :: std :: rend ( _Cont ) )
 {
 return ( :: std :: rend ( _Cont ) );
 }
#line 1635
template < class _Container >
  constexpr auto size ( const _Container & _Cont )
  -> decltype ( _Cont . size ( ) )
 {
 return ( _Cont . size ( ) );
 }
#line 1642
template < class _Ty,
 size_t _Size >
  constexpr size_t size ( const _Ty ( & ) [ _Size ] ) noexcept
 {
 return ( _Size );
 }
#line 1649
template < class _Container >
  constexpr auto empty ( const _Container & _Cont )
  -> decltype ( _Cont . empty ( ) )
 {
 return ( _Cont . empty ( ) );
 }
#line 1656
template < class _Ty,
 size_t _Size >
  constexpr bool empty ( const _Ty ( & ) [ _Size ] ) noexcept
 {
 return ( false );
 }
#line 1663
template < class _Elem >
  constexpr bool empty (
  initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . size ( ) == 0 );
 }
#line 1670
template < class _Container >
  constexpr auto data ( _Container & _Cont )
  -> decltype ( _Cont . data ( ) )
 {
 return ( _Cont . data ( ) );
 }
#line 1677
template < class _Container >
  constexpr auto data ( const _Container & _Cont )
  -> decltype ( _Cont . data ( ) )
 {
 return ( _Cont . data ( ) );
 }
#line 1684
template < class _Ty,
 size_t _Size >
  constexpr _Ty * data ( _Ty ( & _Array ) [ _Size ] ) noexcept
 {
 return ( _Array );
 }
#line 1691
template < class _Elem >
  constexpr const _Elem * data (
  initializer_list < _Elem > _Ilist ) noexcept
 {
 return ( _Ilist . begin ( ) );
 }
#line 1705
struct _Iterator_base12_compatible { 
#line 1707
_Container_proxy *_Myproxy{((_Container_proxy *)0i64)}; 
#line 1708
_Iterator_base12 *_Mynextiter{((_Iterator_base12 *)0i64)}; 
#line 1709
}; 
#line 1712 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Ty,
 size_t _Size >
 class _Array_const_iterator

  : private _Iterator_base12_compatible

 {
public :
 using iterator_category = random_access_iterator_tag;

 using value_type = _Ty;
 using difference_type = ptrdiff_t;
 using pointer = const _Ty *;
 using reference = const _Ty &;
 enum { _EEN_SIZE = _Size };






























































































































 inline _Array_const_iterator ( )
  : _Ptr ( ),
  _Idx ( 0 )
  {
  }

 inline explicit _Array_const_iterator ( pointer _Parg, size_t _Off = 0 )
  : _Ptr ( _Parg ),
  _Idx ( _Off )
  {
  }

  inline reference operator * ( ) const
  {
  return ( * operator -> ( ) );
  }

  inline pointer operator -> ( ) const
  {
  do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1872, 0, "%s", "cannot dereference value-initialized array iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61" L"\x6c\x69\x7a\x65\x64\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1872, 0 ); } while ( false ); }; } while ( false );
  do { if ( _Idx < _Size ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1873, 0, "%s", "cannot dereference out of range array iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65" L"\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1873, 0 ); } while ( false ); }; } while ( false );
  return ( _Ptr + _Idx );
  }

 inline _Array_const_iterator & operator ++ ( )
  {
  do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1879, 0, "%s", "cannot increment value-initialized array iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61\x6c\x69" L"\x7a\x65\x64\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1879, 0 ); } while ( false ); }; } while ( false );
  do { if ( _Idx < _Size ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1880, 0, "%s", "cannot increment array iterator past end" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72" L"\x20\x70\x61\x73\x74\x20\x65\x6e\x64\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1880, 0 ); } while ( false ); }; } while ( false );
  ++ _Idx;
  return ( * this );
  }

 inline _Array_const_iterator operator ++ ( int )
  {
  _Array_const_iterator _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 inline _Array_const_iterator & operator -- ( )
  {
  do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1894, 0, "%s", "cannot decrement value-initialized array iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61\x6c\x69" L"\x7a\x65\x64\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1894, 0 ); } while ( false ); }; } while ( false );
  do { if ( _Idx != 0 ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1895, 0, "%s", "cannot decrement array iterator before begin" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72" L"\x20\x62\x65\x66\x6f\x72\x65\x20\x62\x65\x67\x69\x6e\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1895, 0 ); } while ( false ); }; } while ( false );
  -- _Idx;
  return ( * this );
  }

 inline _Array_const_iterator operator -- ( int )
  {
  _Array_const_iterator _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 constexpr void _Verify_offset ( const ptrdiff_t _Off ) const noexcept
  {
  if ( _Off != 0 )
   {
   do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1911, 0, "%s", "cannot seek value-initialized array iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x65\x6b\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x65\x64\x20\x61" L"\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1911, 0 ); } while ( false ); }; } while ( false );
   }

  if ( _Off < 0 )
   {
#pragma warning(suppress: 4146)
   do { if ( _Idx >= - static_cast < size_t > ( _Off ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1918, 0, "%s", "cannot seek array iterator before begin" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x65\x6b\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x62\x65\x66\x6f" L"\x72\x65\x20\x62\x65\x67\x69\x6e\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1918, 0 ); } while ( false ); }; } while ( false );

   }

  if ( _Off > 0 )
   {
   do { if ( _Size - _Idx >= static_cast < size_t > ( _Off ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1924, 0, "%s", "cannot seek array iterator after end" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x65\x6b\x20\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x61\x66\x74\x65" L"\x72\x20\x65\x6e\x64\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1924, 0 ); } while ( false ); }; } while ( false );

   }
  }

 inline _Array_const_iterator & operator += ( const ptrdiff_t _Off )
  {
  _Verify_offset ( _Off );
  _Idx += _Off;
  return ( * this );
  }

  inline _Array_const_iterator operator + ( const ptrdiff_t _Off ) const
  {
  _Array_const_iterator _Tmp = * this;
  return ( _Tmp += _Off );
  }

 inline _Array_const_iterator & operator -= ( const ptrdiff_t _Off )
  {
  return ( * this += - _Off );
  }

  inline _Array_const_iterator operator - ( const ptrdiff_t _Off ) const
  {
  _Array_const_iterator _Tmp = * this;
  return ( _Tmp -= _Off );
  }

  inline ptrdiff_t operator - ( const _Array_const_iterator & _Right ) const
  {
  _Compat ( _Right );
  return ( static_cast < ptrdiff_t > ( _Idx - _Right . _Idx ) );
  }

  inline reference operator [ ] ( const ptrdiff_t _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

  inline bool operator == ( const _Array_const_iterator & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx == _Right . _Idx );
  }

  inline bool operator != ( const _Array_const_iterator & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

  inline bool operator < ( const _Array_const_iterator & _Right ) const
  {
  _Compat ( _Right );
  return ( _Idx < _Right . _Idx );
  }

  inline bool operator > ( const _Array_const_iterator & _Right ) const
  {
  return ( _Right < * this );
  }

  inline bool operator <= ( const _Array_const_iterator & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

  inline bool operator >= ( const _Array_const_iterator & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

 inline void _Compat ( const _Array_const_iterator & _Right ) const
  {
  do { if ( _Ptr == _Right . _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 1997, 0, "%s", "array iterators incompatible" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 1997, 0 ); } while ( false ); }; } while ( false );
  }

  constexpr pointer _Unwrapped ( ) const
  {
  return ( _Ptr + _Idx );
  }

 constexpr void _Verify_with ( const _Array_const_iterator & _Last ) const noexcept
  {

  do { if ( * this <= _Last ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 2008, 0, "%s", "array iterator range transposed" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x72\x61\x6e\x67\x65\x20\x74\x72\x61\x6e\x73\x70\x6f\x73\x65\x64" L"\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 2008, 0 ); } while ( false ); }; } while ( false );
  }

 constexpr void _Seek_to ( pointer _It )
  {
  _Idx = static_cast < size_t > ( _It - _Ptr );
  }

private :
 pointer _Ptr;
 size_t _Idx;

 };
#line 2023 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Ty,
 size_t _Size >
 constexpr void _Verify_range ( const _Array_const_iterator < _Ty, _Size > & _First,
  const _Array_const_iterator < _Ty, _Size > & _Last ) noexcept
 {

 _First . _Verify_with ( _Last );
 }
#line 2033 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Ty,
 size_t _Size >
  inline _Array_const_iterator < _Ty, _Size > operator + (
  ptrdiff_t _Off,
  _Array_const_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 2043
template < class _Ty,
 size_t _Size >
 class _Array_iterator
  : public _Array_const_iterator < _Ty, _Size >
 {
public :
 using _Mybase = _Array_const_iterator < _Ty, _Size >;
 using iterator_category = random_access_iterator_tag;

 using value_type = _Ty;
 using difference_type = ptrdiff_t;
 using pointer = _Ty *;
 using reference = _Ty &;

 inline _Array_iterator ( )
  {
  }

 inline explicit _Array_iterator ( pointer _Parg, size_t _Off = 0 )
  : _Mybase ( _Parg, _Off )
  {
  }

 enum { _EEN_SIZE = _Size };

  inline reference operator * ( ) const
  {
  return ( const_cast < reference > ( _Mybase :: operator * ( ) ) );
  }

  inline pointer operator -> ( ) const
  {
  return ( const_cast < pointer > ( _Mybase :: operator -> ( ) ) );
  }

 inline _Array_iterator & operator ++ ( )
  {
  ++ * static_cast < _Mybase * > ( this );
  return ( * this );
  }

 inline _Array_iterator operator ++ ( int )
  {
  _Array_iterator _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 inline _Array_iterator & operator -- ( )
  {
  -- * static_cast < _Mybase * > ( this );
  return ( * this );
  }

 inline _Array_iterator operator -- ( int )
  {
  _Array_iterator _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 inline _Array_iterator & operator += ( const ptrdiff_t _Off )
  {
  * static_cast < _Mybase * > ( this ) += _Off;
  return ( * this );
  }

  inline _Array_iterator operator + ( const ptrdiff_t _Off ) const
  {
  _Array_iterator _Tmp = * this;
  return ( _Tmp += _Off );
  }

 inline _Array_iterator & operator -= ( const ptrdiff_t _Off )
  {
  return ( * this += - _Off );
  }

  inline _Array_iterator operator - ( const ptrdiff_t _Off ) const
  {
  _Array_iterator _Tmp = * this;
  return ( _Tmp -= _Off );
  }

  inline ptrdiff_t operator - ( const _Mybase & _Right ) const
  {
  return ( * static_cast < const _Mybase * > ( this ) - _Right );
  }

  inline reference operator [ ] ( const ptrdiff_t _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

  constexpr pointer _Unwrapped ( ) const
  {
  return ( const_cast < pointer > ( _Mybase :: _Unwrapped ( ) ) );
  }
 };
#line 2143
template < class _Ty,
 size_t _Size >
  inline _Array_iterator < _Ty, _Size > operator + (
  ptrdiff_t _Off,
  _Array_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 2153
template < class _Iter >
 class move_iterator
 {
public :
 using iterator_category = typename iterator_traits < _Iter > :: iterator_category;
 using value_type = typename iterator_traits < _Iter > :: value_type;
 using difference_type = typename iterator_traits < _Iter > :: difference_type;
 using pointer = _Iter;
 using _Ref0 = typename iterator_traits < _Iter > :: reference;
 using reference = conditional_t < is_reference_v < _Ref0 >, remove_reference_t < _Ref0 > &&, _Ref0 >;
 using iterator_type = _Iter;

 inline move_iterator ( )
  : current ( )
  {
  }

 inline explicit move_iterator ( iterator_type _Right )
  : current ( _Right )
  {
  }

 template < class _Iter2 >
  inline move_iterator ( const move_iterator < _Iter2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 template < class _Iter2 >
  inline move_iterator & operator = ( const move_iterator < _Iter2 > & _Right )
  {
  current = _Right . base ( );
  return ( * this );
  }

  inline _Iter base ( ) const
  {
  return ( current );
  }

  inline reference operator * ( ) const
  {
  return ( static_cast < reference > ( * current ) );
  }

  inline pointer operator -> ( ) const
  {
  return ( current );
  }

 inline move_iterator & operator ++ ( )
  {
  ++ current;
  return ( * this );
  }

 inline move_iterator operator ++ ( int )
  {
  move_iterator _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 inline move_iterator & operator -- ( )
  {
  -- current;
  return ( * this );
  }

 inline move_iterator operator -- ( int )
  {
  move_iterator _Tmp = * this;
  -- current;
  return ( _Tmp );
  }



 inline move_iterator & operator += ( const difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

  inline move_iterator operator + ( const difference_type _Off ) const
  {
  return ( move_iterator ( current + _Off ) );
  }

 inline move_iterator & operator -= ( const difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

  inline move_iterator operator - ( const difference_type _Off ) const
  {
  return ( move_iterator ( current - _Off ) );
  }

  inline reference operator [ ] ( const difference_type _Off ) const
  {
  return ( :: std :: move ( current [ _Off ] ) );
  }

 template < class _Iter2,
  enable_if_t < _Range_verifiable_v < _Iter, _Iter2 >, int > = 0 >
  friend constexpr void _Verify_range ( const move_iterator & _First, const move_iterator < _Iter2 > & _Last )
  {
  _Verify_range ( _First . base ( ), _Last . base ( ) );
  }

 template < class _Iter2 = iterator_type,
  enable_if_t < _Offset_verifiable_v < _Iter2 >, int > = 0 >
  constexpr void _Verify_offset ( const difference_type _Off ) const
  {
  current . _Verify_offset ( _Off );
  }

 template < class _Iter2 = iterator_type,
  enable_if_t < _Unwrappable_v < _Iter2 >, int > = 0 >
   constexpr move_iterator < _Unwrapped_t < _Iter2 >> _Unwrapped ( ) const
  {
  return ( static_cast < move_iterator < _Unwrapped_t < _Iter2 >> > ( current . _Unwrapped ( ) ) );
  }

 static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v < iterator_type >;

 template < class _Src,
  enable_if_t < _Wrapped_seekable_v < iterator_type, _Src >, int > = 0 >
  constexpr void _Seek_to ( const move_iterator < _Src > & _It )
  {
  current . _Seek_to ( _It . base ( ) );
  }
protected :
 iterator_type current;
 };
#line 2291
template < class _Iter >
  inline move_iterator < _Iter > operator + (
  typename move_iterator < _Iter > :: difference_type _Off,
  const move_iterator < _Iter > & _Right )
 {
 return ( _Right + _Off );
 }
#line 2299
template < class _Iter1,
 class _Iter2 >
  inline auto operator - (
  const move_iterator < _Iter1 > & _Left,
  const move_iterator < _Iter2 > & _Right )
   -> decltype ( _Left . base ( ) - _Right . base ( ) )
 {
 return ( _Left . base ( ) - _Right . base ( ) );
 }
#line 2309
template < class _Iter1,
 class _Iter2 >
  inline bool operator == (
  const move_iterator < _Iter1 > & _Left,
  const move_iterator < _Iter2 > & _Right )
 {
 return ( _Left . base ( ) == _Right . base ( ) );
 }
#line 2318
template < class _Iter1,
 class _Iter2 >
  inline bool operator != (
  const move_iterator < _Iter1 > & _Left,
  const move_iterator < _Iter2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2327
template < class _Iter1,
 class _Iter2 >
  inline bool operator < (
  const move_iterator < _Iter1 > & _Left,
  const move_iterator < _Iter2 > & _Right )
 {
 return ( _Left . base ( ) < _Right . base ( ) );
 }
#line 2336
template < class _Iter1,
 class _Iter2 >
  inline bool operator > (
  const move_iterator < _Iter1 > & _Left,
  const move_iterator < _Iter2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2345
template < class _Iter1,
 class _Iter2 >
  inline bool operator <= (
  const move_iterator < _Iter1 > & _Left,
  const move_iterator < _Iter2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2354
template < class _Iter1,
 class _Iter2 >
  inline bool operator >= (
  const move_iterator < _Iter1 > & _Left,
  const move_iterator < _Iter2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2364
template < class _Iter >
  inline move_iterator < _Iter > make_move_iterator ( _Iter _It )
 {
 return ( move_iterator < _Iter > ( _It ) );
 }
#line 2371
template < class _Traits >
 struct _Char_traits_eq
 {
 using _Elem = typename _Traits :: char_type;

 bool operator ( ) ( _Elem _Left, _Elem _Right ) const
  {
  return ( _Traits :: eq ( _Left, _Right ) );
  }
 };
#line 2383
template < class _Traits >
 struct _Char_traits_lt
 {
 using _Elem = typename _Traits :: char_type;

 bool operator ( ) ( _Elem _Left, _Elem _Right ) const
  {
  return ( _Traits :: lt ( _Left, _Right ) );
  }
 };
#line 2395
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_memmove ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 const char * const _First_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _First ) );
 const char * const _Last_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _Last ) );
 char * const _Dest_ch = const_cast < char * > ( reinterpret_cast < volatile char * > ( _Dest ) );
 const auto _Count = static_cast < size_t > ( _Last_ch - _First_ch );
 :: memmove ( _Dest_ch, _First_ch, _Count );
 return ( reinterpret_cast < _OutIt > ( _Dest_ch + _Count ) );
 }
#line 2407
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ( void ) ++ _First )
  {
  * _Dest = * _First;
  }

 return ( _Dest );
 }
#line 2420
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 2428
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {

 return ( _Copy_unchecked1 ( _First, _Last, _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
 }
#line 2437
template < class _InIt,
 class _OutIt > inline
 _OutIt copy ( _InIt _First, _InIt _Last, _OutIt _Dest )
 {
 _Adl_verify_range ( _First, _Last );
 const auto _UFirst = _Get_unwrapped ( _First );
 const auto _ULast = _Get_unwrapped ( _Last );
 const auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
 _Seek_wrapped ( _Dest, _Copy_unchecked ( _UFirst, _ULast, _UDest ) );
 return ( _Dest );
 }
#line 2450
template < class _InIt,
 class _DestTy,
 size_t _DestSize > inline
 _DestTy * copy ( _InIt _First, _InIt _Last, _DestTy ( & _Dest ) [ _DestSize ] )
 {
 return ( :: std :: copy ( _First, _Last, _Array_iterator < _DestTy, _DestSize > ( _Dest ) ) . _Unwrapped ( ) );
 }
#line 2489 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked4 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _General_ptr_iterator_tag )
 {

 for (;; )
  {
  * _Dest = * _First;
  ++ _Dest;
  -- _Count;
  if ( _Count == 0 )
   {

   return ( _Dest );
   }

  ++ _First;
  }
 }
#line 2511
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked4 ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag )
 {

 return ( _Copy_memmove ( _First, _First + _Count, _Dest ) );
 }
#line 2521
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n_unchecked3 ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {

 return ( _Copy_n_unchecked4 ( _First, _Count,
  _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
 }
#line 2532
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _InIt _First, _Diff _Count_raw, _OutIt _Dest )
 {
 const _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  _Seek_wrapped ( _Dest,
   _Copy_n_unchecked3 ( _Get_unwrapped_n ( _First, _Count ), _Count, _Get_unwrapped_n ( _Dest, _Count ) ) );
  }

 return ( _Dest );
 }
#line 2548
template < class _SourceTy,
 size_t _SourceSize,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _SourceTy ( & _First ) [ _SourceSize ], _Diff _Count_raw, _OutIt _Dest )
 {
 const _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  do { if ( ( :: std :: size ( _First ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 2557, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 2557, 0 ); } while ( false ); }; } while ( false );
  _Seek_wrapped ( _Dest, _Copy_n_unchecked3 ( _First, _Count, _Get_unwrapped_n ( _Dest, _Count ) ) );
  }

 return ( _Dest );
 }
#line 2564
template < class _InIt,
 class _Diff,
 class _DestTy,
 size_t _DestSize > inline
 _DestTy * copy_n ( _InIt _First, _Diff _Count_raw, _DestTy ( & _Dest ) [ _DestSize ] )
 {
 const _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  do { if ( ( :: std :: size ( _Dest ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 2573, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 2573, 0 ); } while ( false ); }; } while ( false );
  return ( _Copy_n_unchecked3 ( _Get_unwrapped_n ( _First, _Count ), _Count, _Dest ) );
  }

 return ( _Dest );
 }
#line 2580
template < class _SourceTy,
 size_t _SourceSize,
 class _Diff,
 class _DestTy,
 size_t _DestSize > inline
 _DestTy * copy_n ( _SourceTy ( & _First ) [ _SourceSize ], _Diff _Count_raw, _DestTy ( & _Dest ) [ _DestSize ] )
 {
 const _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  do { if ( ( :: std :: size ( _First ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 2590, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 2590, 0 ); } while ( false ); }; } while ( false );
  do { if ( ( :: std :: size ( _Dest ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 2591, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x75\x74\x69\x6c\x69\x74\x79", 2591, 0 ); } while ( false ); }; } while ( false );
  return ( _Copy_n_unchecked3 ( _First, _Count, _Dest ) );
  }

 return ( _Dest );
 }
#line 2656 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward_memmove ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 const char * const _First_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _First ) );
 const char * const _Last_ch = const_cast < const char * > ( reinterpret_cast < const volatile char * > ( _Last ) );
 char * const _Dest_ch = const_cast < char * > ( reinterpret_cast < volatile char * > ( _Dest ) );
 const auto _Count = static_cast < size_t > ( _Last_ch - _First_ch );
 return ( static_cast < _BidIt2 > (
  :: memmove ( _Dest_ch - _Count, _First_ch, _Count ) ) );
 }
#line 2668
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = * -- _Last;
 return ( _Dest );
 }
#line 2678
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_backward_memmove ( _First, _Last, _Dest ) );
 }
#line 2686
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 copy_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 _Adl_verify_range ( _First, _Last );
 const auto _UFirst = _Get_unwrapped ( _First );
 const auto _ULast = _Get_unwrapped ( _Last );
 const auto _UDest = _Get_unwrapped_n ( _Dest, - _Idl_distance < _BidIt1 > ( _UFirst, _ULast ) );
 _Seek_wrapped ( _Dest,
  _Copy_backward_unchecked ( _UFirst, _ULast, _UDest, _Ptr_copy_cat ( _UFirst, _UDest ) ) );
 return ( _Dest );
 }
#line 2712 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _General_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ( void ) ++ _First )
  * _Dest = :: std :: move ( * _First );
 return ( _Dest );
 }
#line 2722
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_unchecked1 ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 2730
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_unchecked ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {

 return ( _Move_unchecked1 ( _First, _Last,
  _Dest, _Ptr_move_cat ( _First, _Dest ) ) );
 }
#line 2740
template< class _InIt, class 
#line 2741
_OutIt> inline _OutIt 
#line 2742
move(_InIt _First, _InIt _Last, _OutIt 
#line 2743
_Dest) 
#line 2744
{ 
#line 2745
_Adl_verify_range(_First, _Last); 
#line 2746
const auto _UFirst = _Get_unwrapped(_First); 
#line 2747
const auto _ULast = _Get_unwrapped(_Last); 
#line 2748
const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance< _InIt> (_UFirst, _ULast)); 
#line 2749
_Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest)); 
#line 2751
return _Dest; 
#line 2752
} 
#line 2755
template< class _InIt, class 
#line 2756
_DestTy, size_t 
#line 2757
_DestSize> inline _DestTy *
#line 2758
move(_InIt _First, _InIt _Last, _DestTy (&_Dest)[_DestSize]) 
#line 2759
{ 
#line 2760
return (std::move(_First, _Last, ((_Array_iterator< _DestTy, _DestSize> )(_Dest)))._Unwrapped()); 
#line 2761
} 
#line 2793 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward_unchecked1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _General_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = :: std :: move ( * -- _Last );
 return ( _Dest );
 }
#line 2803
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward_unchecked1 ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag )
 {
 return ( _Copy_backward_memmove ( _First, _Last, _Dest ) );
 }
#line 2811
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward_unchecked ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {

 return ( _Move_backward_unchecked1 ( _First, _Last,
  _Dest, _Ptr_move_cat ( _First, _Dest ) ) );
 }
#line 2820
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 move_backward ( _BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest )
 {
 _Adl_verify_range ( _First, _Last );
 const auto _UFirst = _Get_unwrapped ( _First );
 const auto _ULast = _Get_unwrapped ( _Last );
 const auto _UDest = _Get_unwrapped_n ( _Dest, - _Idl_distance < _BidIt1 > ( _UFirst, _ULast ) );
 _Seek_wrapped ( _Dest, _Move_backward_unchecked ( _UFirst, _ULast, _UDest ) );
 return ( _Dest );
 }
#line 2845 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Ty> 
#line 2846
struct _Is_character : public false_type { 
#line 2849
}; 
#line 2852
template<> struct _Is_character< char>  : public true_type { 
#line 2855
}; 
#line 2858
template<> struct _Is_character< signed char>  : public true_type { 
#line 2861
}; 
#line 2864
template<> struct _Is_character< unsigned char>  : public true_type { 
#line 2867
}; 
#line 2869
template< class _FwdIt, class 
#line 2870
_Ty> 
#line 2871
struct _Fill_memset_is_safe_helper { 
#line 2873
using _Value_type = _Iter_value_t< _FwdIt> ; 
#line 2875
using _Raw_ty = _Unwrap_enum_t< _Ty> ; 
#line 2876
using _Raw_value_type = _Unwrap_enum_t< _Iter_value_t< _FwdIt> > ; 
#line 2878
using type = bool_constant< conjunction_v< is_pointer< _FwdIt> , disjunction< conjunction< _Is_character< _Unwrap_enum_t< _Ty> > , _Is_character< _Unwrap_enum_t< _Iter_value_t< _FwdIt> > > > , conjunction< is_same< bool, _Unwrap_enum_t< _Ty> > , is_same< bool, _Unwrap_enum_t< _Iter_value_t< _FwdIt> > > > > , is_convertible< _Ty, _Iter_value_t< _FwdIt> > > > ; 
#line 2888
}; 
#line 2890
template < class _FwdIt,
 class _Ty > inline
 typename _Fill_memset_is_safe_helper < _FwdIt, _Ty > :: type
 _Fill_memset_is_safe ( const _FwdIt &, const _Ty & )
 {
 return { };
 }
#line 2898
template < class _FwdIt,
 class _Ty > inline
 void _Fill_unchecked1 ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, false_type )
 {
 for (; _First != _Last; ++ _First )
  * _First = _Val;
 }
#line 2906
template < class _FwdIt,
 class _Ty > inline
 void _Fill_unchecked1 ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val, true_type )
 {
 :: memset ( _First, static_cast < unsigned char > ( _Val ), static_cast < size_t > ( _Last - _First ) );
 }
#line 2913
template < class _FwdIt,
 class _Ty > inline
 void _Fill_unchecked ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _Fill_unchecked1 ( _First, _Last, _Val, _Fill_memset_is_safe ( _First, _Val ) );
 }
#line 2920
template < class _FwdIt,
 class _Ty > inline
 void fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 _Adl_verify_range ( _First, _Last );
 _Fill_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Val );
 }
#line 2943 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt _Fill_n_unchecked2 ( _OutIt _Dest, _Diff _Count, const _Ty & _Val, false_type )
 {
 for (; 0 < _Count; -- _Count, ( void ) ++ _Dest )
  * _Dest = _Val;
 return ( _Dest );
 }
#line 2953
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt _Fill_n_unchecked2 ( _OutIt _Dest, _Diff _Count, const _Ty & _Val, true_type )
 {
 :: memset ( _Dest, static_cast < unsigned char > ( _Val ), static_cast < size_t > ( _Count ) );
 return ( _Dest + _Count );
 }
#line 2962
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt fill_n ( _OutIt _Dest, _Diff _Count_raw, const _Ty & _Val )
 {
 const _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  const auto _UDest = _Get_unwrapped_n ( _Dest, _Count );
  _Seek_wrapped ( _Dest,
   _Fill_n_unchecked2 ( _UDest, _Count, _Val, _Fill_memset_is_safe ( _UDest, _Val ) ) );
  }

 return ( _Dest );
 }
#line 2993 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Elem1, class 
#line 2994
_Elem2> 
#line 2995
struct _Value_equality_is_bitwise_equality : public bool_constant< (static_cast< _Elem1>(-1)) == (static_cast< _Elem2>(-1))>  { 
#line 3001
}; 
#line 3003
template< class _Elem1, class 
#line 3004
_Elem2, class 
#line 3005
_Pr> 
#line 3006
struct _Equal_memcmp_is_safe_helper : public false_type { 
#line 3010
}; 
#line 3012
template< class _Elem1, class 
#line 3013
_Elem2> 
#line 3014
struct _Equal_memcmp_is_safe_helper< _Elem1, _Elem2, equal_to<> >  : public bool_constant< conjunction_v< _Is_same_size< _Elem1, _Elem2> , _Is_nonbool_integral< _Elem1> , _Is_nonbool_integral< _Elem2> , negation< is_volatile< _Elem1> > , negation< is_volatile< _Elem2> > , _Value_equality_is_bitwise_equality< _Elem1, _Elem2> > >  { 
#line 3026
}; 
#line 3028
template< class _Elem1, class 
#line 3029
_Elem2> 
#line 3030
struct _Equal_memcmp_is_safe_helper< _Elem1 *, _Elem2 *, equal_to<> >  : public is_same< remove_cv_t< _Elem1> , remove_cv_t< _Elem2> > ::type { 
#line 3033
}; 
#line 3043 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Elem> 
#line 3044
struct _Equal_memcmp_is_safe_helper< _Elem, _Elem, _Char_traits_eq< char_traits< _Elem> > >  : public std::_Equal_memcmp_is_safe_helper< _Elem, _Elem, equal_to<> > ::type { 
#line 3047
}; 
#line 3049
template< class _Elem> 
#line 3050
struct _Equal_memcmp_is_safe_helper< _Elem, _Elem, equal_to< _Elem> >  : public std::_Equal_memcmp_is_safe_helper< _Elem, _Elem, equal_to<> > ::type { 
#line 3054
}; 
#line 3056
template < class _Iter1,
 class _Iter2,
 class _Pr > inline
 false_type _Equal_memcmp_is_safe ( const _Iter1 &, const _Iter2 &, const _Pr & )
 {
 return { };
 }
#line 3064
template < class _Obj1,
 class _Obj2,
 class _Pr > inline
 typename _Equal_memcmp_is_safe_helper <
  remove_const_t < _Obj1 >,
  remove_const_t < _Obj2 >,
  _Pr > :: type
  _Equal_memcmp_is_safe ( _Obj1 * const &, _Obj2 * const &, const _Pr & )
 {
 return { };
 }
#line 3076
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked1 ( _InIt1 _First1, const _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred, false_type )
 {
 for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2 )
  {
  if ( ! _Pred ( * _First1, * _First2 ) )
   {
   return ( false );
   }
  }

 return ( true );
 }
#line 3093
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked1 ( const _InIt1 _First1, const _InIt1 _Last1,
  const _InIt2 _First2, _Pr, true_type )
 {
 const auto _First1_ch = reinterpret_cast < const char * > ( _First1 );
 const auto _First2_ch = reinterpret_cast < const char * > ( _First2 );
 const auto _Count = static_cast < size_t > ( reinterpret_cast < const char * > ( _Last1 ) - _First1_ch );
 return ( :: memcmp ( _First1_ch, _First2_ch, _Count ) == 0 );
 }
#line 3105
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked ( const _InIt1 _First1, const _InIt1 _Last1,
  const _InIt2 _First2, _Pr _Pred )
 {
 return ( _Equal_unchecked1 ( _First1, _Last1, _First2, _Pred,
  _Equal_memcmp_is_safe ( _First1, _First2, _Pred ) ) );
 }
#line 3115
template < class _InIt1,
 class _InIt2,
 class _Pr >
  inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1,
  const _InIt2 _First2, _Pr _Pred )
 {
 _Adl_verify_range ( _First1, _Last1 );
 const auto _UFirst1 = _Get_unwrapped ( _First1 );
 const auto _ULast1 = _Get_unwrapped ( _Last1 );
 const auto _UFirst2 = _Get_unwrapped_n ( _First2, _Idl_distance < _InIt1 > ( _UFirst1, _ULast1 ) );
 return ( _Equal_unchecked ( _UFirst1, _ULast1, _UFirst2, _Pass_fn ( _Pred ) ) );
 }
#line 3129
template < class _InIt1,
 class _RightTy,
 size_t _RightSize,
 class _Pr,
 enable_if_t < ! is_same_v < _RightTy *, _Pr >, int > = 0 >
  inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, _RightTy ( & _First2 ) [ _RightSize ], _Pr _Pred )
 {
 return ( :: std :: equal ( _First1, _Last1,
  _Array_iterator < _RightTy, _RightSize > ( _First2 ), _Pass_fn ( _Pred ) ) );
 }
#line 3162 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt1,
 class _InIt2 >
  inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2 )
 {
 return ( :: std :: equal ( _First1, _Last1, _First2, equal_to < > ( ) ) );
 }
#line 3170
template < class _InIt1,
 class _RightTy,
 size_t _RightSize >
  inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, _RightTy ( & _First2 ) [ _RightSize ] )
 {
 return ( :: std :: equal ( _First1, _Last1, _First2, equal_to < > ( ) ) );
 }
#line 3204 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked ( _InIt1 _First1, const _InIt1 _Last1,
  _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
  input_iterator_tag, input_iterator_tag )
 {

 for (;; )
  {
  if ( _First1 == _Last1 )
   {
   return ( _First2 == _Last2 );
   }

  if ( _First2 == _Last2 )
   {
   return ( false );
   }

  if ( ! _Pred ( * _First1, * _First2 ) )
   {
   return ( false );
   }

  ++ _First1;
  ++ _First2;
  }
 }
#line 3234
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal_unchecked ( const _InIt1 _First1, const _InIt1 _Last1,
  const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred,
  random_access_iterator_tag, random_access_iterator_tag )
 {

 if ( _Last1 - _First1 != _Last2 - _First2 )
  {
  return ( false );
  }

 return ( _Equal_unchecked ( _First1, _Last1, _First2, _Pred ) );
 }
#line 3250
template < class _InIt1,
 class _InIt2,
 class _Pr >
  inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1,
  const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred )
 {
 _Adl_verify_range ( _First1, _Last1 );
 _Adl_verify_range ( _First2, _Last2 );
 return ( _Equal_unchecked ( _Get_unwrapped ( _First1 ), _Get_unwrapped ( _Last1 ),
  _Get_unwrapped ( _First2 ), _Get_unwrapped ( _Last2 ), _Pass_fn ( _Pred ),
   _Iter_cat_t < _InIt1 > ( ), _Iter_cat_t < _InIt2 > ( ) ) );
 }
#line 3273 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt1,
 class _InIt2 >
  inline bool equal ( const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2 )
 {
 return ( :: std :: equal ( _First1, _Last1, _First2, _Last2, equal_to < > ( ) ) );
 }
#line 3293 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Elem1, class 
#line 3294
_Elem2, class 
#line 3295
_FTy> 
#line 3296
struct _Lex_compare_check_element_types_helper : public bool_constant< conjunction_v< _Is_character< _Elem1> , _Is_character< _Elem2> , _Is_character< _FTy> , is_unsigned< _FTy> > >  { 
#line 3304
}; 
#line 3306
template< class _Elem1, class 
#line 3307
_Elem2> 
#line 3308
struct _Lex_compare_check_element_types_helper< _Elem1, _Elem2, void>  : public bool_constant< conjunction_v< _Is_character< _Elem1> , _Is_character< _Elem2> , is_unsigned< _Elem1> , is_unsigned< _Elem2> > >  { 
#line 3316
}; 
#line 3332 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template< class _Memcmp_pr> 
#line 3333
struct _Lex_compare_optimize { 
#line 3335
}; 
#line 3337
template< class _Memcmp_pr, class 
#line 3338
_Obj1, class 
#line 3339
_Obj2, class 
#line 3340
_FTy> using _Lex_compare_check_element_types = _Lex_compare_optimize< conditional_t< _Lex_compare_check_element_types_helper< remove_const_t< _Obj1> , remove_const_t< _Obj2> , _FTy> ::value, _Memcmp_pr, void> > ; 
#line 3345
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 _Lex_compare_optimize < void > _Lex_compare_memcmp_classify ( const _InIt1 &, const _InIt2 &, const _Pr & )
 {
 return { };
 }
#line 3353
template < class _Obj1,
 class _Obj2,
 class _FTy > inline
 _Lex_compare_check_element_types < less < int >, _Obj1, _Obj2, _FTy >
  _Lex_compare_memcmp_classify ( _Obj1 * const &, _Obj2 * const &, const less < _FTy > & )
 {
 return { };
 }
#line 3362
template < class _Obj1,
 class _Obj2,
 class _FTy > inline
 _Lex_compare_check_element_types < greater < int >, _Obj1, _Obj2, _FTy >
  _Lex_compare_memcmp_classify ( _Obj1 * const &, _Obj2 * const &, const greater < _FTy > & )
 {
 return { };
 }
#line 3371
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Lex_compare_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize < void > )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ( void ) ++ _First2 )
  {
  if ( _Debug_lt_pred ( _Pred, * _First1, * _First2 ) )
   return ( true );
  else if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
  }

 return ( _First1 == _Last1 && _First2 != _Last2 );
 }
#line 3388
template < class _InIt1,
 class _InIt2,
 class _Pr,
 class _Memcmp_pr > inline
 bool _Lex_compare_unchecked ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr, _Lex_compare_optimize < _Memcmp_pr > )
 {
 const auto _Num1 = static_cast < size_t > ( _Last1 - _First1 );
 const auto _Num2 = static_cast < size_t > ( _Last2 - _First2 );
 const int _Ans = :: memcmp ( _First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2 );
 return ( _Memcmp_pr { } ( _Ans, 0 ) || ( _Ans == 0 && _Num1 < _Num2 ) );
 }
#line 3401
template < class _InIt1,
 class _InIt2,
 class _Pr >
  inline bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 _Adl_verify_range ( _First1, _Last1 );
 _Adl_verify_range ( _First2, _Last2 );
 const auto _UFirst1 = _Get_unwrapped ( _First1 );
 const auto _ULast1 = _Get_unwrapped ( _Last1 );
 const auto _UFirst2 = _Get_unwrapped ( _First2 );
 const auto _ULast2 = _Get_unwrapped ( _Last2 );
 return ( _Lex_compare_unchecked ( _UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn ( _Pred ),
  _Lex_compare_memcmp_classify ( _UFirst1, _UFirst2, _Pred ) ) );
 }
#line 3417
template < class _InIt1,
 class _InIt2 >
  inline bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 return ( :: std :: lexicographical_compare ( _First1, _Last1,
  _First2, _Last2, less < > ( ) ) );
 }
#line 3456 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, true_type, _Any_tag )
 {
 return ( ( - 128 ) <= _Val && _Val <= 127 );
 }
#line 3462
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, false_type, true_type )
 {
 return ( _Val <= 127 || static_cast < _Ty > ( ( - 128 ) ) <= _Val );
 }
#line 3468
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, false_type, false_type )
 {
 return ( _Val <= 127 );
 }
#line 3474
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, false_type, true_type, _Any_tag )
 {
 return ( 0 <= _Val && _Val <= 255 );
 }
#line 3480
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, false_type, false_type, _Any_tag )
 {
 return ( _Val <= 255 );
 }
#line 3486
template < class _InIt,
 class _Ty > inline
 bool _Within_limits ( _InIt, const _Ty & _Val )
 {
 using _Elem = remove_pointer_t < _InIt >;
 return ( _Within_limits ( _Val, is_signed < _Elem > { }, is_signed < _Ty > { },
  bool_constant < - 1 == static_cast < _Ty > ( - 1 ) > { } ) );
 }
#line 3495
template < class _InIt > inline
 bool _Within_limits ( _InIt, const bool & )
 {
 return ( true );
 }
#line 3501
template < class _InIt,
 class _Ty > inline
 _InIt _Find_unchecked1 ( _InIt _First, const _InIt _Last, const _Ty & _Val, true_type )
 {
 if ( ! _Within_limits ( _First, _Val ) )
  {
  return ( _Last );
  }

 _First = static_cast < _InIt > ( :: memchr (
  _First, static_cast < unsigned char > ( _Val ), static_cast < size_t > ( _Last - _First ) ) );
 return ( _First ? _First : _Last );
 }
#line 3515
template < class _InIt,
 class _Ty > inline
 _InIt _Find_unchecked1 ( _InIt _First, const _InIt _Last, const _Ty & _Val, false_type )
 {
 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   break;
 return ( _First );
 }
#line 3525
template < class _InIt,
 class _Ty > inline
 _InIt _Find_unchecked ( const _InIt _First, const _InIt _Last, const _Ty & _Val )
 {

 using _Memchr_opt = bool_constant < is_integral_v < _Ty > && _Is_any_of_v < _InIt,
  char *, signed char *, unsigned char *, const char *, const signed char *, const unsigned char * >>;

 return ( _Find_unchecked1 ( _First, _Last, _Val, _Memchr_opt { } ) );
 }
#line 3536
template < class _InIt,
 class _Ty >
  inline _InIt find ( _InIt _First, const _InIt _Last, const _Ty & _Val )
 {
 _Adl_verify_range ( _First, _Last );
 _Seek_wrapped ( _First,
  _Find_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Val ) );
 return ( _First );
 }
#line 3555 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt,
 class _Ty,
 class _Pr > inline
 _InIt _Find_pr ( _InIt _First, _InIt _Last, const _Ty & _Val, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  {
  if ( _Pred ( * _First, _Val ) )
   {
   break;
   }
  }

 return ( _First );
 }
#line 3572
template < class _InIt,
 class _Ty >
  inline _Iter_diff_t < _InIt > count ( const _InIt _First, const _InIt _Last, const _Ty & _Val )
 {
 _Adl_verify_range ( _First, _Last );
 auto _UFirst = _Get_unwrapped ( _First );
 const auto _ULast = _Get_unwrapped ( _Last );
 _Iter_diff_t < _InIt > _Count = 0;

 for (; _UFirst != _ULast; ++ _UFirst )
  {
  if ( * _UFirst == _Val )
   {
   ++ _Count;
   }
  }

 return ( _Count );
 }
#line 3602 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _InIt,
 class _Ty,
 class _Pr > inline
 _Iter_diff_t < _InIt > _Count_pr ( _InIt _First, _InIt _Last, const _Ty & _Val, _Pr _Pred )
 {
 _Iter_diff_t < _InIt > _Count = 0;

 for (; _First != _Last; ++ _First )
  {
  if ( _Pred ( * _First, _Val ) )
   {
   ++ _Count;
   }
  }

 return ( _Count );
 }
#line 3621
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 void _Trim_matching_suffixes ( _FwdIt1 &, _FwdIt2 &, _Pr,
  forward_iterator_tag, forward_iterator_tag )
 {
 }
#line 3629
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 void _Trim_matching_suffixes ( _FwdIt1 & _Last1, _FwdIt2 & _Last2, _Pr _Pred,
  bidirectional_iterator_tag, bidirectional_iterator_tag )
 {

 do
  {
  -- _Last1;
  -- _Last2;
  }
 while ( _Pred ( * _Last1, * _Last2 ) );
 ++ _Last1;
 ++ _Last2;
 }
#line 3647
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Check_match_counts ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {
 _Trim_matching_suffixes ( _Last1, _Last2, _Pred,
  _Iter_cat_t < _FwdIt1 > ( ), _Iter_cat_t < _FwdIt2 > ( ) );
 for ( _FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++ _Next1 )
  {
  if ( _Next1 == _Find_pr ( _First1, _Next1, * _Next1, _Pred ) )
   {
   _Iter_diff_t < _FwdIt2 > _Count2 = _Count_pr ( _First2, _Last2, * _Next1, _Pred );
   if ( _Count2 == 0 )
    {
    return ( false );
    }

   _FwdIt1 _Skip1 = _Next_iter ( _Next1 );
   _Iter_diff_t < _FwdIt1 > _Count1 = _Count_pr ( _Skip1, _Last1, * _Next1, _Pred ) + 1;
   if ( _Count2 != _Count1 )
    {
    return ( false );
    }
   }
  }

 return ( true );
 }
#line 3678
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred )
 {
 for (; _First1 != _Last1; ++ _First1, ( void ) ++ _First2 )
  {
  if ( ! _Pred ( * _First1, * _First2 ) )
   {


   auto _Last2 = :: std :: next ( _First2, static_cast < _Iter_diff_t < _FwdIt2 >> ( :: std :: distance ( _First1, _Last1 ) ) );
   return ( _Check_match_counts ( _First1, _Last1, _First2, _Last2, _Pred ) );
   }
  }

 return ( true );
 }
#line 3697
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr >
  inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred )
 {
 _Adl_verify_range ( _First1, _Last1 );
 const auto _UFirst1 = _Get_unwrapped ( _First1 );
 const auto _ULast1 = _Get_unwrapped ( _Last1 );
 const auto _UFirst2 = _Get_unwrapped_n ( _First2, _Idl_distance < _FwdIt1 > ( _UFirst1, _ULast1 ) );
 return ( _Is_permutation_unchecked ( _UFirst1, _ULast1, _UFirst2, _Pass_fn ( _Pred ) ) );
 }
#line 3711
template < class _FwdIt1,
 class _RightTy,
 size_t _RightSize,
 class _Pr,
 class = enable_if_t < ! is_same_v < _RightTy *, _Pr > > >
  inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _RightTy ( & _First2 ) [ _RightSize ], _Pr _Pred )
 {
 return ( :: std :: is_permutation ( _First1, _Last1,
  _Array_iterator < _RightTy, _RightSize > ( _First2 ), _Pass_fn ( _Pred ) ) );
 }
#line 3724 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _FwdIt1,
 class _FwdIt2 > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2 )
 {
 return ( :: std :: is_permutation ( _First1, _Last1,
  _First2, equal_to < > ( ) ) );
 }
#line 3735
template < class _FwdIt1,
 class _RightTy,
 size_t _RightSize >
  inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1, _RightTy ( & _First2 ) [ _RightSize ] )
 {
 return ( :: std :: is_permutation ( _First1, _Last1, _First2, equal_to < > ( ) ) );
 }
#line 3744 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  forward_iterator_tag, forward_iterator_tag )
 {

 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ( void ) ++ _First2 )
  {
  if ( ! _Pred ( * _First1, * _First2 ) )
   {
   if ( :: std :: distance ( _First1, _Last1 ) == :: std :: distance ( _First2, _Last2 ) )
    {
    return ( _Check_match_counts ( _First1, _Last1, _First2, _Last2, _Pred ) );
    }
   else
    {
    return ( false );
    }
   }
  }

 return ( _First1 == _Last1 && _First2 == _Last2 );
 }
#line 3770
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation_unchecked ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred,
  random_access_iterator_tag, random_access_iterator_tag )
 {

 if ( _Last1 - _First1 != _Last2 - _First2 )
  {
  return ( false );
  }

 return ( _Is_permutation_unchecked ( _First1, _Last1, _First2, _Pred ) );
 }
#line 3786
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr >
  inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred )
 {

 _Adl_verify_range ( _First1, _Last1 );
 _Adl_verify_range ( _First2, _Last2 );
 return ( _Is_permutation_unchecked ( _Get_unwrapped ( _First1 ), _Get_unwrapped ( _Last1 ),
  _Get_unwrapped ( _First2 ), _Get_unwrapped ( _Last2 ), _Pass_fn ( _Pred ),
  _Iter_cat_t < _FwdIt1 > ( ), _Iter_cat_t < _FwdIt2 > ( ) ) );
 }
#line 3801
template < class _FwdIt1,
 class _FwdIt2 >
  inline bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2 )
 {
 return ( :: std :: is_permutation ( _First1, _Last1, _First2, _Last2, equal_to < > ( ) ) );
 }
#line 3810
template < class _BidIt > inline
 void _Reverse_unchecked1 ( _BidIt _First, _BidIt _Last, integral_constant < size_t, 0 > )
 {
 for (; _First != _Last && _First != -- _Last; ++ _First )
  {
  :: std :: iter_swap ( _First, _Last );
  }
 }
#line 3820
template < class _BidIt > inline
 void _Reverse_unchecked1 ( const _BidIt _First, const _BidIt _Last, integral_constant < size_t, 1 > )
 {
 __std_reverse_trivially_swappable_1 ( _First, _Last );
 }
#line 3826
template < class _BidIt > inline
 void _Reverse_unchecked1 ( const _BidIt _First, const _BidIt _Last, integral_constant < size_t, 2 > )
 {
 __std_reverse_trivially_swappable_2 ( _First, _Last );
 }
#line 3832
template < class _BidIt > inline
 void _Reverse_unchecked1 ( const _BidIt _First, const _BidIt _Last, integral_constant < size_t, 4 > )
 {
 __std_reverse_trivially_swappable_4 ( _First, _Last );
 }
#line 3838
template < class _BidIt > inline
 void _Reverse_unchecked1 ( const _BidIt _First, const _BidIt _Last, integral_constant < size_t, 8 > )
 {
 __std_reverse_trivially_swappable_8 ( _First, _Last );
 }
#line 3845 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _BidIt > inline
 void _Reverse_unchecked ( const _BidIt _First, const _BidIt _Last )
 {

 using _Elem = remove_pointer_t < _BidIt >;
 constexpr size_t _Opt = is_pointer_v < _BidIt >
  && _Is_trivially_swappable_v < _Elem >
  && ! is_volatile_v < _Elem >
  && ( sizeof ( _Elem ) == 1
   || sizeof ( _Elem ) == 2
   || sizeof ( _Elem ) == 4
   || sizeof ( _Elem ) == 8 ) ? sizeof ( _Elem ) : 0;



 _Reverse_unchecked1 ( _First, _Last, integral_constant < size_t, _Opt > { } );
 }
#line 3863 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _BidIt > inline
 void reverse ( const _BidIt _First, const _BidIt _Last )
 {
 _Adl_verify_range ( _First, _Last );
 _Reverse_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ) );
 }
#line 3882 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _FwdIt > inline
 _FwdIt _Rotate_unchecked1 ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag )
 {
 for ( _FwdIt _Next = _Mid, _Res = _Last;; )
  {
  :: std :: iter_swap ( _First, _Next );
  if ( ++ _First == _Mid )
   {
   if ( ++ _Next == _Last )
    return ( _Res == _Last ? _Mid : _Res );
   else
    _Mid = _Next;
   }
  else if ( ++ _Next == _Last )
   {
   if ( _Res == _Last )
    _Res = _First;
   _Next = _Mid;
   }
  }
 }
#line 3905
template < class _BidIt > inline
 pair < _BidIt, _BidIt > _Reverse_until_sentinel_unchecked (
  _BidIt _First, _BidIt _Sentinel, _BidIt _Last )
 {
 while ( _First != _Sentinel && _Last != _Sentinel )
  {
  :: std :: iter_swap ( _First, -- _Last );
  ++ _First;
  }

 return ( :: std :: make_pair ( _First, _Last ) );
 }
#line 3918
template < class _BidIt > inline
 _BidIt _Rotate_unchecked1 ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag )
 {
 _Reverse_unchecked ( _First, _Mid );
 _Reverse_unchecked ( _Mid, _Last );
 pair < _BidIt, _BidIt > _Tmp = _Reverse_until_sentinel_unchecked ( _First, _Mid, _Last );
 _Reverse_unchecked ( _Tmp . first, _Tmp . second );
 return ( _Mid != _Tmp . first ? _Tmp . first : _Tmp . second );
 }
#line 3929
template < class _RanIt > inline
 _RanIt _Rotate_unchecked1 ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag )
 {
 _Reverse_unchecked ( _First, _Mid );
 _Reverse_unchecked ( _Mid, _Last );
 _Reverse_unchecked ( _First, _Last );
 return ( _First + ( _Last - _Mid ) );
 }
#line 3939
template < class _FwdIt > inline
 _FwdIt _Rotate_unchecked ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {
 if ( _First == _Mid )
  return ( _Last );
 if ( _Mid == _Last )
  return ( _First );
 return ( _Rotate_unchecked1 ( _First, _Mid, _Last, _Iter_cat_t < _FwdIt > ( ) ) );
 }
#line 3949
template < class _FwdIt > inline
 _FwdIt rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {


 _Adl_verify_range ( _First, _Mid );
 _Adl_verify_range ( _Mid, _Last );
 _Seek_wrapped ( _First,
  _Rotate_unchecked ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Mid ),
  _Get_unwrapped ( _Last ) ) );
 return ( _First );
 }
#line 3974 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _FwdIt,
 class _Ty,
 class _Pr >
  inline _FwdIt lower_bound ( _FwdIt _First, const _FwdIt _Last,
  const _Ty & _Val, _Pr _Pred )
 {
 _Adl_verify_range ( _First, _Last );
 auto _UFirst = _Get_unwrapped ( _First );
 _Iter_diff_t < _FwdIt > _Count = :: std :: distance ( _UFirst, _Get_unwrapped ( _Last ) );

 while ( 0 < _Count )
  {
  const _Iter_diff_t < _FwdIt > _Count2 = _Count >> 1;
  const auto _UMid = :: std :: next ( _UFirst, _Count2 );
  if ( _Pred ( * _UMid, _Val ) )
   {
   _UFirst = _Next_iter ( _UMid );
   _Count -= _Count2 + 1;
   }
  else
   {
   _Count = _Count2;
   }
  }

 _Seek_wrapped ( _First, _UFirst );
 return ( _First );
 }
#line 4004
template < class _Diff,
 class _Urng >
 class _Rng_from_urng
 {
public :
 using _Ty0 = make_unsigned_t < _Diff >;
 using _Ty1 = typename _Urng :: result_type;

 using _Udiff = conditional_t < sizeof ( _Ty1 ) < sizeof ( _Ty0 ), _Ty0, _Ty1 >;

 explicit _Rng_from_urng ( _Urng & _Func )
  : _Ref ( _Func ), _Bits ( 8 * sizeof ( _Udiff ) ), _Bmask ( _Udiff ( - 1 ) )
  {
  for (; ( _Urng :: max ) ( ) - ( _Urng :: min ) ( ) < _Bmask; _Bmask >>= 1 )
   -- _Bits;
  }

 _Diff operator ( ) ( _Diff _Index )
  {
  for (;; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while ( _Mask < _Udiff ( _Index - 1 ) )
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits ( );
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if ( _Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff ( _Index - 1 ) )
    return ( static_cast < _Diff > ( _Ret % _Index ) );
   }
  }

 _Udiff _Get_all_bits ( )
  {
  _Udiff _Ret = 0;

  for ( size_t _Num = 0; _Num < 8 * sizeof ( _Udiff );
   _Num += _Bits )
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits ( );
   }

  return ( _Ret );
  }

 _Rng_from_urng ( const _Rng_from_urng & ) = delete;
 _Rng_from_urng & operator = ( const _Rng_from_urng & ) = delete;

private :
 _Udiff _Get_bits ( )
  {
  for (;; )
   {
   _Udiff _Val = _Ref ( ) - ( _Urng :: min ) ( );

   if ( _Val <= _Bmask )
    return ( _Val );
   }
  }

 _Urng & _Ref;
 size_t _Bits;
 _Udiff _Bmask;
 };
#line 4081
template < class _Elem >
 class __declspec ( dllimport ) _Yarn
 {
public :
  _Yarn ( )
  : _Myptr ( nullptr ), _Nul ( 0 )
  {
  }

  _Yarn ( const _Yarn & _Right )
  : _Myptr ( nullptr ), _Nul ( 0 )
  {
  * this = _Right;
  }

  _Yarn ( const _Elem * _Right )
  : _Myptr ( nullptr ), _Nul ( 0 )
  {
  * this = _Right;
  }

 _Yarn & operator = ( const _Yarn & _Right )
  {
  return ( * this = _Right . _Myptr );
  }

 _Yarn & operator = ( const _Elem * _Right )
  {
  if ( _Myptr != _Right )
   {
   _Tidy ( );

   if ( _Right != nullptr )
    {
    const _Elem * _Ptr = _Right;
    while ( * _Ptr != ( _Elem ) 0 )
     {
     ++ _Ptr;
     }

    const auto _Count = ( ++ _Ptr - _Right ) * sizeof ( _Elem );


    _Myptr = ( _Elem * ) _malloc_dbg ( _Count, 2,
     "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility", 4125 );





    if ( _Myptr != nullptr )
     {
     :: memcpy ( _Myptr, _Right, _Count );
     }
    }
   }

  return ( * this );
  }

  ~ _Yarn ( ) noexcept
  {
  _Tidy ( );
  }

 bool empty ( ) const
  {
  return ( _Myptr == nullptr );
  }

   const _Elem * c_str ( ) const
  {
  return ( _Myptr != nullptr ? _Myptr : & _Nul );
  }

 bool _Empty ( ) const
  {
  return ( _Myptr == nullptr );
  }

   const _Elem * _C_str ( ) const
  {
  return ( _Myptr != nullptr ? _Myptr : & _Nul );
  }

private :
 void _Tidy ( )
  {
  if ( _Myptr != nullptr )


   _free_dbg ( _Myptr, 2 );





  _Myptr = nullptr;
  }

 _Elem * _Myptr;
 _Elem _Nul;
 };
#line 4187 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xutility"
template < class _Container >
 class back_insert_iterator
 {
public :
 using iterator_category = output_iterator_tag;
 using value_type = void;
 using difference_type = void;
 using pointer = void;
 using reference = void;

 using container_type = _Container;

 explicit back_insert_iterator ( _Container & _Cont )
  : container ( :: std :: addressof ( _Cont ) )
  {
  }

 back_insert_iterator & operator = ( const typename _Container :: value_type & _Val )
  {
  container -> push_back ( _Val );
  return ( * this );
  }

 back_insert_iterator & operator = ( typename _Container :: value_type && _Val )
  {
  container -> push_back ( :: std :: move ( _Val ) );
  return ( * this );
  }

  back_insert_iterator & operator * ( )
  {
  return ( * this );
  }

 back_insert_iterator & operator ++ ( )
  {
  return ( * this );
  }

 back_insert_iterator operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 };
#line 4236
template < class _Container >
  inline back_insert_iterator < _Container > back_inserter ( _Container & _Cont )
 {
 return ( back_insert_iterator < _Container > ( _Cont ) );
 }
#line 4244
template< class _Ty, class 
#line 4245
_Alloc, class 
#line 4246
 = void> 
#line 4247
struct _Has_allocator_type : public false_type { 
#line 4250
}; 
#line 4252
template< class _Ty, class 
#line 4253
_Alloc> 
#line 4254
struct _Has_allocator_type< _Ty, _Alloc, void_t< typename _Ty::allocator_type> >  : public is_convertible< _Alloc, typename _Ty::allocator_type> ::type { 
#line 4257
}; 
#line 4260
struct allocator_arg_t { 
#line 4262
explicit allocator_arg_t() = default;
#line 4263
}; 
#line 4265
constexpr allocator_arg_t allocator_arg{}; 
#line 4267
[[noreturn]] void __cdecl _Xbad_alloc(); 
#line 4268
[[noreturn]] void __cdecl _Xinvalid_argument(const char *); 
#line 4269
[[noreturn]] void __cdecl _Xlength_error(const char *); 
#line 4270
[[noreturn]] void __cdecl _Xout_of_range(const char *); 
#line 4271
[[noreturn]] void __cdecl _Xoverflow_error(const char *); 
#line 4272
[[noreturn]] void __cdecl _Xruntime_error(const char *); 
#line 4275
template< class _Ty, class 
#line 4276
_Alloc> 
#line 4277
struct uses_allocator : public _Has_allocator_type< _Ty, _Alloc> ::type { 
#line 4280
}; 
#line 4282
template< class _Ty, class 
#line 4283
_Alloc> constexpr bool 
#line 4284
uses_allocator_v = (uses_allocator< _Ty, _Alloc> ::value); 
#line 4287
template< class _Category, class 
#line 4288
_Ty, class 
#line 4289
_Diff = ptrdiff_t, class 
#line 4290
_Pointer = _Ty *, class 
#line 4291
_Reference = _Ty &> 
#line 4292
struct iterator { 
#line 4294
using iterator_category = _Category; 
#line 4295
using value_type = _Ty; 
#line 4296
using difference_type = _Diff; 
#line 4297
using pointer = _Pointer; 
#line 4298
using reference = _Reference; 
#line 4299
}; 
#line 4300
}
#line 4303
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 19
namespace std { 
#line 21
template < size_t _Ty_size > inline
 size_t _Get_size_of_n ( const size_t _Count )
 {
 constexpr size_t _Max_possible = static_cast < size_t > ( - 1 ) / _Ty_size;
 size_t _Result = _Count * _Ty_size;
 if ( _Max_possible < _Count )
  {

  _Result = static_cast < size_t > ( - 1 );
  }

 return ( _Result );
 }
#line 36
template<> inline size_t _Get_size_of_n< 1Ui64> (const size_t _Count) 
#line 37
{ 
#line 38
return _Count; 
#line 39
} 
#line 42
template< class _Ty> constexpr size_t 
#line 43
_New_alignof = _Max_value(__alignof(_Ty), static_cast< size_t>(16Ui64)); 
#line 48
struct _Default_allocate_traits { 
#line 50
__declspec(allocator) static void *_Allocate(const size_t _Bytes) 
#line 51
{ 
#line 52
return ::operator new(_Bytes); 
#line 53
} 
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
}; 
#line 63
constexpr bool _Is_pow_2(const size_t _Value) noexcept 
#line 64
{ 
#line 65
return (_Value != (0)) && ((_Value & (_Value - (1))) == (0)); 
#line 66
} 
#line 69
constexpr size_t _Big_allocation_threshold = (4096); 
#line 70
constexpr size_t _Big_allocation_alignment = (32); 
#line 72
static_assert((((2) * sizeof(void *)) <= _Big_allocation_alignment), "Big allocation alignment should at least match vector register alignment");
#line 74
static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");
#line 78
constexpr size_t _Non_user_size = ((((2) * sizeof(void *)) + _Big_allocation_alignment) - (1)); 
#line 84 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
constexpr size_t _Big_allocation_sentinel = 18085043209519168250Ui64; 
#line 90 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
template < class _Traits > inline
 __declspec ( allocator ) void * _Allocate_manually_vector_aligned ( const size_t _Bytes )
 {
 size_t _Block_size = _Non_user_size + _Bytes;
 if ( _Block_size <= _Bytes )
  {

  _Block_size = static_cast < size_t > ( - 1 );
  }

 const uintptr_t _Ptr_container = reinterpret_cast < uintptr_t > ( _Traits :: _Allocate ( _Block_size ) );
 do { if ( _Ptr_container != 0 ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0", 101, 0, "%s", "invalid argument" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x6d\x65\x6d\x6f\x72\x79\x30", 101, 0 ); } while ( false ); }; } while ( false );
 void * const _Ptr = reinterpret_cast < void * > ( ( _Ptr_container + _Non_user_size )
  & ~ ( _Big_allocation_alignment - 1 ) );
 static_cast < uintptr_t * > ( _Ptr ) [ - 1 ] = _Ptr_container;


 static_cast < uintptr_t * > ( _Ptr ) [ - 2 ] = _Big_allocation_sentinel;

 return ( _Ptr );
 }
#line 113 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
inline void _Adjust_manually_vector_aligned(void *&_Ptr, size_t &_Bytes) 
#line 114
{ 
#line 115
_Bytes += _Non_user_size; 
#line 117
const uintptr_t *const _Ptr_user = reinterpret_cast< uintptr_t *>(_Ptr); 
#line 118
const uintptr_t _Ptr_container = _Ptr_user[-1]; 
#line 122
do { if ((_Ptr_user[-2]) == _Big_allocation_sentinel) { } else { do { (void)((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0", 122, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x41\x64\x6a\x75\x73\x74\x5f\x6d\x61\x6e\x75\x61\x6c\x6c\x79\x5f\x76\x65\x63\x74\x6f\x72\x5f\x61\x6c\x69" L"\x67\x6e\x65\x64", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x6d\x65\x6d\x6f\x72\x79\x30", 122, 0); } while (false); }  ; } while (false); 
#line 127
constexpr uintptr_t _Min_back_shift = ((2) * sizeof(void *)); 
#line 131 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
const uintptr_t _Back_shift = (reinterpret_cast< uintptr_t>(_Ptr)) - _Ptr_container; 
#line 132
do { if ((_Back_shift >= _Min_back_shift) && (_Back_shift <= _Non_user_size)) { } else { do { (void)((1 != _CrtDbgReport(2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0", 132, 0, "%s", "invalid argument")) || (__debugbreak(), 0)); ::_invalid_parameter(L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x61\x72\x67\x75\x6d\x65\x6e\x74\x22", L"\x73\x74\x64\x3a\x3a\x5f\x41\x64\x6a\x75\x73\x74\x5f\x6d\x61\x6e\x75\x61\x6c\x6c\x79\x5f\x76\x65\x63\x74\x6f\x72\x5f\x61\x6c\x69" L"\x67\x6e\x65\x64", L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x6d\x65\x6d\x6f\x72\x79\x30", 132, 0); } while (false); }  ; } while (false); 
#line 133
_Ptr = (reinterpret_cast< void *>(_Ptr_container)); 
#line 134
} 
#line 176 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
template < size_t _Align,
 class _Traits = _Default_allocate_traits,
 enable_if_t < ( ! 0 || _Align <= 16Ui64 ), int > = 0 > inline
 __declspec ( allocator ) void * _Allocate ( const size_t _Bytes )
 {

 if ( _Bytes >= _Big_allocation_threshold )
  {
  return ( _Allocate_manually_vector_aligned < _Traits > ( _Bytes ) );
  }


 if ( _Bytes != 0 )
  {
  return ( _Traits :: _Allocate ( _Bytes ) );
  }

 return ( nullptr );
 }
#line 196 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
template < size_t _Align,
 enable_if_t < ( ! 0 || _Align <= 16Ui64 ), int > = 0 > inline
 void _Deallocate ( void * _Ptr, size_t _Bytes )
 {

 if ( _Bytes >= _Big_allocation_threshold )
  {
  _Adjust_manually_vector_aligned ( _Ptr, _Bytes );
  }


 :: operator delete ( _Ptr, _Bytes );
 }
#line 211 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
template < class _Ty,
 class ... _Types > inline
 void _Construct_in_place ( _Ty & _Obj, _Types && ... _Args )
  noexcept ( is_nothrow_constructible_v < _Ty, _Types ... > )
 {
 :: new ( const_cast < void * > ( static_cast < const volatile void * > ( :: std :: addressof ( _Obj ) ) ) )
  _Ty ( :: std :: forward < _Types > ( _Args ) ... );
 }
#line 221
template < class _Ty,
 class ... _Types > inline
 _Ty * _Global_new ( _Types && ... _Args )
 {
 void * const _Result = _Allocate < _New_alignof < _Ty >> ( sizeof ( _Ty ) );
 try {
 :: new ( _Result ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );
 } catch ( ... ) {
 _Deallocate < _New_alignof < _Ty >> ( _Result, sizeof ( _Ty ) );
 throw;
 }
 return ( static_cast < _Ty * > ( _Result ) );
 }
#line 236
template< class _Ty> struct _Get_first_parameter; 
#line 239
template< template< class , class ...>  class _Ty, class 
#line 240
_First, class ...
#line 241
_Rest> 
#line 242
struct _Get_first_parameter< _Ty< _First, _Rest...> >  { 
#line 244
using type = _First; 
#line 245
}; 
#line 248
template< class _Newfirst, class 
#line 249
_Ty> struct _Replace_first_parameter; 
#line 252
template< class _Newfirst, 
#line 253
template< class , class ...>  class _Ty, class 
#line 254
_First, class ...
#line 255
_Rest> 
#line 256
struct _Replace_first_parameter< _Newfirst, _Ty< _First, _Rest...> >  { 
#line 258
using type = _Ty< _Newfirst, _Rest...> ; 
#line 259
}; 
#line 262
template< class _Ty, class 
#line 263
 = void> 
#line 264
struct _Get_element_type { 
#line 266
using type = typename _Get_first_parameter< _Ty> ::type; 
#line 267
}; 
#line 269
template< class _Ty> 
#line 270
struct _Get_element_type< _Ty, void_t< typename _Ty::element_type> >  { 
#line 272
using type = typename _Ty::element_type; 
#line 273
}; 
#line 276
template< class _Ty, class 
#line 277
 = void> 
#line 278
struct _Get_ptr_difference_type { 
#line 280
using type = ptrdiff_t; 
#line 281
}; 
#line 283
template< class _Ty> 
#line 284
struct _Get_ptr_difference_type< _Ty, void_t< typename _Ty::difference_type> >  { 
#line 286
using type = typename _Ty::difference_type; 
#line 287
}; 
#line 290
template< class _Ty, class 
#line 291
_Other, class 
#line 292
 = void> 
#line 293
struct _Get_rebind_alias { 
#line 295
using type = typename _Replace_first_parameter< _Other, _Ty> ::type; 
#line 296
}; 
#line 298
template< class _Ty, class 
#line 299
_Other> 
#line 300
struct _Get_rebind_alias< _Ty, _Other, void_t< typename _Ty::template rebind< _Other> > >  { 
#line 302
using type = typename _Ty::template rebind< _Other> ; 
#line 303
}; 
#line 306
template < class _Ty >
 struct pointer_traits
 {
 using element_type = typename _Get_element_type < _Ty > :: type;
 using pointer = _Ty;
 using difference_type = typename _Get_ptr_difference_type < _Ty > :: type;

 template < class _Other >
  using rebind = typename _Get_rebind_alias < _Ty, _Other > :: type;

 using _Reftype = conditional_t < is_void_v < element_type >,
  char &,
  add_lvalue_reference_t < element_type >>;

  static pointer pointer_to ( _Reftype _Val )
  {
  return ( _Ty :: pointer_to ( _Val ) );
  }
 };
#line 326
template < class _Ty >
 struct pointer_traits < _Ty * >
 {
 using element_type = _Ty;
 using pointer = _Ty *;
 using difference_type = ptrdiff_t;

 template < class _Other >
  using rebind = _Other *;

 using _Reftype = conditional_t < is_void_v < _Ty >,
  char &,
  add_lvalue_reference_t < _Ty >>;

  static pointer pointer_to ( _Reftype _Val )
  {
  return ( :: std :: addressof ( _Val ) );
  }
 };
#line 347
template< class _Ptr, class 
#line 348
_Ty> using _Rebind_pointer_t = typename pointer_traits< _Ptr> ::template rebind< _Ty> ; 
#line 352
template < class _Pointer,
 enable_if_t < ! is_pointer_v < _Pointer >, int > = 0 > inline
 _Pointer _Refancy ( typename pointer_traits < _Pointer > :: element_type * _Ptr )
 {
 return ( pointer_traits < _Pointer > :: pointer_to ( * _Ptr ) );
 }
#line 359
template < class _Pointer,
 enable_if_t < is_pointer_v < _Pointer >, int > = 0 > inline
 _Pointer _Refancy ( _Pointer _Ptr )
 {
 return ( _Ptr );
 }
#line 367
template < class _Ty > inline
 void _Destroy_in_place ( _Ty & _Obj ) noexcept
 {
 _Obj . ~ _Ty ( );
 }
#line 374
template < class _Ptrty > inline
 auto _Const_cast ( _Ptrty _Ptr )
 {
 using _Elem = typename pointer_traits < _Ptrty > :: element_type;
 using _Modifiable = remove_const_t < _Elem >;
 using _Dest = typename pointer_traits < _Ptrty > :: template rebind < _Modifiable >;

 return ( pointer_traits < _Dest > :: pointer_to ( const_cast < _Modifiable & > ( * _Ptr ) ) );
 }
#line 384
template < class _Ty > inline
 auto _Const_cast ( _Ty * _Ptr )
 {
 return ( const_cast < remove_const_t < _Ty > * > ( _Ptr ) );
 }
#line 391
template< class _Ty, class 
#line 392
 = void> 
#line 393
struct _Get_pointer_type { 
#line 395
using type = typename _Ty::value_type *; 
#line 396
}; 
#line 398
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> 
#line 401
struct _Get_pointer_type< _Ty, void_t< typename _Ty::pointer> >  { 
#line 403
using type = typename _Ty::pointer; 
#line 404
}; 
#pragma warning(pop)
#line 408
template< class _Ty, class 
#line 409
 = void> 
#line 410
struct _Get_const_pointer_type { 
#line 412
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 413
using _Valty = typename _Ty::value_type; 
#line 414
using type = typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< const typename _Ty::value_type> ; 
#line 415
}; 
#line 417
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> 
#line 420
struct _Get_const_pointer_type< _Ty, void_t< typename _Ty::const_pointer> >  { 
#line 422
using type = typename _Ty::const_pointer; 
#line 423
}; 
#pragma warning(pop)
#line 427
template< class _Ty, class 
#line 428
 = void> 
#line 429
struct _Get_void_pointer_type { 
#line 431
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 432
using type = typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< void> ; 
#line 433
}; 
#line 435
template< class _Ty> 
#line 436
struct _Get_void_pointer_type< _Ty, void_t< typename _Ty::void_pointer> >  { 
#line 438
using type = typename _Ty::void_pointer; 
#line 439
}; 
#line 442
template< class _Ty, class 
#line 443
 = void> 
#line 444
struct _Get_const_void_pointer_type { 
#line 446
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 447
using type = typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< const void> ; 
#line 448
}; 
#line 450
template< class _Ty> 
#line 451
struct _Get_const_void_pointer_type< _Ty, void_t< typename _Ty::const_void_pointer> >  { 
#line 453
using type = typename _Ty::const_void_pointer; 
#line 454
}; 
#line 457
template< class _Ty, class 
#line 458
 = void> 
#line 459
struct _Get_difference_type { 
#line 461
using _Ptrty = typename _Get_pointer_type< _Ty> ::type; 
#line 462
using type = typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::difference_type; 
#line 463
}; 
#line 465
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> 
#line 468
struct _Get_difference_type< _Ty, void_t< typename _Ty::difference_type> >  { 
#line 470
using type = typename _Ty::difference_type; 
#line 471
}; 
#pragma warning(pop)
#line 475
template< class _Ty, class 
#line 476
 = void> 
#line 477
struct _Get_size_type { 
#line 479
using type = make_unsigned_t< typename _Get_difference_type< _Ty> ::type> ; 
#line 480
}; 
#line 482
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty> 
#line 485
struct _Get_size_type< _Ty, void_t< typename _Ty::size_type> >  { 
#line 487
using type = typename _Ty::size_type; 
#line 488
}; 
#pragma warning(pop)
#line 492
template< class _Ty, class 
#line 493
 = void> 
#line 494
struct _Get_propagate_on_container_copy { 
#line 496
using type = false_type; 
#line 497
}; 
#line 499
template< class _Ty> 
#line 500
struct _Get_propagate_on_container_copy< _Ty, void_t< typename _Ty::propagate_on_container_copy_assignment> >  { 
#line 502
using type = typename _Ty::propagate_on_container_copy_assignment; 
#line 503
}; 
#line 506
template< class _Ty, class 
#line 507
 = void> 
#line 508
struct _Get_propagate_on_container_move { 
#line 510
using type = false_type; 
#line 511
}; 
#line 513
template< class _Ty> 
#line 514
struct _Get_propagate_on_container_move< _Ty, void_t< typename _Ty::propagate_on_container_move_assignment> >  { 
#line 516
using type = typename _Ty::propagate_on_container_move_assignment; 
#line 517
}; 
#line 520
template< class _Ty, class 
#line 521
 = void> 
#line 522
struct _Get_propagate_on_container_swap { 
#line 524
using type = false_type; 
#line 525
}; 
#line 527
template< class _Ty> 
#line 528
struct _Get_propagate_on_container_swap< _Ty, void_t< typename _Ty::propagate_on_container_swap> >  { 
#line 530
using type = typename _Ty::propagate_on_container_swap; 
#line 531
}; 
#line 534
template< class _Ty, class 
#line 535
 = void> 
#line 536
struct _Get_is_always_equal { 
#line 538
using type = typename is_empty< _Ty> ::type; 
#line 539
}; 
#line 541
template< class _Ty> 
#line 542
struct _Get_is_always_equal< _Ty, void_t< typename _Ty::is_always_equal> >  { 
#line 544
using type = typename _Ty::is_always_equal; 
#line 545
}; 
#line 548
template< class _Ty, class 
#line 549
_Other, class 
#line 550
 = void> 
#line 551
struct _Get_rebind_type { 
#line 553
using type = typename _Replace_first_parameter< _Other, _Ty> ::type; 
#line 554
}; 
#line 556
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Ty, class 
#line 559
_Other> 
#line 560
struct _Get_rebind_type< _Ty, _Other, void_t< typename _Ty::template rebind< _Other> ::other> >  { 
#line 562
using type = typename _Ty::template rebind< _Other> ::other; 
#line 563
}; 
#pragma warning(pop)
#line 567
template< class _Ty> class allocator; 
#line 570
template< class _Alloc, class 
#line 571
 = void> 
#line 572
struct _Is_default_allocator : public false_type { 
#line 575
}; 
#line 577
template< class _Ty> 
#line 578
struct _Is_default_allocator< allocator< _Ty> , typename allocator< _Ty> ::_Not_user_specialized>  : public true_type { 
#line 581
}; 
#line 584
template< class _Void, class ...
#line 585
_Types> 
#line 586
struct _Has_no_alloc_construct : public true_type { 
#line 589
}; 
#line 591
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Alloc, class 
#line 594
_Ptr, class ...
#line 595
_Args> 
#line 596
struct _Has_no_alloc_construct< void_t< decltype(((std::declval< _Alloc &> ().construct(std::declval< _Ptr> (), std::declval< _Args> ()...))))> , _Alloc, _Ptr, _Args...>  : public false_type { 
#line 601
}; 
#pragma warning(pop)
#line 604
template< class _Alloc, class 
#line 605
_Ptr, class ...
#line 606
_Args> using _Uses_default_construct = disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_construct< void, _Alloc, _Ptr, _Args...> > ; 
#line 611
template< class _Alloc, class 
#line 612
_Ptr, class ...
#line 613
_Args> using _Uses_default_construct_t = typename disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_construct< void, _Alloc, _Ptr, _Args...> > ::type; 
#line 618
template< class _Alloc, class 
#line 619
_Ptr, class 
#line 620
 = void> 
#line 621
struct _Has_no_alloc_destroy : public true_type { 
#line 624
}; 
#line 626
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Alloc, class 
#line 629
_Ptr> 
#line 630
struct _Has_no_alloc_destroy< _Alloc, _Ptr, void_t< decltype(((std::declval< _Alloc &> ().destroy(std::declval< _Ptr> ()))))> >  : public false_type { 
#line 633
}; 
#pragma warning(pop)
#line 636
template< class _Alloc, class 
#line 637
_Ptr> using _Uses_default_destroy = disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_destroy< _Alloc, _Ptr> > ; 
#line 642
template< class _Alloc, class 
#line 643
_Ptr> using _Uses_default_destroy_t = typename disjunction< _Is_default_allocator< _Alloc> , _Has_no_alloc_destroy< _Alloc, _Ptr> > ::type; 
#line 648
template< class _Alloc, class 
#line 649
_Size_type, class 
#line 650
_Const_void_pointer, class 
#line 651
 = void> 
#line 652
struct _Has_allocate_hint : public false_type { 
#line 655
}; 
#line 657
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Alloc, class 
#line 660
_Size_type, class 
#line 661
_Const_void_pointer> 
#line 662
struct _Has_allocate_hint< _Alloc, _Size_type, _Const_void_pointer, void_t< decltype(((std::declval< _Alloc &> ().allocate(std::declval< const _Size_type &> (), std::declval< const _Const_void_pointer &> ()))))> >  : public true_type { 
#line 667
}; 
#pragma warning(pop)
#line 671
template< class _Alloc, class 
#line 672
 = void> 
#line 673
struct _Has_max_size : public false_type { 
#line 676
}; 
#line 678
#pragma warning(push)
#pragma warning(disable: 4996)
template< class _Alloc> 
#line 681
struct _Has_max_size< _Alloc, void_t< decltype(((std::declval< const _Alloc &> ().max_size())))> >  : public true_type { 
#line 684
}; 
#pragma warning(pop)
#line 688
template< class _Alloc, class 
#line 689
 = void> 
#line 690
struct _Has_select_on_container_copy_construction : public false_type { 
#line 693
}; 
#line 695
template< class _Alloc> 
#line 696
struct _Has_select_on_container_copy_construction< _Alloc, void_t< decltype(((std::declval< const _Alloc &> ().select_on_container_copy_construction())))> >  : public true_type { 
#line 700
}; 
#line 704
template< class _Alloc> struct allocator_traits; 
#line 707
#pragma warning(push)
#pragma warning(disable: 4996)
template < class _Alloc >
 struct _Normal_allocator_traits
 {
 using allocator_type = _Alloc;
 using value_type = typename _Alloc :: value_type;

 using pointer = typename _Get_pointer_type < _Alloc > :: type;
 using const_pointer = typename _Get_const_pointer_type < _Alloc > :: type;
 using void_pointer = typename _Get_void_pointer_type < _Alloc > :: type;
 using const_void_pointer = typename _Get_const_void_pointer_type < _Alloc > :: type;

 using size_type = typename _Get_size_type < _Alloc > :: type;
 using difference_type = typename _Get_difference_type < _Alloc > :: type;

 using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy < _Alloc > :: type;
 using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move < _Alloc > :: type;
 using propagate_on_container_swap = typename _Get_propagate_on_container_swap < _Alloc > :: type;
 using is_always_equal = typename _Get_is_always_equal < _Alloc > :: type;

 template < class _Other >
  using rebind_alloc = typename _Get_rebind_type < _Alloc, _Other > :: type;

 template < class _Other >
  using rebind_traits = allocator_traits < rebind_alloc < _Other >>;

  static __declspec ( allocator ) pointer allocate ( _Alloc & _Al, const size_type _Count )
  {
  return ( _Al . allocate ( _Count ) );
  }

 static __declspec ( allocator ) pointer _Allocate1 ( _Alloc & _Al, const size_type _Count,
  const const_void_pointer _Hint, true_type )
  {
  return ( _Al . allocate ( _Count, _Hint ) );
  }

 static __declspec ( allocator ) pointer _Allocate1 ( _Alloc & _Al, const size_type _Count,
  const_void_pointer, false_type )
  {
  return ( _Al . allocate ( _Count ) );
  }

  static __declspec ( allocator ) pointer allocate ( _Alloc & _Al, const size_type _Count,
  const const_void_pointer _Hint )
  {
  return ( _Allocate1 ( _Al, _Count, _Hint, _Has_allocate_hint < _Alloc, size_type, const_void_pointer > { } ) );
  }

 static void deallocate ( _Alloc & _Al, pointer _Ptr, size_type _Count )
  {
  _Al . deallocate ( _Ptr, _Count );
  }

 template < class _Ty,
  class ... _Types >
  static void _Construct1 ( true_type, _Alloc &, _Ty * _Ptr, _Types && ... _Args )
  {
  :: new ( static_cast < void * > ( _Ptr ) ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Ty,
  class ... _Types >
  static void _Construct1 ( false_type, _Alloc & _Al, _Ty * _Ptr, _Types && ... _Args )
  {
  _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Ty,
  class ... _Types >
  static void construct ( _Alloc & _Al, _Ty * _Ptr, _Types && ... _Args )
  {
  _Construct1 ( _Uses_default_construct_t < _Alloc, _Ty *, _Types ... > ( ),
   _Al, _Ptr, :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Ty >
  static void _Destroy1 ( _Alloc &, _Ty * _Ptr, true_type )
  {
  _Ptr -> ~ _Ty ( );
  }

 template < class _Ty >
  static void _Destroy1 ( _Alloc & _Al, _Ty * _Ptr, false_type )
  {
  _Al . destroy ( _Ptr );
  }

 template < class _Ty >
  static void destroy ( _Alloc & _Al, _Ty * _Ptr )
  {
  _Destroy1 ( _Al, _Ptr, _Uses_default_destroy_t < _Alloc, _Ty * > ( ) );
  }

 static size_type _Max_size1 ( const _Alloc & _Al, true_type ) noexcept
  {
  return ( _Al . max_size ( ) );
  }

 static size_type _Max_size1 ( const _Alloc &, false_type ) noexcept
  {
  return ( ( numeric_limits < size_type > :: max ) ( ) / sizeof ( value_type ) );
  }

  static size_type max_size ( const _Alloc & _Al ) noexcept
  {
  return ( _Max_size1 ( _Al, _Has_max_size < _Alloc > { } ) );
  }

 static _Alloc _Select_on_container_copy_construction1 ( const _Alloc & _Al, true_type )
  {
  return ( _Al . select_on_container_copy_construction ( ) );
  }

 static _Alloc _Select_on_container_copy_construction1 ( const _Alloc & _Al, false_type )
  {
  return ( _Al );
  }

  static _Alloc select_on_container_copy_construction ( const _Alloc & _Al )
  {
  return ( _Select_on_container_copy_construction1 ( _Al, _Has_select_on_container_copy_construction < _Alloc > { } ) );
  }
 };
#pragma warning(pop)
#line 834
template < class _Alloc >
 struct _Default_allocator_traits
 {
 using allocator_type = _Alloc;
 using value_type = typename _Alloc :: value_type;

 using pointer = value_type *;
 using const_pointer = const value_type *;
 using void_pointer = void *;
 using const_void_pointer = const void *;

 using size_type = size_t;
 using difference_type = ptrdiff_t;

 using propagate_on_container_copy_assignment = false_type;
 using propagate_on_container_move_assignment = true_type;
 using propagate_on_container_swap = false_type;
 using is_always_equal = true_type;

 template < class _Other >
  using rebind_alloc = allocator < _Other >;

 template < class _Other >
  using rebind_traits = allocator_traits < allocator < _Other >>;

  static __declspec ( allocator ) pointer allocate ( _Alloc &, const size_type _Count )
  {
  return ( static_cast < pointer > ( _Allocate < _New_alignof < value_type >> ( _Get_size_of_n < sizeof ( value_type ) > ( _Count ) ) ) );
  }

  static __declspec ( allocator ) pointer allocate ( _Alloc &, const size_type _Count,
  const_void_pointer )
  {
  return ( static_cast < pointer > ( _Allocate < _New_alignof < value_type >> ( _Get_size_of_n < sizeof ( value_type ) > ( _Count ) ) ) );
  }

 static void deallocate ( _Alloc &, const pointer _Ptr, const size_type _Count )
  {

  _Deallocate < _New_alignof < value_type >> ( _Ptr, sizeof ( value_type ) * _Count );
  }

 template < class _Objty,
  class ... _Types >
  static void construct ( _Alloc &, _Objty * const _Ptr, _Types && ... _Args )
  {
  :: new ( const_cast < void * > ( static_cast < const volatile void * > ( _Ptr ) ) )
   _Objty ( :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Uty >
  static void destroy ( _Alloc &, _Uty * const _Ptr )
  {
  _Ptr -> ~ _Uty ( );
  }

  static size_type max_size ( const _Alloc & ) noexcept
  {
  return ( static_cast < size_t > ( - 1 ) / sizeof ( value_type ) );
  }

  static _Alloc select_on_container_copy_construction ( const _Alloc & _Al )
  {
  return ( _Al );
  }
 };
#line 901
template< class _Alloc> 
#line 902
struct allocator_traits : public conditional_t< _Is_default_allocator< _Alloc> ::value, _Default_allocator_traits< _Alloc> , _Normal_allocator_traits< _Alloc> >  { 
#line 906
}; 
#line 909
template< class _Alloc> constexpr bool 
#line 910
_Always_equal_after_move = (allocator_traits< _Alloc> ::is_always_equal::value || allocator_traits< _Alloc> ::propagate_on_container_move_assignment::value); 
#line 914
template< class _Alloc, class 
#line 915
_Value_type> using _Rebind_alloc_t = typename allocator_traits< _Alloc> ::template rebind_alloc< _Value_type> ; 
#line 919
template< class _Alloc> constexpr bool 
#line 920
_Is_simple_alloc_v = ((is_same_v< typename allocator_traits< _Alloc> ::size_type, unsigned __int64>  && is_same_v< typename allocator_traits< _Alloc> ::difference_type, __int64> ) && is_same_v< typename allocator_traits< _Alloc> ::pointer, typename _Alloc::value_type *> ) && is_same_v< typename allocator_traits< _Alloc> ::const_pointer, const typename _Alloc::value_type *> ; 
#line 927
template< class _Value_type> 
#line 928
struct _Simple_types { 
#line 931
using value_type = _Value_type; 
#line 932
using size_type = size_t; 
#line 933
using difference_type = ptrdiff_t; 
#line 934
using pointer = value_type *; 
#line 935
using const_pointer = const value_type *; 
#line 936
}; 
#line 939
template < class _Ty >
 class allocator
 {
public :
 static_assert ( ! is_const_v < _Ty >,
  "The C++ Standard forbids containers of const elements because allocator<const T> is ill-formed."
                                             );

 using _Not_user_specialized = void;

 using value_type = _Ty;

  typedef _Ty * pointer;
  typedef const _Ty * const_pointer;

  typedef _Ty & reference;
  typedef const _Ty & const_reference;

  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

 using propagate_on_container_move_assignment = true_type;
 using is_always_equal = true_type;

 template < class _Other >
  struct rebind
  {
  using other = allocator < _Other >;
  };

   _Ty * address ( _Ty & _Val ) const noexcept
  {
  return ( :: std :: addressof ( _Val ) );
  }

   const _Ty * address ( const _Ty & _Val ) const noexcept
  {
  return ( :: std :: addressof ( _Val ) );
  }

 constexpr allocator ( ) noexcept
  {
  }

 constexpr allocator ( const allocator & ) noexcept = default;
 template < class _Other >
  constexpr allocator ( const allocator < _Other > & ) noexcept
  {
  }

 void deallocate ( _Ty * const _Ptr, const size_t _Count )
  {

  _Deallocate < _New_alignof < _Ty >> ( _Ptr, sizeof ( _Ty ) * _Count );
  }

  __declspec ( allocator ) _Ty * allocate ( const size_t _Count )
  {
  return ( static_cast < _Ty * > ( _Allocate < _New_alignof < _Ty >> ( _Get_size_of_n < sizeof ( _Ty ) > ( _Count ) ) ) );
  }

   __declspec ( allocator ) _Ty * allocate (
   const size_t _Count, const void * )
  {
  return ( allocate ( _Count ) );
  }

 template < class _Objty,
  class ... _Types >
   void construct ( _Objty * const _Ptr, _Types && ... _Args )
  {
  :: new ( const_cast < void * > ( static_cast < const volatile void * > ( _Ptr ) ) )
   _Objty ( :: std :: forward < _Types > ( _Args ) ... );
  }

 template < class _Uty >
   void destroy ( _Uty * const _Ptr )
  {
  _Ptr -> ~ _Uty ( );
  }

   size_t max_size ( ) const noexcept
  {
  return ( static_cast < size_t > ( - 1 ) / sizeof ( _Ty ) );
  }
 };
#line 1028
#pragma pack(8)
template<> 
#line 1028
class allocator< void>  { 
#line 1031
public: using value_type = void; 
#line 1032
using pointer = void *; 
#line 1033
using const_pointer = const void *; 
#line 1035
template< class _Other> 
#line 1036
struct rebind { 
#line 1038
using other = std::allocator< _Other> ; 
#line 1039
}; 
#line 1040
}; 
#pragma pack()
template < class _Ty,
 class _Other >
  inline bool operator == ( const allocator < _Ty > &,
  const allocator < _Other > & ) noexcept
 {
 return ( true );
 }
#line 1050
template < class _Ty,
 class _Other >
  inline bool operator != ( const allocator < _Ty > &,
  const allocator < _Other > & ) noexcept
 {
 return ( false );
 }
#line 1067 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
template < class _Alloc > inline
 void _Pocca ( _Alloc & _Left, const _Alloc & _Right, true_type ) noexcept
 {
 _Left = _Right;
 }
#line 1073
template < class _Alloc > inline
 void _Pocca ( _Alloc &, const _Alloc &, false_type ) noexcept
 {
 }
#line 1078
template < class _Alloc > inline
 void _Pocca ( _Alloc & _Left, const _Alloc & _Right ) noexcept
 {
 typename allocator_traits < _Alloc > :: propagate_on_container_copy_assignment _Tag;
 _Pocca ( _Left, _Right, _Tag );
 }
#line 1086
template < class _Alloc > inline
 void _Pocma ( _Alloc & _Left, _Alloc & _Right, true_type ) noexcept
 {
 _Left = :: std :: move ( _Right );
 }
#line 1092
template < class _Alloc > inline
 void _Pocma ( _Alloc &, _Alloc &, false_type ) noexcept
 {
 }
#line 1097
template < class _Alloc > inline
 void _Pocma ( _Alloc & _Left, _Alloc & _Right ) noexcept
 {
 typename allocator_traits < _Alloc > :: propagate_on_container_move_assignment _Tag;
 _Pocma ( _Left, _Right, _Tag );
 }
#line 1105
template < class _Alloc > inline
 void _Pocs ( _Alloc & _Left, _Alloc & _Right, true_type ) noexcept
 {
 _Swap_adl ( _Left, _Right );
 }
#line 1111
template < class _Alloc > inline
 void _Pocs ( _Alloc & _Left, _Alloc & _Right, false_type ) noexcept
 {
 do { if ( _Left == _Right ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0", 1114, 0, "%s", "containers incompatible for swap" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x20\x66\x6f\x72\x20\x73\x77\x61" L"\x70\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x6d\x65\x6d\x6f\x72\x79\x30", 1114, 0 ); } while ( false ); }; } while ( false );
 ( void ) _Left;
 ( void ) _Right;
 }
#line 1119
template < class _Alloc > inline
 void _Pocs ( _Alloc & _Left, _Alloc & _Right ) noexcept
 {
 typename allocator_traits < _Alloc > :: propagate_on_container_swap _Tag;
 _Pocs ( _Left, _Right, _Tag );
 }
#line 1128
template < class _Alloc > inline
 void _Destroy_range1 (
  typename allocator_traits < _Alloc > :: pointer _First,
  typename allocator_traits < _Alloc > :: pointer _Last,
  _Alloc & _Al, false_type )
 {
 for (; _First != _Last; ++ _First )
  {
  allocator_traits < _Alloc > :: destroy ( _Al, _Unfancy ( _First ) );
  }
 }
#line 1140
template < class _Alloc > inline
 void _Destroy_range1 (
  typename allocator_traits < _Alloc > :: pointer,
  typename allocator_traits < _Alloc > :: pointer,
  _Alloc &, true_type )
 {

 }
#line 1149
template < class _Alloc > inline
 void _Destroy_range (
  typename allocator_traits < _Alloc > :: pointer _First,
  typename allocator_traits < _Alloc > :: pointer _Last,
  _Alloc & _Al )
 {


 using _Val = typename _Alloc :: value_type;
 _Destroy_range1 ( _First, _Last, _Al, bool_constant < conjunction_v <
  is_trivially_destructible < _Val >,
  _Uses_default_destroy < _Alloc, _Val * >> > { } );
 }
#line 1165
template < class _FwdIt > inline
 void _Destroy_range1 ( _FwdIt _First, _FwdIt _Last, false_type )
 {
 for (; _First != _Last; ++ _First )
  {
  _Destroy_in_place ( * _First );
  }
 }
#line 1174
template < class _FwdIt > inline
 void _Destroy_range1 ( _FwdIt, _FwdIt, true_type )
 {

 }
#line 1180
template < class _FwdIt > inline
 void _Destroy_range ( _FwdIt _First, _FwdIt _Last )
 {


 _Destroy_range1 ( _First, _Last, is_trivially_destructible < _Iter_value_t < _FwdIt >> ( ) );
 }
#line 1190
template < class _Size_type > inline
 _Size_type _Convert_size ( const size_t _Len )
 {
 if ( _Len > ( numeric_limits < _Size_type > :: max ) ( ) )
  {
  _Xlength_error ( "size_t too long for _Size_type" );
  }

 return ( static_cast < _Size_type > ( _Len ) );
 }
#line 1202
template<> inline size_t _Convert_size< unsigned __int64> (const size_t _Len) 
#line 1203
{ 
#line 1204
return _Len; 
#line 1205
} 
#line 1208
template < class _Alloc,
 enable_if_t < is_same_v < typename allocator_traits < _Alloc > :: pointer,
  typename _Alloc :: value_type * >, int > = 0 > inline
 void _Deallocate_plain ( _Alloc & _Al, typename _Alloc :: value_type * const _Ptr )
 {
 allocator_traits < _Alloc > :: deallocate ( _Al, _Ptr, 1 );
 }
#line 1216
template < class _Alloc,
 enable_if_t < ! is_same_v < typename allocator_traits < _Alloc > :: pointer,
  typename _Alloc :: value_type * >, int > = 0 > inline
 void _Deallocate_plain ( _Alloc & _Al, typename _Alloc :: value_type * const _Ptr )
 {
 using _Alloc_traits = allocator_traits < _Alloc >;
 using _Ptr_traits = pointer_traits < typename _Alloc_traits :: pointer >;
 _Alloc_traits :: deallocate ( _Al, _Ptr_traits :: pointer_to ( * _Ptr ), 1 );
 }
#line 1225
}
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xatomic0.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 24
typedef 
#line 17
enum memory_order { 
#line 18
memory_order_relaxed, 
#line 19
memory_order_consume, 
#line 20
memory_order_acquire, 
#line 21
memory_order_release, 
#line 22
memory_order_acq_rel, 
#line 23
memory_order_seq_cst
#line 24
} memory_order; 
#line 26
typedef unsigned long _Uint4_t; 
#line 27
typedef _Uint4_t _Atomic_integral_t; 
#line 48 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xatomic0.h"
typedef _Atomic_integral_t _Atomic_counter_t; 
#line 51
inline _Atomic_integral_t _Get_atomic_count(const _Atomic_counter_t &_Counter) 
#line 52
{ 
#line 53
return _Counter; 
#line 54
} 
#line 64 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xatomic0.h"
}
#line 67
#pragma warning(pop)
#pragma pack ( pop )
#line 19 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\intrin0.h"
extern "C" {
#line 118 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\intrin0.h"
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask); 
#line 119
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 121
unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask); 
#line 122
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask); 
#line 124
unsigned char _bittest(const long *, long); 
#line 125
long _InterlockedAnd(volatile long * _Value, long _Mask); 
#line 126
short _InterlockedAnd16(volatile short * _Value, short _Mask); 
#line 130
__int64 _InterlockedAnd64(volatile __int64 * _Value, __int64 _Mask); 
#line 134
char _InterlockedAnd8(volatile char * _Value, char _Mask); 
#line 141
long _InterlockedCompareExchange(volatile long * _Destination, long _Exchange, long _Comparand); 
#line 143
short _InterlockedCompareExchange16(volatile short * _Destination, short _Exchange, short _Comparand); 
#line 147
__int64 _InterlockedCompareExchange64(volatile __int64 * _Destination, __int64 _Exchange, __int64 _Comparand); 
#line 151
char _InterlockedCompareExchange8(volatile char * _Destination, char _Exchange, char _Comparand); 
#line 158
long _InterlockedDecrement(volatile long * _Addend); 
#line 160
long _InterlockedExchange(volatile long * _Target, long _Value); 
#line 162
short _InterlockedExchange16(volatile short * _Target, short _Value); 
#line 166
__int64 _InterlockedExchange64(volatile __int64 * _Target, __int64 _Value); 
#line 170
char _InterlockedExchange8(volatile char * _Target, char _Value); 
#line 174
long _InterlockedExchangeAdd(volatile long * _Addend, long _Value); 
#line 175
short _InterlockedExchangeAdd16(volatile short * _Addend, short _Value); 
#line 179
__int64 _InterlockedExchangeAdd64(volatile __int64 * _Addend, __int64 _Value); 
#line 183
char _InterlockedExchangeAdd8(volatile char * _Addend, char _Value); 
#line 193
long _InterlockedIncrement(volatile long * _Addend); 
#line 195
long _InterlockedOr(volatile long * _Value, long _Mask); 
#line 196
short _InterlockedOr16(volatile short * _Value, short _Mask); 
#line 200
__int64 _InterlockedOr64(volatile __int64 * _Value, __int64 _Mask); 
#line 204
char _InterlockedOr8(volatile char * _Value, char _Mask); 
#line 211
long _InterlockedXor(volatile long * _Value, long _Mask); 
#line 212
short _InterlockedXor16(volatile short * _Value, short _Mask); 
#line 216
__int64 _InterlockedXor64(volatile __int64 * _Value, __int64 _Mask); 
#line 220
char _InterlockedXor8(volatile char * _Value, char _Mask); 
#line 227
void _ReadWriteBarrier(); 
#line 238
unsigned char _interlockedbittestandset(volatile long *, long); 
#line 242
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift); 
#line 243
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct); 
#line 252
}
#line 1249 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory0"
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 16
template< class _Traits> using _Traits_ch_t = typename _Traits::char_type; 
#line 19
template< class _Traits> using _Traits_ptr_t = const typename _Traits::char_type *; 
#line 22
template < class _Traits >
 constexpr bool _Traits_equal ( const _Traits_ptr_t < _Traits > _Left, const size_t _Left_size,
    const _Traits_ptr_t < _Traits > _Right, const size_t _Right_size ) noexcept
 {
 return ( _Left_size == _Right_size && _Traits :: compare ( _Left, _Right, _Left_size ) == 0 );
 }
#line 29
template < class _Traits >
 constexpr int _Traits_compare ( const _Traits_ptr_t < _Traits > _Left, const size_t _Left_size,
    const _Traits_ptr_t < _Traits > _Right, const size_t _Right_size ) noexcept
 {
 const int _Ans = _Traits :: compare ( _Left, _Right, _Min_value ( _Left_size, _Right_size ) );

 if ( _Ans != 0 )
  {
  return ( _Ans );
  }

 if ( _Left_size < _Right_size )
  {
  return ( - 1 );
  }

 if ( _Left_size > _Right_size )
  {
  return ( 1 );
  }

 return ( 0 );
 }
#line 53
template < class _Traits >
 constexpr size_t _Traits_find (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size ) noexcept
 {
 if ( _Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size )
  {







  return ( static_cast < size_t > ( - 1 ) );
  }

 if ( _Needle_size == 0 )
  {
  return ( _Start_at );
  }

 const auto _Possible_matches_end = _Haystack + ( _Hay_size - _Needle_size ) + 1;
 for ( auto _Match_try = _Haystack + _Start_at;; ++ _Match_try )
  {
  _Match_try = _Traits :: find ( _Match_try, static_cast < size_t > ( _Possible_matches_end - _Match_try ), * _Needle );
  if ( ! _Match_try )
   {
   return ( static_cast < size_t > ( - 1 ) );
   }

  if ( _Traits :: compare ( _Match_try, _Needle, _Needle_size ) == 0 )
   {
   return ( static_cast < size_t > ( _Match_try - _Haystack ) );
   }
  }
 }
#line 91
template < class _Traits >
 constexpr size_t _Traits_find_ch (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t < _Traits > _Ch ) noexcept
 {
 if ( _Start_at < _Hay_size )
  {
  const auto _Found_at = _Traits :: find ( _Haystack + _Start_at, _Hay_size - _Start_at, _Ch );
  if ( _Found_at )
   {
   return ( static_cast < size_t > ( _Found_at - _Haystack ) );
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 108
template < class _Traits >
 constexpr size_t _Traits_rfind (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size ) noexcept
 {
 if ( _Needle_size == 0 )
  {
  return ( _Min_value ( _Start_at, _Hay_size ) );
  }

 if ( _Needle_size <= _Hay_size )
  {
  for ( auto _Match_try = _Haystack + _Min_value ( _Start_at, _Hay_size - _Needle_size );; -- _Match_try )
   {
   if ( _Traits :: eq ( * _Match_try, * _Needle )
    && _Traits :: compare ( _Match_try, _Needle, _Needle_size ) == 0 )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }

   if ( _Match_try == _Haystack )
    {
    break;
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 138
template < class _Traits >
 constexpr size_t _Traits_rfind_ch (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t < _Traits > _Ch ) noexcept
 {
 if ( _Hay_size != 0 )
  {
  for ( auto _Match_try = _Haystack + _Min_value ( _Start_at, _Hay_size - 1 );; -- _Match_try )
   {
   if ( _Traits :: eq ( * _Match_try, _Ch ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }

   if ( _Match_try == _Haystack )
    {
    break;
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 162
template < class _Elem,
 bool = _Is_character < _Elem > :: value >
 class _String_bitmap
 {
public :
 constexpr bool _Mark ( const _Elem * _First, const _Elem * const _Last )
  {

  for (; _First != _Last; ++ _First )
   {
   _Matches [ static_cast < unsigned char > ( * _First ) ] = true;
   }

  return ( true );
  }

 constexpr bool _Match ( const _Elem _Ch ) const
  {
  return ( _Matches [ static_cast < unsigned char > ( _Ch ) ] );
  }

private :
 bool _Matches [ 256 ] = { };
 };
#line 187
template < class _Elem >
 class _String_bitmap < _Elem, false >
 {
public :
 static_assert ( is_unsigned_v < _Elem >,
  "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. Visual C++ accepts oth" "er unsigned integral types as an extension."
                                                                     );

 constexpr bool _Mark ( const _Elem * _First, const _Elem * const _Last )
  {

  for (; _First != _Last; ++ _First )
   {
   const auto _Ch = * _First;
   if ( _Ch >= 256U )
    {
    return ( false );
    }

   _Matches [ static_cast < unsigned char > ( _Ch ) ] = true;
   }

  return ( true );
  }

 constexpr bool _Match ( const _Elem _Ch ) const
  {
  return ( _Ch < 256U && _Matches [ _Ch ] );
  }

private :
 bool _Matches [ 256 ] = { };
 };
#line 221
template < class _Traits >
 constexpr size_t _Traits_find_first_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, false_type ) noexcept
 {

 if ( _Needle_size != 0 && _Start_at < _Hay_size )
  {
  const auto _End = _Haystack + _Hay_size;
  for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try )
   {
   if ( _Traits :: find ( _Needle, _Needle_size, * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 242
template < class _Traits >
 constexpr size_t _Traits_find_first_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, true_type ) noexcept
 {

 if ( _Needle_size != 0 && _Start_at < _Hay_size )
  {
  _String_bitmap < typename _Traits :: char_type > _Matches;
  if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) )
   {
   return ( _Traits_find_first_of < _Traits > ( _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
    false_type { } ) );
   }

  const auto _End = _Haystack + _Hay_size;
  for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try )
   {
   if ( _Matches . _Match ( * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 270
template < class _Traits >
 constexpr size_t _Traits_find_last_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, false_type ) noexcept
 {

 if ( _Needle_size != 0 && _Hay_size != 0 )
  {
  for ( auto _Match_try = _Haystack + _Min_value ( _Start_at, _Hay_size - 1 );; -- _Match_try )
   {
   if ( _Traits :: find ( _Needle, _Needle_size, * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }

   if ( _Match_try == _Haystack )
    {
    break;
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 295
template < class _Traits >
 constexpr size_t _Traits_find_last_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, true_type ) noexcept
 {

 if ( _Needle_size != 0 && _Hay_size != 0 )
  {
  _String_bitmap < typename _Traits :: char_type > _Matches;
  if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) )
   {
   return ( _Traits_find_last_of < _Traits > ( _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
    false_type { } ) );
   }

  for ( auto _Match_try = _Haystack + _Min_value ( _Start_at, _Hay_size - 1 );; -- _Match_try )
   {
   if ( _Matches . _Match ( * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }

   if ( _Match_try == _Haystack )
    {
    break;
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 327
template < class _Traits >
 constexpr size_t _Traits_find_first_not_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, false_type ) noexcept
 {

 if ( _Start_at < _Hay_size )
  {
  const auto _End = _Haystack + _Hay_size;
  for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try )
   {
   if ( ! _Traits :: find ( _Needle, _Needle_size, * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 348
template < class _Traits >
 constexpr size_t _Traits_find_first_not_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, true_type ) noexcept
 {

 if ( _Start_at < _Hay_size )
  {
  _String_bitmap < typename _Traits :: char_type > _Matches;
  if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) )
   {
   return ( _Traits_find_first_not_of < _Traits > ( _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
    false_type { } ) );
   }

  const auto _End = _Haystack + _Hay_size;
  for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try )
   {
   if ( ! _Matches . _Match ( * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 376
template < class _Traits >
 constexpr size_t _Traits_find_not_ch (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t < _Traits > _Ch ) noexcept
 {
 if ( _Start_at < _Hay_size )
  {
  const auto _End = _Haystack + _Hay_size;
  for ( auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++ _Match_try )
   {
   if ( ! _Traits :: eq ( * _Match_try, _Ch ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 396
template < class _Traits >
 constexpr size_t _Traits_find_last_not_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, false_type ) noexcept
 {

 if ( _Hay_size != 0 )
  {
  for ( auto _Match_try = _Haystack + _Min_value ( _Start_at, _Hay_size - 1 );; -- _Match_try )
   {
   if ( ! _Traits :: find ( _Needle, _Needle_size, * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }

   if ( _Match_try == _Haystack )
    {
    break;
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 421
template < class _Traits >
 constexpr size_t _Traits_find_last_not_of (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
    const _Traits_ptr_t < _Traits > _Needle, const size_t _Needle_size, true_type ) noexcept
 {

 if ( _Hay_size != 0 )
  {
  _String_bitmap < typename _Traits :: char_type > _Matches;
  if ( ! _Matches . _Mark ( _Needle, _Needle + _Needle_size ) )
   {
   return ( _Traits_find_last_not_of < _Traits > ( _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size,
    false_type { } ) );
   }

  for ( auto _Match_try = _Haystack + _Min_value ( _Start_at, _Hay_size - 1 );; -- _Match_try )
   {
   if ( ! _Matches . _Match ( * _Match_try ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }

   if ( _Match_try == _Haystack )
    {
    break;
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 453
template < class _Traits >
 constexpr size_t _Traits_rfind_not_ch (
    const _Traits_ptr_t < _Traits > _Haystack, const size_t _Hay_size, const size_t _Start_at,
  const _Traits_ch_t < _Traits > _Ch ) noexcept
 {
 if ( _Hay_size != 0 )
  {
  for ( auto _Match_try = _Haystack + _Min_value ( _Start_at, _Hay_size - 1 );; -- _Match_try )
   {
   if ( ! _Traits :: eq ( * _Match_try, _Ch ) )
    {
    return ( static_cast < size_t > ( _Match_try - _Haystack ) );
    }

   if ( _Match_try == _Haystack )
    {
    break;
    }
   }
  }

 return ( static_cast < size_t > ( - 1 ) );
 }
#line 1398 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring"
template < class _Mystr >
 class _String_const_iterator
  : public _Iterator_base
 {
public :
 using iterator_category = random_access_iterator_tag;

 using value_type = typename _Mystr :: value_type;
 using difference_type = typename _Mystr :: difference_type;
 using pointer = typename _Mystr :: const_pointer;
 using reference = const value_type &;

 _String_const_iterator ( )
  : _Ptr ( )
  {
  }

 _String_const_iterator ( pointer _Parg, const _Container_base * _Pstring )
  : _Ptr ( _Parg )
  {
  this -> _Adopt ( _Pstring );
  }

  reference operator * ( ) const
  {

  do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1424, 0, "%s", "cannot dereference value-initialized string iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61" L"\x6c\x69\x7a\x65\x64\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1424, 0 ); } while ( false ); }; } while ( false );
  const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
  do { if ( _Mycont ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1427, 0, "%s", "cannot dereference string iterator because the iterator was invalidated (e.g. reallocation occurred, or the string was destroyed" ")" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61" L"\x74\x6f\x72\x20\x62\x65\x63\x61\x75\x73\x65\x20\x74\x68\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x77\x61\x73\x22\x20\x22\x20" L"\x69\x6e\x76\x61\x6c\x69\x64\x61\x74\x65\x64\x20\x28\x65\x2e\x67\x2e\x20\x72\x65\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x6f" L"\x63\x63\x75\x72\x72\x65\x64\x2c\x20\x6f\x72\x20\x74\x68\x65\x20\x73\x74\x72\x69\x6e\x67\x20\x77\x61\x73\x20\x64\x65\x73\x74\x72" L"\x6f\x79\x65\x64\x29\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1427, 0 ); } while ( false ); }; } while ( false );

  const auto _Contptr = _Mycont -> _Myptr ( );
  const auto _Rawptr = _Unfancy ( _Ptr );
  do { if ( _Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont -> _Mysize ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1431, 0, "%s", "cannot dereference string iterator because it is out of range (e.g. an end iterator)" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x65\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61" L"\x74\x6f\x72\x20\x62\x65\x63\x61\x75\x73\x65\x20\x69\x74\x20\x69\x73\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x20\x28" L"\x65\x2e\x67\x2e\x20\x61\x6e\x20\x65\x6e\x64\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x29\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1431, 0 ); } while ( false ); }; } while ( false );



  ;
  return ( * _Ptr );
  }

  pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _String_const_iterator & operator ++ ( )
  {

  do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1446, 0, "%s", "cannot increment value-initialized string iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61\x6c\x69" L"\x7a\x65\x64\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1446, 0 ); } while ( false ); }; } while ( false );
  const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
  do { if ( _Mycont ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1449, 0, "%s", "cannot increment string iterator because the iterator was invalidated (e.g. reallocation occurred, or the string was destroyed)" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f" L"\x72\x20\x62\x65\x63\x61\x75\x73\x65\x20\x74\x68\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x77\x61\x73\x22\x20\x22\x20\x69\x6e" L"\x76\x61\x6c\x69\x64\x61\x74\x65\x64\x20\x28\x65\x2e\x67\x2e\x20\x72\x65\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x6f\x63\x63" L"\x75\x72\x72\x65\x64\x2c\x20\x6f\x72\x20\x74\x68\x65\x20\x73\x74\x72\x69\x6e\x67\x20\x77\x61\x73\x20\x64\x65\x73\x74\x72\x6f\x79" L"\x65\x64\x29\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1449, 0 ); } while ( false ); }; } while ( false );

  do { if ( _Unfancy ( _Ptr ) < _Mycont -> _Myptr ( ) + _Mycont -> _Mysize ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1451, 0, "%s", "cannot increment string iterator past end" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x69\x6e\x63\x72\x65\x6d\x65\x6e\x74\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f" L"\x72\x20\x70\x61\x73\x74\x20\x65\x6e\x64\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1451, 0 ); } while ( false ); }; } while ( false );



  ++ _Ptr;
  return ( * this );
  }

 _String_const_iterator operator ++ ( int )
  {
  _String_const_iterator _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _String_const_iterator & operator -- ( )
  {

  do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1468, 0, "%s", "cannot decrement value-initialized string iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61\x6c\x69" L"\x7a\x65\x64\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1468, 0 ); } while ( false ); }; } while ( false );
  const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
  do { if ( _Mycont ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1471, 0, "%s", "cannot decrement string iterator because the iterator was invalidated (e.g. reallocation occurred, or the string was destroyed)" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f" L"\x72\x20\x62\x65\x63\x61\x75\x73\x65\x20\x74\x68\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x77\x61\x73\x22\x20\x22\x20\x69\x6e" L"\x76\x61\x6c\x69\x64\x61\x74\x65\x64\x20\x28\x65\x2e\x67\x2e\x20\x72\x65\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x6f\x63\x63" L"\x75\x72\x72\x65\x64\x2c\x20\x6f\x72\x20\x74\x68\x65\x20\x73\x74\x72\x69\x6e\x67\x20\x77\x61\x73\x20\x64\x65\x73\x74\x72\x6f\x79" L"\x65\x64\x29\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1471, 0 ); } while ( false ); }; } while ( false );

  do { if ( _Mycont -> _Myptr ( ) < _Unfancy ( _Ptr ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1472, 0, "%s", "cannot decrement string iterator before begin" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x64\x65\x63\x72\x65\x6d\x65\x6e\x74\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f" L"\x72\x20\x62\x65\x66\x6f\x72\x65\x20\x62\x65\x67\x69\x6e\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1472, 0 ); } while ( false ); }; } while ( false );


  -- _Ptr;
  return ( * this );
  }

 _String_const_iterator operator -- ( int )
  {
  _String_const_iterator _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 void _Verify_offset ( const difference_type _Off ) const noexcept
  {

  if ( _Off == 0 )
   {
   return;
   }

  do { if ( _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1494, 0, "%s", "cannot seek value-initialized string iterator" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x65\x6b\x20\x76\x61\x6c\x75\x65\x2d\x69\x6e\x69\x74\x69\x61\x6c\x69\x7a\x65\x64\x20\x73" L"\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1494, 0 ); } while ( false ); }; } while ( false );
  const auto _Mycont = static_cast < const _Mystr * > ( this -> _Getcont ( ) );
  do { if ( _Mycont ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1497, 0, "%s", "cannot seek string iterator because the iterator was invalidated (e.g. reallocation occurred, or the string was destroyed)" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x65\x6b\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x62\x65\x63" L"\x61\x75\x73\x65\x20\x74\x68\x65\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x77\x61\x73\x22\x20\x22\x20\x69\x6e\x76\x61\x6c\x69\x64" L"\x61\x74\x65\x64\x20\x28\x65\x2e\x67\x2e\x20\x72\x65\x61\x6c\x6c\x6f\x63\x61\x74\x69\x6f\x6e\x20\x6f\x63\x63\x75\x72\x72\x65\x64" L"\x2c\x20\x6f\x72\x20\x74\x68\x65\x20\x73\x74\x72\x69\x6e\x67\x20\x77\x61\x73\x20\x64\x65\x73\x74\x72\x6f\x79\x65\x64\x29\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1497, 0 ); } while ( false ); }; } while ( false );

  const auto _Contptr = _Mycont -> _Myptr ( );
  const auto _Rawptr = _Unfancy ( _Ptr );

  if ( _Off < 0 )
   {
#pragma warning(suppress: 4146)
   do { if ( _Contptr - _Rawptr <= _Off ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1504, 0, "%s", "cannot seek string iterator before begin" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x65\x6b\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x62\x65\x66" L"\x6f\x72\x65\x20\x62\x65\x67\x69\x6e\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1504, 0 ); } while ( false ); }; } while ( false );
   }

  if ( _Off > 0 )
   {
   using _Size_type = typename _Mystr :: size_type;
   const auto _Left = _Mycont -> _Mysize - static_cast < _Size_type > ( _Rawptr - _Contptr );
   do { if ( static_cast < _Size_type > ( _Off ) <= _Left ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1511, 0, "%s", "cannot seek string iterator after end" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x63\x61\x6e\x6e\x6f\x74\x20\x73\x65\x65\x6b\x20\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x61\x66\x74" L"\x65\x72\x20\x65\x6e\x64\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1511, 0 ); } while ( false ); }; } while ( false );
   }



  }

 _String_const_iterator & operator += ( const difference_type _Off )
  {

  _Verify_offset ( _Off );

  _Ptr += _Off;
  return ( * this );
  }

  _String_const_iterator operator + ( const difference_type _Off ) const
  {
  _String_const_iterator _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _String_const_iterator & operator -= ( const difference_type _Off )
  {
  return ( * this += - _Off );
  }

  _String_const_iterator operator - ( const difference_type _Off ) const
  {
  _String_const_iterator _Tmp = * this;
  return ( _Tmp -= _Off );
  }

  difference_type operator - ( const _String_const_iterator & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr - _Right . _Ptr );
  }

  reference operator [ ] ( const difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

  bool operator == ( const _String_const_iterator & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr == _Right . _Ptr );
  }

  bool operator != ( const _String_const_iterator & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

  bool operator < ( const _String_const_iterator & _Right ) const
  {
  _Compat ( _Right );
  return ( _Ptr < _Right . _Ptr );
  }

  bool operator > ( const _String_const_iterator & _Right ) const
  {
  return ( _Right < * this );
  }

  bool operator <= ( const _String_const_iterator & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

  bool operator >= ( const _String_const_iterator & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

 void _Compat ( const _String_const_iterator & _Right ) const
  {

  do { if ( this -> _Getcont ( ) == _Right . _Getcont ( ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1591, 0, "%s", "string iterators incompatible (e.g. point to different string instances)" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x20\x28" L"\x65\x2e\x67\x2e\x22\x20\x22\x20\x70\x6f\x69\x6e\x74\x20\x74\x6f\x20\x64\x69\x66\x66\x65\x72\x65\x6e\x74\x20\x73\x74\x72\x69\x6e" L"\x67\x20\x69\x6e\x73\x74\x61\x6e\x63\x65\x73\x29\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1591, 0 ); } while ( false ); }; } while ( false );




  }


 friend void _Verify_range ( const _String_const_iterator & _First, const _String_const_iterator & _Last )
  {
  do { if ( _First . _Getcont ( ) == _Last . _Getcont ( ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1601, 0, "%s", "string iterators in range are from different containers" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x73\x20\x69\x6e\x20\x72\x61\x6e\x67\x65\x20\x61\x72\x65\x20\x66" L"\x72\x6f\x6d\x20\x64\x69\x66\x66\x65\x72\x65\x6e\x74\x20\x63\x6f\x6e\x74\x61\x69\x6e\x65\x72\x73\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1601, 0 ); } while ( false ); }; } while ( false );

  do { if ( _First . _Ptr <= _Last . _Ptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 1602, 0, "%s", "string iterator range transposed" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x73\x74\x72\x69\x6e\x67\x20\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x72\x61\x6e\x67\x65\x20\x74\x72\x61\x6e\x73\x70\x6f\x73\x65" L"\x64\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 1602, 0 ); } while ( false ); }; } while ( false );
  }


  pointer _Unwrapped ( ) const
  {
  return ( _Ptr );
  }

 void _Seek_to ( pointer _It )
  {
  _Ptr = _It;
  }

 pointer _Ptr;
 };
#line 1619 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring"
template < class _Mystr >
  inline _String_const_iterator < _Mystr > operator + (
  typename _String_const_iterator < _Mystr > :: difference_type _Off,
  _String_const_iterator < _Mystr > _Next )
 {
 return ( _Next += _Off );
 }
#line 1628
template < class _Mystr >
 class _String_iterator
  : public _String_const_iterator < _Mystr >
 {
public :
 using _Mybase = _String_const_iterator < _Mystr >;
 using iterator_category = random_access_iterator_tag;

 using value_type = typename _Mystr :: value_type;
 using difference_type = typename _Mystr :: difference_type;
 using pointer = typename _Mystr :: pointer;
 using reference = value_type &;

 _String_iterator ( )
  {
  }

 _String_iterator ( pointer _Parg, const _Container_base * _Pstring )
  : _Mybase ( _Parg, _Pstring )
  {
  }

  reference operator * ( ) const
  {
  return ( const_cast < reference > ( _Mybase :: operator * ( ) ) );
  }

  pointer operator -> ( ) const
  {
  return ( pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _String_iterator & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _String_iterator operator ++ ( int )
  {
  _String_iterator _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _String_iterator & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _String_iterator operator -- ( int )
  {
  _String_iterator _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _String_iterator & operator += ( const difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

  _String_iterator operator + ( const difference_type _Off ) const
  {
  _String_iterator _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _String_iterator & operator -= ( const difference_type _Off )
  {
  return ( * this += - _Off );
  }

  _String_iterator operator - ( const difference_type _Off ) const
  {
  _String_iterator _Tmp = * this;
  return ( _Tmp -= _Off );
  }

  difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

  reference operator [ ] ( const difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

  pointer _Unwrapped ( ) const
  {
  return ( _Const_cast ( this -> _Ptr ) );
  }
 };
#line 1725
template < class _Mystr >
  inline _String_iterator < _Mystr > operator + (
  typename _String_iterator < _Mystr > :: difference_type _Off,
  _String_iterator < _Mystr > _Next )
 {
 return ( _Next += _Off );
 }
#line 1734
template< class _Value_type, class 
#line 1735
_Size_type, class 
#line 1736
_Difference_type, class 
#line 1737
_Pointer, class 
#line 1738
_Const_pointer, class 
#line 1739
_Reference, class 
#line 1740
_Const_reference> 
#line 1741
struct _String_iter_types { 
#line 1743
using value_type = _Value_type; 
#line 1744
using size_type = _Size_type; 
#line 1745
using difference_type = _Difference_type; 
#line 1746
using pointer = _Pointer; 
#line 1747
using const_pointer = _Const_pointer; 
#line 1748
}; 
#line 1750
template< class _Ty, class 
#line 1751
_Alloc> 
#line 1752
struct _String_base_types { 
#line 1754
using _Alty = _Rebind_alloc_t< _Alloc, _Ty> ; 
#line 1755
using _Alty_traits = allocator_traits< _Rebind_alloc_t< _Alloc, _Ty> > ; 
#line 1757
using _Val_types = conditional_t< _Is_simple_alloc_v< _Rebind_alloc_t< _Alloc, _Ty> > , _Simple_types< _Ty> , _String_iter_types< _Ty, typename allocator_traits< _Rebind_alloc_t< _Alloc, _Ty> > ::size_type, typename allocator_traits< _Rebind_alloc_t< _Alloc, _Ty> > ::difference_type, typename allocator_traits< _Rebind_alloc_t< _Alloc, _Ty> > ::pointer, typename allocator_traits< _Rebind_alloc_t< _Alloc, _Ty> > ::const_pointer, _Ty &, const _Ty &> > ; 
#line 1766
}; 
#line 1769
template < class _Val_types >
 class _String_val
  : public _Container_base
 {
public :
 using value_type = typename _Val_types :: value_type;
 using size_type = typename _Val_types :: size_type;
 using difference_type = typename _Val_types :: difference_type;
 using pointer = typename _Val_types :: pointer;
 using const_pointer = typename _Val_types :: const_pointer;
 using reference = value_type &;
 using const_reference = const value_type &;

 _String_val ( )
  : _Bx ( ),
  _Mysize ( 0 ),
  _Myres ( 0 )
  {
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof ( value_type ) < 1 ? 1
   : 16 / sizeof ( value_type ) };
 enum
  {
  _ALLOC_MASK = sizeof ( value_type ) <= 1 ? 15
   : sizeof ( value_type ) <= 2 ? 7
   : sizeof ( value_type ) <= 4 ? 3
   : sizeof ( value_type ) <= 8 ? 1 : 0
  };

 value_type * _Myptr ( )
  {
  value_type * _Result = _Bx . _Buf;
  if ( _Large_string_engaged ( ) )
   {
   _Result = _Unfancy ( _Bx . _Ptr );
   }

  return ( _Result );
  }

 const value_type * _Myptr ( ) const
  {
  const value_type * _Result = _Bx . _Buf;
  if ( _Large_string_engaged ( ) )
   {
   _Result = _Unfancy ( _Bx . _Ptr );
   }

  return ( _Result );
  }

 bool _Large_string_engaged ( ) const
  {
  return ( _BUF_SIZE <= _Myres );
  }

 void _Check_offset ( const size_type _Off ) const
  {
  if ( _Mysize < _Off )
   {
   _Xran ( );
   }
  }

 void _Check_offset_exclusive ( const size_type _Off ) const
  {
  if ( _Mysize <= _Off )
   {
   _Xran ( );
   }
  }

 [ [ noreturn ] ] static void _Xran ( )
  {
  _Xout_of_range ( "invalid string position" );
  }

 size_type _Clamp_suffix_size ( const size_type _Off, const size_type _Size ) const noexcept
  {
  return ( _Min_value ( _Size, _Mysize - _Off ) );
  }

 union _Bxty
  {
  _Bxty ( )
   {
   }

  ~ _Bxty ( ) noexcept
   {
   }

  value_type _Buf [ _BUF_SIZE ];
  pointer _Ptr;
  char _Alias [ _BUF_SIZE ];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };
#line 1874
template < class _Alloc_types >
 class _String_alloc
 {
public :
 using _Alty = typename _Alloc_types :: _Alty;
 using _Alty_traits = typename _Alloc_types :: _Alty_traits;
 using _Alproxy = _Rebind_alloc_t < _Alty, _Container_proxy >;
 using _Alproxy_traits = allocator_traits < _Alproxy >;
 using _Val_types = typename _Alloc_types :: _Val_types;
 using _Mydata_t = _String_val < _Val_types >;
 using _Bxty = typename _Mydata_t :: _Bxty;

 using value_type = typename _Val_types :: value_type;
 using size_type = typename _Val_types :: size_type;
 using difference_type = typename _Val_types :: difference_type;
 using pointer = typename _Val_types :: pointer;
 using const_pointer = typename _Val_types :: const_pointer;
 using reference = value_type &;
 using const_reference = const value_type &;

 using iterator = _String_iterator < _Mydata_t >;
 using const_iterator = _String_const_iterator < _Mydata_t >;

 enum
  {
  _BUF_SIZE = _Mydata_t :: _BUF_SIZE
  };

 enum
  {
  _ALLOC_MASK = _Mydata_t :: _ALLOC_MASK
  };


























 _String_alloc ( )
  : _Mypair ( _Zero_then_variadic_args_t ( ) )
  {
  _Alloc_proxy ( );
  }

 template < class _Any_alloc,
  class = enable_if_t < ! is_same_v < remove_cv_t < remove_reference_t < _Any_alloc >>, _String_alloc >> >
  _String_alloc ( _Any_alloc && _Al )
  : _Mypair ( _One_then_variadic_args_t ( ),
   :: std :: forward < _Any_alloc > ( _Al ) )
  {
  _Alloc_proxy ( );
  }

 ~ _String_alloc ( ) noexcept
  {
  _Free_proxy ( );
  }

 void _Copy_alloc ( const _Alty & _Al )
  {
  const bool _Reload = _Alty_traits :: propagate_on_container_copy_assignment :: value
   && _Getal ( ) != _Al;

  if ( _Reload )
   {
   _Free_proxy ( );
   }

  _Pocca ( _Getal ( ), _Al );

  if ( _Reload )
   {
   _Alloc_proxy ( );
   }
  }

 void _Move_alloc ( _Alty & _Al )
  {
  const bool _Reload = _Alty_traits :: propagate_on_container_move_assignment :: value
   && _Getal ( ) != _Al;

  if ( _Reload )
   {
   _Free_proxy ( );
   }

  _Pocma ( _Getal ( ), _Al );

  if ( _Reload )
   {
   _Alloc_proxy ( );
   }
  }

 void _Alloc_proxy ( )
  {
  _Alproxy _Proxy_allocator ( _Getal ( ) );
  _Myproxy ( ) = _Unfancy ( _Proxy_allocator . allocate ( 1 ) );
  _Alproxy_traits :: construct ( _Proxy_allocator, _Myproxy ( ), _Container_proxy ( ) );
  _Myproxy ( ) -> _Mycont = :: std :: addressof ( _Get_data ( ) );
  }

 void _Free_proxy ( )
  {
  _Alproxy _Proxy_allocator ( _Getal ( ) );
  _Orphan_all ( );
  _Alproxy_traits :: destroy ( _Proxy_allocator, _Myproxy ( ) );
  _Deallocate_plain ( _Proxy_allocator, _Myproxy ( ) );
  _Myproxy ( ) = nullptr;
  }

 _Iterator_base12 * * _Getpfirst ( ) const
  {
  return ( _Get_data ( ) . _Getpfirst ( ) );
  }

 _Container_proxy * & _Myproxy ( ) noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }

 _Container_proxy * const & _Myproxy ( ) const noexcept
  {
  return ( _Get_data ( ) . _Myproxy );
  }


 void _Orphan_all ( )
  {
  _Get_data ( ) . _Orphan_all ( );
  }

 void _Swap_all ( _String_alloc & _Right )
  {
  _Get_data ( ) . _Swap_all ( _Right . _Get_data ( ) );
  }

 _Alty & _Getal ( ) noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 const _Alty & _Getal ( ) const noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 _Mydata_t & _Get_data ( ) noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 const _Mydata_t & _Get_data ( ) const noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

private :
 _Compressed_pair < _Alty, _Mydata_t > _Mypair;
 };
#line 2057 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring"
template< class _Ty> constexpr size_t 
#line 2058
_Size_after_ebco_v = (is_empty_v< _Ty> ) ? 0 : sizeof(_Ty); 
#line 2061
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Alloc = allocator < _Elem > >
 class basic_string
  : public _String_alloc < _String_base_types < _Elem, _Alloc >>
 {
public :
 static_assert ( ! 0 || is_same_v < _Elem, typename _Alloc :: value_type >,
  "basic_string<T, Traits, Allocator> requires that Allocator\'s value_type match T (See N4659 26.2.1 [container.requirements.gener" "al]/16 allocator_type) Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0 to suppress this diagnostic." "" );

 static_assert ( is_same_v < _Elem, typename _Traits :: char_type >,
  "N4659 24.3.2.1 [string.require]/3 requires that the supplied char_traits character type match the string\'s character type."
                                                                 );

 using _Mybase = _String_alloc < _String_base_types < _Elem, _Alloc >>;
 using traits_type = _Traits;
 using allocator_type = _Alloc;

 using _Alty = typename _Mybase :: _Alty;
 using _Alty_traits = typename _Mybase :: _Alty_traits;
 using _Mydata_t = typename _Mybase :: _Mydata_t;

 using value_type = typename _Mybase :: value_type;
 using size_type = typename _Mybase :: size_type;
 using difference_type = typename _Mybase :: difference_type;
 using pointer = typename _Mybase :: pointer;
 using const_pointer = typename _Mybase :: const_pointer;
 using reference = value_type &;
 using const_reference = const value_type &;

 using iterator = typename _Mybase :: iterator;
 using const_iterator = typename _Mybase :: const_iterator;

 using reverse_iterator = :: std :: reverse_iterator < iterator >;
 using const_reverse_iterator = :: std :: reverse_iterator < const_iterator >;











 using _Use_memcpy_move = bool_constant <
  _Is_specialization_v < _Traits, char_traits > && is_trivial_v < pointer >>;

 static constexpr size_t _Memcpy_move_offset = _Size_after_ebco_v < _Container_base >;
 static constexpr size_t _Memcpy_move_size = sizeof ( _Mydata_t ) - _Memcpy_move_offset;

 template < class _Iter >
  using _Is_elem_cptr = bool_constant < _Is_any_of_v < _Iter,
   const _Elem * const,
   _Elem * const,
   const _Elem *,
   _Elem * >>;









 basic_string ( const basic_string & _Right )
  : _Mybase ( _Alty_traits :: select_on_container_copy_construction ( _Right . _Getal ( ) ) )
  {
  _Construct_lv_contents ( _Right );
  }

 basic_string ( const basic_string & _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Construct_lv_contents ( _Right );
  }

 basic_string ( ) noexcept ( is_nothrow_default_constructible_v < _Alty > )
  : _Mybase ( )
  {
  _Tidy_init ( );
  }

 explicit basic_string ( const _Alloc & _Al ) noexcept
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  }

 basic_string ( const basic_string & _Right, const size_type _Roff, const _Alloc & _Al = _Alloc ( ) )
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  assign ( _Right, _Roff, npos );
  }

 basic_string ( const basic_string & _Right, const size_type _Roff, const size_type _Count, const _Alloc & _Al = _Alloc ( ) )
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Elem * const _Ptr, const size_type _Count )
  : _Mybase ( )
  {
  _Tidy_init ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * const _Ptr, const size_type _Count,
  const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * const _Ptr )
  : _Mybase ( )
  {
  _Tidy_init ( );
  assign ( _Ptr );
  }





 basic_string ( const _Elem * const _Ptr, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  assign ( _Ptr );
  }

 basic_string ( const size_type _Count, const _Elem _Ch )
  : _Mybase ( )
  {
  _Tidy_init ( );
  assign ( _Count, _Ch );
  }





 basic_string ( const size_type _Count, const _Elem _Ch, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  assign ( _Count, _Ch );
  }

 template < class _Iter,
  class = enable_if_t < _Is_iterator_v < _Iter >> >
  basic_string ( _Iter _First, _Iter _Last, const _Alloc & _Al = _Alloc ( ) )
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  _Adl_verify_range ( _First, _Last );
  _Construct ( _Get_unwrapped ( _First ), _Get_unwrapped ( _Last ), _Iter_cat_t < _Iter > ( ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _First, const _Iter _Last, input_iterator_tag )
  {
  try {
  for (; _First != _Last; ++ _First )
   {
   push_back ( static_cast < _Elem > ( * _First ) );
   }

  } catch ( ... ) {
  _Tidy_deallocate ( );
  throw;
  }
  }

 template < class _Iter >
  void _Construct ( const _Iter _First, const _Iter _Last, forward_iterator_tag )
  {
  const size_type _Count = _Convert_size < size_type > ( static_cast < size_t > ( :: std :: distance ( _First, _Last ) ) );
  reserve ( _Count );
  _Construct ( _First, _Last, input_iterator_tag ( ) );
  }

 void _Construct ( _Elem * const _First, _Elem * const _Last, random_access_iterator_tag )
  {
  if ( _First != _Last )
   {
   assign ( _First, _Convert_size < size_type > ( static_cast < size_t > ( _Last - _First ) ) );
   }
  }

 void _Construct ( const _Elem * const _First, const _Elem * const _Last, random_access_iterator_tag )
  {
  if ( _First != _Last )
   {
   assign ( _First, _Convert_size < size_type > ( static_cast < size_t > ( _Last - _First ) ) );
   }
  }

 basic_string ( basic_string && _Right ) noexcept
  : _Mybase ( :: std :: move ( _Right . _Getal ( ) ) )
  {
  _Assign_rv_contents_with_alloc_always_equal ( :: std :: move ( _Right ), _Use_memcpy_move { } );
  }

 basic_string ( basic_string && _Right, const _Alloc & _Al )
  noexcept ( _Alty_traits :: is_always_equal :: value )
  : _Mybase ( _Al )
  {
  _Assign_rv_contents ( :: std :: move ( _Right ), typename _Alty_traits :: is_always_equal { } );
  }






















 basic_string & operator = ( basic_string && _Right ) noexcept ( _Always_equal_after_move < _Alty > )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Tidy_deallocate ( );
   this -> _Move_alloc ( _Right . _Getal ( ) );


   _Assign_rv_contents ( :: std :: move ( _Right ), bool_constant < _Always_equal_after_move < _Alty >> { } );
   }

  return ( * this );
  }

 basic_string & assign ( basic_string && _Right ) noexcept ( _Always_equal_after_move < _Alty > )
  {
  * this = :: std :: move ( _Right );
  return ( * this );
  }

 void _Assign_rv_contents ( basic_string && _Right, true_type ) noexcept
  {



  _Assign_rv_contents_with_alloc_always_equal ( :: std :: move ( _Right ), _Use_memcpy_move { } );
  }

 void _Assign_rv_contents ( basic_string && _Right, false_type )
  {



  if ( this -> _Getal ( ) == _Right . _Getal ( ) )
   {
   _Assign_rv_contents_with_alloc_always_equal ( :: std :: move ( _Right ), _Use_memcpy_move { } );
   }
  else
   {
   _Construct_lv_contents ( _Right );
   }
  }

 void _Assign_rv_contents_with_alloc_always_equal ( basic_string && _Right, true_type ) noexcept
  {



  auto & _Right_data = _Right . _Get_data ( );


  if ( _Right_data . _Large_string_engaged ( ) )
   {
   this -> _Swap_all ( _Right );
   }
  else
   {
   _Right . _Orphan_all ( );
   }


  const auto _My_data_mem = reinterpret_cast < unsigned char * > ( :: std :: addressof ( this -> _Get_data ( ) ) )
   + _Memcpy_move_offset;
  const auto _Right_data_mem = reinterpret_cast < unsigned char * > ( :: std :: addressof ( _Right_data ) )
   + _Memcpy_move_offset;
  :: memcpy ( _My_data_mem, _Right_data_mem, _Memcpy_move_size );
  _Right . _Tidy_init ( );
  }

 void _Assign_rv_contents_with_alloc_always_equal ( basic_string && _Right, false_type ) noexcept
  {



  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  if ( _Right_data . _Large_string_engaged ( ) )
   {
   _Alty_traits :: construct ( this -> _Getal ( ), :: std :: addressof ( _My_data . _Bx . _Ptr ), _Right_data . _Bx . _Ptr );
   _Right_data . _Bx . _Ptr = pointer ( );
   this -> _Swap_all ( _Right );
   }
  else
   {
   _Traits :: copy ( _My_data . _Bx . _Buf, _Right_data . _Bx . _Buf, _Right_data . _Mysize + 1 );
   _Right . _Orphan_all ( );
   }

  _My_data . _Mysize = _Right_data . _Mysize;
  _My_data . _Myres = _Right_data . _Myres;
  _Right . _Tidy_init ( );
  }

 void _Construct_lv_contents ( const basic_string & _Right )
  {


  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  const size_type _Right_size = _Right_data . _Mysize;
  const _Elem * const _Right_ptr = _Right_data . _Myptr ( );
  if ( _Right_size < this -> _BUF_SIZE )
   {
   _Traits :: copy ( _My_data . _Bx . _Buf, _Right_ptr, this -> _BUF_SIZE );
   _My_data . _Mysize = _Right_size;
   _My_data . _Myres = this -> _BUF_SIZE - 1;
   return;
   }

  auto & _Al = this -> _Getal ( );
  const size_type _New_capacity = _Min_value ( _Right_size | this -> _ALLOC_MASK, max_size ( ) );
  const pointer _New_array = _Al . allocate ( _New_capacity + 1 );
  _Alty_traits :: construct ( _Al, :: std :: addressof ( _My_data . _Bx . _Ptr ), _New_array );
  _Traits :: copy ( _Unfancy ( _New_array ), _Right_ptr, _Right_size + 1 );
  _My_data . _Mysize = _Right_size;
  _My_data . _Myres = _New_capacity;
  }

 basic_string ( initializer_list < _Elem > _Ilist, const _Alloc & _Al = allocator_type ( ) )
  : _Mybase ( _Al )
  {
  _Tidy_init ( );
  assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
  }

 basic_string & operator = ( initializer_list < _Elem > _Ilist )
  {
  return ( assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) ) );
  }

 basic_string & operator += ( initializer_list < _Elem > _Ilist )
  {
  return ( append ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) ) );
  }

 basic_string & assign ( initializer_list < _Elem > _Ilist )
  {
  return ( assign ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) ) );
  }

 basic_string & append ( initializer_list < _Elem > _Ilist )
  {
  return ( append ( _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) ) );
  }

 iterator insert ( const const_iterator _Where, const initializer_list < _Elem > _Ilist )
  {
  const difference_type _Off = _Where - begin ( );
  insert ( static_cast < size_type > ( _Off ), _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) );
  return ( begin ( ) + _Off );
  }

 basic_string & replace ( const const_iterator _First, const const_iterator _Last, const initializer_list < _Elem > _Ilist )
  {
  return ( replace ( static_cast < size_type > ( _First - begin ( ) ), static_cast < size_type > ( _Last - _First ),
   _Ilist . begin ( ), _Convert_size < size_type > ( _Ilist . size ( ) ) ) );
  }

 ~ basic_string ( ) noexcept
  {
  _Tidy_deallocate ( );
  }

 static constexpr auto npos { static_cast < size_type > ( - 1 ) };

 basic_string & operator = ( const basic_string & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
#pragma warning(push)
#pragma warning(disable: 4127)
   if ( _Alty_traits :: propagate_on_container_copy_assignment :: value
    && this -> _Getal ( ) != _Right . _Getal ( ) )
    {
    _Tidy_deallocate ( );
    }
#pragma warning(pop)

   this -> _Copy_alloc ( _Right . _Getal ( ) );

   auto & _Right_data = _Right . _Get_data ( );
   assign ( _Right_data . _Myptr ( ), _Right_data . _Mysize );
   }

  return ( * this );
  }










 basic_string & operator = ( const _Elem * const _Ptr )
  {
  return ( assign ( _Ptr ) );
  }

 basic_string & operator = ( const _Elem _Ch )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Mysize = 1;
  _Elem * const _Ptr = _My_data . _Myptr ( );
  _Traits :: assign ( _Ptr [ 0 ], _Ch );
  _Traits :: assign ( _Ptr [ 1 ], _Elem ( ) );
  return ( * this );
  }

 basic_string & operator += ( const basic_string & _Right )
  {
  return ( append ( _Right ) );
  }










 basic_string & operator += ( const _Elem * const _Ptr )
  {
  return ( append ( _Ptr ) );
  }

 basic_string & operator += ( _Elem _Ch )
  {
  push_back ( _Ch );
  return ( * this );
  }

 basic_string & append ( const basic_string & _Right )
  {
  auto & _Right_data = _Right . _Get_data ( );
  return ( append ( _Right_data . _Myptr ( ), _Right_data . _Mysize ) );
  }

 basic_string & append ( const basic_string & _Right, const size_type _Roff, size_type _Count = npos )
  {
  auto & _Right_data = _Right . _Get_data ( );
  _Right_data . _Check_offset ( _Roff );
  _Count = _Right_data . _Clamp_suffix_size ( _Roff, _Count );
  return ( append ( _Right_data . _Myptr ( ) + _Roff, _Count ) );
  }



















 basic_string & append ( const _Elem * const _Ptr, const size_type _Count )
  {
  auto & _My_data = this -> _Get_data ( );
  const size_type _Old_size = _My_data . _Mysize;
  if ( _Count <= _My_data . _Myres - _Old_size )
   {
   _My_data . _Mysize = _Old_size + _Count;
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _Traits :: move ( _Old_ptr + _Old_size, _Ptr, _Count );
   _Traits :: assign ( _Old_ptr [ _Old_size + _Count ], _Elem ( ) );
   return ( * this );
   }

  return ( _Reallocate_grow_by ( _Count,
   [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
    const _Elem * const _Ptr, const size_type _Count ) {
   _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
   _Traits :: copy ( _New_ptr + _Old_size, _Ptr, _Count );
   _Traits :: assign ( _New_ptr [ _Old_size + _Count ], _Elem ( ) );
   }, _Ptr, _Count ) );
  }

 basic_string & append ( const _Elem * const _Ptr )
  {
  return ( append ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) ) );
  }

 basic_string & append ( const size_type _Count, const _Elem _Ch )
  {
  auto & _My_data = this -> _Get_data ( );
  const size_type _Old_size = _My_data . _Mysize;
  if ( _Count <= _My_data . _Myres - _Old_size )
   {
   _My_data . _Mysize = _Old_size + _Count;
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _Traits :: assign ( _Old_ptr + _Old_size, _Count, _Ch );
   _Traits :: assign ( _Old_ptr [ _Old_size + _Count ], _Elem ( ) );
   return ( * this );
   }

  return ( _Reallocate_grow_by ( _Count,
   [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
    const size_type _Count, const _Elem _Ch ) {
   _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
   _Traits :: assign ( _New_ptr + _Old_size, _Count, _Ch );
   _Traits :: assign ( _New_ptr [ _Old_size + _Count ], _Elem ( ) );
   }, _Count, _Ch ) );
  }

 template < class _Iter,
  class = enable_if_t < _Is_iterator_v < _Iter >> >
  basic_string & append ( const _Iter _First, const _Iter _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 basic_string & assign ( const basic_string & _Right )
  {
  * this = _Right;
  return ( * this );
  }

 basic_string & assign ( const basic_string & _Right, const size_type _Roff, size_type _Count = npos )
  {
  auto & _Right_data = _Right . _Get_data ( );
  _Right_data . _Check_offset ( _Roff );
  _Count = _Right_data . _Clamp_suffix_size ( _Roff, _Count );
  return ( assign ( _Right_data . _Myptr ( ) + _Roff, _Count ) );
  }



















 basic_string & assign ( const _Elem * const _Ptr, const size_type _Count )
  {
  auto & _My_data = this -> _Get_data ( );
  if ( _Count <= _My_data . _Myres )
   {
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _My_data . _Mysize = _Count;
   _Traits :: move ( _Old_ptr, _Ptr, _Count );
   _Traits :: assign ( _Old_ptr [ _Count ], _Elem ( ) );
   return ( * this );
   }

  return ( _Reallocate_for ( _Count, [ ] ( _Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr ) {
   _Traits :: copy ( _New_ptr, _Ptr, _Count );
   _Traits :: assign ( _New_ptr [ _Count ], _Elem ( ) );
   }, _Ptr ) );
  }

 basic_string & assign ( const _Elem * const _Ptr )
  {
  return ( assign ( _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) ) );
  }

 basic_string & assign ( const size_type _Count, const _Elem _Ch )
  {
  auto & _My_data = this -> _Get_data ( );
  if ( _Count <= _My_data . _Myres )
   {
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _My_data . _Mysize = _Count;
   _Traits :: assign ( _Old_ptr, _Count, _Ch );
   _Traits :: assign ( _Old_ptr [ _Count ], _Elem ( ) );
   return ( * this );
   }

  return ( _Reallocate_for ( _Count, [ ] ( _Elem * const _New_ptr, const size_type _Count, const _Elem _Ch ) {
   _Traits :: assign ( _New_ptr, _Count, _Ch );
   _Traits :: assign ( _New_ptr [ _Count ], _Elem ( ) );
   }, _Ch ) );
  }

 template < class _Iter,
  class = enable_if_t < _Is_iterator_v < _Iter >> >
  basic_string & assign ( const _Iter _First, const _Iter _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 basic_string & insert ( const size_type _Off, const basic_string & _Right )
  {
  auto & _Right_data = _Right . _Get_data ( );
  return ( insert ( _Off, _Right_data . _Myptr ( ), _Right_data . _Mysize ) );
  }

 basic_string & insert ( const size_type _Off, const basic_string & _Right, const size_type _Roff, size_type _Count = npos )
  {
  auto & _Right_data = _Right . _Get_data ( );
  _Right_data . _Check_offset ( _Roff );
  _Count = _Right_data . _Clamp_suffix_size ( _Roff, _Count );
  return ( insert ( _Off, _Right_data . _Myptr ( ) + _Roff, _Count ) );
  }




















 basic_string & insert ( const size_type _Off, const _Elem * const _Ptr,
   const size_type _Count )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  const size_type _Old_size = _My_data . _Mysize;
  if ( _Count <= _My_data . _Myres - _Old_size )
   {
   _My_data . _Mysize = _Old_size + _Count;
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _Elem * const _Insert_at = _Old_ptr + _Off;


   size_type _Ptr_shifted_after;
   if ( _Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size )
    {
    _Ptr_shifted_after = _Count;
    }
   else if ( _Insert_at <= _Ptr )
    {
    _Ptr_shifted_after = 0;
    }
   else
    {
    _Ptr_shifted_after = static_cast < size_type > ( _Insert_at - _Ptr );
    }

   _Traits :: move ( _Insert_at + _Count, _Insert_at, _Old_size - _Off + 1 );
   _Traits :: copy ( _Insert_at, _Ptr, _Ptr_shifted_after );
   _Traits :: copy ( _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,
    _Count - _Ptr_shifted_after );
   return ( * this );
   }

  return ( _Reallocate_grow_by ( _Count,
   [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
    const size_type _Off, const _Elem * const _Ptr, const size_type _Count ) {
   _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
   _Traits :: copy ( _New_ptr + _Off, _Ptr, _Count );
   _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1 );
   }, _Off, _Ptr, _Count ) );
  }

 basic_string & insert ( const size_type _Off, const _Elem * const _Ptr )
  {
  return ( insert ( _Off, _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) ) );
  }

 basic_string & insert ( const size_type _Off, const size_type _Count, const _Elem _Ch )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  const size_type _Old_size = _My_data . _Mysize;
  if ( _Count <= _My_data . _Myres - _Old_size )
   {
   _My_data . _Mysize = _Old_size + _Count;
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _Elem * const _Insert_at = _Old_ptr + _Off;
   _Traits :: move ( _Insert_at + _Count, _Insert_at, _Old_size - _Off + 1 );
   _Traits :: assign ( _Insert_at, _Count, _Ch );
   return ( * this );
   }

  return ( _Reallocate_grow_by ( _Count,
   [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
    const size_type _Off, const size_type _Count, const _Elem _Ch ) {
   _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
   _Traits :: assign ( _New_ptr + _Off, _Count, _Ch );
   _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1 );
   }, _Off, _Count, _Ch ) );
  }

 iterator insert ( const const_iterator _Where, const _Elem _Ch )
  {
  const difference_type _Off = _Where - begin ( );
  insert ( static_cast < size_type > ( _Off ), 1, _Ch );
  return ( begin ( ) + _Off );
  }

 iterator insert ( const const_iterator _Where, const size_type _Count, const _Elem _Ch )
  {
  const difference_type _Off = _Where - begin ( );
  insert ( static_cast < size_type > ( _Off ), _Count, _Ch );
  return ( begin ( ) + _Off );
  }

 template < class _Iter,
  class = enable_if_t < _Is_iterator_v < _Iter >> >
  iterator insert ( const const_iterator _Where, const _Iter _First, const _Iter _Last )
  {
  const difference_type _Off = _Where - begin ( );
  replace ( _Where, _Where, _First, _Last );
  return ( begin ( ) + _Off );
  }

 basic_string & erase ( const size_type _Off = 0 )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  _Eos ( _Off );
  return ( * this );
  }

 basic_string & erase ( const size_type _Off, size_type _Count )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  _Count = _My_data . _Clamp_suffix_size ( _Off, _Count );
  const size_type _Old_size = _My_data . _Mysize;
  _Elem * const _My_ptr = _My_data . _Myptr ( );
  _Elem * const _Erase_at = _My_ptr + _Off;
  const size_type _New_size = _Old_size - _Count;
  _My_data . _Mysize = _New_size;
  _Traits :: move ( _Erase_at, _Erase_at + _Count, _New_size - _Off + 1 );
  return ( * this );
  }

 iterator erase ( const const_iterator _Where )
  {
  const difference_type _Off = _Where - begin ( );
  erase ( static_cast < size_type > ( _Off ), 1 );
  return ( begin ( ) + _Off );
  }

 iterator erase ( const const_iterator _First, const const_iterator _Last )
  {
  _Adl_verify_range ( _First, _Last );
  const difference_type _Off = _First - begin ( );
  erase ( static_cast < size_type > ( _Off ), static_cast < size_type > ( _Last - _First ) );
  return ( begin ( ) + _Off );
  }

 void clear ( ) noexcept
  {
  _Eos ( 0 );
  }

 basic_string & replace ( const size_type _Off, const size_type _N0, const basic_string & _Right )
  {
  auto & _Right_data = _Right . _Get_data ( );
  return ( replace ( _Off, _N0, _Right_data . _Myptr ( ), _Right_data . _Mysize ) );
  }

 basic_string & replace ( const size_type _Off, size_type _N0,
  const basic_string & _Right, const size_type _Roff, size_type _Count = npos )
  {
  auto & _Right_data = _Right . _Get_data ( );
  _Right_data . _Check_offset ( _Roff );
  _Count = _Right_data . _Clamp_suffix_size ( _Roff, _Count );
  return ( replace ( _Off, _N0, _Right_data . _Myptr ( ) + _Roff, _Count ) );
  }




















 basic_string & replace ( const size_type _Off, size_type _N0,
    const _Elem * const _Ptr, const size_type _Count )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  _N0 = _My_data . _Clamp_suffix_size ( _Off, _N0 );
  if ( _N0 == _Count )
   {
   _Traits :: move ( _My_data . _Myptr ( ) + _Off, _Ptr, _Count );
   return ( * this );
   }

  const size_type _Old_size = _My_data . _Mysize;
  const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
  if ( _Count < _N0 )
   {
   _My_data . _Mysize = _Old_size - ( _N0 - _Count );
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _Elem * const _Insert_at = _Old_ptr + _Off;
   _Traits :: move ( _Insert_at, _Ptr, _Count );
   _Traits :: move ( _Insert_at + _Count, _Insert_at + _N0, _Suffix_size );
   return ( * this );
   }

  const size_type _Growth = static_cast < size_type > ( _Count - _N0 );
  if ( _Growth <= _My_data . _Myres - _Old_size )
   {
   _My_data . _Mysize = _Old_size + _Growth;
   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _Elem * const _Insert_at = _Old_ptr + _Off;
   _Elem * const _Suffix_at = _Insert_at + _N0;

   size_type _Ptr_shifted_after;
   if ( _Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size )
    {
    _Ptr_shifted_after = _Count;
    }
   else if ( _Suffix_at <= _Ptr )
    {
    _Ptr_shifted_after = 0;
    }
   else
    {
    _Ptr_shifted_after = static_cast < size_type > ( _Suffix_at - _Ptr );
    }

   _Traits :: move ( _Suffix_at + _Growth, _Suffix_at, _Suffix_size );



   _Traits :: move ( _Insert_at, _Ptr, _Ptr_shifted_after );


   _Traits :: copy ( _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after,
    _Count - _Ptr_shifted_after );
   return ( * this );
   }

  return ( _Reallocate_grow_by ( _Growth,
   [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
    const size_type _Off, const size_type _N0, const _Elem * const _Ptr, const size_type _Count ) {
   _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
   _Traits :: copy ( _New_ptr + _Off, _Ptr, _Count );
   _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1 );
   }, _Off, _N0, _Ptr, _Count ) );
  }

 basic_string & replace ( const size_type _Off, const size_type _N0, const _Elem * const _Ptr )
  {
  return ( replace ( _Off, _N0, _Ptr, _Convert_size < size_type > ( _Traits :: length ( _Ptr ) ) ) );
  }

 basic_string & replace ( const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  _N0 = _My_data . _Clamp_suffix_size ( _Off, _N0 );
  if ( _Count == _N0 )
   {
   _Traits :: assign ( _My_data . _Myptr ( ) + _Off, _Count, _Ch );
   return ( * this );
   }

  const size_type _Old_size = _My_data . _Mysize;
  if ( _Count < _N0 || _Count - _N0 <= _My_data . _Myres - _Old_size )
   {
   _My_data . _Mysize = _Old_size + _Count - _N0;

   _Elem * const _Old_ptr = _My_data . _Myptr ( );
   _Elem * const _Insert_at = _Old_ptr + _Off;
   _Traits :: move ( _Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1 );
   _Traits :: assign ( _Insert_at, _Count, _Ch );
   return ( * this );
   }

  return ( _Reallocate_grow_by ( _Count - _N0,
   [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
    const size_type _Off, const size_type _N0, const size_type _Count, const _Elem _Ch ) {
   _Traits :: copy ( _New_ptr, _Old_ptr, _Off );
   _Traits :: assign ( _New_ptr + _Off, _Count, _Ch );
   _Traits :: copy ( _New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1 );
   }, _Off, _N0, _Count, _Ch ) );
  }

 basic_string & replace ( const const_iterator _First, const const_iterator _Last, const basic_string & _Right )
  {
  return ( replace ( static_cast < size_type > ( _First - begin ( ) ), static_cast < size_type > ( _Last - _First ), _Right ) );
  }










 basic_string & replace ( const const_iterator _First, const const_iterator _Last,
    const _Elem * const _Ptr, const size_type _Count )
  {
  return ( replace ( static_cast < size_type > ( _First - begin ( ) ), static_cast < size_type > ( _Last - _First ), _Ptr, _Count ) );
  }

 basic_string & replace ( const const_iterator _First, const const_iterator _Last, const _Elem * const _Ptr )
  {
  return ( replace ( static_cast < size_type > ( _First - begin ( ) ), static_cast < size_type > ( _Last - _First ), _Ptr ) );
  }

 basic_string & replace ( const const_iterator _First, const const_iterator _Last,
  const size_type _Count, const _Elem _Ch )
  {
  return ( replace ( static_cast < size_type > ( _First - begin ( ) ), static_cast < size_type > ( _Last - _First ), _Count, _Ch ) );
  }

 template < class _Iter >
  basic_string & _Replace_range ( const const_iterator _First, const const_iterator _Last,
  const _Iter _First2, const _Iter _Last2, false_type )
  {
  const basic_string _Right ( _First2, _Last2, get_allocator ( ) );
  replace ( _First, _Last, _Right );
  return ( * this );
  }

 template < class _Ptr >
  basic_string & _Replace_range ( const const_iterator _First, const const_iterator _Last,
  const _Ptr _First2, const _Ptr _Last2, true_type )
  {
  return ( replace ( static_cast < size_type > ( _First - cbegin ( ) ), static_cast < size_type > ( _Last - _First ),
   _First2, static_cast < size_type > ( _Last2 - _First2 ) ) );
  }

 template < class _Iter,
  class = enable_if_t < _Is_iterator_v < _Iter >> >
  basic_string & replace ( const const_iterator _First, const const_iterator _Last,
   const _Iter _First2, const _Iter _Last2 )
  {
  _Adl_verify_range ( _First2, _Last2 );
  const auto _UFirst2 = _Get_unwrapped ( _First2 );
  const auto _ULast2 = _Get_unwrapped ( _Last2 );
  return ( _Replace_range ( _First, _Last, _UFirst2, _ULast2, _Is_elem_cptr < decltype ( _UFirst2 ) > ( ) ) );
  }

  iterator begin ( ) noexcept
  {
  auto _My_data = :: std :: addressof ( this -> _Get_data ( ) );
  return ( iterator ( _Refancy < pointer > ( _My_data -> _Myptr ( ) ), _My_data ) );
  }

  const_iterator begin ( ) const noexcept
  {
  auto _My_data = :: std :: addressof ( this -> _Get_data ( ) );
  return ( const_iterator ( _Refancy < const_pointer > ( _My_data -> _Myptr ( ) ), _My_data ) );
  }

  iterator end ( ) noexcept
  {
  auto _My_data = :: std :: addressof ( this -> _Get_data ( ) );
  return ( iterator ( _Refancy < pointer > ( _My_data -> _Myptr ( ) )
   + static_cast < difference_type > ( _My_data -> _Mysize ), _My_data ) );
  }

  const_iterator end ( ) const noexcept
  {
  auto _My_data = :: std :: addressof ( this -> _Get_data ( ) );
  return ( const_iterator ( _Refancy < const_pointer > ( _My_data -> _Myptr ( ) )
   + static_cast < difference_type > ( _My_data -> _Mysize ), _My_data ) );
  }

 _Elem * _Unchecked_begin ( ) noexcept
  {
  return ( this -> _Get_data ( ) . _Myptr ( ) );
  }

 const _Elem * _Unchecked_begin ( ) const noexcept
  {
  return ( this -> _Get_data ( ) . _Myptr ( ) );
  }

 _Elem * _Unchecked_end ( ) noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( _My_data . _Myptr ( ) + _My_data . _Mysize );
  }

 const _Elem * _Unchecked_end ( ) const noexcept
  {
  const auto & _My_data = this -> _Get_data ( );
  return ( _My_data . _Myptr ( ) + _My_data . _Mysize );
  }

  reverse_iterator rbegin ( ) noexcept
  {
  return ( reverse_iterator ( end ( ) ) );
  }

  const_reverse_iterator rbegin ( ) const noexcept
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

  reverse_iterator rend ( ) noexcept
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

  const_reverse_iterator rend ( ) const noexcept
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

  const_iterator cbegin ( ) const noexcept
  {
  return ( begin ( ) );
  }

  const_iterator cend ( ) const noexcept
  {
  return ( end ( ) );
  }

  const_reverse_iterator crbegin ( ) const noexcept
  {
  return ( rbegin ( ) );
  }

  const_reverse_iterator crend ( ) const noexcept
  {
  return ( rend ( ) );
  }

 void shrink_to_fit ( )
  {
  auto & _My_data = this -> _Get_data ( );
  if ( ! _My_data . _Large_string_engaged ( ) )
   {
   return;
   }

  if ( _My_data . _Mysize < this -> _BUF_SIZE )
   {
   _Become_small ( );
   return;
   }

  const size_type _Target_capacity = _Min_value ( _My_data . _Mysize | this -> _ALLOC_MASK, max_size ( ) );
  if ( _Target_capacity < _My_data . _Myres )
   {
   auto & _Al = this -> _Getal ( );
   const pointer _New_ptr = _Al . allocate ( _Target_capacity + 1 );
   this -> _Orphan_all ( );
   _Traits :: copy ( _Unfancy ( _New_ptr ), _Unfancy ( _My_data . _Bx . _Ptr ), _My_data . _Mysize + 1 );
   _Al . deallocate ( _My_data . _Bx . _Ptr, _My_data . _Myres + 1 );
   _My_data . _Bx . _Ptr = _New_ptr;
   _My_data . _Myres = _Target_capacity;
   }
  }

  reference at ( const size_type _Off )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset_exclusive ( _Off );
  return ( _My_data . _Myptr ( ) [ _Off ] );
  }

  const_reference at ( const size_type _Off ) const
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset_exclusive ( _Off );
  return ( _My_data . _Myptr ( ) [ _Off ] );
  }

  reference operator [ ] ( const size_type _Off )
  {
  auto & _My_data = this -> _Get_data ( );

  do { if ( _Off <= _My_data . _Mysize ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 3204, 0, "%s", "string subscript out of range" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x73\x74\x72\x69\x6e\x67\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 3204, 0 ); } while ( false ); }; } while ( false );

  return ( _My_data . _Myptr ( ) [ _Off ] );
  }

  const_reference operator [ ] ( const size_type _Off ) const
  {
  auto & _My_data = this -> _Get_data ( );

  do { if ( _Off <= _My_data . _Mysize ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 3213, 0, "%s", "string subscript out of range" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x73\x74\x72\x69\x6e\x67\x20\x73\x75\x62\x73\x63\x72\x69\x70\x74\x20\x6f\x75\x74\x20\x6f\x66\x20\x72\x61\x6e\x67\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 3213, 0 ); } while ( false ); }; } while ( false );

  return ( _My_data . _Myptr ( ) [ _Off ] );
  }









 void push_back ( const _Elem _Ch )
  {
  auto & _My_data = this -> _Get_data ( );
  const size_type _Old_size = _My_data . _Mysize;
  if ( _Old_size < _My_data . _Myres )
   {
   _My_data . _Mysize = _Old_size + 1;
   _Elem * const _Ptr = _My_data . _Myptr ( );
   _Traits :: assign ( _Ptr [ _Old_size ], _Ch );
   _Traits :: assign ( _Ptr [ _Old_size + 1 ], _Elem ( ) );
   return;
   }

  _Reallocate_grow_by ( 1,
   [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
    const _Elem _Ch ) {
   _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size );
   _Traits :: assign ( _New_ptr [ _Old_size ], _Ch );
   _Traits :: assign ( _New_ptr [ _Old_size + 1 ], _Elem ( ) );
   }, _Ch );
  }

 void pop_back ( )
  {
  auto & _My_data = this -> _Get_data ( );
  const size_type _Old_size = _My_data . _Mysize;

  do { if ( _Old_size != 0 ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring", 3253, 0, "%s", "invalid to pop_back empty string" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x6e\x76\x61\x6c\x69\x64\x20\x74\x6f\x20\x70\x6f\x70\x5f\x62\x61\x63\x6b\x20\x65\x6d\x70\x74\x79\x20\x73\x74\x72\x69\x6e" L"\x67\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x78\x73\x74\x72\x69\x6e\x67", 3253, 0 ); } while ( false ); }; } while ( false );

  _Eos ( _Old_size - 1 );
  }

  reference front ( )
  {
  return ( * begin ( ) );
  }

  const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

  reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

  const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

    const _Elem * c_str ( ) const noexcept
  {
  return ( this -> _Get_data ( ) . _Myptr ( ) );
  }

    const _Elem * data ( ) const noexcept
  {
  return ( this -> _Get_data ( ) . _Myptr ( ) );
  }








  size_type length ( ) const noexcept
  {
  return ( this -> _Get_data ( ) . _Mysize );
  }

  size_type size ( ) const noexcept
  {
  return ( this -> _Get_data ( ) . _Mysize );
  }

  size_type max_size ( ) const noexcept
  {
  const size_type _Alloc_max = _Alty_traits :: max_size ( this -> _Getal ( ) );
  const size_type _Storage_max =
   _Max_value ( _Alloc_max, static_cast < size_type > ( this -> _BUF_SIZE ) );
  return ( _Min_value (
   static_cast < size_type > ( ( numeric_limits < difference_type > :: max ) ( ) ),
   _Storage_max - 1
   ) );

  }

 void resize ( const size_type _Newsize, const _Elem _Ch = _Elem ( ) )
  {
  const size_type _Old_size = size ( );
  if ( _Newsize <= _Old_size )
   {
   _Eos ( _Newsize );
   }
  else
   {
   append ( _Newsize - _Old_size, _Ch );
   }
  }

  size_type capacity ( ) const noexcept
  {
  return ( this -> _Get_data ( ) . _Myres );
  }

 void reserve ( const size_type _Newcap = 0 )
  {
  auto & _My_data = this -> _Get_data ( );
  if ( _My_data . _Mysize > _Newcap )
   {
   return;
   }

  if ( _My_data . _Myres == _Newcap )
   {
   return;
   }

  if ( _My_data . _Myres < _Newcap )
   {
   const size_type _Old_size = _My_data . _Mysize;
   _Reallocate_grow_by ( _Newcap - _Old_size,
    [ ] ( _Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size ) {
    _Traits :: copy ( _New_ptr, _Old_ptr, _Old_size + 1 );
    } );

   _My_data . _Mysize = _Old_size;
   return;
   }

  if ( this -> _BUF_SIZE > _Newcap && _My_data . _Large_string_engaged ( ) )
   {
   _Become_small ( );
   return;
   }


  }

  bool empty ( ) const noexcept
  {
  return ( size ( ) == 0 );
  }

 size_type copy ( _Elem * const _Ptr,
  size_type _Count, const size_type _Off = 0 ) const
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  _Count = _My_data . _Clamp_suffix_size ( _Off, _Count );
  _Traits :: copy ( _Ptr, _My_data . _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

   size_type _Copy_s (
    _Elem * const _Dest, const size_type _Dest_size,
  size_type _Count, const size_type _Off = 0 ) const
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  _Count = _My_data . _Clamp_suffix_size ( _Off, _Count );
  _Traits :: _Copy_s ( _Dest, _Dest_size, _My_data . _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 void _Swap_data ( basic_string & _Right, true_type )
  {
  const auto _My_data_mem = reinterpret_cast < unsigned char * > ( :: std :: addressof ( this -> _Get_data ( ) ) )
   + _Memcpy_move_offset;
  const auto _Right_data_mem = reinterpret_cast < unsigned char * > ( :: std :: addressof ( _Right . _Get_data ( ) ) )
   + _Memcpy_move_offset;
  unsigned char _Temp_mem [ _Memcpy_move_size ];
  :: memcpy ( _Temp_mem, _My_data_mem, _Memcpy_move_size );
  :: memcpy ( _My_data_mem, _Right_data_mem, _Memcpy_move_size );
  :: memcpy ( _Right_data_mem, _Temp_mem, _Memcpy_move_size );
  }

 void _Swap_bx_large_with_small ( _Mydata_t & _Starts_large, _Mydata_t & _Starts_small )
  {
  const pointer _Ptr = _Starts_large . _Bx . _Ptr;
  auto & _Al = this -> _Getal ( );
  _Alty_traits :: destroy ( _Al, :: std :: addressof ( _Starts_large . _Bx . _Ptr ) );
  _Traits :: copy ( _Starts_large . _Bx . _Buf, _Starts_small . _Bx . _Buf, this -> _BUF_SIZE );
  _Alty_traits :: construct ( _Al, :: std :: addressof ( _Starts_small . _Bx . _Ptr ), _Ptr );
  }

 void _Swap_data ( basic_string & _Right, false_type )
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  const bool _My_large = _My_data . _Large_string_engaged ( );
  const bool _Right_large = _Right_data . _Large_string_engaged ( );
  if ( _My_large )
   {
   if ( _Right_large )
    {
    _Swap_adl ( _My_data . _Bx . _Ptr, _Right_data . _Bx . _Ptr );
    }
   else
    {
    _Swap_bx_large_with_small ( _My_data, _Right_data );
    }
   }
  else
   {
   if ( _Right_large )
    {
    _Swap_bx_large_with_small ( _Right_data, _My_data );
    }
   else
    {
    _Elem _Temp_buf [ this -> _BUF_SIZE ];
    _Traits :: copy ( _Temp_buf, _My_data . _Bx . _Buf, this -> _BUF_SIZE );
    _Traits :: copy ( _My_data . _Bx . _Buf, _Right_data . _Bx . _Buf, this -> _BUF_SIZE );
    _Traits :: copy ( _Right_data . _Bx . _Buf, _Temp_buf, this -> _BUF_SIZE );
    }
   }

  :: std :: swap ( _My_data . _Mysize, _Right_data . _Mysize );
  :: std :: swap ( _My_data . _Myres, _Right_data . _Myres );
  }

 void swap ( basic_string & _Right ) noexcept
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Pocs ( this -> _Getal ( ), _Right . _Getal ( ) );


   auto & _My_data = this -> _Get_data ( );
   auto & _Right_data = _Right . _Get_data ( );
   const bool _My_large = _My_data . _Large_string_engaged ( );
   const bool _Right_large = _Right_data . _Large_string_engaged ( );
   if ( ! _My_large )
    {
    _My_data . _Orphan_all ( );
    }

   if ( ! _Right_large )
    {
    _Right_data . _Orphan_all ( );
    }

   if ( _My_large || _Right_large )
    {
    _My_data . _Swap_all ( _Right_data );
    }

   }

  _Swap_data ( _Right, _Use_memcpy_move { } );
  }













  size_type find ( const basic_string & _Right, const size_type _Off = 0 ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off,
    _Right_data . _Myptr ( ), _Right_data . _Mysize ) ) );
  }

  size_type find ( const _Elem * const _Ptr, const size_type _Off, const size_type _Count )
  const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Count ) ) );
  }

  size_type find ( const _Elem * const _Ptr, const size_type _Off = 0 ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) ) );
  }

  size_type find ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_ch < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ch ) ) );
  }













  size_type rfind ( const basic_string & _Right, const size_type _Off = npos ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_rfind < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off,
    _Right_data . _Myptr ( ), _Right_data . _Mysize ) ) );
  }

  size_type rfind ( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_rfind < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Count ) ) );
  }

  size_type rfind ( const _Elem * const _Ptr, const size_type _Off = npos )
  const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_rfind < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ) ) ) );
  }

  size_type rfind ( const _Elem _Ch, const size_type _Off = npos ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_rfind_ch < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ch ) ) );
  }













  size_type find_first_of ( const basic_string & _Right, const size_type _Off = 0 ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( static_cast < size_type > ( _Traits_find_first_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off,
   _Right_data . _Myptr ( ), _Right_data . _Mysize, _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_first_of ( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_first_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Count,
    _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_first_of ( const _Elem * const _Ptr, const size_type _Off = 0 )
  const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_first_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ),
    _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_first_of ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_ch < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ch ) ) );
  }













  size_type find_last_of ( const basic_string & _Right, size_type _Off = npos ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( static_cast < size_type > ( _Traits_find_last_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off,
   _Right_data . _Myptr ( ), _Right_data . _Mysize, _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_last_of ( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_last_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Count,
    _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_last_of ( const _Elem * const _Ptr, const size_type _Off = npos )
  const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_last_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Traits :: length ( _Ptr ),
    _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_last_of ( const _Elem _Ch, const size_type _Off = npos ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > ( _Traits_rfind_ch < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ch ) ) );
  }













  size_type find_first_not_of ( const basic_string & _Right, const size_type _Off = 0 ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( static_cast < size_type > ( _Traits_find_first_not_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off,
   _Right_data . _Myptr ( ), _Right_data . _Mysize, _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_first_not_of ( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_first_not_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Count,
    _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_first_not_of ( const _Elem * const _Ptr, size_type _Off = 0 ) const
  noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_first_not_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr,
    _Traits :: length ( _Ptr ), _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_first_not_of ( const _Elem _Ch, const size_type _Off = 0 ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > ( _Traits_find_not_ch < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ch ) ) );
  }













  size_type find_last_not_of ( const basic_string & _Right, const size_type _Off = npos ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( static_cast < size_type > ( _Traits_find_last_not_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off,
   _Right_data . _Myptr ( ), _Right_data . _Mysize, _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_last_not_of ( const _Elem * const _Ptr, const size_type _Off,
  const size_type _Count ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_find_last_not_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ptr, _Count,
    _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_last_not_of ( const _Elem * const _Ptr, const size_type _Off = npos ) const
  noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > ( _Traits_find_last_not_of < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off,
   _Ptr, _Traits :: length ( _Ptr ), _Is_specialization < _Traits, char_traits > { } ) ) );
  }

  size_type find_last_not_of ( const _Elem _Ch, const size_type _Off = npos ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( static_cast < size_type > (
   _Traits_rfind_not_ch < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Off, _Ch ) ) );
  }








  basic_string substr ( const size_type _Off = 0, const size_type _Count = npos ) const
  {
  return ( basic_string ( * this, _Off, _Count, get_allocator ( ) ) );
  }

 bool _Equal ( const basic_string & _Right ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( _Traits_equal < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Right_data . _Myptr ( ), _Right_data . _Mysize ) );
  }

 bool _Equal ( const _Elem * const _Ptr ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( _Traits_equal < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize, _Ptr, _Traits :: length ( _Ptr ) ) );
  }





































  int compare ( const basic_string & _Right ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  return ( _Traits_compare < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize,
   _Right_data . _Myptr ( ), _Right_data . _Mysize ) );
  }

  int compare ( size_type _Off, size_type _N0, const basic_string & _Right ) const
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  auto & _Right_data = _Right . _Get_data ( );
  return ( _Traits_compare < _Traits > ( _My_data . _Myptr ( ) + _Off, _My_data . _Clamp_suffix_size ( _Off, _N0 ),
   _Right_data . _Myptr ( ), _Right_data . _Mysize ) );
  }

  int compare ( const size_type _Off, const size_type _N0, const basic_string & _Right,
  const size_type _Roff, const size_type _Count = npos ) const
  {
  auto & _My_data = this -> _Get_data ( );
  auto & _Right_data = _Right . _Get_data ( );
  _My_data . _Check_offset ( _Off );
  _Right_data . _Check_offset ( _Roff );
  return ( _Traits_compare < _Traits > ( _My_data . _Myptr ( ) + _Off, _My_data . _Clamp_suffix_size ( _Off, _N0 ),
   _Right_data . _Myptr ( ) + _Roff, _Right_data . _Clamp_suffix_size ( _Roff, _Count ) ) );
  }

  int compare ( const _Elem * const _Ptr ) const noexcept
  {
  auto & _My_data = this -> _Get_data ( );
  return ( _Traits_compare < _Traits > ( _My_data . _Myptr ( ), _My_data . _Mysize,
   _Ptr, _Traits :: length ( _Ptr ) ) );
  }

  int compare ( const size_type _Off, const size_type _N0, const _Elem * const _Ptr ) const
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  return ( _Traits_compare < _Traits > ( _My_data . _Myptr ( ) + _Off, _My_data . _Clamp_suffix_size ( _Off, _N0 ),
   _Ptr, _Traits :: length ( _Ptr ) ) );
  }

  int compare ( const size_type _Off, const size_type _N0, const _Elem * const _Ptr,
  const size_type _Count ) const
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Check_offset ( _Off );
  return ( _Traits_compare < _Traits > ( _My_data . _Myptr ( ) + _Off, _My_data . _Clamp_suffix_size ( _Off, _N0 ),
   _Ptr, _Count ) );
  }

  allocator_type get_allocator ( ) const noexcept
  {
  return ( static_cast < allocator_type > ( this -> _Getal ( ) ) );
  }

 size_type _Calculate_growth ( const size_type _Requested ) const
  {
  const size_type _Max = max_size ( );
  auto & _My_data = this -> _Get_data ( );
  const size_type _Masked = _Requested | this -> _ALLOC_MASK;
  if ( _Masked > _Max )
   {
   return ( _Max );
   }

  const size_type _Old = _My_data . _Myres;
  if ( _Old > _Max - _Old / 2 )
   {
   return ( _Max );
   }

  return ( _Max_value ( _Masked, _Old + _Old / 2 ) );
  }

 template < class _Fty,
  class ... _ArgTys >
  basic_string & _Reallocate_for ( const size_type _New_size, _Fty _Fn, _ArgTys ... _Args )
  {

  if ( _New_size > max_size ( ) )
   {
   _Xlen ( );
   }

  auto & _My_data = this -> _Get_data ( );
  const size_type _Old_capacity = _My_data . _Myres;
  const size_type _New_capacity = _Calculate_growth ( _New_size );
  auto & _Al = this -> _Getal ( );
  const pointer _New_ptr = _Al . allocate ( _New_capacity + 1 );
  _My_data . _Orphan_all ( );
  _My_data . _Mysize = _New_size;
  _My_data . _Myres = _New_capacity;
  _Fn ( _Unfancy ( _New_ptr ), _New_size, _Args ... );
  if ( this -> _BUF_SIZE <= _Old_capacity )
   {
   _Al . deallocate ( _My_data . _Bx . _Ptr, _Old_capacity + 1 );
   _My_data . _Bx . _Ptr = _New_ptr;
   }
  else
   {
   _Alty_traits :: construct ( _Al, :: std :: addressof ( _My_data . _Bx . _Ptr ), _New_ptr );
   }

  return ( * this );
  }

 template < class _Fty,
  class ... _ArgTys >
  basic_string & _Reallocate_grow_by ( const size_type _Size_increase, _Fty _Fn, _ArgTys ... _Args )
  {

  auto & _My_data = this -> _Get_data ( );
  const size_type _Old_size = _My_data . _Mysize;
  if ( max_size ( ) - _Old_size < _Size_increase )
   {
   _Xlen ( );
   }

  const size_type _New_size = _Old_size + _Size_increase;
  const size_type _Old_capacity = _My_data . _Myres;
  const size_type _New_capacity = _Calculate_growth ( _New_size );
  auto & _Al = this -> _Getal ( );
  const pointer _New_ptr = _Al . allocate ( _New_capacity + 1 );
  _My_data . _Orphan_all ( );
  _My_data . _Mysize = _New_size;
  _My_data . _Myres = _New_capacity;
  _Elem * const _Raw_new = _Unfancy ( _New_ptr );
  if ( this -> _BUF_SIZE <= _Old_capacity )
   {
   const pointer _Old_ptr = _My_data . _Bx . _Ptr;
   _Fn ( _Raw_new, _Unfancy ( _Old_ptr ), _Old_size, _Args ... );
   _Al . deallocate ( _Old_ptr, _Old_capacity + 1 );
   _My_data . _Bx . _Ptr = _New_ptr;
   }
  else
   {
   _Fn ( _Raw_new, _My_data . _Bx . _Buf, _Old_size, _Args ... );
   _Alty_traits :: construct ( _Al, :: std :: addressof ( _My_data . _Bx . _Ptr ), _New_ptr );
   }

  return ( * this );
  }

 void _Become_small ( )
  {


  auto & _My_data = this -> _Get_data ( );
  _My_data . _Orphan_all ( );
  const pointer _Ptr = _My_data . _Bx . _Ptr;
  auto & _Al = this -> _Getal ( );
  _Alty_traits :: destroy ( _Al, :: std :: addressof ( _My_data . _Bx . _Ptr ) );
  _Traits :: copy ( _My_data . _Bx . _Buf, _Unfancy ( _Ptr ), _My_data . _Mysize + 1 );
  _Al . deallocate ( _Ptr, _My_data . _Myres + 1 );
  _My_data . _Myres = this -> _BUF_SIZE - 1;
  }

 void _Eos ( const size_type _Newsize )
  {
  auto & _My_data = this -> _Get_data ( );
  _Traits :: assign ( _My_data . _Myptr ( ) [ _My_data . _Mysize = _Newsize ], _Elem ( ) );
  }

 void _Tidy_init ( )
  {
  auto & _My_data = this -> _Get_data ( );
  _My_data . _Mysize = 0;
  _My_data . _Myres = this -> _BUF_SIZE - 1;


  _Traits :: assign ( _My_data . _Bx . _Buf [ 0 ], _Elem ( ) );
  }

 void _Tidy_deallocate ( )
  {
  this -> _Orphan_all ( );
  auto & _My_data = this -> _Get_data ( );
  if ( _My_data . _Large_string_engaged ( ) )
   {
   const pointer _Ptr = _My_data . _Bx . _Ptr;
   auto & _Al = this -> _Getal ( );
   _Alty_traits :: destroy ( _Al, :: std :: addressof ( _My_data . _Bx . _Ptr ) );
   _Al . deallocate ( _Ptr, _My_data . _Myres + 1 );
   }

  _My_data . _Mysize = 0;
  _My_data . _Myres = this -> _BUF_SIZE - 1;


  _Traits :: assign ( _My_data . _Bx . _Buf [ 0 ], _Elem ( ) );
  }

 [ [ noreturn ] ] static void _Xlen ( )
  {
  _Xlength_error ( "string too long" );
  }
 };
#line 4034 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring"
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 _Left . swap ( _Right );
 }
#line 4043
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 4057
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const _Elem * const _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 using _String_type = basic_string < _Elem, _Traits, _Alloc >;
 using _Size_type = typename _String_type :: size_type;
 _String_type _Ans;
 _Ans . reserve ( _Convert_size < _Size_type > ( _Traits :: length ( _Left ) + _Right . size ( ) ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 4073
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( 1 + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 4087
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
    const _Elem * const _Right )
 {
 using _String_type = basic_string < _Elem, _Traits, _Alloc >;
 using _Size_type = typename _String_type :: size_type;
 _String_type _Ans;
 _Ans . reserve ( _Convert_size < _Size_type > ( _Left . size ( ) + _Traits :: length ( _Right ) ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 4103
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + 1 );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 4117
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 4127
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 4137
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 if ( _Right . size ( ) <= _Left . capacity ( ) - _Left . size ( )
  || _Right . capacity ( ) - _Right . size ( ) < _Left . size ( ) )
  return ( :: std :: move ( _Left . append ( _Right ) ) );
 else
  return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 4151
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
    const _Elem * const _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 4161
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 using size_type = typename allocator_traits < _Alloc > :: size_type;
 return ( :: std :: move ( _Right . insert ( static_cast < size_type > ( 0 ), static_cast < size_type > ( 1 ), _Left ) ) );
 }
#line 4172
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
    const _Elem * const _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 4182
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const _Elem _Right )
 {
 _Left . push_back ( _Right );
 return ( :: std :: move ( _Left ) );
 }
#line 4193
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 4203
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator == (
    const _Elem * const _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . _Equal ( _Left ) );
 }
#line 4213
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
    const _Elem * const _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 4223
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( ! ( _Left == _Right ) );
 }
#line 4233
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator != (
    const _Elem * const _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 4243
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
    const _Elem * const _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 4253
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 4263
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator < (
    const _Elem * const _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . compare ( _Left ) > 0 );
 }
#line 4273
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
    const _Elem * const _Right )
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 4283
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( _Right < _Left );
 }
#line 4293
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator > (
    const _Elem * const _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 4303
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
    const _Elem * const _Right )
 {
 return ( _Right < _Left );
 }
#line 4313
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( ! ( _Right < _Left ) );
 }
#line 4323
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator <= (
    const _Elem * const _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 4333
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
    const _Elem * const _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 4343
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right ) noexcept
 {
 return ( ! ( _Left < _Right ) );
 }
#line 4353
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator >= (
    const _Elem * const _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 4363
template < class _Elem,
 class _Traits,
 class _Alloc >
  inline bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
    const _Elem * const _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 4373
using string = basic_string< char> ; 
#line 4374
using wstring = basic_string< __wchar_t> ; 
#line 4375
using u16string = basic_string< char16_t, char_traits< char16_t> , allocator< char16_t> > ; 
#line 4376
using u32string = basic_string< char32_t, char_traits< char32_t> , allocator< char32_t> > ; 
#line 4379
template < class _Elem,
 class _Traits,
 class _Alloc >
 struct hash < basic_string < _Elem, _Traits, _Alloc > >
 {
  typedef basic_string < _Elem, _Traits, _Alloc > argument_type;
  typedef size_t result_type;

  size_t operator ( ) ( const basic_string < _Elem, _Traits, _Alloc > & _Keyval ) const noexcept
  {
  return ( _Hash_array_representation ( _Keyval . c_str ( ), _Keyval . size ( ) ) );
  }
 };
#line 4392
}
#line 4396
#pragma warning(pop)
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 17
class logic_error : public exception { 
#line 21
public: typedef exception _Mybase; 
#line 23
explicit logic_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 25
{ 
#line 26
} 
#line 28
explicit logic_error(const char *_Message) : _Mybase(_Message) 
#line 30
{ 
#line 31
} 
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 45
class domain_error : public logic_error { 
#line 49
public: typedef logic_error _Mybase; 
#line 51
explicit domain_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 53
{ 
#line 54
} 
#line 56
explicit domain_error(const char *_Message) : _Mybase(_Message) 
#line 58
{ 
#line 59
} 
#line 70 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 73
class invalid_argument : public logic_error { 
#line 77
public: typedef logic_error _Mybase; 
#line 79
explicit invalid_argument(const string &_Message) : _Mybase(_Message.c_str()) 
#line 81
{ 
#line 82
} 
#line 84
explicit invalid_argument(const char *_Message) : _Mybase(_Message) 
#line 86
{ 
#line 87
} 
#line 98 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 101
class length_error : public logic_error { 
#line 105
public: typedef logic_error _Mybase; 
#line 107
explicit length_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 109
{ 
#line 110
} 
#line 112
explicit length_error(const char *_Message) : _Mybase(_Message) 
#line 114
{ 
#line 115
} 
#line 126 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 129
class out_of_range : public logic_error { 
#line 133
public: typedef logic_error _Mybase; 
#line 135
explicit out_of_range(const string &_Message) : _Mybase(_Message.c_str()) 
#line 137
{ 
#line 138
} 
#line 140
explicit out_of_range(const char *_Message) : _Mybase(_Message) 
#line 142
{ 
#line 143
} 
#line 154 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 157
class runtime_error : public exception { 
#line 161
public: typedef exception _Mybase; 
#line 163
explicit runtime_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 165
{ 
#line 166
} 
#line 168
explicit runtime_error(const char *_Message) : _Mybase(_Message) 
#line 170
{ 
#line 171
} 
#line 182 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 185
class overflow_error : public runtime_error { 
#line 189
public: typedef runtime_error _Mybase; 
#line 191
explicit overflow_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 193
{ 
#line 194
} 
#line 196
explicit overflow_error(const char *_Message) : _Mybase(_Message) 
#line 198
{ 
#line 199
} 
#line 210 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 213
class underflow_error : public runtime_error { 
#line 217
public: typedef runtime_error _Mybase; 
#line 219
explicit underflow_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 221
{ 
#line 222
} 
#line 224
explicit underflow_error(const char *_Message) : _Mybase(_Message) 
#line 226
{ 
#line 227
} 
#line 238 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 241
class range_error : public runtime_error { 
#line 245
public: typedef runtime_error _Mybase; 
#line 247
explicit range_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 249
{ 
#line 250
} 
#line 252
explicit range_error(const char *_Message) : _Mybase(_Message) 
#line 254
{ 
#line 255
} 
#line 266 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\stdexcept"
}; 
#line 267
}
#line 270
#pragma warning(pop)
#pragma pack ( pop )
#line 24 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\typeinfo"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 31
#pragma warning(disable: 4275)
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_typeinfo.h"
#pragma pack ( push, 8 )
#line 21 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_typeinfo.h"
struct __type_info_node; 
#line 27 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_typeinfo.h"
extern __type_info_node __type_info_root_node; 
#line 32 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_typeinfo.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 34
struct __std_type_info_data { 
#line 36
const char *_UndecoratedName; 
#line 37
const char _DecoratedName[1]; 
#line 38
__std_type_info_data() = delete;
#line 39
__std_type_info_data(const __std_type_info_data &) = delete;
#line 40
__std_type_info_data(__std_type_info_data &&) = delete;
#line 42
__std_type_info_data &operator=(const __std_type_info_data &) = delete;
#line 43
__std_type_info_data &operator=(__std_type_info_data &&) = delete;
#line 44
}; 
#line 46
int __cdecl __std_type_info_compare(const __std_type_info_data * _Lhs, const __std_type_info_data * _Rhs); 
#line 51
size_t __cdecl __std_type_info_hash(const __std_type_info_data * _Data); 
#line 55
const char *__cdecl __std_type_info_name(__std_type_info_data * _Data, __type_info_node * _RootNode); 
#line 60
}__pragma( pack ( pop )) 
#line 63
#pragma warning(push)
#pragma warning(disable: 4577)
class type_info { 
#line 69
public: type_info(const type_info &) = delete;
#line 70
type_info &operator=(const type_info &) = delete;
#line 72
size_t hash_code() const noexcept 
#line 73
{ 
#line 74
return __std_type_info_hash(&(_Data)); 
#line 75
} 
#line 77
bool operator==(const type_info &_Other) const noexcept 
#line 78
{ 
#line 79
return __std_type_info_compare(&(_Data), &(_Other._Data)) == 0; 
#line 80
} 
#line 82
bool operator!=(const type_info &_Other) const noexcept 
#line 83
{ 
#line 84
return __std_type_info_compare(&(_Data), &(_Other._Data)) != 0; 
#line 85
} 
#line 87
bool before(const type_info &_Other) const noexcept 
#line 88
{ 
#line 89
return __std_type_info_compare(&(_Data), &(_Other._Data)) < 0; 
#line 90
} 
#line 92
const char *name() const noexcept 
#line 93
{ 
#line 97
return __std_type_info_name(&(_Data), &__type_info_root_node); 
#line 99 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_typeinfo.h"
} 
#line 101
const char *raw_name() const noexcept 
#line 102
{ 
#line 103
return (_Data)._DecoratedName; 
#line 104
} 
#line 106
virtual ~type_info() noexcept; 
#line 110
private: mutable __std_type_info_data _Data; 
#line 111
}; 
#pragma warning(pop)
#line 114
namespace std { 
#line 115
using ::type_info;
#line 116
}
#line 120
namespace std { 
#line 122
#pragma warning(push)
#pragma warning(disable: 4577)
class bad_cast : public exception { 
#line 129
public: bad_cast() noexcept : exception("bad cast", 1) 
#line 131
{ 
#line 132
} 
#line 134
static bad_cast __construct_from_string_literal(const char *const _Message) noexcept 
#line 135
{ 
#line 136
return bad_cast(_Message, 1); 
#line 137
} 
#line 141
private: bad_cast(const char *const _Message, int) noexcept : exception(_Message, 1) 
#line 143
{ 
#line 144
} 
#line 145
}; 
#line 147
class bad_typeid : public exception { 
#line 152
public: bad_typeid() noexcept : exception("bad typeid", 1) 
#line 154
{ 
#line 155
} 
#line 157
static bad_typeid __construct_from_string_literal(const char *const _Message) noexcept 
#line 158
{ 
#line 159
return bad_typeid(_Message, 1); 
#line 160
} 
#line 164
friend class __non_rtti_object; 
#line 166
private: bad_typeid(const char *const _Message, int) noexcept : exception(_Message, 1) 
#line 168
{ 
#line 169
} 
#line 170
}; 
#line 172
class __non_rtti_object : public bad_typeid { 
#line 177
public: static __non_rtti_object __construct_from_string_literal(const char *const _Message) noexcept 
#line 178
{ 
#line 179
return __non_rtti_object(_Message, 1); 
#line 180
} 
#line 184
private: __non_rtti_object(const char *const _Message, int) noexcept : bad_typeid(_Message, 1) 
#line 186
{ 
#line 187
} 
#line 188
}; 
#line 190
#pragma warning(pop)
}
#line 195 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\vcruntime_typeinfo.h"
#pragma pack ( pop )
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\typeinfo"
namespace std { 
#line 38
constexpr int _Small_object_num_ptrs = ((6) + ((16) / sizeof(void *))); 
#line 95 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\typeinfo"
}
#line 99
#pragma pack ( pop )
#pragma warning(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 25
__declspec(dllimport) int __cdecl _isctype(int _C, int _Type); 
#line 26
__declspec(dllimport) int __cdecl _isctype_l(int _C, int _Type, _locale_t _Locale); 
#line 27
__declspec(dllimport) int __cdecl isalpha(int _C); 
#line 28
__declspec(dllimport) int __cdecl _isalpha_l(int _C, _locale_t _Locale); 
#line 29
__declspec(dllimport) int __cdecl isupper(int _C); 
#line 30
__declspec(dllimport) int __cdecl _isupper_l(int _C, _locale_t _Locale); 
#line 31
__declspec(dllimport) int __cdecl islower(int _C); 
#line 32
__declspec(dllimport) int __cdecl _islower_l(int _C, _locale_t _Locale); 
#line 35
__declspec(dllimport) int __cdecl isdigit(int _C); 
#line 37
__declspec(dllimport) int __cdecl _isdigit_l(int _C, _locale_t _Locale); 
#line 38
__declspec(dllimport) int __cdecl isxdigit(int _C); 
#line 39
__declspec(dllimport) int __cdecl _isxdigit_l(int _C, _locale_t _Locale); 
#line 42
__declspec(dllimport) int __cdecl isspace(int _C); 
#line 44
__declspec(dllimport) int __cdecl _isspace_l(int _C, _locale_t _Locale); 
#line 45
__declspec(dllimport) int __cdecl ispunct(int _C); 
#line 46
__declspec(dllimport) int __cdecl _ispunct_l(int _C, _locale_t _Locale); 
#line 47
__declspec(dllimport) int __cdecl isblank(int _C); 
#line 48
__declspec(dllimport) int __cdecl _isblank_l(int _C, _locale_t _Locale); 
#line 49
__declspec(dllimport) int __cdecl isalnum(int _C); 
#line 50
__declspec(dllimport) int __cdecl _isalnum_l(int _C, _locale_t _Locale); 
#line 51
__declspec(dllimport) int __cdecl isprint(int _C); 
#line 52
__declspec(dllimport) int __cdecl _isprint_l(int _C, _locale_t _Locale); 
#line 53
__declspec(dllimport) int __cdecl isgraph(int _C); 
#line 54
__declspec(dllimport) int __cdecl _isgraph_l(int _C, _locale_t _Locale); 
#line 55
__declspec(dllimport) int __cdecl iscntrl(int _C); 
#line 56
__declspec(dllimport) int __cdecl _iscntrl_l(int _C, _locale_t _Locale); 
#line 59
__declspec(dllimport) int __cdecl toupper(int _C); 
#line 62
__declspec(dllimport) int __cdecl tolower(int _C); 
#line 64
__declspec(dllimport) int __cdecl _tolower(int _C); 
#line 65
__declspec(dllimport) int __cdecl _tolower_l(int _C, _locale_t _Locale); 
#line 66
__declspec(dllimport) int __cdecl _toupper(int _C); 
#line 67
__declspec(dllimport) int __cdecl _toupper_l(int _C, _locale_t _Locale); 
#line 69
__declspec(dllimport) int __cdecl __isascii(int _C); 
#line 70
__declspec(dllimport) int __cdecl __toascii(int _C); 
#line 71
__declspec(dllimport) int __cdecl __iscsymf(int _C); 
#line 72
__declspec(dllimport) int __cdecl __iscsym(int _C); 
#line 81
__inline int __cdecl __acrt_locale_get_ctype_array_value(const unsigned short *const 
#line 82
_Locale_pctype_array, const int 
#line 83
_Char_value, const int 
#line 84
_Mask) 
#line 86
{ 
#line 91
if ((_Char_value >= (-1)) && (_Char_value <= 255)) 
#line 92
{ 
#line 93
return (_Locale_pctype_array[_Char_value]) & _Mask; 
#line 94
}  
#line 96
return 0; 
#line 97
} 
#line 127
__declspec(dllimport) int __cdecl _chvalidator(int _Ch, int _Mask); 
#line 162 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
__inline __crt_locale_data_public *__cdecl __acrt_get_locale_data_prefix(const volatile void *const _LocalePointers) 
#line 163
{ 
#line 164
const _locale_t _TypedLocalePointers = (_locale_t)_LocalePointers; 
#line 165
return (__crt_locale_data_public *)(_TypedLocalePointers->locinfo); 
#line 166
} 
#line 169
__declspec(dllimport) int __cdecl _chvalidator_l(_locale_t, int _Ch, int _Mask); 
#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
__inline int __cdecl _chvalidchk_l(const int 
#line 173
_C, const int 
#line 174
_Mask, const _locale_t 
#line 175
_Locale) 
#line 177
{ 
#line 179
return _chvalidator_l(_Locale, _C, _Mask); 
#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
} 
#line 193
__inline int __cdecl _ischartype_l(const int 
#line 194
_C, const int 
#line 195
_Mask, const _locale_t 
#line 196
_Locale) 
#line 198
{ 
#line 199
if (_Locale && ((__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max) > 1)) 
#line 200
{ 
#line 201
return _isctype_l(_C, _Mask, _Locale); 
#line 202
}  
#line 204
return _chvalidchk_l(_C, _Mask, _Locale); 
#line 205
} 
#line 251 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\ctype.h"
}__pragma( pack ( pop )) 
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 30
struct lconv { 
#line 32
char *decimal_point; 
#line 33
char *thousands_sep; 
#line 34
char *grouping; 
#line 35
char *int_curr_symbol; 
#line 36
char *currency_symbol; 
#line 37
char *mon_decimal_point; 
#line 38
char *mon_thousands_sep; 
#line 39
char *mon_grouping; 
#line 40
char *positive_sign; 
#line 41
char *negative_sign; 
#line 42
char int_frac_digits; 
#line 43
char frac_digits; 
#line 44
char p_cs_precedes; 
#line 45
char p_sep_by_space; 
#line 46
char n_cs_precedes; 
#line 47
char n_sep_by_space; 
#line 48
char p_sign_posn; 
#line 49
char n_sign_posn; 
#line 50
__wchar_t *_W_decimal_point; 
#line 51
__wchar_t *_W_thousands_sep; 
#line 52
__wchar_t *_W_int_curr_symbol; 
#line 53
__wchar_t *_W_currency_symbol; 
#line 54
__wchar_t *_W_mon_decimal_point; 
#line 55
__wchar_t *_W_mon_thousands_sep; 
#line 56
__wchar_t *_W_positive_sign; 
#line 57
__wchar_t *_W_negative_sign; 
#line 58
}; 
#line 60
struct tm; 
#line 84
__declspec(dllimport) void __cdecl _lock_locales(); 
#line 85
__declspec(dllimport) void __cdecl _unlock_locales(); 
#line 88
__declspec(dllimport) int __cdecl _configthreadlocale(int _Flag); 
#line 93
__declspec(dllimport) char *__cdecl setlocale(int _Category, const char * _Locale); 
#line 99
__declspec(dllimport) lconv *__cdecl localeconv(); 
#line 102
__declspec(dllimport) _locale_t __cdecl _get_current_locale(); 
#line 105
__declspec(dllimport) _locale_t __cdecl _create_locale(int _Category, const char * _Locale); 
#line 110
__declspec(dllimport) void __cdecl _free_locale(_locale_t _Locale); 
#line 116
__declspec(dllimport) __wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); 
#line 122
__declspec(dllimport) _locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); 
#line 129
__declspec(dllimport) __wchar_t **__cdecl ___lc_locale_name_func(); 
#line 130
__declspec(dllimport) unsigned __cdecl ___lc_codepage_func(); 
#line 131
__declspec(dllimport) unsigned __cdecl ___lc_collate_cp_func(); 
#line 139
__declspec(dllimport) char *__cdecl _Getdays(); 
#line 143
__declspec(dllimport) char *__cdecl _Getmonths(); 
#line 145
__declspec(dllimport) void *__cdecl _Gettnames(); 
#line 149
__declspec(dllimport) __wchar_t *__cdecl _W_Getdays(); 
#line 153
__declspec(dllimport) __wchar_t *__cdecl _W_Getmonths(); 
#line 155
__declspec(dllimport) void *__cdecl _W_Gettnames(); 
#line 158
__declspec(dllimport) size_t __cdecl _Strftime(char * _Buffer, size_t _Max_size, const char * _Format, const tm * _Timeptr, void * _Lc_time_arg); 
#line 166
__declspec(dllimport) size_t __cdecl _Wcsftime(__wchar_t * _Buffer, size_t _Max_size, const __wchar_t * _Format, const tm * _Timeptr, void * _Lc_time_arg); 
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\locale.h"
}__pragma( pack ( pop )) 
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 20
extern "C" {
#line 61 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo.h"
typedef 
#line 57
struct _Collvec { 
#line 59
unsigned _Page; 
#line 60
__wchar_t *_LocaleName; 
#line 61
} _Collvec; 
#line 69
typedef 
#line 63
struct _Ctypevec { 
#line 65
unsigned _Page; 
#line 66
const short *_Table; 
#line 67
int _Delfl; 
#line 68
__wchar_t *_LocaleName; 
#line 69
} _Ctypevec; 
#line 77
typedef 
#line 71
struct _Cvtvec { 
#line 73
unsigned _Page; 
#line 74
unsigned _Mbcurmax; 
#line 75
int _Isclocale; 
#line 76
unsigned char _Isleadbyte[32]; 
#line 77
} _Cvtvec; 
#line 80
_Collvec __cdecl _Getcoll(); 
#line 81
_Ctypevec __cdecl _Getctype(); 
#line 82
_Cvtvec __cdecl _Getcvt(); 
#line 88 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo.h"
int __cdecl _Getdateorder(); 
#line 100 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo.h"
int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *); 
#line 104 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo.h"
float __cdecl _Stof(const char *, char **, long); 
#line 106
double __cdecl _Stod(const char *, char **, long); 
#line 108
long double __cdecl _Stold(const char *, char **, long); 
#line 111
int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *); 
#line 113
size_t __cdecl _Strxfrm(char * _String1, char * _End1, const char *, const char *, const _Collvec *); 
#line 116
int __cdecl _Tolower(int, const _Ctypevec *); 
#line 117
int __cdecl _Toupper(int, const _Ctypevec *); 
#line 118
int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *); 
#line 120
int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); 
#line 122
size_t __cdecl _Wcsxfrm(__wchar_t * _String1, __wchar_t * _End1, const __wchar_t *, const __wchar_t *, const _Collvec *); 
#line 126
short __cdecl _Getwctype(__wchar_t, const _Ctypevec *); 
#line 127
const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *); 
#line 129
__wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *); 
#line 130
__wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *); 
#line 134
}
#line 138 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo.h"
extern "C" {
#line 141
__declspec(dllimport) char *__cdecl _Getdays(); 
#line 145
__declspec(dllimport) char *__cdecl _Getmonths(); 
#line 147
__declspec(dllimport) void *__cdecl _Gettnames(); 
#line 150
__declspec(dllimport) size_t __cdecl _Strftime(char *, size_t _Maxsize, const char *, const tm *, void *); 
#line 156
__declspec(dllimport) __wchar_t *__cdecl _W_Getdays(); 
#line 160
__declspec(dllimport) __wchar_t *__cdecl _W_Getmonths(); 
#line 162
__declspec(dllimport) void *__cdecl _W_Gettnames(); 
#line 165
__declspec(dllimport) size_t __cdecl _Wcsftime(__wchar_t *, size_t _Maxsize, const __wchar_t *, const tm *, void *); 
#line 168
}
#line 178
_locale_t __cdecl _GetLocaleForCP(unsigned); 
#line 183 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
namespace std { 
#line 19
class __declspec(dllimport) _Timevec { 
#line 22
public: _Timevec(void *_Ptr = 0) : _Timeptr(_Ptr) 
#line 24
{ 
#line 25
} 
#line 27
_Timevec(const _Timevec &_Right) 
#line 28
{ 
#line 29
((*this) = _Right); 
#line 30
} 
#line 32
~_Timevec() noexcept 
#line 33
{ 
#line 34
free(_Timeptr); 
#line 35
} 
#line 37
_Timevec &operator=(const _Timevec &_Right) 
#line 38
{ 
#line 39
(_Timeptr) = (_Right._Timeptr); 
#line 40
(((_Timevec *)(&_Right))->_Timeptr) = (nullptr); 
#line 41
return *this; 
#line 42
} 
#line 44
void *_Getptr() const 
#line 45
{ 
#line 46
return _Timeptr; 
#line 47
} 
#line 50
private: void *_Timeptr; 
#line 51
}; 
#line 54
class __declspec(dllimport) _Locinfo { 
#line 57
public: typedef ::_Collvec _Collvec; 
#line 58
typedef ::_Ctypevec _Ctypevec; 
#line 59
typedef ::_Cvtvec _Cvtvec; 
#line 60
typedef std::_Timevec _Timevec; 
#line 62
static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 
#line 64
static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 
#line 66
static void __cdecl _Locinfo_dtor(_Locinfo *); 
#line 68
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 
#line 71
_Locinfo(const char *_Pch = "C") : _Lock(0) 
#line 76 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo"
{ 
#line 77
if (_Pch == (nullptr)) { 
#line 78
throw ((runtime_error)("bad locale name")); }  
#line 79
_Locinfo_ctor(this, _Pch); 
#line 80
} 
#line 82
_Locinfo(int _Cat, const char *_Pch) : _Lock(0) 
#line 87 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo"
{ 
#line 88
if (_Pch == (nullptr)) { 
#line 89
throw ((runtime_error)("bad locale name")); }  
#line 90
_Locinfo_ctor(this, _Cat, _Pch); 
#line 91
} 
#line 93
~_Locinfo() noexcept 
#line 94
{ 
#line 95
_Locinfo_dtor(this); 
#line 96
} 
#line 98
_Locinfo &_Addcats(int _Cat, const char *_Pch) 
#line 99
{ 
#line 100
if (_Pch == (nullptr)) { 
#line 101
throw ((runtime_error)("bad locale name")); }  
#line 102
return _Locinfo_Addcats(this, _Cat, _Pch); 
#line 103
} 
#line 105
const char *_Getname() const 
#line 106
{ 
#line 107
return (_Newlocname)._C_str(); 
#line 108
} 
#line 110
_Collvec _Getcoll() const 
#line 111
{ 
#line 112
return ::_Getcoll(); 
#line 113
} 
#line 115
_Ctypevec _Getctype() const 
#line 116
{ 
#line 117
return ::_Getctype(); 
#line 118
} 
#line 120
_Cvtvec _Getcvt() const 
#line 121
{ 
#line 122
return ::_Getcvt(); 
#line 123
} 
#line 125
const lconv *_Getlconv() const 
#line 126
{ 
#line 127
return localeconv(); 
#line 128
} 
#line 130
_Timevec _Gettnames() const 
#line 131
{ 
#line 132
return ((std::_Timevec)(::_Gettnames())); 
#line 133
} 
#line 135
const char *_Getdays() const 
#line 136
{ 
#line 137
const char *_Ptr = ::_Getdays(); 
#line 139
if (_Ptr != (nullptr)) 
#line 140
{ 
#line 141
((((_Locinfo *)this)->_Days) = _Ptr); 
#line 142
free((void *)_Ptr); 
#line 143
}  
#line 144
return (!(_Days)._Empty()) ? (_Days)._C_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"); 
#line 147
} 
#line 149
const char *_Getmonths() const 
#line 150
{ 
#line 151
const char *_Ptr = ::_Getmonths(); 
#line 153
if (_Ptr != (nullptr)) 
#line 154
{ 
#line 155
((((_Locinfo *)this)->_Months) = _Ptr); 
#line 156
free((void *)_Ptr); 
#line 157
}  
#line 158
return (!(_Months)._Empty()) ? (_Months)._C_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember"); 
#line 163
} 
#line 165
const char *_Getfalse() const 
#line 166
{ 
#line 167
return "false"; 
#line 168
} 
#line 170
const char *_Gettrue() const 
#line 171
{ 
#line 172
return "true"; 
#line 173
} 
#line 175
int _Getdateorder() const 
#line 176
{ 
#line 177
return ::_Getdateorder(); 
#line 178
} 
#line 180
_Timevec _W_Gettnames() const 
#line 181
{ 
#line 182
return ((std::_Timevec)(::_W_Gettnames())); 
#line 183
} 
#line 185
const unsigned short *_W_Getdays() const 
#line 186
{ 
#line 187
const __wchar_t *_Ptr = ::_W_Getdays(); 
#line 189
if (_Ptr != (nullptr)) 
#line 190
{ 
#line 191
((((_Locinfo *)this)->_W_Days) = _Ptr); 
#line 192
free((void *)_Ptr); 
#line 193
}  
#line 194
return (const unsigned short *)((!(_W_Days)._Empty()) ? (_W_Days)._C_str() : (L"\x3a\x53\x75\x6e\x3a\x53\x75\x6e\x64\x61\x79\x3a\x4d\x6f\x6e\x3a\x4d\x6f\x6e\x64\x61\x79\x3a\x54\x75\x65\x3a\x54\x75\x65\x73\x64" L"\x61\x79\x3a\x57\x65\x64\x3a\x57\x65\x64\x6e\x65\x73\x64\x61\x79\x3a\x54\x68\x75\x3a\x54\x68\x75\x72\x73\x64\x61\x79\x3a\x46\x72" L"\x69\x3a\x46\x72\x69\x64\x61\x79\x3a\x53\x61\x74\x3a\x53\x61\x74\x75\x72\x64\x61\x79")); 
#line 198
} 
#line 200
const unsigned short *_W_Getmonths() const 
#line 201
{ 
#line 202
const __wchar_t *_Ptr = ::_W_Getmonths(); 
#line 204
if (_Ptr != (nullptr)) 
#line 205
{ 
#line 206
((((_Locinfo *)this)->_W_Months) = _Ptr); 
#line 207
free((void *)_Ptr); 
#line 208
}  
#line 209
return (const unsigned short *)((!(_W_Months)._Empty()) ? (_W_Months)._C_str() : (L"\x3a\x4a\x61\x6e\x3a\x4a\x61\x6e\x75\x61\x72\x79\x3a\x46\x65\x62\x3a\x46\x65\x62\x72\x75\x61\x72\x79\x3a\x4d\x61\x72\x3a\x4d\x61" L"\x72\x63\x68\x3a\x41\x70\x72\x3a\x41\x70\x72\x69\x6c\x3a\x4d\x61\x79\x3a\x4d\x61\x79\x3a\x4a\x75\x6e\x3a\x4a\x75\x6e\x65\x3a\x4a" L"\x75\x6c\x3a\x4a\x75\x6c\x79\x3a\x41\x75\x67\x3a\x41\x75\x67\x75\x73\x74\x3a\x53\x65\x70\x3a\x53\x65\x70\x74\x65\x6d\x62\x65\x72" L"\x3a\x4f\x63\x74\x3a\x4f\x63\x74\x6f\x62\x65\x72\x3a\x4e\x6f\x76\x3a\x4e\x6f\x76\x65\x6d\x62\x65\x72\x3a\x44\x65\x63\x3a\x44\x65" L"\x63\x65\x6d\x62\x65\x72")); 
#line 215
} 
#line 217
_Locinfo(const _Locinfo &) = delete;
#line 218
_Locinfo &operator=(const _Locinfo &) = delete;
#line 225
private: _Lockit _Lock; 
#line 228 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocinfo"
_Yarn< char>  _Days; 
#line 229
_Yarn< char>  _Months; 
#line 230
_Yarn< __wchar_t>  _W_Days; 
#line 231
_Yarn< __wchar_t>  _W_Months; 
#line 232
_Yarn< char>  _Oldlocname; 
#line 233
_Yarn< char>  _Newlocname; 
#line 234
}; 
#line 237
template < class _Elem > inline
 int __cdecl _LStrcoll ( const _Elem * _First1, const _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( * _First1 < * _First2 )
   return ( - 1 );
  else if ( * _First2 < * _First1 )
   return ( + 1 );
 return ( _First2 != _Last2 ? - 1 : _First1 != _Last1 ? + 1 : 0 );
 }
#line 251
template<> inline int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *
#line 252
_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 253
_Vector) 
#line 254
{ 
#line 255
return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 256
} 
#line 259
template<> inline int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *
#line 260
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 261
_Vector) 
#line 262
{ 
#line 263
return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 264
} 
#line 267
template < class _Elem > inline
 size_t __cdecl _LStrxfrm ( _Elem * _First1, _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 const ptrdiff_t _Count = _Last2 - _First2;
 if ( _Count <= _Last1 - _First1 )
  {
  :: memcpy ( _First1, _First2, _Count * sizeof ( _Elem ) );
  }

 return ( _Count );
 }
#line 282
template<> inline size_t __cdecl _LStrxfrm(char *
#line 283
_First1, char *_Last1, const char *
#line 284
_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 285
_Vector) 
#line 286
{ 
#line 287
return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 288
} 
#line 291
template<> inline size_t __cdecl _LStrxfrm(__wchar_t *
#line 292
_First1, __wchar_t *_Last1, const __wchar_t *
#line 293
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 294
_Vector) 
#line 295
{ 
#line 296
return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 297
} 
#line 298
}
#line 301
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 17
template < class _Ty > inline
 pair < _Ty *, ptrdiff_t > _Get_temporary_buffer ( ptrdiff_t _Count ) noexcept
 {
 if ( static_cast < size_t > ( _Count ) <= static_cast < size_t > ( - 1 ) / sizeof ( _Ty ) )
  {
  for (; 0 < _Count; _Count /= 2 )
   {
   const auto _Size = static_cast < size_t > ( _Count ) * sizeof ( _Ty );
   void * _Pbuf;











    {
    _Pbuf = :: operator new ( _Size, nothrow );
    }
   if ( _Pbuf )
    {
    return { static_cast < _Ty * > ( _Pbuf ), _Count };
    }
   }
  }

 return { nullptr, 0 };
 }
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory"
template < class _Ty > inline
 void _Return_temporary_buffer ( _Ty * const _Pbuf ) noexcept
 {











  {
  :: operator delete ( _Pbuf );
  }
 }
#line 71 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xmemory"
template < class _FwdIt >
 struct _Uninitialized_backout
 {
 _FwdIt _First;
 _FwdIt _Last;

 explicit _Uninitialized_backout ( _FwdIt _Dest )
  : _First ( _Dest ),
  _Last ( _Dest )
  { }

 _Uninitialized_backout ( _FwdIt _First_, _FwdIt _Last_ )
  : _First ( _First_ ),
  _Last ( _Last_ )
  { }

 _Uninitialized_backout ( const _Uninitialized_backout & ) = delete;
 _Uninitialized_backout & operator = ( const _Uninitialized_backout & ) = delete;

 ~ _Uninitialized_backout ( )
  {
  _Destroy_range ( _First, _Last );
  }

 template < class ... _Types >
  void _Emplace_back ( _Types && ... _Vals )
  {
  _Construct_in_place ( * _Last, :: std :: forward < _Types > ( _Vals ) ... );
  ++ _Last;
  }

 _FwdIt _Release ( )
  {
  _First = _Last;
  return ( _Last );
  }
 };
#line 110
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_move_unchecked1 ( _InIt _First, const _InIt _Last,
  const _FwdIt _Dest, _General_ptr_iterator_tag )
 {
 _Uninitialized_backout < _FwdIt > _Backout { _Dest };
 for (; _First != _Last; ++ _First )
  {
  _Backout . _Emplace_back ( :: std :: move ( * _First ) );
  }

 return ( _Backout . _Release ( ) );
 }
#line 124
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_move_unchecked1 ( const _InIt _First, const _InIt _Last,
  const _FwdIt _Dest, _Really_trivial_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 132
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_move_unchecked ( const _InIt _First, const _InIt _Last,
  const _FwdIt _Dest )
 {
 return ( _Uninitialized_move_unchecked1 ( _First, _Last, _Dest, _Ptr_move_cat ( _First, _Dest ) ) );
 }
#line 141
template < class _FwdIt,
 class _Alloc >
 class _Uninitialized_backout_al
 {
public :
 _Uninitialized_backout_al ( _FwdIt _Dest, _Alloc & _Al_ )
  : _First ( _Dest ),
  _Last ( _Dest ),
  _Al ( _Al_ )
  {
  }

 _Uninitialized_backout_al ( const _Uninitialized_backout_al & ) = delete;
 _Uninitialized_backout_al & operator = ( const _Uninitialized_backout_al & ) = delete;

 ~ _Uninitialized_backout_al ( )
  {
  _Destroy_range ( _First, _Last, _Al );
  }

 template < class ... _Types >
  void _Emplace_back ( _Types && ... _Vals )
  {
  allocator_traits < _Alloc > :: construct ( _Al, _Unfancy ( _Last ), :: std :: forward < _Types > ( _Vals ) ... );
  ++ _Last;
  }

 _FwdIt _Release ( )
  {
  _First = _Last;
  return ( _Last );
  }

private :
 _FwdIt _First;
 _FwdIt _Last;
 _Alloc & _Al;
 };
#line 181
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_copy_al_unchecked ( _InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc & _Al,
  _General_ptr_iterator_tag, _Any_tag )
 {
 _Uninitialized_backout_al < _FwdIt, _Alloc > _Backout { _Dest, _Al };
 for (; _First != _Last; ++ _First )
  {
  _Backout . _Emplace_back ( * _First );
  }

 return ( _Backout . _Release ( ) );
 }
#line 196
template < class _Ty1,
 class _Ty2,
 class _Alloc > inline
 _Ty2 * _Uninitialized_copy_al_unchecked ( _Ty1 * const _First, _Ty1 * const _Last, _Ty2 * const _Dest, _Alloc &,
  _Really_trivial_ptr_iterator_tag, true_type )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 205
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_copy ( const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc & _Al )
 {

 const auto _UFirst = _Get_unwrapped ( _First );
 const auto _ULast = _Get_unwrapped ( _Last );
 const auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
 _Seek_wrapped ( _Dest,
  _Uninitialized_copy_al_unchecked ( _UFirst, _ULast, _UDest, _Al,
   _Ptr_copy_cat ( _UFirst, _UDest ),
   _Uses_default_construct_t < _Alloc, decltype ( _Unfancy ( _UDest ) ), decltype ( * _UFirst ) > ( ) ) );

 return ( _Dest );
 }
#line 223
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_move_al_unchecked ( _InIt _First, const _InIt _Last, const _FwdIt _Dest, _Alloc & _Al,
  _General_ptr_iterator_tag, _Any_tag )
 {
 _Uninitialized_backout_al < _FwdIt, _Alloc > _Backout { _Dest, _Al };
 for (; _First != _Last; ++ _First )
  {
  _Backout . _Emplace_back ( :: std :: move ( * _First ) );
  }

 return ( _Backout . _Release ( ) );
 }
#line 238
template < class _Ty1,
 class _Ty2,
 class _Alloc > inline
 _Ty2 * _Uninitialized_move_al_unchecked ( _Ty1 * const _First, _Ty1 * const _Last, _Ty2 * const _Dest, _Alloc &,
  _Really_trivial_ptr_iterator_tag, true_type )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 247
template < class _InIt,
 class _FwdIt,
 class _Alloc > inline
 _FwdIt _Uninitialized_move ( const _InIt _First, const _InIt _Last, _FwdIt _Dest, _Alloc & _Al )
 {

 const auto _UFirst = _Get_unwrapped ( _First );
 const auto _ULast = _Get_unwrapped ( _Last );
 const auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
 _Seek_wrapped ( _Dest,
  _Uninitialized_move_al_unchecked ( _UFirst, _ULast, _UDest, _Al,
   _Ptr_move_cat ( _UFirst, _UDest ),
   _Uses_default_construct_t < _Alloc, decltype ( _Unfancy ( _UDest ) ), decltype ( :: std :: move ( * _UFirst ) ) > ( ) ) );
 return ( _Dest );
 }
#line 264
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 _FwdIt _Uninit_alloc_fill_n1 ( const _FwdIt _First, _Diff _Count, const _Iter_value_t < _FwdIt > & _Val,
  _Alloc & _Al, false_type )
 {
 _Uninitialized_backout_al < _FwdIt, _Alloc > _Backout { _First, _Al };
 for (; 0 < _Count; -- _Count )
  {
  _Backout . _Emplace_back ( _Val );
  }

 return ( _Backout . _Release ( ) );
 }
#line 279
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 _FwdIt _Uninit_alloc_fill_n1 ( const _FwdIt _First, const _Diff _Count, const _Iter_value_t < _FwdIt > & _Val,
  _Alloc &, true_type )
 {
 :: memset ( _First, static_cast < unsigned char > ( _Val ), static_cast < size_t > ( _Count ) );
 return ( _First + _Count );
 }
#line 289
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 _FwdIt _Uninitialized_fill_n ( const _FwdIt _First, const _Diff _Count, const _Iter_value_t < _FwdIt > & _Val,
  _Alloc & _Al )
 {
 return ( _Uninit_alloc_fill_n1 ( _First, _Count, _Val, _Al,
  bool_constant < conjunction_v < decltype ( _Fill_memset_is_safe ( _First, _Val ) ),
   _Uses_default_construct < _Alloc, decltype ( _Unfancy ( _First ) ), decltype ( _Val ) >> > { } ) );
 }
#line 301
template< class _FwdIt> using _Use_memset_value_construct_t = bool_constant< conjunction_v< is_pointer< _FwdIt> , is_scalar< _Iter_value_t< _FwdIt> > , negation< is_volatile< _Iter_value_t< _FwdIt> > > , negation< is_member_pointer< _Iter_value_t< _FwdIt> > > > > ; 
#line 308
template < class _FwdIt > inline
 _FwdIt _Zero_range ( const _FwdIt _First, const _FwdIt _Last )
 {
 char * const _First_ch = reinterpret_cast < char * > ( _First );
 char * const _Last_ch = reinterpret_cast < char * > ( _Last );
 :: memset ( _First_ch, 0, static_cast < size_t > ( _Last_ch - _First_ch ) );
 return ( _Last );
 }
#line 317
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 _FwdIt _Uninitialized_value_construct_n1 ( const _FwdIt _First, _Diff _Count, _Alloc & _Al, false_type )
 {
 _Uninitialized_backout_al < _FwdIt, _Alloc > _Backout { _First, _Al };
 for (; 0 < _Count; -- _Count )
  {
  _Backout . _Emplace_back ( );
  }

 return ( _Backout . _Release ( ) );
 }
#line 331
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 _FwdIt _Uninitialized_value_construct_n1 ( _FwdIt _First, _Diff _Count, _Alloc &, true_type )
 {
 return ( _Zero_range ( _First, _First + _Count ) );
 }
#line 339
template < class _FwdIt,
 class _Diff,
 class _Alloc > inline
 _FwdIt _Uninitialized_value_construct_n ( _FwdIt _First, _Diff _Count, _Alloc & _Al )
 {
 return ( _Uninitialized_value_construct_n1 ( _First, _Count, _Al,
  bool_constant < conjunction_v < _Use_memset_value_construct_t < _FwdIt >,
   _Uses_default_construct < _Alloc, decltype ( _Unfancy ( _First ) ) >> > { } ) );
 }
#line 350
struct _Not_a_node_tag { 
#line 352
}; 
#line 355
template < class _Ty >
   pair < _Ty *, ptrdiff_t > get_temporary_buffer ( ptrdiff_t _Count ) noexcept
 {
 return ( _Get_temporary_buffer < _Ty > ( _Count ) );
 }
#line 362
template < class _Ty >
  void return_temporary_buffer ( _Ty * _Pbuf )
 {
 _Return_temporary_buffer ( _Pbuf );
 }
#line 367
}
#line 371
#pragma warning(pop)
#pragma pack ( pop )
#line 11 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 18
namespace std { 
#line 20
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_unchecked ( _InIt _First, const _InIt _Last,
  const _FwdIt _Dest, _General_ptr_iterator_tag )
 {
 _Uninitialized_backout < _FwdIt > _Backout { _Dest };
 for (; _First != _Last; ++ _First )
  {
  _Backout . _Emplace_back ( * _First );
  }

 return ( _Backout . _Release ( ) );
 }
#line 34
template < class _InIt,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_unchecked ( const _InIt _First, const _InIt _Last,
  const _FwdIt _Dest, _Really_trivial_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _Last, _Dest ) );
 }
#line 42
template < class _InIt,
 class _FwdIt > inline
 _FwdIt uninitialized_copy ( const _InIt _First, const _InIt _Last, _FwdIt _Dest )
 {
 _Adl_verify_range ( _First, _Last );
 const auto _UFirst = _Get_unwrapped ( _First );
 const auto _ULast = _Get_unwrapped ( _Last );
 const auto _UDest = _Get_unwrapped_n ( _Dest, _Idl_distance < _InIt > ( _UFirst, _ULast ) );
 _Seek_wrapped ( _Dest,
  _Uninitialized_copy_unchecked ( _UFirst, _ULast, _UDest, _Ptr_copy_cat ( _UFirst, _UDest ) ) );
 return ( _Dest );
 }
#line 56
template < class _InIt,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * uninitialized_copy ( const _InIt _First, const _InIt _Last,
  _OutTy ( & _Dest ) [ _OutSize ] )
 {
 return ( :: std :: uninitialized_copy ( _First, _Last, _Array_iterator < _OutTy, _OutSize > ( _Dest ) ) . _Unwrapped ( ) );
 }
#line 68 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n_unchecked2 ( _InIt _First, _Diff _Count,
  const _FwdIt _Dest, _General_ptr_iterator_tag )
 {
 _Uninitialized_backout < _FwdIt > _Backout { _Dest };
 for (; 0 < _Count; -- _Count, ( void ) ++ _First )
  {
  _Backout . _Emplace_back ( * _First );
  }

 return ( _Backout . _Release ( ) );
 }
#line 83
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt _Uninitialized_copy_n_unchecked2 ( const _InIt _First, const _Diff _Count,
  const _FwdIt _Dest, _Really_trivial_ptr_iterator_tag )
 {
 return ( _Copy_memmove ( _First, _First + _Count, _Dest ) );
 }
#line 92
template < class _InIt,
 class _Diff,
 class _FwdIt > inline
 _FwdIt uninitialized_copy_n ( const _InIt _First, const _Diff _Count_raw, _FwdIt _Dest )
 {
 _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  const auto _UFirst = _Get_unwrapped_n ( _First, _Count );
  const auto _UDest = _Get_unwrapped_n ( _Dest, _Count );
  _Seek_wrapped ( _Dest,
   _Uninitialized_copy_n_unchecked2 ( _UFirst, _Count, _UDest, _Ptr_copy_cat ( _UFirst, _UDest ) ) );
  }

 return ( _Dest );
 }
#line 110
template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _FwdIt > inline
 _FwdIt uninitialized_copy_n ( _InTy ( & _First ) [ _InSize ], const _Diff _Count_raw, _FwdIt _Dest )
 {
 _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  do { if ( ( :: std :: size ( _First ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory", 119, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x6d\x65\x6d\x6f\x72\x79", 119, 0 ); } while ( false ); }; } while ( false );
  const auto _UDest = _Get_unwrapped_n ( _Dest, _Count );
  _Seek_wrapped ( _Dest,
   _Uninitialized_copy_n_unchecked2 ( _First, _Count, _UDest, _Ptr_copy_cat ( _First, _UDest ) ) );
  }

 return ( _Dest );
 }
#line 128
template < class _InIt,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * uninitialized_copy_n ( const _InIt _First, const _Diff _Count_raw, _OutTy ( & _Dest ) [ _OutSize ] )
 {
 _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  do { if ( ( :: std :: size ( _Dest ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory", 137, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x6d\x65\x6d\x6f\x72\x79", 137, 0 ); } while ( false ); }; } while ( false );
  const auto _UFirst = _Get_unwrapped_n ( _First, _Count );
  return ( _Uninitialized_copy_n_unchecked2 ( _UFirst, _Count, _Dest, _Ptr_copy_cat ( _UFirst, _Dest ) ) );
  }

 return ( _Dest );
 }
#line 145
template < class _InTy,
 size_t _InSize,
 class _Diff,
 class _OutTy,
 size_t _OutSize > inline
 _OutTy * uninitialized_copy_n ( _InTy ( & _First ) [ _InSize ], const _Diff _Count_raw, _OutTy ( & _Dest ) [ _OutSize ] )
 {
 _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  do { if ( ( :: std :: size ( _First ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory", 155, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x6d\x65\x6d\x6f\x72\x79", 155, 0 ); } while ( false ); }; } while ( false );
  do { if ( ( :: std :: size ( _Dest ) >= static_cast < common_type_t < size_t, decltype ( _Count ) >> ( _Count ) ) ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory", 156, 0, "%s", "array too small" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x72\x72\x61\x79\x20\x74\x6f\x6f\x20\x73\x6d\x61\x6c\x6c\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x6d\x65\x6d\x6f\x72\x79", 156, 0 ); } while ( false ); }; } while ( false );
  return ( _Uninitialized_copy_n_unchecked2 ( _First, _Count, _Dest, _Ptr_copy_cat ( _First, _Dest ) ) );
  }

 return ( _Dest );
 }
#line 306 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _FwdIt,
 class _Tval > inline
 void _Uninitialized_fill_unchecked ( const _FwdIt _First, const _FwdIt _Last, const _Tval & _Val, false_type )
 {
 _Uninitialized_backout < _FwdIt > _Backout { _First };
 while ( _Backout . _Last != _Last )
  {
  _Backout . _Emplace_back ( _Val );
  }

 _Backout . _Release ( );
 }
#line 319
template < class _FwdIt,
 class _Tval > inline
 void _Uninitialized_fill_unchecked ( const _FwdIt _First, const _FwdIt _Last, const _Tval & _Val, true_type )
 {
 :: memset ( _First, static_cast < unsigned char > ( _Val ), static_cast < size_t > ( _Last - _First ) );
 }
#line 326
template < class _FwdIt,
 class _Tval > inline
 void uninitialized_fill ( const _FwdIt _First, const _FwdIt _Last, const _Tval & _Val )
 {
 _Adl_verify_range ( _First, _Last );
 const auto _UFirst = _Get_unwrapped ( _First );
 _Uninitialized_fill_unchecked ( _UFirst, _Get_unwrapped ( _Last ), _Val, _Fill_memset_is_safe ( _UFirst, _Val ) );
 }
#line 338
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 _FwdIt _Uninitialized_fill_n_unchecked1 ( const _FwdIt _First, _Diff _Count, const _Tval & _Val, false_type )
 {
 _Uninitialized_backout < _FwdIt > _Backout { _First };
 for (; 0 < _Count; -- _Count )
  {
  _Backout . _Emplace_back ( _Val );
  }

 return ( _Backout . _Release ( ) );
 }
#line 352
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 _FwdIt _Uninitialized_fill_n_unchecked1 ( const _FwdIt _First, const _Diff _Count, const _Tval & _Val, true_type )
 {
 :: memset ( _First, static_cast < unsigned char > ( _Val ), _Count );
 return ( _First + _Count );
 }
#line 361
template < class _FwdIt,
 class _Diff,
 class _Tval > inline
 _FwdIt uninitialized_fill_n ( _FwdIt _First, const _Diff _Count_raw, const _Tval & _Val )
 {
 _Algorithm_int_t < _Diff > _Count = _Count_raw;
 if ( 0 < _Count )
  {
  const auto _UFirst = _Get_unwrapped_n ( _First, _Count );
  _Seek_wrapped ( _First,
   _Uninitialized_fill_n_unchecked1 ( _UFirst, _Count, _Val, _Fill_memset_is_safe ( _UFirst, _Val ) ) );
  }

 return ( _First );
 }
#line 564 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _OutIt,
 class _Ty >
 class raw_storage_iterator
 {
public :
 using iterator_category = output_iterator_tag;
 using value_type = void;
 using difference_type = void;
 using pointer = void;
 using reference = void;

 explicit raw_storage_iterator ( _OutIt _First )
  : _Next ( _First )
  {
  }

  raw_storage_iterator & operator * ( )
  {
  return ( * this );
  }

 raw_storage_iterator & operator = ( const _Ty & _Val )
  {
  _Construct_in_place ( * _Next, _Val );
  return ( * this );
  }

 raw_storage_iterator & operator = ( _Ty && _Val )
  {
  _Construct_in_place ( * _Next, :: std :: move ( _Val ) );
  return ( * this );
  }

 raw_storage_iterator & operator ++ ( )
  {
  ++ _Next;
  return ( * this );
  }

 raw_storage_iterator operator ++ ( int )
  {
  raw_storage_iterator _Ans = * this;
  ++ _Next;
  return ( _Ans );
  }

  _OutIt base ( ) const
  {
  return ( _Next );
  }

private :
 _OutIt _Next;
 };
#line 622
template < class _Ty >
 class auto_ptr;
#line 625
template < class _Ty >
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref ( _Ty * _Right )
  : _Ref ( _Right )
  {
  }

 _Ty * _Ref;
 };
#line 636
template < class _Ty >
 class auto_ptr
 {
public :
 typedef _Ty element_type;

 explicit auto_ptr ( _Ty * _Ptr = nullptr ) noexcept
  : _Myptr ( _Ptr )
  {
  }

 auto_ptr ( auto_ptr & _Right ) noexcept
  : _Myptr ( _Right . release ( ) )
  {
  }

 auto_ptr ( auto_ptr_ref < _Ty > _Right ) noexcept
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = nullptr;
  _Myptr = _Ptr;
  }

 template < class _Other >
  operator auto_ptr < _Other > ( ) noexcept
  {
  return ( auto_ptr < _Other > ( * this ) );
  }

 template < class _Other >
  operator auto_ptr_ref < _Other > ( ) noexcept
  {
  _Other * _Cvtptr = _Myptr;
  auto_ptr_ref < _Other > _Ans ( _Cvtptr );
  _Myptr = nullptr;
  return ( _Ans );
  }

 template < class _Other >
  auto_ptr & operator = ( auto_ptr < _Other > & _Right ) noexcept
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 template < class _Other >
  auto_ptr ( auto_ptr < _Other > & _Right ) noexcept
  : _Myptr ( _Right . release ( ) )
  {
  }

 auto_ptr & operator = ( auto_ptr & _Right ) noexcept
  {
  reset ( _Right . release ( ) );
  return ( * this );
  }

 auto_ptr & operator = ( auto_ptr_ref < _Ty > _Right ) noexcept
  {
  _Ty * _Ptr = _Right . _Ref;
  _Right . _Ref = 0;
  reset ( _Ptr );
  return ( * this );
  }

 ~ auto_ptr ( ) noexcept
  {
  delete _Myptr;
  }

  _Ty & operator * ( ) const noexcept
  {

  do { if ( _Myptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory", 709, 0, "%s", "auto_ptr not dereferencable" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x75\x74\x6f\x5f\x70\x74\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62\x6c\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x6d\x65\x6d\x6f\x72\x79", 709, 0 ); } while ( false ); }; } while ( false );


  return ( * get ( ) );
  }

  _Ty * operator -> ( ) const noexcept
  {

  do { if ( _Myptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory", 718, 0, "%s", "auto_ptr not dereferencable" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x61\x75\x74\x6f\x5f\x70\x74\x72\x20\x6e\x6f\x74\x20\x64\x65\x72\x65\x66\x65\x72\x65\x6e\x63\x61\x62\x6c\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x6d\x65\x6d\x6f\x72\x79", 718, 0 ); } while ( false ); }; } while ( false );


  return ( get ( ) );
  }

  _Ty * get ( ) const noexcept
  {
  return ( _Myptr );
  }

 _Ty * release ( ) noexcept
  {
  _Ty * _Tmp = _Myptr;
  _Myptr = nullptr;
  return ( _Tmp );
  }

 void reset ( _Ty * _Ptr = nullptr )
  {
  if ( _Ptr != _Myptr )
   delete _Myptr;
  _Myptr = _Ptr;
  }

private :
 _Ty * _Myptr;
 };
#line 748 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
#pragma pack(8)
template<> 
#line 748
class auto_ptr< void>  { 
#line 751
public: typedef void element_type; 
#line 752
}; 
#pragma pack()
#line 757 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
#pragma pack(8)
#line 757
class bad_weak_ptr : public exception { 
#line 761
public: bad_weak_ptr() noexcept 
#line 762
{ 
#line 763
} 
#line 765
virtual const char *what() const noexcept override 
#line 766
{ 
#line 767
return "bad_weak_ptr"; 
#line 768
} 
#line 769
}; 
#pragma pack()
#line 772
#pragma pack(8)
#line 772
class __declspec(novtable) _Ref_count_base { 
#line 786
virtual void _Destroy() noexcept = 0; 
#line 787
virtual void _Delete_this() noexcept = 0; 
#line 790 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
_Atomic_counter_t _Uses; 
#line 791
_Atomic_counter_t _Weaks; 
#line 794
protected: _Ref_count_base() : _Uses((1)), _Weaks((1)) 
#line 796
{ 
#line 797
} 
#line 800
public: virtual ~_Ref_count_base() noexcept 
#line 801
{ 
#line 802
} 
#line 804
bool _Incref_nz() 
#line 805
{ 
#line 806
for (; ;) 
#line 807
{ 
#line 809
const _Atomic_integral_t _Count = static_cast< volatile _Atomic_counter_t &>(_Uses); 
#line 812
if (_Count == (0)) { 
#line 813
return false; }  
#line 815
if ((static_cast< _Atomic_integral_t>(_InterlockedCompareExchange(reinterpret_cast< volatile long *>(&(_Uses)), static_cast< long>(_Count + (1)), static_cast< long>(_Count)))) == _Count) { 
#line 818
return true; }  
#line 830 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
}  
#line 831
} 
#line 833
void _Incref() 
#line 834
{ 
#line 835
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Uses))); 
#line 836
} 
#line 838
void _Incwref() 
#line 839
{ 
#line 840
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Weaks))); 
#line 841
} 
#line 843
void _Decref() 
#line 844
{ 
#line 845
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Uses))) == (0)) 
#line 846
{ 
#line 847
this->_Destroy(); 
#line 848
this->_Decwref(); 
#line 849
}  
#line 850
} 
#line 852
void _Decwref() 
#line 853
{ 
#line 854
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Weaks))) == (0)) 
#line 855
{ 
#line 856
this->_Delete_this(); 
#line 857
}  
#line 858
} 
#line 860
long _Use_count() const noexcept 
#line 861
{ 
#line 862
return static_cast< long>(_Get_atomic_count(_Uses)); 
#line 863
} 
#line 865
virtual void *_Get_deleter(const type_info &) const noexcept 
#line 866
{ 
#line 867
return nullptr; 
#line 868
} 
#line 869
}; 
#pragma pack()
#line 872
template < class _Ty >
 class _Ref_count
  : public _Ref_count_base
 {
public :
 explicit _Ref_count ( _Ty * _Px )
  : _Ref_count_base ( ), _Ptr ( _Px )
  {
  }

private :
 virtual void _Destroy ( ) noexcept override
  {
  delete _Ptr;
  }

 virtual void _Delete_this ( ) noexcept override
  {
  delete this;
  }

 _Ty * _Ptr;
 };
#line 897
template < class _Resource,
 class _Dx >
 class _Ref_count_resource
  : public _Ref_count_base
 {
public :
 _Ref_count_resource ( _Resource _Px, _Dx _Dt )
  : _Ref_count_base ( ), _Mypair ( _One_then_variadic_args_t ( ), :: std :: move ( _Dt ), _Px )
  {
  }

 virtual void * _Get_deleter ( const type_info & _Typeid ) const noexcept override
  {

  if ( _Typeid == typeid ( _Dx ) )
   {
   return ( const_cast < _Dx * > ( :: std :: addressof ( _Mypair . _Get_first ( ) ) ) );
   }




  return ( nullptr );
  }

private :
 virtual void _Destroy ( ) noexcept override
  {
  _Mypair . _Get_first ( ) ( _Mypair . _Get_second ( ) );
  }

 virtual void _Delete_this ( ) noexcept override
  {
  delete this;
  }

 _Compressed_pair < _Dx, _Resource > _Mypair;
 };
#line 937 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _Resource,
 class _Dx,
 class _Alloc >
 class _Ref_count_resource_alloc
  : public _Ref_count_base
 {
public :
 _Ref_count_resource_alloc ( _Resource _Px, _Dx _Dt, const _Alloc & _Ax )
  : _Ref_count_base ( ), _Mypair ( _One_then_variadic_args_t ( ), :: std :: move ( _Dt ),
   _One_then_variadic_args_t ( ), _Ax, _Px )
  {
  }

 virtual void * _Get_deleter ( const type_info & _Typeid ) const noexcept override
  {

  if ( _Typeid == typeid ( _Dx ) )
   {
   return ( const_cast < _Dx * > ( :: std :: addressof ( _Mypair . _Get_first ( ) ) ) );
   }




  return ( nullptr );
  }

private :
 using _Myalty = _Rebind_alloc_t < _Alloc, _Ref_count_resource_alloc >;

 virtual void _Destroy ( ) noexcept override
  {
  _Mypair . _Get_first ( ) ( _Mypair . _Get_second ( ) . _Get_second ( ) );
  }

 virtual void _Delete_this ( ) noexcept override
  {
  _Myalty _Al = _Mypair . _Get_second ( ) . _Get_first ( );
  allocator_traits < _Myalty > :: destroy ( _Al, this );
  _Deallocate_plain ( _Al, this );
  }

 _Compressed_pair < _Dx, _Compressed_pair < _Myalty, _Resource >> _Mypair;
 };
#line 983 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _Ty >
 struct default_delete;
#line 986
template < class _Ty,
 class _Dx = default_delete < _Ty > >
 class unique_ptr;
#line 990
template < class _Ty >
 class shared_ptr;
#line 993
template < class _Ty >
 class weak_ptr;
#line 996
template< class _Yty, class 
#line 997
 = void> 
#line 998
struct _Can_enable_shared : public false_type { 
#line 1001
}; 
#line 1003
template< class _Yty> 
#line 1004
struct _Can_enable_shared< _Yty, void_t< typename _Yty::_Esft_type> >  : public is_convertible< remove_cv_t< _Yty>  *, typename _Yty::_Esft_type *> ::type { 
#line 1007
}; 
#line 1009
template < class _Other,
 class _Yty >
 void _Enable_shared_from_this1 ( const shared_ptr < _Other > & _This, _Yty * _Ptr, true_type )
 {
 if ( _Ptr && _Ptr -> _Wptr . expired ( ) )
  {
  _Ptr -> _Wptr = shared_ptr < remove_cv_t < _Yty >> ( _This, const_cast < remove_cv_t < _Yty > * > ( _Ptr ) );
  }
 }
#line 1019
template < class _Other,
 class _Yty >
 void _Enable_shared_from_this1 ( const shared_ptr < _Other > &, _Yty *, false_type )
 {
 }
#line 1025
template < class _Other,
 class _Yty >
 void _Enable_shared_from_this ( const shared_ptr < _Other > & _This, _Yty * _Ptr )
 {
 _Enable_shared_from_this1 ( _This, _Ptr, bool_constant < conjunction_v <
  negation < is_array < _Other >>,
  negation < is_volatile < _Yty >>,
  _Can_enable_shared < _Yty >> > { } );
 }
#line 1036
template < class _Ty >
 class _Ptr_base
 {
public :
 using element_type = remove_extent_t < _Ty >;

  long use_count ( ) const noexcept
  {
  return ( _Rep ? _Rep -> _Use_count ( ) : 0 );
  }

 template < class _Ty2 >
   bool owner_before ( const _Ptr_base < _Ty2 > & _Right ) const noexcept
  {
  return ( _Rep < _Right . _Rep );
  }

 _Ptr_base ( const _Ptr_base & ) = delete;
 _Ptr_base & operator = ( const _Ptr_base & ) = delete;

protected :
  element_type * get ( ) const noexcept
  {
  return ( _Ptr );
  }

 constexpr _Ptr_base ( ) noexcept = default;

 ~ _Ptr_base ( ) = default;

 template < class _Ty2 >
  void _Move_construct_from ( _Ptr_base < _Ty2 > && _Right )
  {
  _Ptr = _Right . _Ptr;
  _Rep = _Right . _Rep;

  _Right . _Ptr = nullptr;
  _Right . _Rep = nullptr;
  }

 template < class _Ty2 >
  void _Copy_construct_from ( const shared_ptr < _Ty2 > & _Other )
  {
  if ( _Other . _Rep )
   {
   _Other . _Rep -> _Incref ( );
   }

  _Ptr = _Other . _Ptr;
  _Rep = _Other . _Rep;
  }

 template < class _Ty2 >
  void _Alias_construct_from ( const shared_ptr < _Ty2 > & _Other, element_type * _Px )
  {
  if ( _Other . _Rep )
   {
   _Other . _Rep -> _Incref ( );
   }

  _Ptr = _Px;
  _Rep = _Other . _Rep;
  }

 template < class _Ty0 >
  friend class weak_ptr;

 template < class _Ty2 >
  bool _Construct_from_weak ( const weak_ptr < _Ty2 > & _Other )
  {
  if ( _Other . _Rep && _Other . _Rep -> _Incref_nz ( ) )
   {
   _Ptr = _Other . _Ptr;
   _Rep = _Other . _Rep;
   return ( true );
   }

  return ( false );
  }

 void _Decref ( )
  {
  if ( _Rep )
   {
   _Rep -> _Decref ( );
   }
  }

 void _Swap ( _Ptr_base & _Right ) noexcept
  {
  :: std :: swap ( _Ptr, _Right . _Ptr );
  :: std :: swap ( _Rep, _Right . _Rep );
  }

 void _Set_ptr_rep ( element_type * _Other_ptr, _Ref_count_base * _Other_rep )
  {
  _Ptr = _Other_ptr;
  _Rep = _Other_rep;
  }

 template < class _Ty2 >
  void _Weakly_construct_from ( const _Ptr_base < _Ty2 > & _Other )
  {
  if ( _Other . _Rep )
   {
   _Other . _Rep -> _Incwref ( );
   }

  _Ptr = _Other . _Ptr;
  _Rep = _Other . _Rep;
  }

 void _Decwref ( )
  {
  if ( _Rep )
   {
   _Rep -> _Decwref ( );
   }
  }

private :
 element_type * _Ptr { nullptr };
 _Ref_count_base * _Rep { nullptr };

 template < class _Ty0 >
  friend class _Ptr_base;


 template < class _Dx,
  class _Ty0 >
  friend _Dx * get_deleter ( const shared_ptr < _Ty0 > & _Sx ) noexcept;

 };
#line 1171 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template< class _Yty, class 
#line 1172
 = void> 
#line 1173
struct _Can_scalar_delete : public false_type { 
#line 1175
}; 
#line 1176
template< class _Yty> 
#line 1177
struct _Can_scalar_delete< _Yty, void_t< decltype((delete std::declval< _Yty *> ()))> >  : public true_type { 
#line 1179
}; 
#line 1182
template< class _Yty, class 
#line 1183
 = void> 
#line 1184
struct _Can_array_delete : public false_type { 
#line 1186
}; 
#line 1187
template< class _Yty> 
#line 1188
struct _Can_array_delete< _Yty, void_t< decltype((delete [] std::declval< _Yty *> ()))> >  : public true_type { 
#line 1190
}; 
#line 1193
template< class _Fx, class 
#line 1194
_Arg, class 
#line 1195
 = void> 
#line 1196
struct _Can_call_function_object : public false_type { 
#line 1198
}; 
#line 1199
template< class _Fx, class 
#line 1200
_Arg> 
#line 1201
struct _Can_call_function_object< _Fx, _Arg, void_t< decltype((std::declval< _Fx> ()(std::declval< _Arg> ())))> >  : public true_type { 
#line 1203
}; 
#line 1206
template< class _Yty, class 
#line 1207
_Ty> 
#line 1208
struct _SP_convertible : public is_convertible< _Yty *, _Ty *> ::type { 
#line 1210
}; 
#line 1211
template< class _Yty, class 
#line 1212
_Uty> 
#line 1213
struct _SP_convertible< _Yty, _Uty []>  : public is_convertible< _Yty (*)[], _Uty (*)[]> ::type { 
#line 1215
}; 
#line 1216
template< class _Yty, class 
#line 1217
_Uty, size_t 
#line 1218
_Ext> 
#line 1219
struct _SP_convertible< _Yty, _Uty [_Ext]>  : public is_convertible< _Yty (*)[_Ext], _Uty (*)[_Ext]> ::type { 
#line 1221
}; 
#line 1224
template< class _Yty, class 
#line 1225
_Ty> 
#line 1226
struct _SP_pointer_compatible : public is_convertible< _Yty *, _Ty *> ::type { 
#line 1230
}; 
#line 1231
template< class _Uty, size_t 
#line 1232
_Ext> 
#line 1233
struct _SP_pointer_compatible< _Uty [_Ext], _Uty []>  : public true_type { 
#line 1236
}; 
#line 1237
template< class _Uty, size_t 
#line 1238
_Ext> 
#line 1239
struct _SP_pointer_compatible< _Uty [_Ext], const _Uty []>  : public true_type { 
#line 1242
}; 
#line 1243
template< class _Uty, size_t 
#line 1244
_Ext> 
#line 1245
struct _SP_pointer_compatible< _Uty [_Ext], volatile _Uty []>  : public true_type { 
#line 1248
}; 
#line 1249
template< class _Uty, size_t 
#line 1250
_Ext> 
#line 1251
struct _SP_pointer_compatible< _Uty [_Ext], const volatile _Uty []>  : public true_type { 
#line 1254
}; 
#line 1257
template < class _Ty >
 class shared_ptr
  : public _Ptr_base < _Ty >
 {
private :
 using _Mybase = _Ptr_base < _Ty >;

public :
 using typename _Mybase :: element_type;





 constexpr shared_ptr ( ) noexcept
  {
  }

 constexpr shared_ptr ( nullptr_t ) noexcept
  {
  }

 template < class _Ux,
  enable_if_t < conjunction_v < conditional_t < is_array_v < _Ty >, _Can_array_delete < _Ux >, _Can_scalar_delete < _Ux >>,
   _SP_convertible < _Ux, _Ty >>, int > = 0 >
  explicit shared_ptr ( _Ux * _Px )
  {
  _Setp ( _Px, is_array < _Ty > { } );
  }

 template < class _Ux,
  class _Dx,
  enable_if_t < conjunction_v < is_move_constructible < _Dx >,
   _Can_call_function_object < _Dx &, _Ux * & >,
   _SP_convertible < _Ux, _Ty >>, int > = 0 >
  shared_ptr ( _Ux * _Px, _Dx _Dt )
  {
  _Setpd ( _Px, :: std :: move ( _Dt ) );
  }

 template < class _Ux,
  class _Dx,
  class _Alloc,
  enable_if_t < conjunction_v < is_move_constructible < _Dx >,
   _Can_call_function_object < _Dx &, _Ux * & >,
   _SP_convertible < _Ux, _Ty >>, int > = 0 >
  shared_ptr ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  _Setpda ( _Px, :: std :: move ( _Dt ), _Ax );
  }

 template < class _Dx,
  enable_if_t < conjunction_v < is_move_constructible < _Dx >,
   _Can_call_function_object < _Dx &, nullptr_t & >
  >, int > = 0 >
  shared_ptr ( nullptr_t, _Dx _Dt )
  {
  _Setpd ( nullptr, :: std :: move ( _Dt ) );
  }

 template < class _Dx,
  class _Alloc,
  enable_if_t < conjunction_v < is_move_constructible < _Dx >,
   _Can_call_function_object < _Dx &, nullptr_t & >
  >, int > = 0 >
  shared_ptr ( nullptr_t, _Dx _Dt, _Alloc _Ax )
  {
  _Setpda ( nullptr, :: std :: move ( _Dt ), _Ax );
  }

 template < class _Ty2 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Right, element_type * _Px ) noexcept
  {
  this -> _Alias_construct_from ( _Right, _Px );
  }

 shared_ptr ( const shared_ptr & _Other ) noexcept
  {
  this -> _Copy_construct_from ( _Other );
  }

 template < class _Ty2,
  enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
  shared_ptr ( const shared_ptr < _Ty2 > & _Other ) noexcept
  {
  this -> _Copy_construct_from ( _Other );
  }

 shared_ptr ( shared_ptr && _Right ) noexcept
  {
  this -> _Move_construct_from ( :: std :: move ( _Right ) );
  }

 template < class _Ty2,
  enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
  shared_ptr ( shared_ptr < _Ty2 > && _Right ) noexcept
  {
  this -> _Move_construct_from ( :: std :: move ( _Right ) );
  }

 template < class _Ty2,
  enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
  explicit shared_ptr ( const weak_ptr < _Ty2 > & _Other )
  {
  if ( ! this -> _Construct_from_weak ( _Other ) )
   {
   throw bad_weak_ptr { };
   }
  }


 template < class _Ty2,
  enable_if_t < is_convertible_v < _Ty2 *, _Ty * >, int > = 0 >
  shared_ptr ( auto_ptr < _Ty2 > && _Other )
  {
  _Ty2 * _Px = _Other . get ( );
  _Set_ptr_rep_and_enable_shared ( _Px, new _Ref_count < _Ty2 > ( _Px ) );
  _Other . release ( );
  }


 template < class _Ux,
  class _Dx,
  enable_if_t < conjunction_v <
   _SP_pointer_compatible < _Ux, _Ty >,
   is_convertible < typename unique_ptr < _Ux, _Dx > :: pointer, element_type * >
  >, int > = 0 >
  shared_ptr ( unique_ptr < _Ux, _Dx > && _Other )
  {
  using _Fancy_t = typename unique_ptr < _Ux, _Dx > :: pointer;
  using _Raw_t = typename unique_ptr < _Ux, _Dx > :: element_type *;
  using _Deleter_t = conditional_t < is_reference_v < _Dx >, decltype ( :: std :: ref ( _Other . get_deleter ( ) ) ), _Dx >;

  const _Fancy_t _Fancy = _Other . get ( );

  if ( _Fancy )
   {
   const _Raw_t _Raw = _Fancy;
   const auto _Rx = new _Ref_count_resource < _Fancy_t, _Deleter_t > ( _Fancy, _Other . get_deleter ( ) );
   _Set_ptr_rep_and_enable_shared ( _Raw, _Rx );
   _Other . release ( );
   }
  }

 ~ shared_ptr ( ) noexcept
  {
  this -> _Decref ( );
  }

 shared_ptr & operator = ( const shared_ptr & _Right ) noexcept
  {
  shared_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  shared_ptr & operator = ( const shared_ptr < _Ty2 > & _Right ) noexcept
  {
  shared_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 shared_ptr & operator = ( shared_ptr && _Right ) noexcept
  {
  shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  shared_ptr & operator = ( shared_ptr < _Ty2 > && _Right ) noexcept
  {
  shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }


 template < class _Ty2 >
  shared_ptr & operator = ( auto_ptr < _Ty2 > && _Right )
  {
  shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }


 template < class _Ux,
  class _Dx >
  shared_ptr & operator = ( unique_ptr < _Ux, _Dx > && _Right )
  {
  shared_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }

 void swap ( shared_ptr & _Other ) noexcept
  {
  this -> _Swap ( _Other );
  }

 void reset ( ) noexcept
  {
  shared_ptr ( ) . swap ( * this );
  }

 template < class _Ux >
  void reset ( _Ux * _Px )
  {
  shared_ptr ( _Px ) . swap ( * this );
  }

 template < class _Ux,
  class _Dx >
  void reset ( _Ux * _Px, _Dx _Dt )
  {
  shared_ptr ( _Px, _Dt ) . swap ( * this );
  }

 template < class _Ux,
  class _Dx,
  class _Alloc >
  void reset ( _Ux * _Px, _Dx _Dt, _Alloc _Ax )
  {
  shared_ptr ( _Px, _Dt, _Ax ) . swap ( * this );
  }

 using _Mybase :: get;

 template < class _Ty2 = _Ty,
  enable_if_t < ! disjunction_v < is_array < _Ty2 >, is_void < _Ty2 >>, int > = 0 >
   _Ty2 & operator * ( ) const noexcept
  {
  return ( * get ( ) );
  }

 template < class _Ty2 = _Ty,
  enable_if_t < ! is_array_v < _Ty2 >, int > = 0 >
   _Ty2 * operator -> ( ) const noexcept
  {
  return ( get ( ) );
  }

 template < class _Ty2 = _Ty,
  class _Elem = element_type,
  enable_if_t < is_array_v < _Ty2 >, int > = 0 >
   _Elem & operator [ ] ( ptrdiff_t _Idx ) const
  {
  return ( get ( ) [ _Idx ] );
  }

   bool unique ( ) const noexcept
  {
  return ( this -> use_count ( ) == 1 );
  }

 explicit operator bool ( ) const noexcept
  {
  return ( get ( ) != nullptr );
  }

private :
 template < class _Ux >
  void _Setp ( _Ux * _Px, true_type )
  {
  _Setpd ( _Px, default_delete < _Ux [ ] > { } );
  }

 template < class _Ux >
  void _Setp ( _Ux * _Px, false_type )
  {
  try {
  _Set_ptr_rep_and_enable_shared ( _Px, new _Ref_count < _Ux > ( _Px ) );
  } catch ( ... ) {
  delete _Px;
  throw;
  }
  }

 template < class _UxptrOrNullptr,
  class _Dx >
  void _Setpd ( _UxptrOrNullptr _Px, _Dx _Dt )
  {
  try {
  _Set_ptr_rep_and_enable_shared ( _Px, new _Ref_count_resource < _UxptrOrNullptr, _Dx > ( _Px, :: std :: move ( _Dt ) ) );
  } catch ( ... ) {
  _Dt ( _Px );
  throw;
  }
  }

 template < class _UxptrOrNullptr,
  class _Dx,
  class _Alloc >
  void _Setpda ( _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax )
  {
  using _Refd = _Ref_count_resource_alloc < _UxptrOrNullptr, _Dx, _Alloc >;
  using _Alref_alloc = _Rebind_alloc_t < _Alloc, _Refd >;
  using _Alref_traits = allocator_traits < _Alref_alloc >;
  _Alref_alloc _Alref ( _Ax );

  try {
  const auto _Pfancy = _Alref_traits :: allocate ( _Alref, 1 );
  _Refd * const _Pref = _Unfancy ( _Pfancy );
   try {
   _Alref_traits :: construct ( _Alref, _Pref, _Px, :: std :: move ( _Dt ), _Ax );
   _Set_ptr_rep_and_enable_shared ( _Px, _Pref );
   } catch ( ... ) {
   _Alref_traits :: deallocate ( _Alref, _Pfancy, 1 );
   throw;
   }
  } catch ( ... ) {
  _Dt ( _Px );
  throw;
  }
  }

 template < class _Ty0,
  class ... _Types >
  friend shared_ptr < _Ty0 > make_shared ( _Types && ... _Args );

 template < class _Ty0,
  class _Alloc,
  class ... _Types >
  friend shared_ptr < _Ty0 > allocate_shared ( const _Alloc & _Al_arg, _Types && ... _Args );

 template < class _Ux >
  void _Set_ptr_rep_and_enable_shared ( _Ux * _Px, _Ref_count_base * _Rx )
  {
  this -> _Set_ptr_rep ( _Px, _Rx );
  _Enable_shared_from_this ( * this, _Px );
  }

 void _Set_ptr_rep_and_enable_shared ( nullptr_t, _Ref_count_base * _Rx )
  {
  this -> _Set_ptr_rep ( nullptr, _Rx );
  }
 };
#line 1601 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _Ty1,
 class _Ty2 >
  bool operator == ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept
 {
 return ( _Left . get ( ) == _Right . get ( ) );
 }
#line 1608
template < class _Ty1,
 class _Ty2 >
  bool operator != ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept
 {
 return ( _Left . get ( ) != _Right . get ( ) );
 }
#line 1615
template < class _Ty1,
 class _Ty2 >
  bool operator < ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept
 {
 return ( _Left . get ( ) < _Right . get ( ) );
 }
#line 1622
template < class _Ty1,
 class _Ty2 >
  bool operator >= ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept
 {
 return ( _Left . get ( ) >= _Right . get ( ) );
 }
#line 1629
template < class _Ty1,
 class _Ty2 >
  bool operator > ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept
 {
 return ( _Left . get ( ) > _Right . get ( ) );
 }
#line 1636
template < class _Ty1,
 class _Ty2 >
  bool operator <= ( const shared_ptr < _Ty1 > & _Left, const shared_ptr < _Ty2 > & _Right ) noexcept
 {
 return ( _Left . get ( ) <= _Right . get ( ) );
 }
#line 1643
template < class _Ty >
  bool operator == ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept
 {
 return ( _Left . get ( ) == nullptr );
 }
#line 1649
template < class _Ty >
  bool operator == ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept
 {
 return ( nullptr == _Right . get ( ) );
 }
#line 1655
template < class _Ty >
  bool operator != ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept
 {
 return ( _Left . get ( ) != nullptr );
 }
#line 1661
template < class _Ty >
  bool operator != ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept
 {
 return ( nullptr != _Right . get ( ) );
 }
#line 1667
template < class _Ty >
  bool operator < ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept
 {
 return ( _Left . get ( ) < static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) );
 }
#line 1673
template < class _Ty >
  bool operator < ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept
 {
 return ( static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) < _Right . get ( ) );
 }
#line 1679
template < class _Ty >
  bool operator >= ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept
 {
 return ( _Left . get ( ) >= static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) );
 }
#line 1685
template < class _Ty >
  bool operator >= ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept
 {
 return ( static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) >= _Right . get ( ) );
 }
#line 1691
template < class _Ty >
  bool operator > ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept
 {
 return ( _Left . get ( ) > static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) );
 }
#line 1697
template < class _Ty >
  bool operator > ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept
 {
 return ( static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) > _Right . get ( ) );
 }
#line 1703
template < class _Ty >
  bool operator <= ( const shared_ptr < _Ty > & _Left, nullptr_t ) noexcept
 {
 return ( _Left . get ( ) <= static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) );
 }
#line 1709
template < class _Ty >
  bool operator <= ( nullptr_t, const shared_ptr < _Ty > & _Right ) noexcept
 {
 return ( static_cast < typename shared_ptr < _Ty > :: element_type * > ( nullptr ) <= _Right . get ( ) );
 }
#line 1715
template < class _Elem,
 class _Traits,
 class _Ty >
 basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Out, const shared_ptr < _Ty > & _Px )
 {
 return ( _Out << _Px . get ( ) );
 }
#line 1723
template < class _Ty >
 void swap ( shared_ptr < _Ty > & _Left, shared_ptr < _Ty > & _Right ) noexcept
 {
 _Left . swap ( _Right );
 }
#line 1729
template < class _Ty1,
 class _Ty2 >
  shared_ptr < _Ty1 > static_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept
 {
 const auto _Ptr = static_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
 return ( shared_ptr < _Ty1 > ( _Other, _Ptr ) );
 }
#line 1737
template < class _Ty1,
 class _Ty2 >
  shared_ptr < _Ty1 > const_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept
 {
 const auto _Ptr = const_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
 return ( shared_ptr < _Ty1 > ( _Other, _Ptr ) );
 }
#line 1745
template < class _Ty1,
 class _Ty2 >
  shared_ptr < _Ty1 > reinterpret_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept
 {
 const auto _Ptr = reinterpret_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );
 return ( shared_ptr < _Ty1 > ( _Other, _Ptr ) );
 }
#line 1754
template < class _Ty1,
 class _Ty2 >
  shared_ptr < _Ty1 > dynamic_pointer_cast ( const shared_ptr < _Ty2 > & _Other ) noexcept
 {
 const auto _Ptr = dynamic_cast < typename shared_ptr < _Ty1 > :: element_type * > ( _Other . get ( ) );

 if ( _Ptr )
  {
  return ( shared_ptr < _Ty1 > ( _Other, _Ptr ) );
  }

 return ( shared_ptr < _Ty1 > ( ) );
 }
#line 1774 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _Dx,
 class _Ty >
  _Dx * get_deleter ( const shared_ptr < _Ty > & _Sx ) noexcept
 {
 if ( _Sx . _Rep )
  {
  return ( static_cast < _Dx * > ( _Sx . _Rep -> _Get_deleter ( typeid ( _Dx ) ) ) );
  }

 return ( nullptr );
 }
#line 1792 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _Ty >
 class _Ref_count_obj
  : public _Ref_count_base
 {
public :
 template < class ... _Types >
  explicit _Ref_count_obj ( _Types && ... _Args )
  : _Ref_count_base ( )
  {
  :: new ( static_cast < void * > ( & _Storage ) ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );
  }

 _Ty * _Getptr ( )
  {
  return ( reinterpret_cast < _Ty * > ( & _Storage ) );
  }

private :
 virtual void _Destroy ( ) noexcept override
  {
  _Getptr ( ) -> ~ _Ty ( );
  }

 virtual void _Delete_this ( ) noexcept override
  {
  delete this;
  }

 aligned_union_t < 1, _Ty > _Storage;
 };
#line 1824
template < class _Ty,
 class _Alloc >
 class _Ref_count_obj_alloc
  : public _Ref_count_base
 {
public :
 template < class ... _Types >
  explicit _Ref_count_obj_alloc ( const _Alloc & _Al_arg, _Types && ... _Args )
  : _Ref_count_base ( ), _Mypair ( _One_then_variadic_args_t ( ), _Al_arg )
  {
  :: new ( static_cast < void * > ( & _Mypair . _Get_second ( ) ) ) _Ty ( :: std :: forward < _Types > ( _Args ) ... );
  }

 _Ty * _Getptr ( )
  {
  return ( reinterpret_cast < _Ty * > ( & _Mypair . _Get_second ( ) ) );
  }

private :
 using _Myalty = _Rebind_alloc_t < _Alloc, _Ref_count_obj_alloc >;
 using _Mystoragety = aligned_union_t < 1, _Ty >;

 virtual void _Destroy ( ) noexcept override
  {
  _Getptr ( ) -> ~ _Ty ( );
  }

 virtual void _Delete_this ( ) noexcept override
  {
  _Myalty _Al = _Mypair . _Get_first ( );
  allocator_traits < _Myalty > :: destroy ( _Al, this );
  _Deallocate_plain ( _Al, this );
  }

 _Compressed_pair < _Myalty, _Mystoragety > _Mypair;
 };
#line 1862
template < class _Ty,
 class ... _Types >
  inline shared_ptr < _Ty > make_shared ( _Types && ... _Args )
 {
 const auto _Rx = new _Ref_count_obj < _Ty > ( :: std :: forward < _Types > ( _Args ) ... );

 shared_ptr < _Ty > _Ret;
 _Ret . _Set_ptr_rep_and_enable_shared ( _Rx -> _Getptr ( ), _Rx );
 return ( _Ret );
 }
#line 1874
template < class _Ty,
 class _Alloc,
 class ... _Types >
  inline shared_ptr < _Ty > allocate_shared ( const _Alloc & _Al_arg, _Types && ... _Args )
 {
 using _Refoa = _Ref_count_obj_alloc < _Ty, _Alloc >;
 using _Alref_alloc = _Rebind_alloc_t < _Alloc, _Refoa >;
 using _Alref_traits = allocator_traits < _Alref_alloc >;
 _Alref_alloc _Alref ( _Al_arg );

 const auto _Rx = _Alref_traits :: allocate ( _Alref, 1 );

 try {
  _Alref_traits :: construct ( _Alref, _Unfancy ( _Rx ), _Al_arg, :: std :: forward < _Types > ( _Args ) ... );
 } catch ( ... ) {
  _Alref_traits :: deallocate ( _Alref, _Rx, 1 );
 throw;
 }

 shared_ptr < _Ty > _Ret;
 _Ret . _Set_ptr_rep_and_enable_shared ( _Rx -> _Getptr ( ), _Unfancy ( _Rx ) );
 return ( _Ret );
 }
#line 1899
template < class _Ty >
 class weak_ptr
  : public _Ptr_base < _Ty >
 {
public :
 constexpr weak_ptr ( ) noexcept
  {
  }

 weak_ptr ( const weak_ptr & _Other ) noexcept
  {
  this -> _Weakly_construct_from ( _Other );
  }

 template < class _Ty2,
  enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
  weak_ptr ( const shared_ptr < _Ty2 > & _Other ) noexcept
  {
  this -> _Weakly_construct_from ( _Other );
  }

 template < class _Ty2,
  enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
  weak_ptr ( const weak_ptr < _Ty2 > & _Other ) noexcept
  {
  this -> _Weakly_construct_from ( _Other . lock ( ) );
  }

 weak_ptr ( weak_ptr && _Other ) noexcept
  {
  this -> _Move_construct_from ( :: std :: move ( _Other ) );
  }

 template < class _Ty2,
  enable_if_t < _SP_pointer_compatible < _Ty2, _Ty > :: value, int > = 0 >
  weak_ptr ( weak_ptr < _Ty2 > && _Other ) noexcept
  {
  this -> _Weakly_construct_from ( _Other . lock ( ) );
  _Other . reset ( );
  }

 ~ weak_ptr ( ) noexcept
  {
  this -> _Decwref ( );
  }

 weak_ptr & operator = ( const weak_ptr & _Right ) noexcept
  {
  weak_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  weak_ptr & operator = ( const weak_ptr < _Ty2 > & _Right ) noexcept
  {
  weak_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 weak_ptr & operator = ( weak_ptr && _Right ) noexcept
  {
  weak_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  weak_ptr & operator = ( weak_ptr < _Ty2 > && _Right ) noexcept
  {
  weak_ptr ( :: std :: move ( _Right ) ) . swap ( * this );
  return ( * this );
  }

 template < class _Ty2 >
  weak_ptr & operator = ( const shared_ptr < _Ty2 > & _Right ) noexcept
  {
  weak_ptr ( _Right ) . swap ( * this );
  return ( * this );
  }

 void reset ( ) noexcept
  {
  weak_ptr ( ) . swap ( * this );
  }

 void swap ( weak_ptr & _Other ) noexcept
  {
  this -> _Swap ( _Other );
  }

  bool expired ( ) const noexcept
  {
  return ( this -> use_count ( ) == 0 );
  }

  shared_ptr < _Ty > lock ( ) const noexcept
  {
  shared_ptr < _Ty > _Ret;
  ( void ) _Ret . _Construct_from_weak ( * this );
  return ( _Ret );
  }
 };
#line 2006 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _Ty >
 void swap ( weak_ptr < _Ty > & _Left, weak_ptr < _Ty > & _Right ) noexcept
 {
 _Left . swap ( _Right );
 }
#line 2013
template < class _Ty >
 class enable_shared_from_this
 {
public :
 using _Esft_type = enable_shared_from_this;

  shared_ptr < _Ty > shared_from_this ( )
  {
  return ( shared_ptr < _Ty > ( _Wptr ) );
  }

  shared_ptr < const _Ty > shared_from_this ( ) const
  {
  return ( shared_ptr < const _Ty > ( _Wptr ) );
  }

  weak_ptr < _Ty > weak_from_this ( ) noexcept
  {
  return ( _Wptr );
  }

  weak_ptr < const _Ty > weak_from_this ( ) const noexcept
  {
  return ( _Wptr );
  }

protected :
 constexpr enable_shared_from_this ( ) noexcept
  : _Wptr ( )
  {
  }

 enable_shared_from_this ( const enable_shared_from_this & ) noexcept
  : _Wptr ( )
  {
  }

 enable_shared_from_this & operator = ( const enable_shared_from_this & ) noexcept
  {
  return ( * this );
  }

 ~ enable_shared_from_this ( ) = default;

private :
 template < class _Other,
  class _Yty >
  friend void _Enable_shared_from_this1 ( const shared_ptr < _Other > & _This, _Yty * _Ptr, true_type );

 mutable weak_ptr < _Ty > _Wptr;
 };
#line 2069
template < class _Ty >
 struct default_delete
 {
 constexpr default_delete ( ) noexcept = default;

 template < class _Ty2,
  enable_if_t < is_convertible_v < _Ty2 *, _Ty * >, int > = 0 >
  default_delete ( const default_delete < _Ty2 > & ) noexcept
  {
  }

 void operator ( ) ( _Ty * _Ptr ) const noexcept
  {
  static_assert ( 0 < sizeof ( _Ty ),
   "can\'t delete an incomplete type" );
  delete _Ptr;
  }
 };
#line 2088
template< class _Ty> 
#pragma pack(8)
#line 2089
struct default_delete< _Ty []>  { 
#line 2091
constexpr default_delete() noexcept = default;
#line 2093
template < class _Uty,
  enable_if_t < is_convertible_v < _Uty ( * ) [ ], _Ty ( * ) [ ] >, int > = 0 >
  default_delete ( const default_delete < _Uty [ ] > & ) noexcept
  {
  }
#line 2099
template < class _Uty,
  enable_if_t < is_convertible_v < _Uty ( * ) [ ], _Ty ( * ) [ ] >, int > = 0 >
  void operator ( ) ( _Uty * _Ptr ) const noexcept
  {
  static_assert ( 0 < sizeof ( _Uty ),
   "can\'t delete an incomplete type" );
  delete [ ] _Ptr;
  }
#line 2107
}; 
#pragma pack(8)
#line 2110
template< class _Ty, class 
#line 2111
_Dx_noref, class 
#line 2112
 = void> 
#line 2113
struct _Get_deleter_pointer_type { 
#line 2115
typedef _Ty *type; 
#line 2116
}; 
#line 2118
template< class _Ty, class 
#line 2119
_Dx_noref> 
#line 2120
struct _Get_deleter_pointer_type< _Ty, _Dx_noref, void_t< typename _Dx_noref::pointer> >  { 
#line 2122
typedef typename _Dx_noref::pointer type; 
#line 2123
}; 
#line 2126
template < class _Ty,
 class _Dx >
 class _Unique_ptr_base
 {
public :
 typedef remove_reference_t < _Dx > _Dx_noref;
 typedef typename _Get_deleter_pointer_type < _Ty, _Dx_noref > :: type pointer;

 template < class _Ptr2,
  class _Dx2 >
  _Unique_ptr_base ( _Ptr2 _Ptr, _Dx2 && _Dt )
  : _Mypair ( _One_then_variadic_args_t ( ), :: std :: forward < _Dx2 > ( _Dt ), _Ptr )
  {
  }

 template < class _Ptr2 >
  constexpr _Unique_ptr_base ( _Ptr2 _Ptr )
  : _Mypair ( _Zero_then_variadic_args_t ( ), _Ptr )
  {
  }

  _Dx & get_deleter ( ) noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

  const _Dx & get_deleter ( ) const noexcept
  {
  return ( _Mypair . _Get_first ( ) );
  }

 pointer & _Myptr ( ) noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 const pointer & _Myptr ( ) const noexcept
  {
  return ( _Mypair . _Get_second ( ) );
  }

 _Compressed_pair < _Dx, pointer > _Mypair;
 };
#line 2170
template< class _Dx2> using _Unique_ptr_enable_default_t = enable_if_t< conjunction_v< negation< is_pointer< _Dx2> > , is_default_constructible< _Dx2> > , int> ; 
#line 2175
template < class _Ty,
 class _Dx >
 class unique_ptr
  : public _Unique_ptr_base < _Ty, _Dx >
 {
public :
 typedef _Unique_ptr_base < _Ty, _Dx > _Mybase;
 typedef typename _Mybase :: pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase :: get_deleter;

 template < class _Dx2 = _Dx,
  _Unique_ptr_enable_default_t < _Dx2 > = 0 >
  constexpr unique_ptr ( ) noexcept
   : _Mybase ( pointer ( ) )
  {
  }

 template < class _Dx2 = _Dx,
  _Unique_ptr_enable_default_t < _Dx2 > = 0 >
  constexpr unique_ptr ( nullptr_t ) noexcept
   : _Mybase ( pointer ( ) )
  {
  }

 unique_ptr & operator = ( nullptr_t ) noexcept
  {
  reset ( );
  return ( * this );
  }

 template < class _Dx2 = _Dx,
  _Unique_ptr_enable_default_t < _Dx2 > = 0 >
  explicit unique_ptr ( pointer _Ptr ) noexcept
   : _Mybase ( _Ptr )
  {
  }

 template < class _Dx2 = _Dx,
  enable_if_t < is_constructible_v < _Dx2, const _Dx2 & >, int > = 0 >
  unique_ptr ( pointer _Ptr, const _Dx & _Dt ) noexcept
   : _Mybase ( _Ptr, _Dt )
  {
  }

 template < class _Dx2 = _Dx,
  enable_if_t < conjunction_v < negation < is_reference < _Dx2 >>,
   is_constructible < _Dx2, _Dx2 >>, int > = 0 >
  unique_ptr ( pointer _Ptr, _Dx && _Dt ) noexcept
   : _Mybase ( _Ptr, :: std :: move ( _Dt ) )
  {
  }

 template < class _Dx2 = _Dx,
  enable_if_t < conjunction_v < is_reference < _Dx2 >,
   is_constructible < _Dx2, remove_reference_t < _Dx2 >> >, int > = 0 >
  unique_ptr ( pointer, remove_reference_t < _Dx > && ) = delete;

 unique_ptr ( unique_ptr && _Right ) noexcept
  : _Mybase ( _Right . release ( ),
   :: std :: forward < _Dx > ( _Right . get_deleter ( ) ) )
  {
  }

 template < class _Ty2,
  class _Dx2,
  enable_if_t < conjunction_v < negation < is_array < _Ty2 >>,
   is_convertible < typename unique_ptr < _Ty2, _Dx2 > :: pointer, pointer >,
   conditional_t < is_reference_v < _Dx >, is_same < _Dx2, _Dx >, is_convertible < _Dx2, _Dx >>
  >, int > = 0 >
  unique_ptr ( unique_ptr < _Ty2, _Dx2 > && _Right ) noexcept
   : _Mybase ( _Right . release ( ),
    :: std :: forward < _Dx2 > ( _Right . get_deleter ( ) ) )
  {
  }


 template < class _Ty2,
  enable_if_t < conjunction_v < is_convertible < _Ty2 *, _Ty * >,
   is_same < _Dx, default_delete < _Ty >> >, int > = 0 >
  unique_ptr ( auto_ptr < _Ty2 > && _Right ) noexcept
   : _Mybase ( _Right . release ( ) )
  {
  }


 template < class _Ty2,
  class _Dx2,
  enable_if_t < conjunction_v < negation < is_array < _Ty2 >>,
   is_assignable < _Dx &, _Dx2 >,
   is_convertible < typename unique_ptr < _Ty2, _Dx2 > :: pointer, pointer >
  >, int > = 0 >
  unique_ptr & operator = ( unique_ptr < _Ty2, _Dx2 > && _Right ) noexcept
  {
  reset ( _Right . release ( ) );
  this -> get_deleter ( ) = :: std :: forward < _Dx2 > ( _Right . get_deleter ( ) );
  return ( * this );
  }

 unique_ptr & operator = ( unique_ptr && _Right ) noexcept
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   reset ( _Right . release ( ) );
   this -> get_deleter ( ) = :: std :: forward < _Dx > ( _Right . get_deleter ( ) );
   }
  return ( * this );
  }

 void swap ( unique_ptr & _Right ) noexcept
  {
  _Swap_adl ( this -> _Myptr ( ), _Right . _Myptr ( ) );
  _Swap_adl ( this -> get_deleter ( ), _Right . get_deleter ( ) );
  }

 ~ unique_ptr ( ) noexcept
  {
  if ( get ( ) != pointer ( ) )
   {
   this -> get_deleter ( ) ( get ( ) );
   }
  }

  add_lvalue_reference_t < _Ty > operator * ( ) const
  {
  return ( * get ( ) );
  }

  pointer operator -> ( ) const noexcept
  {
  return ( this -> _Myptr ( ) );
  }

  pointer get ( ) const noexcept
  {
  return ( this -> _Myptr ( ) );
  }

 explicit operator bool ( ) const noexcept
  {
  return ( get ( ) != pointer ( ) );
  }

 pointer release ( ) noexcept
  {
  pointer _Ans = get ( );
  this -> _Myptr ( ) = pointer ( );
  return ( _Ans );
  }

 void reset ( pointer _Ptr = pointer ( ) ) noexcept
  {
  pointer _Old = get ( );
  this -> _Myptr ( ) = _Ptr;
  if ( _Old != pointer ( ) )
   {
   this -> get_deleter ( ) ( _Old );
   }
  }

 unique_ptr ( const unique_ptr & ) = delete;
 unique_ptr & operator = ( const unique_ptr & ) = delete;
 };
#line 2342 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
template < class _Ty,
 class _Dx >
 class unique_ptr < _Ty [ ], _Dx >
  : public _Unique_ptr_base < _Ty, _Dx >
 {
public :
 typedef _Unique_ptr_base < _Ty, _Dx > _Mybase;
 typedef typename _Mybase :: pointer pointer;
 typedef _Ty element_type;
 typedef _Dx deleter_type;

 using _Mybase :: get_deleter;

 template < class _Dx2 = _Dx,
  _Unique_ptr_enable_default_t < _Dx2 > = 0 >
  constexpr unique_ptr ( ) noexcept
   : _Mybase ( pointer ( ) )
  {
  }

 template < class _Uty,
  class _Is_nullptr = is_same < _Uty, nullptr_t >>
  using _Enable_ctor_reset = enable_if_t <
   is_same_v < _Uty, pointer >
   || _Is_nullptr :: value
   || ( is_same_v < pointer, element_type * >
   && is_pointer_v < _Uty >
   && is_convertible_v <
    remove_pointer_t < _Uty > ( * ) [ ],
    element_type ( * ) [ ]
   > ) >;

 template < class _Uty,
  class _Dx2 = _Dx,
  _Unique_ptr_enable_default_t < _Dx2 > = 0,
  class = _Enable_ctor_reset < _Uty >>
  explicit unique_ptr ( _Uty _Ptr ) noexcept
   : _Mybase ( _Ptr )
  {
  }

 template < class _Uty,
  class _Dx2 = _Dx,
  enable_if_t < is_constructible_v < _Dx2, const _Dx2 & >, int > = 0,
  class = _Enable_ctor_reset < _Uty >>
  unique_ptr ( _Uty _Ptr, const _Dx & _Dt ) noexcept
   : _Mybase ( _Ptr, _Dt )
  {
  }

 template < class _Uty,
  class _Dx2 = _Dx,
  enable_if_t < conjunction_v < negation < is_reference < _Dx2 >>,
   is_constructible < _Dx2, _Dx2 >>, int > = 0,
  class = _Enable_ctor_reset < _Uty >>
  unique_ptr ( _Uty _Ptr, _Dx && _Dt ) noexcept
   : _Mybase ( _Ptr, :: std :: move ( _Dt ) )
  {
  }

 template < class _Uty,
  class _Dx2 = _Dx,
  enable_if_t < conjunction_v < is_reference < _Dx2 >,
   is_constructible < _Dx2, remove_reference_t < _Dx2 >> >, int > = 0 >
  unique_ptr ( _Uty, remove_reference_t < _Dx > && ) = delete;

 unique_ptr ( unique_ptr && _Right ) noexcept
  : _Mybase ( _Right . release ( ),
   :: std :: forward < _Dx > ( _Right . get_deleter ( ) ) )
  {
  }

 unique_ptr & operator = ( unique_ptr && _Right ) noexcept
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   reset ( _Right . release ( ) );
   this -> get_deleter ( ) = :: std :: move ( _Right . get_deleter ( ) );
   }
  return ( * this );
  }

 template < class _Uty,
  class _Ex,
  class _More,
  class _UP_pointer = typename unique_ptr < _Uty, _Ex > :: pointer,
  class _UP_element_type = typename unique_ptr < _Uty, _Ex > :: element_type >
  using _Enable_conversion = enable_if_t < conjunction_v <
   is_array < _Uty >,
   is_same < pointer, element_type * >,
   is_same < _UP_pointer, _UP_element_type * >,
   is_convertible < _UP_element_type ( * ) [ ], element_type ( * ) [ ] >,
   _More >>;

 template < class _Uty,
  class _Ex,
  class = _Enable_conversion < _Uty, _Ex,
   conditional_t < is_reference_v < _Dx >, is_same < _Ex, _Dx >, is_convertible < _Ex, _Dx >> >>
  unique_ptr ( unique_ptr < _Uty, _Ex > && _Right ) noexcept
   : _Mybase ( _Right . release ( ),
    :: std :: forward < _Ex > ( _Right . get_deleter ( ) ) )
  {
  }

 template < class _Uty,
  class _Ex,
  class = _Enable_conversion < _Uty, _Ex, is_assignable < _Dx &, _Ex >> >
  unique_ptr & operator = ( unique_ptr < _Uty, _Ex > && _Right ) noexcept
  {
  reset ( _Right . release ( ) );
  this -> get_deleter ( ) = :: std :: forward < _Ex > ( _Right . get_deleter ( ) );
  return ( * this );
  }

 template < class _Dx2 = _Dx,
  _Unique_ptr_enable_default_t < _Dx2 > = 0 >
  constexpr unique_ptr ( nullptr_t ) noexcept
   : _Mybase ( pointer ( ) )
  {
  }

 unique_ptr & operator = ( nullptr_t ) noexcept
  {
  reset ( );
  return ( * this );
  }

 void reset ( nullptr_t = nullptr ) noexcept
  {
  reset ( pointer ( ) );
  }

 void swap ( unique_ptr & _Right ) noexcept
  {
  _Swap_adl ( this -> _Myptr ( ), _Right . _Myptr ( ) );
  _Swap_adl ( this -> get_deleter ( ), _Right . get_deleter ( ) );
  }

 ~ unique_ptr ( ) noexcept
  {
  _Delete ( );
  }

  _Ty & operator [ ] ( size_t _Idx ) const
  {
  return ( get ( ) [ _Idx ] );
  }

  pointer get ( ) const noexcept
  {
  return ( this -> _Myptr ( ) );
  }

 explicit operator bool ( ) const noexcept
  {
  return ( get ( ) != pointer ( ) );
  }

 pointer release ( ) noexcept
  {
  pointer _Ans = get ( );
  this -> _Myptr ( ) = pointer ( );
  return ( _Ans );
  }

 template < class _Uty,
  class = _Enable_ctor_reset < _Uty, false_type >>
  void reset ( _Uty _Ptr ) noexcept
  {
  pointer _Old = get ( );
  this -> _Myptr ( ) = _Ptr;
  if ( _Old != pointer ( ) )
   {
   this -> get_deleter ( ) ( _Old );
   }
  }

 unique_ptr ( const unique_ptr & ) = delete;
 unique_ptr & operator = ( const unique_ptr & ) = delete;

private :
 void _Delete ( )
  {
  if ( get ( ) != pointer ( ) )
   {
   this -> get_deleter ( ) ( get ( ) );
   }
  }
 };
#line 2534
template < class _Ty,
 class ... _Types,
 enable_if_t < ! is_array_v < _Ty >, int > = 0 >
  inline unique_ptr < _Ty > make_unique ( _Types && ... _Args )
 {
 return ( unique_ptr < _Ty > ( new _Ty ( :: std :: forward < _Types > ( _Args ) ... ) ) );
 }
#line 2542
template < class _Ty,
 enable_if_t < is_array_v < _Ty > && extent_v < _Ty > == 0, int > = 0 >
  inline unique_ptr < _Ty > make_unique ( size_t _Size )
 {
 typedef remove_extent_t < _Ty > _Elem;
 return ( unique_ptr < _Ty > ( new _Elem [ _Size ] ( ) ) );
 }
#line 2550
template < class _Ty,
 class ... _Types,
 enable_if_t < extent_v < _Ty > != 0, int > = 0 >
 void make_unique ( _Types && ... ) = delete;
#line 2557
template < class _Alloc >
 struct _Allocator_deleter
 {
 _Alloc _Al;

 using pointer = typename allocator_traits < _Alloc > :: pointer;
 void operator ( ) ( pointer _Ptr ) noexcept
  {
  allocator_traits < _Alloc > :: destroy ( _Al, _Unfancy ( _Ptr ) );
  _Al . deallocate ( _Ptr, 1 );
  }
 };
#line 2570
template< class _Alloc> using _Unique_ptr_alloc = unique_ptr< typename _Alloc::value_type, _Allocator_deleter< _Alloc> > ; 
#line 2573
template < class _Alloc,
 class ... _Args >
 _Unique_ptr_alloc < _Alloc > _Make_unique_alloc ( _Alloc & _Al, _Args && ... _Vals )
 {
 auto _Ptr = _Al . allocate ( 1 );
 try {
  allocator_traits < _Alloc > :: construct ( _Al, _Unfancy ( _Ptr ), :: std :: forward < _Args > ( _Vals ) ... );
 } catch ( ... ) {
  _Al . deallocate ( _Ptr, 1 );
 throw;
 }

 return ( _Unique_ptr_alloc < _Alloc > ( _Ptr, _Allocator_deleter < _Alloc > { _Al } ) );
 }
#line 2588
template < class _Ty,
 class _Dx,
 enable_if_t < _Is_swappable < _Dx > :: value, int > = 0 >
 void swap ( unique_ptr < _Ty, _Dx > & _Left, unique_ptr < _Ty, _Dx > & _Right ) noexcept
 {
 _Left . swap ( _Right );
 }
#line 2596
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
  bool operator == ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( _Left . get ( ) == _Right . get ( ) );
 }
#line 2605
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
  bool operator != ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2614
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
  bool operator < ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 typedef typename unique_ptr < _Ty1, _Dx1 > :: pointer _Ptr1;
 typedef typename unique_ptr < _Ty2, _Dx2 > :: pointer _Ptr2;
 typedef common_type_t < _Ptr1, _Ptr2 > _Common;
 return ( less < _Common > ( ) ( _Left . get ( ), _Right . get ( ) ) );
 }
#line 2626
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
  bool operator >= ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2635
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
  bool operator > ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2644
template < class _Ty1,
 class _Dx1,
 class _Ty2,
 class _Dx2 >
  bool operator <= ( const unique_ptr < _Ty1, _Dx1 > & _Left, const unique_ptr < _Ty2, _Dx2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2653
template < class _Ty,
 class _Dx >
  bool operator == ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t ) noexcept
 {
 return ( ! _Left );
 }
#line 2660
template < class _Ty,
 class _Dx >
  bool operator == ( nullptr_t, const unique_ptr < _Ty, _Dx > & _Right ) noexcept
 {
 return ( ! _Right );
 }
#line 2667
template < class _Ty,
 class _Dx >
  bool operator != ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right ) noexcept
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2674
template < class _Ty,
 class _Dx >
  bool operator != ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right ) noexcept
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2681
template < class _Ty,
 class _Dx >
  bool operator < ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right )
 {
 typedef typename unique_ptr < _Ty, _Dx > :: pointer _Ptr;
 return ( less < _Ptr > ( ) ( _Left . get ( ), _Right ) );
 }
#line 2689
template < class _Ty,
 class _Dx >
  bool operator < ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right )
 {
 typedef typename unique_ptr < _Ty, _Dx > :: pointer _Ptr;
 return ( less < _Ptr > ( ) ( _Left, _Right . get ( ) ) );
 }
#line 2697
template < class _Ty,
 class _Dx >
  bool operator >= ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2704
template < class _Ty,
 class _Dx >
  bool operator >= ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2711
template < class _Ty,
 class _Dx >
  bool operator > ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right )
 {
 return ( _Right < _Left );
 }
#line 2718
template < class _Ty,
 class _Dx >
  bool operator > ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2725
template < class _Ty,
 class _Dx >
  bool operator <= ( const unique_ptr < _Ty, _Dx > & _Left, nullptr_t _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2732
template < class _Ty,
 class _Dx >
  bool operator <= ( nullptr_t _Left, const unique_ptr < _Ty, _Dx > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2739
template< class _OutTy, class 
#line 2740
_PxTy, class 
#line 2741
 = void> 
#line 2742
struct _Can_stream_unique_ptr : public false_type { 
#line 2744
}; 
#line 2745
template< class _OutTy, class 
#line 2746
_PxTy> 
#line 2747
struct _Can_stream_unique_ptr< _OutTy, _PxTy, void_t< decltype((std::declval< _OutTy> () << (std::declval< _PxTy> ().get())))> >  : public true_type { 
#line 2750
}; 
#line 2752
template < class _Elem,
 class _Traits,
 class _Yty,
 class _Dx,
 enable_if_t < _Can_stream_unique_ptr < basic_ostream < _Elem, _Traits > &, const unique_ptr < _Yty, _Dx > & > :: value, int > = 0 >
 basic_ostream < _Elem, _Traits > & operator << ( basic_ostream < _Elem, _Traits > & _Out, const unique_ptr < _Yty, _Dx > & _Px )
 {
 _Out << _Px . get ( );
 return ( _Out );
 }
#line 2764
enum class pointer_safety { 
#line 2765
relaxed, 
#line 2766
preferred, 
#line 2767
strict
#line 2768
}; 
#line 2770
inline void declare_reachable(void *) 
#line 2771
{ 
#line 2772
} 
#line 2774
template < class _Ty > inline
 _Ty * undeclare_reachable ( _Ty * _Ptr )
 {
 return ( _Ptr );
 }
#line 2780
inline void declare_no_pointers(char *, size_t) 
#line 2781
{ 
#line 2782
} 
#line 2784
inline void undeclare_no_pointers(char *, size_t) 
#line 2785
{ 
#line 2786
} 
#line 2788
inline pointer_safety get_pointer_safety() noexcept 
#line 2789
{ 
#line 2790
return pointer_safety::relaxed; 
#line 2791
} 
#line 2794
template< class _Ty = void> struct owner_less; 
#line 2797
template < class _Ty >
 struct owner_less < shared_ptr < _Ty > >
 {
  typedef shared_ptr < _Ty > first_argument_type;
  typedef shared_ptr < _Ty > second_argument_type;
  typedef bool result_type;

  bool operator ( ) ( const shared_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }

  bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }

  bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }
 };
#line 2820
template < class _Ty >
 struct owner_less < weak_ptr < _Ty > >
 {
  typedef weak_ptr < _Ty > first_argument_type;
  typedef weak_ptr < _Ty > second_argument_type;
  typedef bool result_type;

  bool operator ( ) ( const weak_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }

  bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Ty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }

  bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Ty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }
 };
#line 2844
template<> struct owner_less< void>  { 
#line 2846
using is_transparent = int; 
#line 2848
template < class _Ty,
  class _Uty >
   bool operator ( ) ( const shared_ptr < _Ty > & _Left, const shared_ptr < _Uty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }
#line 2855
template < class _Ty,
  class _Uty >
   bool operator ( ) ( const shared_ptr < _Ty > & _Left, const weak_ptr < _Uty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }
#line 2862
template < class _Ty,
  class _Uty >
   bool operator ( ) ( const weak_ptr < _Ty > & _Left, const shared_ptr < _Uty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }
#line 2869
template < class _Ty,
  class _Uty >
   bool operator ( ) ( const weak_ptr < _Ty > & _Left, const weak_ptr < _Uty > & _Right ) const noexcept
  {
  return ( _Left . owner_before ( _Right ) );
  }
#line 2875
}; 
#line 2878
template < class _Ty,
 class _Dx >
 struct hash < unique_ptr < _Ty, _Dx > >
  : _Conditionally_enabled_hash < unique_ptr < _Ty, _Dx >,
   is_default_constructible_v < hash < typename unique_ptr < _Ty, _Dx > :: pointer >> >
 {
 static size_t _Do_hash ( const unique_ptr < _Ty, _Dx > & _Keyval )
   noexcept ( _Is_nothrow_hashable < typename unique_ptr < _Ty, _Dx > :: pointer > :: value )
  {
  return ( hash < typename unique_ptr < _Ty, _Dx > :: pointer > { } ( _Keyval . get ( ) ) );
  }
 };
#line 2891
template < class _Ty >
 struct hash < shared_ptr < _Ty > >
 {
  typedef shared_ptr < _Ty > argument_type;
  typedef size_t result_type;

  size_t operator ( ) ( const shared_ptr < _Ty > & _Keyval ) const noexcept
  {
  return ( hash < typename shared_ptr < _Ty > :: element_type * > ( ) ( _Keyval . get ( ) ) );
  }
 };
#line 2904
inline void *align(size_t _Bound, size_t _Size, void *&_Ptr, size_t &_Space) noexcept 
#line 2905
{ 
#line 2906
size_t _Off = static_cast< size_t>((reinterpret_cast< uintptr_t>(_Ptr)) & (_Bound - (1))); 
#line 2907
if (_Off != (0)) 
#line 2908
{ 
#line 2909
_Off = (_Bound - _Off); 
#line 2910
}  
#line 2912
if ((_Space < _Off) || ((_Space - _Off) < _Size)) 
#line 2913
{ 
#line 2914
return nullptr; 
#line 2915
}  
#line 2918
_Ptr = ((static_cast< char *>(_Ptr)) + _Off); 
#line 2919
_Space -= _Off; 
#line 2920
return _Ptr; 
#line 2921
} 
#line 2926
extern "C" {
#line 2927
void __cdecl _Lock_shared_ptr_spin_lock(); 
#line 2928
void __cdecl _Unlock_shared_ptr_spin_lock(); 
#line 2929
}
#line 2932
struct _Shared_ptr_spin_lock { 
#line 2934
_Shared_ptr_spin_lock() 
#line 2935
{ 
#line 2936
_Lock_shared_ptr_spin_lock(); 
#line 2937
} 
#line 2939
~_Shared_ptr_spin_lock() noexcept 
#line 2940
{ 
#line 2941
_Unlock_shared_ptr_spin_lock(); 
#line 2942
} 
#line 2943
}; 
#line 2945
template < class _Ty >
  inline bool atomic_is_lock_free ( const shared_ptr < _Ty > * )
 {
 return ( false );
 }
#line 2951
template < class _Ty >
  inline shared_ptr < _Ty > atomic_load_explicit ( const shared_ptr < _Ty > * _Ptr,
  memory_order )
 {
 _Shared_ptr_spin_lock _Lock;
 shared_ptr < _Ty > _Result = * _Ptr;
 return ( _Result );
 }
#line 2960
template < class _Ty >
  inline shared_ptr < _Ty > atomic_load ( const shared_ptr < _Ty > * _Ptr )
 {
 return ( :: std :: atomic_load_explicit ( _Ptr, memory_order_seq_cst ) );
 }
#line 2966
template < class _Ty > inline
 void atomic_store_explicit ( shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other,
  memory_order )
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr -> swap ( _Other );
 }
#line 2974
template < class _Ty > inline
 void atomic_store ( shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other )
 {
 :: std :: atomic_store_explicit ( _Ptr, :: std :: move ( _Other ), memory_order_seq_cst );
 }
#line 2980
template < class _Ty > inline
 shared_ptr < _Ty > atomic_exchange_explicit (
  shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other,
  memory_order )
 {
 _Shared_ptr_spin_lock _Lock;
 _Ptr -> swap ( _Other );
 return ( _Other );
 }
#line 2990
template < class _Ty > inline
 shared_ptr < _Ty > atomic_exchange (
  shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > _Other )
 {
 return ( :: std :: atomic_exchange_explicit ( _Ptr, :: std :: move ( _Other ), memory_order_seq_cst ) );
 }
#line 2997
template < class _Ty > inline
 bool atomic_compare_exchange_weak_explicit (
  shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value,
  memory_order, memory_order )
 {
 shared_ptr < _Ty > _Old_exp;
 _Shared_ptr_spin_lock _Lock;
 bool _Success = _Ptr -> get ( ) == _Exp -> get ( )
  && ! _Ptr -> owner_before ( * _Exp )
  && ! _Exp -> owner_before ( * _Ptr );
 if ( _Success )
  _Ptr -> swap ( _Value );
 else
  {
  _Exp -> swap ( _Old_exp );
  * _Exp = * _Ptr;
  }
 return ( _Success );
 }
#line 3017
template < class _Ty > inline
 bool atomic_compare_exchange_weak (
  shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp,
   shared_ptr < _Ty > _Value )
 {
 return ( :: std :: atomic_compare_exchange_weak_explicit ( _Ptr, _Exp, :: std :: move ( _Value ),
  memory_order_seq_cst, memory_order_seq_cst ) );
 }
#line 3026
template < class _Ty > inline
 bool atomic_compare_exchange_strong_explicit (
  shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp, shared_ptr < _Ty > _Value,
  memory_order, memory_order )
 {
 return ( :: std :: atomic_compare_exchange_weak_explicit ( _Ptr, _Exp, :: std :: move ( _Value ),
  memory_order_seq_cst, memory_order_seq_cst ) );
 }
#line 3035
template < class _Ty > inline
 bool atomic_compare_exchange_strong (
 shared_ptr < _Ty > * _Ptr, shared_ptr < _Ty > * _Exp,
  shared_ptr < _Ty > _Value )
 {
 return ( :: std :: atomic_compare_exchange_strong_explicit ( _Ptr, _Exp, :: std :: move ( _Value ),
  memory_order_seq_cst, memory_order_seq_cst ) );
 }
#line 3045
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 3046
using std::allocate_shared;
#line 3047
using std::bad_weak_ptr;
#line 3048
using std::const_pointer_cast;
#line 3049
using std::dynamic_pointer_cast;
#line 3050
using std::enable_shared_from_this;
#line 3051
using std::get_deleter;
#line 3052
using std::make_shared;
#line 3053
using std::shared_ptr;
#line 3054
using std::static_pointer_cast;
#line 3055
using std::swap;
#line 3056
using std::weak_ptr;
#line 3057
}
#line 3060 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\memory"
}
#line 3063
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xfacet"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 20
namespace std { 
#line 22
class __declspec(dllimport) _Facet_base { 
#line 25
public: virtual ~_Facet_base() noexcept 
#line 26
{ 
#line 27
} 
#line 30
virtual void _Incref() = 0; 
#line 33
virtual _Facet_base *_Decref() = 0; 
#line 34
}; 
#line 40 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *); 
#line 42 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xfacet"
}
#line 45
#pragma warning(pop)
#pragma pack ( pop )
#line 15 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 22
namespace std { 
#line 24
template< class _Dummy> 
#line 25
class _Locbase { 
#line 28
public: static const int collate = ((1 << 1) >> 1); 
#line 29
static const int ctype = ((1 << 2) >> 1); 
#line 30
static const int monetary = ((1 << 3) >> 1); 
#line 31
static const int numeric = ((1 << 4) >> 1); 
#line 32
static const int time = ((1 << 5) >> 1); 
#line 33
static const int messages = ((1 << 6) >> 1); 
#line 34
static const int all = (((1 << (6 + 1)) >> 1) - 1); 
#line 35
static const int none = 0; 
#line 36
}; 
#line 38
template< class _Dummy> const int _Locbase< _Dummy> ::collate; 
#line 40
template< class _Dummy> const int _Locbase< _Dummy> ::ctype; 
#line 42
template< class _Dummy> const int _Locbase< _Dummy> ::monetary; 
#line 44
template< class _Dummy> const int _Locbase< _Dummy> ::numeric; 
#line 46
template< class _Dummy> const int _Locbase< _Dummy> ::time; 
#line 48
template< class _Dummy> const int _Locbase< _Dummy> ::messages; 
#line 50
template< class _Dummy> const int _Locbase< _Dummy> ::all; 
#line 52
template< class _Dummy> const int _Locbase< _Dummy> ::none; 
#line 56
class locale; 
#line 57
template < class _Facet >
 const _Facet & __cdecl use_facet ( const locale & );
#line 59
template< class _Elem> class collate; 
#line 62
struct __declspec(dllimport) _Crt_new_delete { 
#line 65
void *__cdecl operator new(size_t _Size) 
#line 66
{ 
#line 67
void *_Ptr = operator new(_Size, nothrow); 
#line 68
if (!_Ptr) { 
#line 69
_Xbad_alloc(); }  
#line 70
return _Ptr; 
#line 71
} 
#line 73
void *__cdecl operator new(size_t _Size, const nothrow_t &) noexcept 
#line 74
{ 
#line 75
return _malloc_dbg((_Size > (0)) ? _Size : (1), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale", 75); 
#line 76
} 
#line 78
void __cdecl operator delete(void *_Ptr) noexcept 
#line 79
{ 
#line 80
::free(_Ptr); 
#line 81
} 
#line 83
void __cdecl operator delete(void *_Ptr, const nothrow_t &) noexcept 
#line 84
{ 
#line 85
operator delete(_Ptr); 
#line 86
} 
#line 88
void *__cdecl operator new(size_t, void *_Ptr) noexcept 
#line 89
{ 
#line 90
return _Ptr; 
#line 91
} 
#line 93
void __cdecl operator delete(void *, void *) noexcept 
#line 94
{ 
#line 95
} 
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
}; 
#line 99
class locale : public _Locbase< int> , public _Crt_new_delete { 
#line 103
public: typedef int category; 
#line 106
class __declspec(dllimport) id { 
#line 109
public: id(size_t _Val = 0) : _Id(_Val) 
#line 111
{ 
#line 112
} 
#line 114
operator size_t() 
#line 115
{ 
#line 116
if ((_Id) == (0)) 
#line 117
{ 
#line 118
{ _Lockit _Lock(0); 
#line 119
if ((_Id) == (0)) 
#line 120
{ 
#line 121
(_Id) = (static_cast< size_t>(++_Id_cnt)); 
#line 122
}  
#line 123
} 
#line 124
}  
#line 125
return _Id; 
#line 126
} 
#line 129
private: size_t _Id; 
#line 131
static int _Id_cnt; 
#line 134
public: id(const id &) = delete;
#line 135
id &operator=(const id &) = delete;
#line 136
}; 
#line 138
class _Locimp; 
#line 141
class __declspec(dllimport) facet : public _Facet_base, public _Crt_new_delete { 
#line 145
public: static size_t __cdecl _Getcat(const facet ** = 0, const locale * = 0) 
#line 147
{ 
#line 148
return static_cast< size_t>(-1); 
#line 149
} 
#line 151
virtual void _Incref() override 
#line 152
{ 
#line 153
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Myrefs))); 
#line 154
} 
#line 156
virtual _Facet_base *_Decref() override 
#line 157
{ 
#line 158
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Myrefs))) == (0)) 
#line 159
{ 
#line 160
return this; 
#line 161
}  
#line 163
return nullptr; 
#line 164
} 
#line 167
private: _Atomic_counter_t _Myrefs; 
#line 170
protected: explicit facet(size_t _Initrefs = 0) : _Myrefs(static_cast< _Atomic_integral_t>(_Initrefs)) 
#line 172
{ 
#line 173
} 
#line 175
virtual ~facet() noexcept 
#line 176
{ 
#line 177
} 
#line 180
public: facet(const facet &) = delete;
#line 181
facet &operator=(const facet &) = delete;
#line 182
}; 
#line 185
class __declspec(dllimport) _Locimp : public facet { 
#line 189
protected: virtual ~_Locimp() noexcept 
#line 190
{ 
#line 191
_Locimp_dtor(this); 
#line 192
} 
#line 196
private: static _Locimp *__cdecl _New_Locimp(bool _Transparent = false); 
#line 198
static _Locimp *__cdecl _New_Locimp(const _Locimp & _Right); 
#line 201
static void __cdecl _Locimp_dtor(_Locimp *); 
#line 203
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 
#line 205
static void __cdecl _Locimp_ctor(_Locimp *, const _Locimp &); 
#line 207
friend class locale; 
#line 209
_Locimp(bool _Transparent) : facet(1), _Facetvec((nullptr)), _Facetcount((0)), _Catmask(none), _Xparent(_Transparent), _Name("*") 
#line 213
{ 
#line 214
} 
#line 216
_Locimp(const _Locimp &_Right) : facet(1), _Facetvec((nullptr)), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name((_Right._Name).c_str()) 
#line 220
{ 
#line 221
_Locimp_ctor(this, _Right); 
#line 222
} 
#line 224
void _Addfac(facet *_Pfacet, size_t _Id) 
#line 225
{ 
#line 226
_Locimp_Addfac(this, _Pfacet, _Id); 
#line 227
} 
#line 229
static _Locimp *__cdecl _Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 232
static void __cdecl _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 236
static void __cdecl _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 240 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
static void __cdecl _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 243
facet **_Facetvec; 
#line 244
size_t _Facetcount; 
#line 245
category _Catmask; 
#line 246
bool _Xparent; 
#line 247
_Yarn< char>  _Name; 
#line 249
static _Locimp *_Clocptr; 
#line 252
public: _Locimp &operator=(const _Locimp &) = delete;
#line 253
}; 
#line 255
template < class _Elem,
  class _Traits,
  class _Alloc >
  bool operator ( ) ( const basic_string < _Elem, _Traits, _Alloc > & _Left,
   const basic_string < _Elem, _Traits, _Alloc > & _Right ) const
  {
  const auto & _Coll_fac = use_facet < :: std :: collate < _Elem >> ( * this );

  return ( _Coll_fac . compare ( _Left . c_str ( ), _Left . c_str ( ) + _Left . size ( ),
   _Right . c_str ( ), _Right . c_str ( ) + _Right . size ( ) ) < 0 );
  }
#line 267
template < class _Facet >
  locale combine ( const locale & _Loc ) const
  {
  _Facet * _Facptr;

  try {
   _Facptr = ( _Facet * ) & use_facet < _Facet > ( _Loc );
  } catch ( ... ) {
   _Xruntime_error ( "locale::combine facet missing" );
  }

  _Locimp * _Newimp = _Locimp :: _New_Locimp ( * _Ptr );
  _Newimp -> _Addfac ( _Facptr, _Facet :: id );
  _Newimp -> _Catmask = none;
  _Newimp -> _Name = "*";
  return ( locale ( _Newimp ) );
  }
#line 285
template < class _Facet >
  locale ( const locale & _Loc, const _Facet * _Facptr )
   : _Ptr ( _Locimp :: _New_Locimp ( * _Loc . _Ptr ) )
  {
  if ( _Facptr != nullptr )
   {
   _Ptr -> _Addfac ( ( _Facet * ) _Facptr, _Facet :: id );
   _Ptr -> _Catmask = none;
   _Ptr -> _Name = "*";
   }
  }
#line 297
locale(_Uninitialized) 
#line 298
{ 
#line 299
} 
#line 301
locale(const locale &_Right) noexcept : _Ptr(_Right._Ptr) 
#line 303
{ 
#line 304
(_Ptr)->_Incref(); 
#line 305
} 
#line 307
locale() noexcept : _Ptr(_Init(true)) 
#line 309
{ 
#line 310
} 
#line 313
locale(const locale &_Loc, const locale &_Other, category 
#line 314
_Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) 
#line 316
{ 
#line 317
if (_Cat != none) 
#line 318
{ 
#line 319
try { 
#line 320
{ _Locinfo _Lobj; 
#line 321
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other); 
#line 322
_Lobj._Addcats((_Loc._Ptr)->_Catmask, (_Loc.name()).c_str()); 
#line 324
_Lobj._Addcats((_Other._Ptr)->_Catmask, (_Other.name()).c_str()); 
#line 326
((_Ptr)->_Catmask) = (((_Loc._Ptr)->_Catmask) | ((_Other._Ptr)->_Catmask)); 
#line 328
(((_Ptr)->_Name) = (_Lobj._Getname())); 
#line 329
} 
#line 330
} catch (...) { 
#line 331
delete (_Ptr)->_Decref(); 
#line 332
throw; 
#line 333
}  
#line 334
}  
#line 335
} 
#line 338
private: void _Construct(const string &_Str, category 
#line 339
_Cat) 
#line 340
{ 
#line 341
bool _Bad = false; 
#line 342
_Init(); 
#line 343
if (_Cat != none) 
#line 344
{ 
#line 345
try { 
#line 346
{ _Locinfo _Lobj(_Cat, _Str.c_str()); 
#line 347
if (this->_Badname(_Lobj)) { 
#line 348
_Bad = true; } else 
#line 350
{ 
#line 351
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr); 
#line 352
((_Ptr)->_Catmask) = _Cat; 
#line 353
(((_Ptr)->_Name) = (_Str.c_str())); 
#line 354
}  
#line 355
} 
#line 356
} catch (...) { 
#line 357
delete (_Ptr)->_Decref(); 
#line 358
throw; 
#line 359
}  
#line 360
}  
#line 362
if (_Bad) 
#line 363
{ 
#line 364
delete (_Ptr)->_Decref(); 
#line 365
_Xruntime_error("bad locale name"); 
#line 366
}  
#line 367
} 
#line 370
public: explicit locale(const char *_Locname, category 
#line 371
_Cat = all) : _Ptr(_Locimp::_New_Locimp()) 
#line 373
{ 
#line 376
if (_Locname == (nullptr)) { 
#line 377
_Xruntime_error("bad locale name"); }  
#line 378
this->_Construct(_Locname, _Cat); 
#line 379
} 
#line 381
locale(const locale &_Loc, const char *_Locname, category 
#line 382
_Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) 
#line 384
{ 
#line 387
if (_Locname == (nullptr)) { 
#line 388
_Xruntime_error("bad locale name"); }  
#line 389
this->_Construct(_Locname, _Cat); 
#line 390
} 
#line 392
explicit locale(const string &_Str, category 
#line 393
_Cat = all) : _Ptr(_Locimp::_New_Locimp()) 
#line 395
{ 
#line 396
this->_Construct(_Str, _Cat); 
#line 397
} 
#line 399
locale(const locale &_Loc, const string &_Str, category 
#line 400
_Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) 
#line 402
{ 
#line 403
this->_Construct(_Str, _Cat); 
#line 404
} 
#line 407 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
~locale() noexcept 
#line 408
{ 
#line 409
if ((_Ptr) != (nullptr)) { 
#line 410
delete (_Ptr)->_Decref(); }  
#line 411
} 
#line 413
locale &operator=(const locale &_Right) noexcept 
#line 414
{ 
#line 415
if ((_Ptr) != (_Right._Ptr)) 
#line 416
{ 
#line 417
delete (_Ptr)->_Decref(); 
#line 418
(_Ptr) = (_Right._Ptr); 
#line 419
(_Ptr)->_Incref(); 
#line 420
}  
#line 421
return *this; 
#line 422
} 
#line 424
string name() const 
#line 425
{ 
#line 426
return (((_Ptr) == (nullptr)) ? string() : ((_Ptr)->_Name).c_str()); 
#line 427
} 
#line 429
const char *c_str() const 
#line 430
{ 
#line 431
return ((_Ptr) == (nullptr)) ? "" : ((_Ptr)->_Name).c_str(); 
#line 432
} 
#line 434
const facet *_Getfacet(size_t _Id) const 
#line 435
{ 
#line 436
const facet *_Facptr = (_Id < ((_Ptr)->_Facetcount)) ? ((_Ptr)->_Facetvec)[_Id] : (nullptr); 
#line 438
if ((_Facptr != (nullptr)) || (!((_Ptr)->_Xparent))) { 
#line 439
return _Facptr; } else 
#line 441
{ 
#line 442
_Locimp *_Ptr0 = _Getgloballocale(); 
#line 443
return (_Id < (_Ptr0->_Facetcount)) ? (_Ptr0->_Facetvec)[_Id] : (nullptr); 
#line 446
}  
#line 447
} 
#line 449
bool operator==(const locale &_Loc) const 
#line 450
{ 
#line 451
return ((_Ptr) == (_Loc._Ptr)) || (((this->name()).compare("*") != 0) && ((this->name()).compare(_Loc.name()) == 0)); 
#line 454
} 
#line 456
bool operator!=(const locale &_Right) const 
#line 457
{ 
#line 458
return !((*this) == _Right); 
#line 459
} 
#line 462
static const locale &__cdecl classic(); 
#line 465
static locale __cdecl global(const locale &); 
#line 468
static locale __cdecl empty(); 
#line 471
private: locale(_Locimp *_Ptrimp) : _Ptr(_Ptrimp) 
#line 473
{ 
#line 474
} 
#line 477
static _Locimp *__cdecl _Init(bool _Do_incref = false); 
#line 479
static _Locimp *__cdecl _Getgloballocale(); 
#line 481
static void __cdecl _Setgloballocale(void *); 
#line 483
bool _Badname(const _Locinfo &_Lobj) 
#line 484
{ 
#line 485
return ::strcmp(_Lobj._Getname(), "*") == 0; 
#line 486
} 
#line 488
_Locimp *_Ptr; 
#line 489
}; 
#line 492
template< class _Facet> 
#line 493
struct _Facetptr { 
#line 495
static const locale::facet *_Psave; 
#line 496
}; 
#line 498
template< class _Facet> const locale::facet *
#line 500
_Facetptr< _Facet> ::_Psave = (nullptr); 
#line 502
template < class _Facet > inline
 const _Facet & __cdecl use_facet ( const locale & _Loc )

 {
 { :: std :: _Lockit _Lock ( 0 );
  const locale :: facet * _Psave =
   _Facetptr < _Facet > :: _Psave;

  const size_t _Id = _Facet :: id;
  const locale :: facet * _Pf = _Loc . _Getfacet ( _Id );

  if ( _Pf == nullptr )
   {
   if ( _Psave != nullptr )
    {
    _Pf = _Psave;
    }
   else if ( _Facet :: _Getcat ( & _Psave, & _Loc ) == static_cast < size_t > ( - 1 ) )
    {

    throw bad_cast { };



    }
   else
    {
    auto _Pfmod = const_cast < locale :: facet * > ( _Psave );
    unique_ptr < _Facet_base > _Psave_guard ( static_cast < _Facet_base * > ( _Pfmod ) );




    _Facet_Register ( _Pfmod );


    _Pfmod -> _Incref ( );
    _Facetptr < _Facet > :: _Psave = _Psave;
    _Pf = _Psave;

    ( void ) _Psave_guard . release ( );
    }
   }

  return ( static_cast < const _Facet & > ( * _Pf ) );
 }
 }
#line 551 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
template < class _Elem,
 class _InIt > inline
 int __cdecl _Getloctxt ( _InIt & _First, _InIt & _Last, size_t _Numfields,
  const _Elem * _Ptr )
 {
 for ( size_t _Off = 0; _Ptr [ _Off ] != ( _Elem ) 0; ++ _Off )
  if ( _Ptr [ _Off ] == _Ptr [ 0 ] )
   ++ _Numfields;
 string _Str ( _Numfields, '\000' );

 int _Ans = - 2;
 for ( size_t _Column = 1;; ++ _Column, ( void ) ++ _First, _Ans = - 1 )
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++ _Field )
   {
   while ( _Ptr [ _Off ] != ( _Elem ) 0 && _Ptr [ _Off ] != _Ptr [ 0 ] )
    {
    ++ _Off;
    }

   if ( _Str [ _Field ] != '\000' )
    {
    _Off += _Str [ _Field ];
    }
   else if ( _Ptr [ _Off += _Column ] == _Ptr [ 0 ] || _Ptr [ _Off ] == ( _Elem ) 0 )
    {
    _Str [ _Field ] = ( char ) ( _Column < 127 ? _Column : 127 );
    _Ans = ( int ) _Field;
    }
   else if ( _First == _Last || _Ptr [ _Off ] != * _First )
    {
    _Str [ _Field ] = ( char ) ( _Column < 127 ? _Column : 127 );
    }
   else
    {
    _Prefix = true;
    }
   }

  if ( ! _Prefix || _First == _Last )
   break;
  }
 return ( _Ans );
 }
#line 601
template < class _Elem > inline
 char __cdecl _Maklocbyte ( _Elem _Char,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( char ) ( unsigned char ) _Char );
 }
#line 609
template<> inline char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &
#line 610
_Cvt) 
#line 611
{ 
#line 612
char _Byte = '\000'; 
#line 613
mbstate_t _Mbst1 = {}; 
#line 614
_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt); 
#line 615
return _Byte; 
#line 616
} 
#line 620
template<> inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec &
#line 621
_Cvt) 
#line 622
{ 
#line 623
char _Byte = '\000'; 
#line 624
mbstate_t _Mbst1 = {}; 
#line 625
_Wcrtomb(&_Byte, (__wchar_t)_Char, &_Mbst1, &_Cvt); 
#line 626
return _Byte; 
#line 627
} 
#line 631 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
template < class _Elem > inline
 _Elem __cdecl _Maklocchr ( char _Byte, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( _Elem ) ( unsigned char ) _Byte );
 }
#line 639
template<> inline __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *, const _Locinfo::_Cvtvec &
#line 640
_Cvt) 
#line 641
{ 
#line 642
__wchar_t _Wc = L'\x0'; 
#line 643
mbstate_t _Mbst1 = {}; 
#line 644
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt); 
#line 645
return _Wc; 
#line 646
} 
#line 650
template<> inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *, const _Locinfo::_Cvtvec &
#line 651
_Cvt) 
#line 652
{ 
#line 653
unsigned short _Wc = ((unsigned short)0); 
#line 654
mbstate_t _Mbst1 = {}; 
#line 655
_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt); 
#line 656
return _Wc; 
#line 657
} 
#line 661 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
template < class _Elem > inline
 _Elem * __cdecl _Maklocstr ( const char * _Ptr, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 size_t _Count = :: strlen ( _Ptr ) + 1;

 _Elem * _Ptrdest = ( _Elem * ) _calloc_dbg ( _Count, sizeof ( _Elem ),
  2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale", 668 );

 if ( ! _Ptrdest )
  _Xbad_alloc ( );

 for ( _Elem * _Ptrnext = _Ptrdest; 0 < _Count; -- _Count, ++ _Ptrnext, ++ _Ptr )
  * _Ptrnext = ( _Elem ) ( unsigned char ) * _Ptr;

 return ( _Ptrdest );
 }
#line 680
template<> inline __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *, const _Locinfo::_Cvtvec &
#line 681
_Cvt) 
#line 682
{ 
#line 683
size_t _Count, _Count1; 
#line 684
size_t _Wchars; 
#line 685
const char *_Ptr1; 
#line 686
int _Bytes; 
#line 687
__wchar_t _Wc; 
#line 688
mbstate_t _Mbst1 = {}; 
#line 690
_Count1 = (::strlen(_Ptr) + (1)); 
#line 691
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 693
if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 694
break; }  }  
#line 695
++_Wchars; 
#line 697
__wchar_t *_Ptrdest = (__wchar_t *)_calloc_dbg(_Wchars, sizeof(__wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale", 698); 
#line 700
if (!_Ptrdest) { 
#line 701
_Xbad_alloc(); }  
#line 702
__wchar_t *_Ptrnext = _Ptrdest; 
#line 703
mbstate_t _Mbst2 = {}; 
#line 705
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 707
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 708
break; }  }  
#line 709
(*_Ptrnext) = L'\x0'; 
#line 711
return _Ptrdest; 
#line 712
} 
#line 716
template<> inline unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *, const _Locinfo::_Cvtvec &
#line 717
_Cvt) 
#line 718
{ 
#line 719
size_t _Count, _Count1; 
#line 720
size_t _Wchars; 
#line 721
const char *_Ptr1; 
#line 722
int _Bytes; 
#line 723
unsigned short _Wc; 
#line 724
mbstate_t _Mbst1 = {}; 
#line 726
_Count1 = (::strlen(_Ptr) + (1)); 
#line 727
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) 
#line 729
{ 
#line 730
if ((_Bytes = _Mbrtowc((__wchar_t *)(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) 
#line 732
{ 
#line 733
break; 
#line 734
}  
#line 735
}  
#line 737
++_Wchars; 
#line 739
__wchar_t *_Ptrdest = (__wchar_t *)_calloc_dbg(_Wchars, sizeof(__wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale", 740); 
#line 742
if (!_Ptrdest) 
#line 743
{ 
#line 744
_Xbad_alloc(); 
#line 745
}  
#line 747
__wchar_t *_Ptrnext = _Ptrdest; 
#line 748
mbstate_t _Mbst2 = {}; 
#line 749
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) 
#line 751
{ 
#line 752
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) 
#line 753
{ 
#line 754
break; 
#line 755
}  
#line 756
}  
#line 758
(*_Ptrnext) = L'\x0'; 
#line 759
return (unsigned short *)_Ptrdest; 
#line 760
} 
#line 764 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
class __declspec(dllimport) codecvt_base : public locale::facet { 
#line 769
public: enum { 
#line 770
ok, partial, error, noconv}; 
#line 771
typedef int result; 
#line 773
codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) 
#line 775
{ 
#line 776
} 
#line 778
bool always_noconv() const noexcept 
#line 779
{ 
#line 780
return this->do_always_noconv(); 
#line 781
} 
#line 783
int max_length() const noexcept 
#line 784
{ 
#line 785
return this->do_max_length(); 
#line 786
} 
#line 788
int encoding() const noexcept 
#line 789
{ 
#line 790
return this->do_encoding(); 
#line 791
} 
#line 793
virtual ~codecvt_base() noexcept 
#line 794
{ 
#line 795
} 
#line 798
protected: virtual bool do_always_noconv() const noexcept 
#line 799
{ 
#line 800
return false; 
#line 801
} 
#line 803
virtual int do_max_length() const noexcept 
#line 804
{ 
#line 805
return 1; 
#line 806
} 
#line 808
virtual int do_encoding() const noexcept 
#line 809
{ 
#line 810
return 1; 
#line 811
} 
#line 812
}; 
#line 815
template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt
  : public codecvt_base
 {
public :
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in ( _Statype & _State,
  const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
  _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const
  {
  return ( do_in ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result out ( _Statype & _State,
  const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_out ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result unshift ( _Statype & _State,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_unshift ( _State, _First2, _Last2, _Mid2 ) );
  }

 int length ( _Statype & _State, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( do_length ( _State, _First1, _Last1, _Count ) );
  }

  static locale :: id id;

 explicit codecvt ( size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Locinfo ( ) );
  }

  codecvt ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr,
  const locale * _Ploc = nullptr )
  {
  if ( _Ppf != nullptr && * _Ppf == nullptr )
   * _Ppf = new codecvt < _Elem, _Byte, _Statype > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ codecvt ( ) noexcept
  {
  }

 void _Init ( const _Locinfo & )
  {
  }

 virtual bool do_always_noconv ( ) const noexcept
  {
  return ( is_same_v < _Byte, _Elem > );
  }

 virtual result do_in ( _Statype &,
  const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
  _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const
  {
  _Mid1 = _First1;
  _Mid2 = _First2;
  if ( is_same_v < _Byte, _Elem > )
   {
   return ( noconv );
   }


  for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++ _Mid1, ++ _Mid2 )
   {
   * _Mid2 = ( _Elem ) * _Mid1;
   }

  return ( ok );
  }

 virtual result do_out ( _Statype &,
  const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  _Mid1 = _First1;
  _Mid2 = _First2;
  if ( is_same_v < _Byte, _Elem > )
   {
   return ( noconv );
   }


  for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++ _Mid1, ++ _Mid2 )
   {
   * _Mid2 = ( _Byte ) * _Mid1;
   }

  return ( ok );
  }

 virtual result do_unshift ( _Statype &,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const
  {
  _Mid2 = _First2;
  return ( ok );
  }

 virtual int do_length ( _Statype &, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( static_cast < int > ( _Min_value ( _Count, static_cast < size_t > ( _Last1 - _First1 ) ) ) );
  }
 };
#line 951
template< class _Elem, class 
#line 952
_Byte, class 
#line 953
_Statype> locale::id 
#line 954
codecvt< _Elem, _Byte, _Statype> ::id; 
#line 961
enum _Codecvt_mode { 
#line 962
_Consume_header = 4, 
#line 963
_Generate_header = 2
#line 964
}; 
#line 968
template<> class __declspec(dllimport) codecvt< char16_t, char, _Mbstatet>  : public codecvt_base { 
#line 972
public: typedef std::codecvt< char16_t, char, _Mbstatet>  _Mybase; 
#line 973
typedef char16_t _Elem; 
#line 974
typedef char _Byte; 
#line 975
typedef _Mbstatet _Statype; 
#line 976
typedef _Elem intern_type; 
#line 977
typedef _Byte extern_type; 
#line 978
typedef _Statype state_type; 
#line 980
result in(_Statype &_State, const _Byte *
#line 981
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 982
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 983
{ 
#line 984
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 986
} 
#line 988
result out(_Statype &_State, const _Elem *
#line 989
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 990
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 991
{ 
#line 992
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 994
} 
#line 996
result unshift(_Statype &_State, _Byte *
#line 997
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 998
{ 
#line 999
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1001
} 
#line 1003
int length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1004
_Last1, size_t _Count) const 
#line 1005
{ 
#line 1006
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1007
} 
#line 1009
static locale::id id; 
#line 1011
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((1114111)), _Mode(_Consume_header) 
#line 1013
{ 
#line 1014
{ _Locinfo _Lobj; 
#line 1015
this->_Init(_Lobj); 
#line 1016
} 
#line 1017
} 
#line 1019
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((1114111)), _Mode(_Consume_header) 
#line 1021
{ 
#line 1022
this->_Init(_Lobj); 
#line 1023
} 
#line 1025
codecvt(const _Locinfo &_Lobj, unsigned long _Maxcode_arg, _Codecvt_mode 
#line 1026
_Mode_arg, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) 
#line 1028
{ 
#line 1029
this->_Init(_Lobj); 
#line 1030
} 
#line 1032
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1033
_Ploc = 0) 
#line 1034
{ 
#line 1035
if ((_Ppf != (nullptr)) && ((*_Ppf) == (nullptr))) 
#line 1036
{ 
#line 1037
(*_Ppf) = (new std::codecvt< char16_t, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); 
#line 1038
}  
#line 1040
return 2; 
#line 1041
} 
#line 1044
protected: virtual ~codecvt() noexcept 
#line 1045
{ 
#line 1046
} 
#line 1048
void _Init(const _Locinfo &) 
#line 1049
{ 
#line 1050
} 
#line 1052
virtual result do_in(_Statype &_State, const _Byte *
#line 1053
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1054
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1055
{ 
#line 1056
unsigned short *_Pstate = (unsigned short *)(&_State); 
#line 1057
_Mid1 = _First1; 
#line 1058
_Mid2 = _First2; 
#line 1060
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1061
{ 
#line 1062
unsigned char _By = (unsigned char)(*_Mid1); 
#line 1063
unsigned long _Ch; 
#line 1064
int _Nextra, _Nskip; 
#line 1066
if ((*_Pstate) > 1) 
#line 1067
{ 
#line 1068
if ((_By < 128) || (192 <= _By)) 
#line 1069
{ 
#line 1070
return _Mybase::error; 
#line 1071
}  
#line 1074
++_Mid1; 
#line 1075
(*(_Mid2++)) = ((_Elem)((*_Pstate) | (_By & 63))); 
#line 1076
(*_Pstate) = (1); 
#line 1077
continue; 
#line 1078
}  
#line 1080
if (_By < 128) 
#line 1081
{ 
#line 1082
_Ch = _By; 
#line 1083
_Nextra = 0; 
#line 1084
} else { 
#line 1085
if (_By < 192) 
#line 1086
{ 
#line 1087
++_Mid1; 
#line 1088
return _Mybase::error; 
#line 1089
} else { 
#line 1090
if (_By < 224) 
#line 1091
{ 
#line 1092
_Ch = (static_cast< unsigned long>(_By & 31)); 
#line 1093
_Nextra = 1; 
#line 1094
} else { 
#line 1095
if (_By < 240) 
#line 1096
{ 
#line 1097
_Ch = (static_cast< unsigned long>(_By & 15)); 
#line 1098
_Nextra = 2; 
#line 1099
} else { 
#line 1100
if (_By < 248) 
#line 1101
{ 
#line 1102
_Ch = (static_cast< unsigned long>(_By & 7)); 
#line 1103
_Nextra = 3; 
#line 1104
} else 
#line 1106
{ 
#line 1107
_Ch = (static_cast< unsigned long>(_By & 3)); 
#line 1108
_Nextra = ((_By < 252) ? 4 : 5); 
#line 1109
}  }  }  }  }  
#line 1111
_Nskip = ((_Nextra < 3) ? 0 : 1); 
#line 1112
_First1 = _Mid1; 
#line 1114
if (_Nextra == 0) 
#line 1115
{ 
#line 1116
++_Mid1; 
#line 1117
} else { 
#line 1118
if ((_Last1 - _Mid1) < ((_Nextra + 1) - _Nskip)) 
#line 1119
{ 
#line 1120
break; 
#line 1121
} else 
#line 1123
{ 
#line 1124
for (++_Mid1; _Nskip < _Nextra; (--_Nextra), (++_Mid1)) 
#line 1125
{ 
#line 1126
if (((_By = ((unsigned char)(*_Mid1))) < 128) || (192 <= _By)) 
#line 1127
{ 
#line 1128
return _Mybase::error; 
#line 1129
} else 
#line 1131
{ 
#line 1132
_Ch = ((_Ch << 6) | (_By & 63)); 
#line 1133
}  
#line 1134
}  
#line 1135
}  }  
#line 1137
if (0 < _Nskip) 
#line 1138
{ 
#line 1139
_Ch <<= 6; 
#line 1140
}  
#line 1142
if ((((_Maxcode) < (1114111)) ? _Maxcode : (1114111)) < _Ch) 
#line 1143
{ 
#line 1144
return _Mybase::error; 
#line 1145
}  
#line 1147
if ((65535) < _Ch) 
#line 1148
{ 
#line 1149
unsigned short _Ch0 = (unsigned short)((55296) | ((_Ch >> 10) - (64))); 
#line 1152
(*(_Mid2++)) = ((_Elem)_Ch0); 
#line 1153
(*_Pstate) = ((unsigned short)((56320) | (_Ch & (1023)))); 
#line 1154
continue; 
#line 1155
}  
#line 1157
if (_Nskip != 0) 
#line 1158
{ 
#line 1159
if (_Mid1 == _Last1) 
#line 1160
{ 
#line 1161
_Mid1 = _First1; 
#line 1162
break; 
#line 1163
}  
#line 1165
if (((_By = ((unsigned char)(*(_Mid1++)))) < 128) || (192 <= _By)) 
#line 1166
{ 
#line 1167
return _Mybase::error; 
#line 1168
}  
#line 1170
_Ch |= (_By & 63); 
#line 1171
}  
#line 1173
if ((*_Pstate) == 0) 
#line 1174
{ 
#line 1175
(*_Pstate) = (1); 
#line 1177
if ((((_Mode) & (_Consume_header)) != 0) && (_Ch == (65279))) 
#line 1178
{ 
#line 1179
const result _Ans = this->do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1182
if (_Ans == (_Mybase::partial)) 
#line 1183
{ 
#line 1184
(*_Pstate) = (0); 
#line 1185
_Mid1 = _First1; 
#line 1186
}  
#line 1188
return _Ans; 
#line 1189
}  
#line 1190
}  
#line 1192
(*(_Mid2++)) = ((_Elem)_Ch); 
#line 1193
} }  
#line 1195
return (_First1 == _Mid1) ? _Mybase::partial : _Mybase::ok; 
#line 1196
} 
#line 1198
virtual result do_out(_Statype &_State, const _Elem *
#line 1199
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1200
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1201
{ 
#line 1202
unsigned short *_Pstate = (unsigned short *)(&_State); 
#line 1203
_Mid1 = _First1; 
#line 1204
_Mid2 = _First2; 
#line 1206
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) 
#line 1207
{ 
#line 1208
unsigned long _Ch; 
#line 1209
const unsigned short _Ch1 = (unsigned short)(*_Mid1); 
#line 1210
bool _Save = false; 
#line 1212
if (1 < (*_Pstate)) 
#line 1213
{ 
#line 1214
if ((_Ch1 < 56320) || (57344 <= _Ch1)) { 
#line 1215
return _Mybase::error; }  
#line 1216
_Ch = (static_cast< unsigned long>(((*_Pstate) << 10) | (_Ch1 - 56320))); 
#line 1217
} else { 
#line 1218
if ((55296 <= _Ch1) && (_Ch1 < 56320)) 
#line 1219
{ 
#line 1220
_Ch = (static_cast< unsigned long>(((_Ch1 - 55296) + 64) << 10)); 
#line 1221
_Save = true; 
#line 1222
} else { 
#line 1224
_Ch = _Ch1; }  }  
#line 1226
_Byte _By; 
#line 1227
int _Nextra; 
#line 1229
if (_Ch < (128)) 
#line 1230
{ 
#line 1231
_By = ((_Byte)_Ch); 
#line 1232
_Nextra = 0; 
#line 1233
} else { 
#line 1234
if (_Ch < (2048)) 
#line 1235
{ 
#line 1236
_By = ((_Byte)((192) | (_Ch >> 6))); 
#line 1237
_Nextra = 1; 
#line 1238
} else { 
#line 1239
if (_Ch < (65536)) 
#line 1240
{ 
#line 1241
_By = ((_Byte)((224) | (_Ch >> 12))); 
#line 1242
_Nextra = 2; 
#line 1243
} else 
#line 1245
{ 
#line 1246
_By = ((_Byte)((240) | (_Ch >> 18))); 
#line 1247
_Nextra = 3; 
#line 1248
}  }  }  
#line 1250
int _Nput = (_Nextra < 3) ? _Nextra + 1 : (_Save ? 1 : 3); 
#line 1252
if ((_Last2 - _Mid2) < _Nput) 
#line 1253
{ 
#line 1254
break; 
#line 1255
}  
#line 1257
if (((*_Pstate) == 0) && (((_Mode) & (_Generate_header)) != 0)) 
#line 1258
{ 
#line 1259
if ((_Last2 - _Mid2) < (3 + _Nput)) 
#line 1260
{ 
#line 1261
break; 
#line 1262
}  
#line 1265
(*(_Mid2++)) = ((_Byte)((unsigned char)239)); 
#line 1266
(*(_Mid2++)) = ((_Byte)((unsigned char)187)); 
#line 1267
(*(_Mid2++)) = ((_Byte)((unsigned char)191)); 
#line 1268
}  
#line 1270
++_Mid1; 
#line 1271
if (_Save || (_Nextra < 3)) 
#line 1272
{ 
#line 1273
(*(_Mid2++)) = _By; 
#line 1274
--_Nput; 
#line 1275
}  
#line 1277
for (; 0 < _Nput; --_Nput) 
#line 1278
{ 
#line 1279
(*(_Mid2++)) = ((_Byte)(((_Ch >> (6 * (--_Nextra))) & (63)) | (128))); 
#line 1280
}  
#line 1282
(*_Pstate) = ((unsigned short)(_Save ? _Ch >> 10 : (1))); 
#line 1283
}  
#line 1285
return (_First1 == _Mid1) ? _Mybase::partial : _Mybase::ok; 
#line 1286
} 
#line 1288
virtual result do_unshift(_Statype &_State, _Byte *
#line 1289
_First2, _Byte *, _Byte *&_Mid2) const 
#line 1290
{ 
#line 1291
unsigned short *_Pstate = (unsigned short *)(&_State); 
#line 1292
_Mid2 = _First2; 
#line 1294
return (1 < (*_Pstate)) ? _Mybase::error : _Mybase::ok; 
#line 1296
} 
#line 1298
virtual int do_length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1299
_Last1, size_t _Count) const 
#line 1300
{ 
#line 1301
size_t _Wchars = (0); 
#line 1302
_Statype _Mystate = _State; 
#line 1304
while ((_Wchars < _Count) && (_First1 != _Last1)) { 
#line 1305
{ 
#line 1306
const _Byte *_Mid1; 
#line 1307
_Elem *_Mid2; 
#line 1308
_Elem _Ch; 
#line 1309
const auto _Result = this->do_in(_Mystate, _First1, _Last1, _Mid1, &_Ch, (&_Ch) + 1, _Mid2); 
#line 1310
if (_Result == (_Mybase::noconv)) 
#line 1311
{ 
#line 1312
_Wchars += (static_cast< size_t>(_Last1 - _First1)); 
#line 1313
break; 
#line 1314
}  
#line 1316
if (_Result == (_Mybase::ok)) 
#line 1317
{ 
#line 1318
if (_Mid2 == ((&_Ch) + 1)) 
#line 1319
{ 
#line 1320
++_Wchars; 
#line 1321
}  
#line 1323
_First1 = _Mid1; 
#line 1324
continue; 
#line 1325
}  
#line 1327
break; 
#line 1328
} }  
#line 1330
return static_cast< int>(_Min_value(static_cast< size_t>(2147483647), _Wchars)); 
#line 1331
} 
#line 1333
virtual bool do_always_noconv() const noexcept override 
#line 1334
{ 
#line 1335
return false; 
#line 1336
} 
#line 1338
virtual int do_max_length() const noexcept override 
#line 1339
{ 
#line 1340
return (((_Mode) & (_Consume_header)) != 0) ? 9 : ((((_Mode) & (_Generate_header)) != 0) ? 7 : 6); 
#line 1343
} 
#line 1345
virtual int do_encoding() const noexcept override 
#line 1346
{ 
#line 1347
return 0; 
#line 1348
} 
#line 1351
private: unsigned long _Maxcode; 
#line 1352
_Codecvt_mode _Mode; 
#line 1353
}; 
#line 1357
template<> class __declspec(dllimport) codecvt< char32_t, char, _Mbstatet>  : public codecvt_base { 
#line 1361
public: typedef std::codecvt< char32_t, char, _Mbstatet>  _Mybase; 
#line 1362
typedef char32_t _Elem; 
#line 1363
typedef char _Byte; 
#line 1364
typedef _Mbstatet _Statype; 
#line 1365
typedef _Elem intern_type; 
#line 1366
typedef _Byte extern_type; 
#line 1367
typedef _Statype state_type; 
#line 1369
result in(_Statype &_State, const _Byte *
#line 1370
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1371
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1372
{ 
#line 1373
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1375
} 
#line 1377
result out(_Statype &_State, const _Elem *
#line 1378
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1379
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1380
{ 
#line 1381
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1383
} 
#line 1385
result unshift(_Statype &_State, _Byte *
#line 1386
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1387
{ 
#line 1388
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1390
} 
#line 1392
int length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1393
_Last1, size_t _Count) const 
#line 1394
{ 
#line 1395
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1396
} 
#line 1398
static locale::id id; 
#line 1400
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((4294967295U)), _Mode(_Consume_header) 
#line 1402
{ 
#line 1403
{ _Locinfo _Lobj; 
#line 1404
this->_Init(_Lobj); 
#line 1405
} 
#line 1406
} 
#line 1408
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode((4294967295U)), _Mode(_Consume_header) 
#line 1410
{ 
#line 1411
this->_Init(_Lobj); 
#line 1412
} 
#line 1414
codecvt(const _Locinfo &_Lobj, unsigned long _Maxcode_arg, _Codecvt_mode 
#line 1415
_Mode_arg, size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) 
#line 1417
{ 
#line 1418
this->_Init(_Lobj); 
#line 1419
} 
#line 1421
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1422
_Ploc = 0) 
#line 1423
{ 
#line 1424
if ((_Ppf != (nullptr)) && ((*_Ppf) == (nullptr))) { 
#line 1425
(*_Ppf) = (new std::codecvt< char32_t, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); }  
#line 1427
return 2; 
#line 1428
} 
#line 1431
protected: virtual ~codecvt() noexcept 
#line 1432
{ 
#line 1433
} 
#line 1435
void _Init(const _Locinfo &) 
#line 1436
{ 
#line 1437
} 
#line 1439
virtual result do_in(_Statype &_State, const _Byte *
#line 1440
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1441
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1442
{ 
#line 1443
char *_Pstate = (char *)(&_State); 
#line 1444
_Mid1 = _First1; 
#line 1445
_Mid2 = _First2; 
#line 1447
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) 
#line 1448
{ 
#line 1449
unsigned char _By = (unsigned char)(*_Mid1); 
#line 1450
unsigned long _Ch; 
#line 1451
int _Nextra; 
#line 1453
if (_By < 128) 
#line 1454
{ 
#line 1455
_Ch = _By; 
#line 1456
_Nextra = 0; 
#line 1457
} else { 
#line 1458
if (_By < 192) 
#line 1459
{ 
#line 1460
++_Mid1; 
#line 1461
return _Mybase::error; 
#line 1462
} else { 
#line 1463
if (_By < 224) 
#line 1464
{ 
#line 1465
_Ch = (static_cast< unsigned long>(_By & 31)); 
#line 1466
_Nextra = 1; 
#line 1467
} else { 
#line 1468
if (_By < 240) 
#line 1469
{ 
#line 1470
_Ch = (static_cast< unsigned long>(_By & 15)); 
#line 1471
_Nextra = 2; 
#line 1472
} else { 
#line 1473
if (_By < 248) 
#line 1474
{ 
#line 1475
_Ch = (static_cast< unsigned long>(_By & 7)); 
#line 1476
_Nextra = 3; 
#line 1477
} else 
#line 1479
{ 
#line 1480
_Ch = (static_cast< unsigned long>(_By & 3)); 
#line 1481
_Nextra = ((_By < 252) ? 4 : 5); 
#line 1482
}  }  }  }  }  
#line 1484
if (_Nextra == 0) 
#line 1485
{ 
#line 1486
++_Mid1; 
#line 1487
} else { 
#line 1488
if ((_Last1 - _Mid1) < (_Nextra + 1)) 
#line 1489
{ 
#line 1490
break; 
#line 1491
} else 
#line 1493
{ 
#line 1494
for (++_Mid1; 0 < _Nextra; (--_Nextra), (++_Mid1)) 
#line 1495
{ 
#line 1496
if (((_By = ((unsigned char)(*_Mid1))) < 128) || (192 <= _By)) 
#line 1497
{ 
#line 1498
return _Mybase::error; 
#line 1499
} else 
#line 1501
{ 
#line 1502
_Ch = ((_Ch << 6) | (_By & 63)); 
#line 1503
}  
#line 1504
}  
#line 1505
}  }  
#line 1507
if ((*_Pstate) == 0) 
#line 1508
{ 
#line 1509
(*_Pstate) = (1); 
#line 1511
if ((((_Mode) & (_Consume_header)) != 0) && (_Ch == (65279))) 
#line 1512
{ 
#line 1513
const result _Ans = this->do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1516
if (_Ans == (_Mybase::partial)) 
#line 1517
{ 
#line 1518
(*_Pstate) = (0); 
#line 1519
_Mid1 = _First1; 
#line 1520
}  
#line 1521
return _Ans; 
#line 1522
}  
#line 1523
}  
#line 1525
if ((_Maxcode) < _Ch) 
#line 1526
{ 
#line 1527
return _Mybase::error; 
#line 1528
}  
#line 1530
(*(_Mid2++)) = ((_Elem)_Ch); 
#line 1531
}  
#line 1533
return (_First1 == _Mid1) ? _Mybase::partial : _Mybase::ok; 
#line 1534
} 
#line 1536
virtual result do_out(_Statype &_State, const _Elem *
#line 1537
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1538
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1539
{ 
#line 1540
char *_Pstate = (char *)(&_State); 
#line 1541
_Mid1 = _First1; 
#line 1542
_Mid2 = _First2; 
#line 1544
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) 
#line 1545
{ 
#line 1546
_Byte _By; 
#line 1547
int _Nextra; 
#line 1548
unsigned long _Ch = (unsigned long)(*_Mid1); 
#line 1550
if ((_Maxcode) < _Ch) { 
#line 1551
return _Mybase::error; }  
#line 1553
if (_Ch < (128)) 
#line 1554
{ 
#line 1555
_By = ((_Byte)_Ch); 
#line 1556
_Nextra = 0; 
#line 1557
} else { 
#line 1558
if (_Ch < (2048)) 
#line 1559
{ 
#line 1560
_By = ((_Byte)((192) | (_Ch >> 6))); 
#line 1561
_Nextra = 1; 
#line 1562
} else { 
#line 1563
if (_Ch < (65536)) 
#line 1564
{ 
#line 1565
_By = ((_Byte)((224) | (_Ch >> 12))); 
#line 1566
_Nextra = 2; 
#line 1567
} else { 
#line 1568
if (_Ch < (2097152)) 
#line 1569
{ 
#line 1570
_By = ((_Byte)((240) | (_Ch >> 18))); 
#line 1571
_Nextra = 3; 
#line 1572
} else { 
#line 1573
if (_Ch < (67108864)) 
#line 1574
{ 
#line 1575
_By = ((_Byte)((248) | (_Ch >> 24))); 
#line 1576
_Nextra = 4; 
#line 1577
} else 
#line 1579
{ 
#line 1580
_By = ((_Byte)((252) | ((_Ch >> 30) & (3)))); 
#line 1581
_Nextra = 5; 
#line 1582
}  }  }  }  }  
#line 1584
if ((*_Pstate) == 0) 
#line 1585
{ 
#line 1586
(*_Pstate) = (1); 
#line 1587
if (((_Mode) & (_Generate_header)) != 0) 
#line 1588
{ 
#line 1589
if ((_Last2 - _Mid2) < ((3 + 1) + _Nextra)) 
#line 1590
{ 
#line 1591
return _Mybase::partial; 
#line 1592
}  
#line 1595
(*(_Mid2++)) = ((_Byte)((unsigned char)239)); 
#line 1596
(*(_Mid2++)) = ((_Byte)((unsigned char)187)); 
#line 1597
(*(_Mid2++)) = ((_Byte)((unsigned char)191)); 
#line 1598
}  
#line 1599
}  
#line 1601
if ((_Last2 - _Mid2) < (1 + _Nextra)) 
#line 1602
{ 
#line 1603
break; 
#line 1604
}  
#line 1606
++_Mid1; 
#line 1607
for ((*(_Mid2++)) = _By; 0 < _Nextra;) 
#line 1608
{ 
#line 1609
(*(_Mid2++)) = ((_Byte)(((_Ch >> (6 * (--_Nextra))) & (63)) | (128))); 
#line 1610
}  
#line 1611
}  
#line 1612
return (_First1 == _Mid1) ? _Mybase::partial : _Mybase::ok; 
#line 1613
} 
#line 1615
virtual result do_unshift(_Statype &, _Byte *
#line 1616
_First2, _Byte *, _Byte *&_Mid2) const 
#line 1617
{ 
#line 1618
_Mid2 = _First2; 
#line 1620
return _Mybase::ok; 
#line 1621
} 
#line 1623
virtual int do_length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1624
_Last1, size_t _Count) const 
#line 1625
{ 
#line 1626
size_t _Wchars = (0); 
#line 1627
_Statype _Mystate = _State; 
#line 1629
while ((_Wchars < _Count) && (_First1 != _Last1)) { 
#line 1630
{ 
#line 1631
const _Byte *_Mid1; 
#line 1632
_Elem *_Mid2; 
#line 1633
_Elem _Ch; 
#line 1634
const auto _Result = this->do_in(_Mystate, _First1, _Last1, _Mid1, &_Ch, (&_Ch) + 1, _Mid2); 
#line 1635
if (_Result == (_Mybase::noconv)) 
#line 1636
{ 
#line 1637
_Wchars += (static_cast< size_t>(_Last1 - _First1)); 
#line 1638
break; 
#line 1639
}  
#line 1641
if (_Result == (_Mybase::ok)) 
#line 1642
{ 
#line 1643
if (_Mid2 == ((&_Ch) + 1)) 
#line 1644
{ 
#line 1645
++_Wchars; 
#line 1646
}  
#line 1648
_First1 = _Mid1; 
#line 1649
continue; 
#line 1650
}  
#line 1652
break; 
#line 1653
} }  
#line 1655
return static_cast< int>(_Min_value(static_cast< size_t>(2147483647), _Wchars)); 
#line 1656
} 
#line 1658
virtual bool do_always_noconv() const noexcept override 
#line 1659
{ 
#line 1660
return false; 
#line 1661
} 
#line 1663
virtual int do_max_length() const noexcept override 
#line 1664
{ 
#line 1665
return (((_Mode) & ((_Consume_header) | (_Generate_header))) != 0) ? 9 : 6; 
#line 1667
} 
#line 1669
virtual int do_encoding() const noexcept override 
#line 1670
{ 
#line 1671
return (((_Mode) & ((_Consume_header) | (_Generate_header))) != 0) ? -1 : 0; 
#line 1673
} 
#line 1676
private: unsigned long _Maxcode; 
#line 1677
_Codecvt_mode _Mode; 
#line 1678
}; 
#line 1682
template<> class __declspec(dllimport) codecvt< __wchar_t, char, _Mbstatet>  : public codecvt_base { 
#line 1686
public: typedef __wchar_t _Elem; 
#line 1687
typedef char _Byte; 
#line 1688
typedef _Mbstatet _Statype; 
#line 1689
typedef _Elem intern_type; 
#line 1690
typedef _Byte extern_type; 
#line 1691
typedef _Statype state_type; 
#line 1693
result in(_Statype &_State, const _Byte *
#line 1694
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1695
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1696
{ 
#line 1697
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1699
} 
#line 1701
result out(_Statype &_State, const _Elem *
#line 1702
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1703
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1704
{ 
#line 1705
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1707
} 
#line 1709
result unshift(_Statype &_State, _Byte *
#line 1710
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1711
{ 
#line 1712
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1714
} 
#line 1716
int length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1717
_Last1, size_t _Count) const 
#line 1718
{ 
#line 1719
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1720
} 
#line 1722
static locale::id id; 
#line 1724
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1726
{ 
#line 1727
{ _Locinfo _Lobj; 
#line 1728
this->_Init(_Lobj); 
#line 1729
} 
#line 1730
} 
#line 1732
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1734
{ 
#line 1735
this->_Init(_Lobj); 
#line 1736
} 
#line 1738
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1739
_Ploc = 0) 
#line 1740
{ 
#line 1741
if ((_Ppf != (nullptr)) && ((*_Ppf) == (nullptr))) { 
#line 1742
(*_Ppf) = (new std::codecvt< __wchar_t, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); }  
#line 1744
return 2; 
#line 1745
} 
#line 1748
protected: virtual ~codecvt() noexcept 
#line 1749
{ 
#line 1750
} 
#line 1752
void _Init(const _Locinfo &_Lobj) 
#line 1753
{ 
#line 1754
(_Cvt) = _Lobj._Getcvt(); 
#line 1755
} 
#line 1757
virtual result do_in(_Statype &, const _Byte *
#line 1758
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1759
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1760
{ 
#line 1761
_Statype _Mystate{}; 
#line 1762
_Adl_verify_range(_First1, _Last1); 
#line 1763
_Adl_verify_range(_First2, _Last2); 
#line 1764
_Mid1 = _First1; 
#line 1765
_Mid2 = _First2; 
#line 1766
for (; ;) 
#line 1767
{ 
#line 1768
if (_Mid1 == _Last1) 
#line 1769
{ 
#line 1770
return ok; 
#line 1771
}  
#line 1773
if (_Mid2 == _Last2) 
#line 1774
{ 
#line 1775
return partial; 
#line 1776
}  
#line 1778
int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast< size_t>(_Last1 - _Mid1), &_Mystate, &(_Cvt)); 
#line 1779
switch (_Bytes) 
#line 1780
{ 
#line 1781
case -2:  
#line 1782
return partial; 
#line 1784
case -1:  
#line 1785
return error; 
#line 1787
case 0:  
#line 1788
_Bytes = 1; 
#line 1791
default:  
#line 1792
_Mid1 += _Bytes; 
#line 1793
++_Mid2; 
#line 1794
break; 
#line 1795
}  
#line 1796
}  
#line 1797
} 
#line 1799
virtual result do_out(_Statype &_State, const _Elem *
#line 1800
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1801
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1802
{ 
#line 1803
_Adl_verify_range(_First1, _Last1); 
#line 1804
_Adl_verify_range(_First2, _Last2); 
#line 1805
_Mid1 = _First1; 
#line 1806
_Mid2 = _First2; 
#line 1807
int _Bytes; 
#line 1809
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) 
#line 1810
{ 
#line 1811
if (((int)5) <= (_Last2 - _Mid2)) 
#line 1812
{ 
#line 1813
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) 
#line 1815
{ 
#line 1816
return error; 
#line 1817
} else 
#line 1819
{ 
#line 1820
++_Mid1; 
#line 1821
_Mid2 += _Bytes; 
#line 1822
}  
#line 1823
} else 
#line 1825
{ 
#line 1826
_Byte _Buf[5]; 
#line 1827
_Statype _Stsave = _State; 
#line 1829
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) 
#line 1831
{ 
#line 1832
return error; 
#line 1833
} else { 
#line 1834
if ((_Last2 - _Mid2) < _Bytes) 
#line 1835
{ 
#line 1836
_State = _Stsave; 
#line 1837
break; 
#line 1838
} else 
#line 1840
{ 
#line 1841
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 1842
++_Mid1; 
#line 1843
_Mid2 += _Bytes; 
#line 1844
}  }  
#line 1845
}  
#line 1846
}  
#line 1848
return (_Mid1 == _Last1) ? ok : partial; 
#line 1849
} 
#line 1851
virtual result do_unshift(_Statype &_State, _Byte *
#line 1852
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1853
{ 
#line 1854
_Adl_verify_range(_First2, _Last2); 
#line 1855
_Mid2 = _First2; 
#line 1856
result _Ans = (ok); 
#line 1857
int _Bytes; 
#line 1858
_Byte _Buf[5]; 
#line 1859
_Statype _Stsave = _State; 
#line 1861
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 1862
_Ans = (error); } else { 
#line 1863
if ((_Last2 - _Mid2) < (--_Bytes)) 
#line 1864
{ 
#line 1865
_State = _Stsave; 
#line 1866
_Ans = (partial); 
#line 1867
} else { 
#line 1868
if (0 < _Bytes) 
#line 1869
{ 
#line 1870
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 1871
_Mid2 += _Bytes; 
#line 1872
}  }  }  
#line 1873
return _Ans; 
#line 1874
} 
#line 1876
virtual int do_length(_Statype &, const _Byte *_First1, const _Byte *
#line 1877
_Last1, size_t _Count) const 
#line 1878
{ 
#line 1879
_Adl_verify_range(_First1, _Last1); 
#line 1880
size_t _Wchars = (0); 
#line 1881
_Statype _Mystate{}; 
#line 1883
while ((_Wchars < _Count) && (_First1 != _Last1)) 
#line 1884
{ 
#line 1885
_Elem _Ch; 
#line 1886
int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast< size_t>(_Last1 - _First1), &_Mystate, &(_Cvt)); 
#line 1887
if (_Bytes < 0) 
#line 1888
{ 
#line 1889
break; 
#line 1890
}  
#line 1892
if (_Bytes == 0) 
#line 1893
{ 
#line 1894
_Bytes = 1; 
#line 1895
}  
#line 1898
_First1 += _Bytes; 
#line 1899
++_Wchars; 
#line 1900
}  
#line 1902
return static_cast< int>(_Min_value(static_cast< size_t>(2147483647), _Wchars)); 
#line 1903
} 
#line 1905
virtual bool do_always_noconv() const noexcept override 
#line 1906
{ 
#line 1907
return false; 
#line 1908
} 
#line 1910
virtual int do_max_length() const noexcept override 
#line 1911
{ 
#line 1912
return 5; 
#line 1913
} 
#line 1915
virtual int do_encoding() const noexcept override 
#line 1916
{ 
#line 1917
return 0; 
#line 1918
} 
#line 1921
private: _Locinfo::_Cvtvec _Cvt; 
#line 1922
}; 
#line 1927
template<> class __declspec(dllimport) codecvt< unsigned short, char, _Mbstatet>  : public codecvt_base { 
#line 1931
public: typedef unsigned short _Elem; 
#line 1932
typedef char _Byte; 
#line 1933
typedef _Mbstatet _Statype; 
#line 1934
typedef _Elem intern_type; 
#line 1935
typedef _Byte extern_type; 
#line 1936
typedef _Statype state_type; 
#line 1938
result in(_Statype &_State, const _Byte *
#line 1939
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1940
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1941
{ 
#line 1942
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1944
} 
#line 1946
result out(_Statype &_State, const _Elem *
#line 1947
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1948
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1949
{ 
#line 1950
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1952
} 
#line 1954
result unshift(_Statype &_State, _Byte *
#line 1955
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1956
{ 
#line 1957
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1959
} 
#line 1961
int length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1962
_Last1, size_t _Count) const 
#line 1963
{ 
#line 1964
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1965
} 
#line 1967
static locale::id id; 
#line 1969
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1971
{ 
#line 1972
{ _Locinfo _Lobj; 
#line 1973
this->_Init(_Lobj); 
#line 1974
} 
#line 1975
} 
#line 1977
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1979
{ 
#line 1980
this->_Init(_Lobj); 
#line 1981
} 
#line 1983
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1984
_Ploc = 0) 
#line 1985
{ 
#line 1986
if ((_Ppf != (nullptr)) && ((*_Ppf) == (nullptr))) { 
#line 1987
(*_Ppf) = (new std::codecvt< unsigned short, char, _Mbstatet> (((_Locinfo)(_Ploc->c_str())))); }  
#line 1989
return 2; 
#line 1990
} 
#line 1993
protected: virtual ~codecvt() noexcept 
#line 1994
{ 
#line 1995
} 
#line 1997
void _Init(const _Locinfo &_Lobj) 
#line 1998
{ 
#line 1999
(_Cvt) = _Lobj._Getcvt(); 
#line 2000
} 
#line 2002
virtual result do_in(_Statype &, const _Byte *
#line 2003
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 2004
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 2005
{ 
#line 2006
_Statype _Mystate{}; 
#line 2007
_Adl_verify_range(_First1, _Last1); 
#line 2008
_Adl_verify_range(_First2, _Last2); 
#line 2009
_Mid1 = _First1; 
#line 2010
_Mid2 = _First2; 
#line 2011
for (; ;) 
#line 2012
{ 
#line 2013
if (_Mid1 == _Last1) 
#line 2014
{ 
#line 2015
return ok; 
#line 2016
}  
#line 2018
if (_Mid2 == _Last2) 
#line 2019
{ 
#line 2020
return partial; 
#line 2021
}  
#line 2023
int _Bytes = _Mbrtowc(reinterpret_cast< __wchar_t *>(_Mid2), _Mid1, static_cast< size_t>(_Last1 - _Mid1), &_Mystate, &(_Cvt)); 
#line 2025
switch (_Bytes) 
#line 2026
{ 
#line 2027
case -2:  
#line 2028
return partial; 
#line 2030
case -1:  
#line 2031
return error; 
#line 2033
case 0:  
#line 2034
_Bytes = 1; 
#line 2037
default:  
#line 2038
_Mid1 += _Bytes; 
#line 2039
++_Mid2; 
#line 2040
break; 
#line 2041
}  
#line 2042
}  
#line 2043
} 
#line 2045
virtual result do_out(_Statype &_State, const _Elem *
#line 2046
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 2047
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 2048
{ 
#line 2049
_Adl_verify_range(_First1, _Last1); 
#line 2050
_Adl_verify_range(_First2, _Last2); 
#line 2051
_Mid1 = _First1; 
#line 2052
_Mid2 = _First2; 
#line 2053
int _Bytes; 
#line 2055
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) 
#line 2056
{ 
#line 2057
if (((int)5) <= (_Last2 - _Mid2)) 
#line 2058
{ 
#line 2059
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) 
#line 2061
{ 
#line 2062
return error; 
#line 2063
} else 
#line 2065
{ 
#line 2066
++_Mid1; 
#line 2067
_Mid2 += _Bytes; 
#line 2068
}  
#line 2069
} else 
#line 2071
{ 
#line 2072
_Byte _Buf[5]; 
#line 2073
_Statype _Stsave = _State; 
#line 2075
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) 
#line 2077
{ 
#line 2078
return error; 
#line 2079
} else { 
#line 2080
if ((_Last2 - _Mid2) < _Bytes) 
#line 2081
{ 
#line 2082
_State = _Stsave; 
#line 2083
break; 
#line 2084
} else 
#line 2086
{ 
#line 2087
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2088
++_Mid1; 
#line 2089
_Mid2 += _Bytes; 
#line 2090
}  }  
#line 2091
}  
#line 2092
}  
#line 2094
return (_Mid1 == _Last1) ? ok : partial; 
#line 2095
} 
#line 2097
virtual result do_unshift(_Statype &_State, _Byte *
#line 2098
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 2099
{ 
#line 2100
_Adl_verify_range(_First2, _Last2); 
#line 2101
_Mid2 = _First2; 
#line 2102
result _Ans = (ok); 
#line 2103
int _Bytes; 
#line 2104
_Byte _Buf[5]; 
#line 2105
_Statype _Stsave = _State; 
#line 2107
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) 
#line 2108
{ 
#line 2109
_Ans = (error); 
#line 2110
} else { 
#line 2111
if ((_Last2 - _Mid2) < (--_Bytes)) 
#line 2112
{ 
#line 2113
_State = _Stsave; 
#line 2114
_Ans = (partial); 
#line 2115
} else { 
#line 2116
if (0 < _Bytes) 
#line 2117
{ 
#line 2118
::memcpy(_Mid2, _Buf, static_cast< size_t>(_Bytes)); 
#line 2119
_Mid2 += _Bytes; 
#line 2120
}  }  }  
#line 2122
return _Ans; 
#line 2123
} 
#line 2125
virtual int do_length(_Statype &, const _Byte *_First1, const _Byte *
#line 2126
_Last1, size_t _Count) const 
#line 2127
{ 
#line 2128
_Adl_verify_range(_First1, _Last1); 
#line 2129
size_t _Wchars = (0); 
#line 2130
_Statype _Mystate{}; 
#line 2132
while ((_Wchars < _Count) && (_First1 != _Last1)) 
#line 2133
{ 
#line 2134
__wchar_t _Ch; 
#line 2135
int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast< size_t>(_Last1 - _First1), &_Mystate, &(_Cvt)); 
#line 2136
if (_Bytes < 0) 
#line 2137
{ 
#line 2138
break; 
#line 2139
}  
#line 2141
if (_Bytes == 0) 
#line 2142
{ 
#line 2143
_Bytes = 1; 
#line 2144
}  
#line 2147
_First1 += _Bytes; 
#line 2148
++_Wchars; 
#line 2149
}  
#line 2151
return static_cast< int>(_Min_value(static_cast< size_t>(2147483647), _Wchars)); 
#line 2152
} 
#line 2154
virtual bool do_always_noconv() const noexcept override 
#line 2155
{ 
#line 2156
return false; 
#line 2157
} 
#line 2159
virtual int do_max_length() const noexcept override 
#line 2160
{ 
#line 2161
return 5; 
#line 2162
} 
#line 2164
virtual int do_encoding() const noexcept override 
#line 2165
{ 
#line 2166
return 0; 
#line 2167
} 
#line 2170
private: _Locinfo::_Cvtvec _Cvt; 
#line 2171
}; 
#line 2175 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt_byname
  : public codecvt < _Elem, _Byte, _Statype >
 {
public :
 explicit codecvt_byname ( const char * _Locname, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Locname ), _Refs )
  {
  }

 explicit codecvt_byname ( const string & _Str, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }

protected :
 virtual ~ codecvt_byname ( ) noexcept
  {
  }
 };
#line 2199
struct __declspec(dllimport) ctype_base : public locale::facet { 
#line 2203
enum { 
#line 2204
alnum = 263, alpha = 259, 
#line 2205
cntrl = 32, digit = 4, graph = 279, 
#line 2206
lower = 2, print = 471, 
#line 2207
punct = 16, space = 72, upper = 1, 
#line 2208
xdigit = 128, blank = 72}; 
#line 2209
typedef short mask; 
#line 2211
ctype_base(size_t _Refs = 0) : locale::facet(_Refs) 
#line 2213
{ 
#line 2214
} 
#line 2216
virtual ~ctype_base() noexcept 
#line 2217
{ 
#line 2218
} 
#line 2219
}; 
#line 2222
template < class _Elem >
 class ctype
  : public ctype_base
 {
public :
 typedef _Elem char_type;

 bool is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( do_is ( _Maskval, _Ch ) );
  }

 const _Elem * is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  return ( do_is ( _First, _Last, _Dest ) );
  }

 const _Elem * scan_is ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_is ( _Maskval, _First, _Last ) );
  }

 const _Elem * scan_not ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_not ( _Maskval, _First, _Last ) );
  }

 _Elem tolower ( _Elem _Ch ) const
  {
  return ( do_tolower ( _Ch ) );
  }

 const _Elem * tolower ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_tolower ( _First, _Last ) );
  }

 _Elem toupper ( _Elem _Ch ) const
  {
  return ( do_toupper ( _Ch ) );
  }

 const _Elem * toupper ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_toupper ( _First, _Last ) );
  }

 _Elem widen ( char _Byte ) const
  {
  return ( do_widen ( _Byte ) );
  }

 const char * widen ( const char * _First, const char * _Last,
  _Elem * _Dest ) const
  {
  return ( do_widen ( _First, _Last, _Dest ) );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  return ( do_narrow ( _Ch, _Dflt ) );
  }

 const _Elem * narrow ( const _Elem * _First, const _Elem * _Last,
  char _Dflt, char * _Dest ) const
  {
  return ( do_narrow ( _First, _Last, _Dflt, _Dest ) );
  }

  static locale :: id id;

 explicit ctype ( size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  ctype ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr,
  const locale * _Ploc = nullptr )
  {
  if ( _Ppf != nullptr && * _Ppf == nullptr )
   * _Ppf = new ctype < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ ctype ( ) noexcept
  {
  if ( _Ctype . _Delfl )
   :: free ( ( void * ) _Ctype . _Table );

  :: free ( _Ctype . _LocaleName );
  }

 void _Init ( const _Locinfo & _Lobj )
  {
  _Ctype = _Lobj . _Getctype ( );
  _Cvt = _Lobj . _Getcvt ( );
  }

 virtual bool do_is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( ( _Ctype . _Table [ ( unsigned char ) narrow ( _Ch ) ]
   & _Maskval ) != 0 );
  }

 virtual const _Elem * do_is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  _Adl_verify_range ( _First, _Last );
  for (; _First != _Last; ++ _First, ++ _Dest )
   {
   * _Dest = _Ctype . _Table [ ( unsigned char ) narrow ( * _First ) ];
   }

  return ( _First );
  }

 virtual const _Elem * do_scan_is ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  _Adl_verify_range ( _First, _Last );
  while ( _First != _Last && ! is ( _Maskval, * _First ) )
   {
   ++ _First;
   }

  return ( _First );
  }

 virtual const _Elem * do_scan_not ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  _Adl_verify_range ( _First, _Last );
  while ( _First != _Last && is ( _Maskval, * _First ) )
   {
   ++ _First;
   }

  return ( _First );
  }

 virtual _Elem do_tolower ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   {
   return ( _Ch );
   }

  return ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_tolower ( _Elem * _First,
  const _Elem * _Last ) const
  {
  _Adl_verify_range ( ( const _Elem * ) _First, _Last );
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    {
    * _First = ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
    }
   }
  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_toupper ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   {
   return ( _Ch );
   }

  return ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_toupper ( _Elem * _First,
  const _Elem * _Last ) const
  {
  _Adl_verify_range ( ( const _Elem * ) _First, _Last );
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    {
    * _First = ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
    }
   }

  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_widen ( char _Byte ) const
  {
  return ( _Maklocchr ( _Byte, static_cast < _Elem * > ( nullptr ), _Cvt ) );
  }

 virtual const char * do_widen ( const char * _First,
  const char * _Last, _Elem * _Dest ) const
  {
  _Adl_verify_range ( _First, _Last );
  for (; _First != _Last; ++ _First, ++ _Dest )
   {
   * _Dest = _Maklocchr ( * _First, static_cast < _Elem * > ( nullptr ), _Cvt );
   }

  return ( _First );
  }

 char _Donarrow ( _Elem _Ch, char _Dflt ) const
  {
  char _Byte;
  if ( _Ch == ( _Elem ) 0 )
   {
   return ( '\000' );
   }

  if ( ( _Byte = _Maklocbyte ( _Ch, _Cvt ) ) == '\000' )
   {
   return ( _Dflt );
   }

  return ( _Byte );
  }

 virtual char do_narrow ( _Elem _Ch, char _Dflt ) const
  {
  return ( _Donarrow ( _Ch, _Dflt ) );
  }

 virtual const _Elem * do_narrow ( const _Elem * _First,
  const _Elem * _Last, char _Dflt, char * _Dest ) const
  {
  _Adl_verify_range ( _First, _Last );
  for (; _First != _Last; ++ _First, ++ _Dest )
   {
   * _Dest = _Donarrow ( * _First, _Dflt );
   }

  return ( _First );
  }

private :
 _Locinfo :: _Ctypevec _Ctype;
 _Locinfo :: _Cvtvec _Cvt;
 };
#line 2490
template< class _Elem> locale::id 
#line 2491
ctype< _Elem> ::id; 
#line 2499
template<> class __declspec(dllimport) ctype< char>  : public ctype_base { 
#line 2503
public: typedef char _Elem; 
#line 2504
typedef _Elem char_type; 
#line 2506
bool is(mask _Maskval, _Elem _Ch) const 
#line 2507
{ 
#line 2508
return ((((_Ctype)._Table)[(unsigned char)_Ch]) & _Maskval) != 0; 
#line 2509
} 
#line 2511
const _Elem *is(const _Elem *_First, const _Elem *
#line 2512
_Last, mask *_Dest) const 
#line 2513
{ 
#line 2514
_Adl_verify_range(_First, _Last); 
#line 2515
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2516
(*_Dest) = (((_Ctype)._Table)[(unsigned char)(*_First)]); }  
#line 2517
return _First; 
#line 2518
} 
#line 2520
const _Elem *scan_is(mask _Maskval, const _Elem *
#line 2521
_First, const _Elem *_Last) const 
#line 2522
{ 
#line 2523
_Adl_verify_range(_First, _Last); 
#line 2524
while ((_First != _Last) && (!this->is(_Maskval, *_First))) 
#line 2525
{ 
#line 2526
++_First; 
#line 2527
}  
#line 2529
return _First; 
#line 2530
} 
#line 2532
const _Elem *scan_not(mask _Maskval, const _Elem *
#line 2533
_First, const _Elem *_Last) const 
#line 2534
{ 
#line 2535
_Adl_verify_range(_First, _Last); 
#line 2536
while ((_First != _Last) && this->is(_Maskval, *_First)) 
#line 2537
{ 
#line 2538
++_First; 
#line 2539
}  
#line 2541
return _First; 
#line 2542
} 
#line 2544
_Elem tolower(_Elem _Ch) const 
#line 2545
{ 
#line 2546
return this->do_tolower(_Ch); 
#line 2547
} 
#line 2549
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2550
{ 
#line 2551
return this->do_tolower(_First, _Last); 
#line 2552
} 
#line 2554
_Elem toupper(_Elem _Ch) const 
#line 2555
{ 
#line 2556
return this->do_toupper(_Ch); 
#line 2557
} 
#line 2559
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2560
{ 
#line 2561
return this->do_toupper(_First, _Last); 
#line 2562
} 
#line 2564
_Elem widen(char _Byte) const 
#line 2565
{ 
#line 2566
return this->do_widen(_Byte); 
#line 2567
} 
#line 2569
const _Elem *widen(const char *_First, const char *_Last, _Elem *
#line 2570
_Dest) const 
#line 2571
{ 
#line 2572
return this->do_widen(_First, _Last, _Dest); 
#line 2573
} 
#line 2575
_Elem narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2576
{ 
#line 2577
return this->do_narrow(_Ch, _Dflt); 
#line 2578
} 
#line 2580
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2581
_Dflt, char *_Dest) const 
#line 2582
{ 
#line 2583
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2584
} 
#line 2586
static locale::id id; 
#line 2588
explicit ctype(const mask *_Table = 0, bool 
#line 2589
_Deletetable = false, size_t 
#line 2590
_Refs = 0) : ctype_base(_Refs) 
#line 2592
{ 
#line 2593
{ _Locinfo _Lobj; 
#line 2594
this->_Init(_Lobj); 
#line 2595
} 
#line 2597
this->_Tidy(); 
#line 2598
if (_Table != (nullptr)) 
#line 2599
{ 
#line 2600
((_Ctype)._Table) = _Table; 
#line 2601
((_Ctype)._Delfl) = (_Deletetable ? -1 : 0); 
#line 2602
} else 
#line 2604
{ 
#line 2605
((_Ctype)._Table) = classic_table(); 
#line 2606
((_Ctype)._Delfl) = 0; 
#line 2607
}  
#line 2608
} 
#line 2610
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2612
{ 
#line 2613
this->_Init(_Lobj); 
#line 2614
} 
#line 2616
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2617
_Ploc = 0) 
#line 2618
{ 
#line 2619
if ((_Ppf != (nullptr)) && ((*_Ppf) == (nullptr))) { 
#line 2620
(*_Ppf) = (new std::ctype< char> (((_Locinfo)(_Ploc->c_str())))); }  
#line 2622
return 2; 
#line 2623
} 
#line 2625
const mask *table() const noexcept 
#line 2626
{ 
#line 2627
return (_Ctype)._Table; 
#line 2628
} 
#line 2630
static const mask *__cdecl classic_table() noexcept 
#line 2631
{ 
#line 2632
return ::std::use_facet< std::ctype< char> > (locale::classic()).table(); 
#line 2633
} 
#line 2635
static const size_t table_size = (1 << 8); 
#line 2639
protected: virtual ~ctype() noexcept 
#line 2640
{ 
#line 2641
this->_Tidy(); 
#line 2642
} 
#line 2644
void _Init(const _Locinfo &_Lobj) 
#line 2645
{ 
#line 2646
(_Ctype) = _Lobj._Getctype(); 
#line 2647
} 
#line 2649
void _Tidy() 
#line 2650
{ 
#line 2651
if (0 < ((_Ctype)._Delfl)) { 
#line 2652
::free((void *)((_Ctype)._Table)); } else { 
#line 2653
if (((_Ctype)._Delfl) < 0) { 
#line 2654
delete [] ((_Ctype)._Table); }  }  
#line 2656
::free((_Ctype)._LocaleName); 
#line 2657
} 
#line 2659
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2660
{ 
#line 2661
return (_Elem)_Tolower((unsigned char)_Ch, &(_Ctype)); 
#line 2662
} 
#line 2664
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2665
_Last) const 
#line 2666
{ 
#line 2667
_Adl_verify_range((const _Elem *)_First, _Last); 
#line 2668
for (; _First != _Last; ++_First) 
#line 2669
{ 
#line 2670
(*_First) = ((_Elem)_Tolower((unsigned char)(*_First), &(_Ctype))); 
#line 2671
}  
#line 2673
return (const _Elem *)_First; 
#line 2674
} 
#line 2676
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2677
{ 
#line 2678
return (_Elem)_Toupper((unsigned char)_Ch, &(_Ctype)); 
#line 2679
} 
#line 2681
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2682
_Last) const 
#line 2683
{ 
#line 2684
_Adl_verify_range((const _Elem *)_First, _Last); 
#line 2685
for (; _First != _Last; ++_First) 
#line 2686
{ 
#line 2687
(*_First) = ((_Elem)_Toupper((unsigned char)(*_First), &(_Ctype))); 
#line 2688
}  
#line 2690
return (const _Elem *)_First; 
#line 2691
} 
#line 2693
virtual _Elem do_widen(char _Byte) const 
#line 2694
{ 
#line 2695
return _Byte; 
#line 2696
} 
#line 2698
virtual const _Elem *do_widen(const char *_First, const char *
#line 2699
_Last, _Elem *_Dest) const 
#line 2700
{ 
#line 2701
_Adl_verify_range(_First, _Last); 
#line 2702
::memcpy(_Dest, _First, static_cast< size_t>(_Last - _First)); 
#line 2703
return _Last; 
#line 2704
} 
#line 2706
virtual _Elem do_narrow(_Elem _Ch, char) const 
#line 2707
{ 
#line 2708
return _Ch; 
#line 2709
} 
#line 2711
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 2712
_Last, char, char *_Dest) const 
#line 2713
{ 
#line 2714
_Adl_verify_range(_First, _Last); 
#line 2715
::memcpy(_Dest, _First, static_cast< size_t>(_Last - _First)); 
#line 2716
return _Last; 
#line 2717
} 
#line 2720
private: _Locinfo::_Ctypevec _Ctype; 
#line 2721
}; 
#line 2725
template<> class __declspec(dllimport) ctype< __wchar_t>  : public ctype_base { 
#line 2729
public: typedef __wchar_t _Elem; 
#line 2730
typedef _Elem char_type; 
#line 2732
bool is(mask _Maskval, _Elem _Ch) const 
#line 2733
{ 
#line 2734
return this->do_is(_Maskval, _Ch); 
#line 2735
} 
#line 2737
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2738
_Dest) const 
#line 2739
{ 
#line 2740
return this->do_is(_First, _Last, _Dest); 
#line 2741
} 
#line 2743
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2744
_Last) const 
#line 2745
{ 
#line 2746
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2747
} 
#line 2749
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2750
_Last) const 
#line 2751
{ 
#line 2752
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2753
} 
#line 2755
_Elem tolower(_Elem _Ch) const 
#line 2756
{ 
#line 2757
return this->do_tolower(_Ch); 
#line 2758
} 
#line 2760
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2761
{ 
#line 2762
return this->do_tolower(_First, _Last); 
#line 2763
} 
#line 2765
_Elem toupper(_Elem _Ch) const 
#line 2766
{ 
#line 2767
return this->do_toupper(_Ch); 
#line 2768
} 
#line 2770
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2771
{ 
#line 2772
return this->do_toupper(_First, _Last); 
#line 2773
} 
#line 2775
_Elem widen(char _Byte) const 
#line 2776
{ 
#line 2777
return this->do_widen(_Byte); 
#line 2778
} 
#line 2780
const char *widen(const char *_First, const char *_Last, _Elem *
#line 2781
_Dest) const 
#line 2782
{ 
#line 2783
return this->do_widen(_First, _Last, _Dest); 
#line 2784
} 
#line 2786
char narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2787
{ 
#line 2788
return this->do_narrow(_Ch, _Dflt); 
#line 2789
} 
#line 2791
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2792
_Dflt, char *_Dest) const 
#line 2793
{ 
#line 2794
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2795
} 
#line 2797
static locale::id id; 
#line 2799
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 
#line 2801
{ 
#line 2802
{ _Locinfo _Lobj; 
#line 2803
this->_Init(_Lobj); 
#line 2804
} 
#line 2805
} 
#line 2807
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2809
{ 
#line 2810
this->_Init(_Lobj); 
#line 2811
} 
#line 2813
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2814
_Ploc = 0) 
#line 2815
{ 
#line 2816
if ((_Ppf != (nullptr)) && ((*_Ppf) == (nullptr))) 
#line 2817
{ 
#line 2818
(*_Ppf) = (new std::ctype< __wchar_t> (((_Locinfo)(_Ploc->c_str())))); 
#line 2819
}  
#line 2821
return 2; 
#line 2822
} 
#line 2825
protected: virtual ~ctype() noexcept 
#line 2826
{ 
#line 2827
if ((_Ctype)._Delfl) { 
#line 2828
::free((void *)((_Ctype)._Table)); }  
#line 2830
::free((_Ctype)._LocaleName); 
#line 2831
} 
#line 2833
void _Init(const _Locinfo &_Lobj) 
#line 2834
{ 
#line 2835
(_Ctype) = _Lobj._Getctype(); 
#line 2836
(_Cvt) = _Lobj._Getcvt(); 
#line 2837
} 
#line 2839
virtual bool do_is(mask _Maskval, _Elem _Ch) const 
#line 2840
{ 
#line 2841
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 2842
} 
#line 2844
virtual const _Elem *do_is(const _Elem *_First, const _Elem *
#line 2845
_Last, mask *_Dest) const 
#line 2846
{ 
#line 2847
_Adl_verify_range(_First, _Last); 
#line 2848
return ::_Getwctypes(_First, _Last, _Dest, &(_Ctype)); 
#line 2849
} 
#line 2851
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
#line 2852
_First, const _Elem *_Last) const 
#line 2853
{ 
#line 2854
_Adl_verify_range(_First, _Last); 
#line 2855
while ((_First != _Last) && (!this->is(_Maskval, *_First))) 
#line 2856
{ 
#line 2857
++_First; 
#line 2858
}  
#line 2860
return _First; 
#line 2861
} 
#line 2863
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
#line 2864
_First, const _Elem *_Last) const 
#line 2865
{ 
#line 2866
_Adl_verify_range(_First, _Last); 
#line 2867
while ((_First != _Last) && this->is(_Maskval, *_First)) 
#line 2868
{ 
#line 2869
++_First; 
#line 2870
}  
#line 2872
return _First; 
#line 2873
} 
#line 2875
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2876
{ 
#line 2877
return _Towlower(_Ch, &(_Ctype)); 
#line 2878
} 
#line 2880
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2881
_Last) const 
#line 2882
{ 
#line 2883
_Adl_verify_range((const _Elem *)_First, _Last); 
#line 2884
for (; _First != _Last; ++_First) 
#line 2885
{ 
#line 2886
(*_First) = _Towlower(*_First, &(_Ctype)); 
#line 2887
}  
#line 2889
return (const _Elem *)_First; 
#line 2890
} 
#line 2892
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2893
{ 
#line 2894
return _Towupper(_Ch, &(_Ctype)); 
#line 2895
} 
#line 2897
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2898
_Last) const 
#line 2899
{ 
#line 2900
_Adl_verify_range((const _Elem *)_First, _Last); 
#line 2901
for (; _First != _Last; ++_First) 
#line 2902
{ 
#line 2903
(*_First) = _Towupper(*_First, &(_Ctype)); 
#line 2904
}  
#line 2906
return (const _Elem *)_First; 
#line 2907
} 
#line 2909
_Elem _Dowiden(char _Byte) const 
#line 2910
{ 
#line 2911
mbstate_t _Mbst = {}; 
#line 2912
__wchar_t _Wc; 
#line 2913
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? (__wchar_t)((wint_t)65535) : _Wc; 
#line 2915
} 
#line 2917
virtual _Elem do_widen(char _Byte) const 
#line 2918
{ 
#line 2919
return this->_Dowiden(_Byte); 
#line 2920
} 
#line 2922
virtual const char *do_widen(const char *_First, const char *
#line 2923
_Last, _Elem *_Dest) const 
#line 2924
{ 
#line 2925
_Adl_verify_range(_First, _Last); 
#line 2926
for (; _First != _Last; (++_First), (++_Dest)) 
#line 2927
{ 
#line 2928
(*_Dest) = this->_Dowiden(*_First); 
#line 2929
}  
#line 2931
return _First; 
#line 2932
} 
#line 2934
char _Donarrow(_Elem _Ch, char _Dflt) const 
#line 2935
{ 
#line 2936
char _Buf[5]; 
#line 2937
mbstate_t _Mbst = {}; 
#line 2938
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : (_Buf[0]); 
#line 2940
} 
#line 2942
virtual char do_narrow(_Elem _Ch, char _Dflt) const 
#line 2943
{ 
#line 2944
return this->_Donarrow(_Ch, _Dflt); 
#line 2945
} 
#line 2947
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 2948
_Last, char _Dflt, char *_Dest) const 
#line 2949
{ 
#line 2950
_Adl_verify_range(_First, _Last); 
#line 2951
for (; _First != _Last; (++_First), (++_Dest)) 
#line 2952
{ 
#line 2953
(*_Dest) = this->_Donarrow(*_First, _Dflt); 
#line 2954
}  
#line 2956
return _First; 
#line 2957
} 
#line 2960
private: _Locinfo::_Ctypevec _Ctype; 
#line 2961
_Locinfo::_Cvtvec _Cvt; 
#line 2962
}; 
#line 2967
template<> class __declspec(dllimport) ctype< unsigned short>  : public ctype_base { 
#line 2971
public: typedef unsigned short _Elem; 
#line 2972
typedef _Elem char_type; 
#line 2974
bool is(mask _Maskval, _Elem _Ch) const 
#line 2975
{ 
#line 2976
return this->do_is(_Maskval, _Ch); 
#line 2977
} 
#line 2979
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2980
_Dest) const 
#line 2981
{ 
#line 2982
return this->do_is(_First, _Last, _Dest); 
#line 2983
} 
#line 2985
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2986
_Last) const 
#line 2987
{ 
#line 2988
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2989
} 
#line 2991
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2992
_Last) const 
#line 2993
{ 
#line 2994
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2995
} 
#line 2997
_Elem tolower(_Elem _Ch) const 
#line 2998
{ 
#line 2999
return this->do_tolower(_Ch); 
#line 3000
} 
#line 3002
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 3003
{ 
#line 3004
return this->do_tolower(_First, _Last); 
#line 3005
} 
#line 3007
_Elem toupper(_Elem _Ch) const 
#line 3008
{ 
#line 3009
return this->do_toupper(_Ch); 
#line 3010
} 
#line 3012
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 3013
{ 
#line 3014
return this->do_toupper(_First, _Last); 
#line 3015
} 
#line 3017
_Elem widen(char _Byte) const 
#line 3018
{ 
#line 3019
return this->do_widen(_Byte); 
#line 3020
} 
#line 3022
const char *widen(const char *_First, const char *_Last, _Elem *
#line 3023
_Dest) const 
#line 3024
{ 
#line 3025
return this->do_widen(_First, _Last, _Dest); 
#line 3026
} 
#line 3028
char narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 3029
{ 
#line 3030
return this->do_narrow(_Ch, _Dflt); 
#line 3031
} 
#line 3033
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 3034
_Dflt, char *_Dest) const 
#line 3035
{ 
#line 3036
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 3037
} 
#line 3039
static locale::id id; 
#line 3041
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 
#line 3043
{ 
#line 3044
{ _Locinfo _Lobj; 
#line 3045
this->_Init(_Lobj); 
#line 3046
} 
#line 3047
} 
#line 3049
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 3051
{ 
#line 3052
this->_Init(_Lobj); 
#line 3053
} 
#line 3055
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 3056
_Ploc = 0) 
#line 3057
{ 
#line 3058
if ((_Ppf != (nullptr)) && ((*_Ppf) == (nullptr))) 
#line 3059
{ 
#line 3060
(*_Ppf) = (new std::ctype< unsigned short> (((_Locinfo)(_Ploc->c_str())))); 
#line 3061
}  
#line 3063
return 2; 
#line 3064
} 
#line 3067
protected: virtual ~ctype() noexcept 
#line 3068
{ 
#line 3069
if ((_Ctype)._Delfl) { 
#line 3070
::free((void *)((_Ctype)._Table)); }  
#line 3072
::free((_Ctype)._LocaleName); 
#line 3073
} 
#line 3075
void _Init(const _Locinfo &_Lobj) 
#line 3076
{ 
#line 3077
(_Ctype) = _Lobj._Getctype(); 
#line 3078
(_Cvt) = _Lobj._Getcvt(); 
#line 3079
} 
#line 3081
virtual bool do_is(mask _Maskval, _Elem _Ch) const 
#line 3082
{ 
#line 3083
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 3084
} 
#line 3086
virtual const _Elem *do_is(const _Elem *_First, const _Elem *
#line 3087
_Last, mask *_Dest) const 
#line 3088
{ 
#line 3089
_Adl_verify_range(_First, _Last); 
#line 3090
return (const _Elem *)::_Getwctypes((const __wchar_t *)_First, (const __wchar_t *)_Last, _Dest, &(_Ctype)); 
#line 3092
} 
#line 3094
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
#line 3095
_First, const _Elem *_Last) const 
#line 3096
{ 
#line 3097
_Adl_verify_range(_First, _Last); 
#line 3098
while ((_First != _Last) && (!this->is(_Maskval, *_First))) 
#line 3099
{ 
#line 3100
++_First; 
#line 3101
}  
#line 3103
return _First; 
#line 3104
} 
#line 3106
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
#line 3107
_First, const _Elem *_Last) const 
#line 3108
{ 
#line 3109
_Adl_verify_range(_First, _Last); 
#line 3110
while ((_First != _Last) && this->is(_Maskval, *_First)) 
#line 3111
{ 
#line 3112
++_First; 
#line 3113
}  
#line 3115
return _First; 
#line 3116
} 
#line 3118
virtual _Elem do_tolower(_Elem _Ch) const 
#line 3119
{ 
#line 3120
return _Towlower(_Ch, &(_Ctype)); 
#line 3121
} 
#line 3123
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 3124
_Last) const 
#line 3125
{ 
#line 3126
_Adl_verify_range((const _Elem *)_First, _Last); 
#line 3127
for (; _First != _Last; ++_First) 
#line 3128
{ 
#line 3129
(*_First) = (_Towlower(*_First, &(_Ctype))); 
#line 3130
}  
#line 3132
return (const _Elem *)_First; 
#line 3133
} 
#line 3135
virtual _Elem do_toupper(_Elem _Ch) const 
#line 3136
{ 
#line 3137
return _Towupper(_Ch, &(_Ctype)); 
#line 3138
} 
#line 3140
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 3141
_Last) const 
#line 3142
{ 
#line 3143
_Adl_verify_range((const _Elem *)_First, _Last); 
#line 3144
for (; _First != _Last; ++_First) 
#line 3145
{ 
#line 3146
(*_First) = (_Towupper(*_First, &(_Ctype))); 
#line 3147
}  
#line 3149
return (const _Elem *)_First; 
#line 3150
} 
#line 3152
_Elem _Dowiden(char _Byte) const 
#line 3153
{ 
#line 3154
mbstate_t _Mbst = {}; 
#line 3155
unsigned short _Wc; 
#line 3156
return (_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? (unsigned short)((wint_t)65535) : _Wc; 
#line 3158
} 
#line 3160
virtual _Elem do_widen(char _Byte) const 
#line 3161
{ 
#line 3162
return this->_Dowiden(_Byte); 
#line 3163
} 
#line 3165
virtual const char *do_widen(const char *_First, const char *
#line 3166
_Last, _Elem *_Dest) const 
#line 3167
{ 
#line 3168
_Adl_verify_range(_First, _Last); 
#line 3169
for (; _First != _Last; (++_First), (++_Dest)) 
#line 3170
{ 
#line 3171
(*_Dest) = this->_Dowiden(*_First); 
#line 3172
}  
#line 3174
return _First; 
#line 3175
} 
#line 3177
char _Donarrow(_Elem _Ch, char _Dflt) const 
#line 3178
{ 
#line 3179
char _Buf[5]; 
#line 3180
mbstate_t _Mbst = {}; 
#line 3181
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : (_Buf[0]); 
#line 3183
} 
#line 3185
virtual char do_narrow(_Elem _Ch, char _Dflt) const 
#line 3186
{ 
#line 3187
return this->_Donarrow(_Ch, _Dflt); 
#line 3188
} 
#line 3190
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 3191
_Last, char _Dflt, char *_Dest) const 
#line 3192
{ 
#line 3193
_Adl_verify_range(_First, _Last); 
#line 3194
for (; _First != _Last; (++_First), (++_Dest)) 
#line 3195
{ 
#line 3196
(*_Dest) = this->_Donarrow(*_First, _Dflt); 
#line 3197
}  
#line 3199
return _First; 
#line 3200
} 
#line 3203
private: _Locinfo::_Ctypevec _Ctype; 
#line 3204
_Locinfo::_Cvtvec _Cvt; 
#line 3205
}; 
#line 3209 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
template < class _Elem >
 class ctype_byname
 : public ctype < _Elem >
 {
public :
 explicit ctype_byname ( const char * _Locname, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Locname ), _Refs )
  {
  }

 explicit ctype_byname ( const string & _Str, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }

protected :
 virtual ~ ctype_byname ( ) noexcept
  {
  }
 };
#line 3232
template<> class ctype_byname< char>  : public ctype< char>  { 
#line 3236
public: explicit ctype_byname(const char *_Locname, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Locname)), _Refs) 
#line 3238
{ 
#line 3239
} 
#line 3241
explicit ctype_byname(const string &_Str, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Str.c_str())), _Refs) 
#line 3243
{ 
#line 3244
} 
#line 3247
protected: virtual ~ctype_byname() noexcept 
#line 3248
{ 
#line 3249
} 
#line 3250
}; 
#line 3255
template class __declspec(dllimport) codecvt< char, char, _Mbstatet> ;
#line 3258 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocale"
}
#line 3261
#pragma warning(pop)
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xcall_once.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 16
namespace std { 
#line 18
struct once_flag { 
#line 20
constexpr once_flag() noexcept : _Opaque((nullptr)) 
#line 22
{ 
#line 23
} 
#line 25
once_flag(const once_flag &) = delete;
#line 26
once_flag &operator=(const once_flag &) = delete;
#line 28
void *_Opaque; 
#line 29
}; 
#line 31
typedef int (__stdcall *_Execute_once_fp_t)(void *, void *, void **); 
#line 32
int __cdecl _Execute_once(once_flag & _Flag, _Execute_once_fp_t _Callback, void * _Pv) noexcept; 
#line 35
}
#line 39
#pragma warning(pop)
#pragma pack ( pop )
#line 9 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xerrc.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 16
namespace std { 
#line 18
enum class errc { 
#line 20
address_family_not_supported = 102, 
#line 21
address_in_use = 100, 
#line 22
address_not_available, 
#line 23
already_connected = 113, 
#line 24
argument_list_too_long = 7, 
#line 25
argument_out_of_domain = 33, 
#line 26
bad_address = 14, 
#line 27
bad_file_descriptor = 9, 
#line 28
bad_message = 104, 
#line 29
broken_pipe = 32, 
#line 30
connection_aborted = 106, 
#line 31
connection_already_in_progress = 103, 
#line 32
connection_refused = 107, 
#line 33
connection_reset, 
#line 34
cross_device_link = 18, 
#line 35
destination_address_required = 109, 
#line 36
device_or_resource_busy = 16, 
#line 37
directory_not_empty = 41, 
#line 38
executable_format_error = 8, 
#line 39
file_exists = 17, 
#line 40
file_too_large = 27, 
#line 41
filename_too_long = 38, 
#line 42
function_not_supported = 40, 
#line 43
host_unreachable = 110, 
#line 44
identifier_removed, 
#line 45
illegal_byte_sequence = 42, 
#line 46
inappropriate_io_control_operation = 25, 
#line 47
interrupted = 4, 
#line 48
invalid_argument = 22, 
#line 49
invalid_seek = 29, 
#line 50
io_error = 5, 
#line 51
is_a_directory = 21, 
#line 52
message_size = 115, 
#line 53
network_down, 
#line 54
network_reset, 
#line 55
network_unreachable, 
#line 56
no_buffer_space, 
#line 57
no_child_process = 10, 
#line 58
no_link = 121, 
#line 59
no_lock_available = 39, 
#line 60
no_message_available = 120, 
#line 61
no_message = 122, 
#line 62
no_protocol_option, 
#line 63
no_space_on_device = 28, 
#line 64
no_stream_resources = 124, 
#line 65
no_such_device_or_address = 6, 
#line 66
no_such_device = 19, 
#line 67
no_such_file_or_directory = 2, 
#line 68
no_such_process, 
#line 69
not_a_directory = 20, 
#line 70
not_a_socket = 128, 
#line 71
not_a_stream = 125, 
#line 72
not_connected, 
#line 73
not_enough_memory = 12, 
#line 74
not_supported = 129, 
#line 75
operation_canceled = 105, 
#line 76
operation_in_progress = 112, 
#line 77
operation_not_permitted = 1, 
#line 78
operation_not_supported = 130, 
#line 79
operation_would_block = 140, 
#line 80
owner_dead = 133, 
#line 81
permission_denied = 13, 
#line 82
protocol_error = 134, 
#line 83
protocol_not_supported, 
#line 84
read_only_file_system = 30, 
#line 85
resource_deadlock_would_occur = 36, 
#line 86
resource_unavailable_try_again = 11, 
#line 87
result_out_of_range = 34, 
#line 88
state_not_recoverable = 127, 
#line 89
stream_timeout = 137, 
#line 90
text_file_busy = 139, 
#line 91
timed_out = 138, 
#line 92
too_many_files_open_in_system = 23, 
#line 93
too_many_files_open, 
#line 94
too_many_links = 31, 
#line 95
too_many_symbolic_link_levels = 114, 
#line 96
value_too_large = 132, 
#line 97
wrong_protocol_type = 136
#line 98
}; 
#line 100
}
#line 104
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\system_error"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 19
namespace std { 
#line 21
enum class io_errc { 
#line 22
stream = 1
#line 23
}; 
#line 26
template< class _Enum> 
#line 27
struct is_error_code_enum : public false_type { 
#line 30
}; 
#line 33
template<> struct is_error_code_enum< io_errc>  : public true_type { 
#line 36
}; 
#line 38
template< class _Ty> constexpr bool 
#line 39
is_error_code_enum_v = (is_error_code_enum< _Ty> ::value); 
#line 42
template< class _Enum> 
#line 43
struct is_error_condition_enum : public false_type { 
#line 46
}; 
#line 49
template<> struct is_error_condition_enum< errc>  : public true_type { 
#line 52
}; 
#line 54
template< class _Ty> constexpr bool 
#line 55
is_error_condition_enum_v = (is_error_condition_enum< _Ty> ::value); 
#line 57
class error_code; 
#line 58
class error_condition; 
#line 59
inline error_code make_error_code(errc) noexcept; 
#line 60
inline error_code make_error_code(io_errc) noexcept; 
#line 61
inline error_condition make_error_condition(errc) noexcept; 
#line 62
inline error_condition make_error_condition(io_errc) noexcept; 
#line 65
class error_category; 
#line 67
inline const error_category &generic_category() noexcept; 
#line 68
inline const error_category &iostream_category() noexcept; 
#line 69
inline const error_category &system_category() noexcept; 
#line 71
class __declspec(novtable) error_category { 
#line 74
public: error_category() noexcept 
#line 75
{ 
#line 76
(_Addr) = (reinterpret_cast< uintptr_t>(this)); 
#line 77
} 
#line 79
virtual ~error_category() noexcept 
#line 80
{ 
#line 81
} 
#line 83
virtual const char *name() const noexcept = 0; 
#line 85
virtual string message(int _Errval) const = 0; 
#line 87
inline virtual error_condition default_error_condition(int _Errval) const noexcept; 
#line 89
inline virtual bool equivalent(int _Errval, const error_condition & _Cond) const noexcept; 
#line 91
inline virtual bool equivalent(const error_code & _Code, int _Errval) const noexcept; 
#line 93
bool operator==(const error_category &_Right) const noexcept 
#line 94
{ 
#line 95
return (_Addr) == (_Right._Addr); 
#line 96
} 
#line 98
bool operator!=(const error_category &_Right) const noexcept 
#line 99
{ 
#line 100
return !((*this) == _Right); 
#line 101
} 
#line 103
bool operator<(const error_category &_Right) const noexcept 
#line 104
{ 
#line 105
return (_Addr) < (_Right._Addr); 
#line 106
} 
#line 108
error_category(const error_category &) = delete;
#line 109
error_category &operator=(const error_category &) = delete;
#line 112
protected: uintptr_t _Addr; 
#line 114
enum: uintptr_t { 
#line 116
_Future_addr = 1Ui64, 
#line 117
_Generic_addr = 3Ui64, 
#line 118
_Iostream_addr = 5Ui64, 
#line 119
_System_addr = 7Ui64
#line 120
}; 
#line 121
}; 
#line 124
class error_code { 
#line 127
public: error_code() noexcept : _Myval(0), _Mycat(&system_category()) 
#line 130
{ 
#line 131
} 
#line 133
error_code(int _Val, const error_category &_Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) 
#line 136
{ 
#line 137
} 
#line 139
template < class _Enum,
  enable_if_t < is_error_code_enum_v < _Enum >, int > = 0 >
  error_code ( _Enum _Errcode ) noexcept
  : _Myval ( 0 ),
  _Mycat ( nullptr )
  {
  * this = make_error_code ( _Errcode );
  }
#line 148
void assign(int _Val, const error_category &_Cat) noexcept 
#line 149
{ 
#line 150
(_Myval) = _Val; 
#line 151
(_Mycat) = (&_Cat); 
#line 152
} 
#line 154
template < class _Enum,
  enable_if_t < is_error_code_enum_v < _Enum >, int > = 0 >
  error_code & operator = ( _Enum _Errcode ) noexcept
  {
  * this = make_error_code ( _Errcode );
  return ( * this );
  }
#line 162
void clear() noexcept 
#line 163
{ 
#line 164
(_Myval) = 0; 
#line 165
(_Mycat) = (&system_category()); 
#line 166
} 
#line 168
int value() const noexcept 
#line 169
{ 
#line 170
return _Myval; 
#line 171
} 
#line 173
const error_category &category() const noexcept 
#line 174
{ 
#line 175
return *(_Mycat); 
#line 176
} 
#line 178
inline error_condition default_error_condition() const noexcept; 
#line 180
string message() const 
#line 181
{ 
#line 182
return this->category().message(this->value()); 
#line 183
} 
#line 185
explicit operator bool() const noexcept 
#line 186
{ 
#line 187
return this->value() != 0; 
#line 188
} 
#line 191
private: int _Myval; 
#line 192
const error_category *_Mycat; 
#line 193
}; 
#line 196
class error_condition { 
#line 199
public: error_condition() noexcept : _Myval(0), _Mycat(&generic_category()) 
#line 202
{ 
#line 203
} 
#line 205
error_condition(int _Val, const error_category &_Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) 
#line 208
{ 
#line 209
} 
#line 211
template < class _Enum,
  enable_if_t < is_error_condition_enum_v < _Enum >, int > = 0 >
  error_condition ( _Enum _Errcode ) noexcept
  : _Myval ( 0 ),
  _Mycat ( nullptr )
  {
  * this = make_error_condition ( _Errcode );
  }
#line 220
void assign(int _Val, const error_category &_Cat) noexcept 
#line 221
{ 
#line 222
(_Myval) = _Val; 
#line 223
(_Mycat) = (&_Cat); 
#line 224
} 
#line 226
template < class _Enum,
  enable_if_t < is_error_condition_enum_v < _Enum >, int > = 0 >
  error_condition & operator = ( _Enum _Errcode ) noexcept
  {
  * this = make_error_condition ( _Errcode );
  return ( * this );
  }
#line 234
void clear() noexcept 
#line 235
{ 
#line 236
(_Myval) = 0; 
#line 237
(_Mycat) = (&generic_category()); 
#line 238
} 
#line 240
int value() const noexcept 
#line 241
{ 
#line 242
return _Myval; 
#line 243
} 
#line 245
const error_category &category() const noexcept 
#line 246
{ 
#line 247
return *(_Mycat); 
#line 248
} 
#line 250
string message() const 
#line 251
{ 
#line 252
return this->category().message(this->value()); 
#line 253
} 
#line 255
explicit operator bool() const noexcept 
#line 256
{ 
#line 257
return this->value() != 0; 
#line 258
} 
#line 261
private: int _Myval; 
#line 262
const error_category *_Mycat; 
#line 263
}; 
#line 266
inline bool operator==(const error_code &_Left, const error_code &_Right) noexcept 
#line 267
{ 
#line 268
return ((_Left.category()) == (_Right.category())) && (_Left.value() == _Right.value()); 
#line 270
} 
#line 272
inline bool operator==(const error_code &_Left, const error_condition &_Right) noexcept 
#line 273
{ 
#line 274
return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value()); 
#line 276
} 
#line 278
inline bool operator==(const error_condition &_Left, const error_code &_Right) noexcept 
#line 279
{ 
#line 280
return _Right.category().equivalent(_Right.value(), _Left) || _Left.category().equivalent(_Right, _Left.value()); 
#line 282
} 
#line 284
inline bool operator==(const error_condition &_Left, const error_condition &_Right) noexcept 
#line 285
{ 
#line 286
return ((_Left.category()) == (_Right.category())) && (_Left.value() == _Right.value()); 
#line 288
} 
#line 291
inline bool operator!=(const error_code &_Left, const error_code &_Right) noexcept 
#line 292
{ 
#line 293
return !((_Left == _Right)); 
#line 294
} 
#line 296
inline bool operator!=(const error_code &_Left, const error_condition &_Right) noexcept 
#line 297
{ 
#line 298
return !((_Left == _Right)); 
#line 299
} 
#line 301
inline bool operator!=(const error_condition &_Left, const error_code &_Right) noexcept 
#line 302
{ 
#line 303
return !((_Left == _Right)); 
#line 304
} 
#line 306
inline bool operator!=(const error_condition &_Left, const error_condition &_Right) noexcept 
#line 307
{ 
#line 308
return !((_Left == _Right)); 
#line 309
} 
#line 312
inline bool operator<(const error_code &_Left, const error_code &_Right) noexcept 
#line 313
{ 
#line 314
return ((_Left.category()) < (_Right.category())) || (((_Left.category()) == (_Right.category())) && (_Left.value() < _Right.value())); 
#line 317
} 
#line 319
inline bool operator<(const error_condition &_Left, const error_condition &_Right) noexcept 
#line 320
{ 
#line 321
return ((_Left.category()) < (_Right.category())) || (((_Left.category()) == (_Right.category())) && (_Left.value() < _Right.value())); 
#line 324
} 
#line 327
inline error_condition error_category::default_error_condition(int _Errval) const noexcept 
#line 328
{ 
#line 329
return error_condition(_Errval, *this); 
#line 330
} 
#line 332
inline bool error_category::equivalent(int _Errval, const error_condition &_Cond) const noexcept 
#line 333
{ 
#line 334
return ((this->default_error_condition(_Errval)) == _Cond); 
#line 335
} 
#line 337
inline bool error_category::equivalent(const error_code &_Code, int _Errval) const noexcept 
#line 338
{ 
#line 339
return ((*this) == (_Code.category())) && (_Code.value() == _Errval); 
#line 340
} 
#line 343
inline error_condition error_code::default_error_condition() const noexcept 
#line 344
{ 
#line 345
return this->category().default_error_condition(this->value()); 
#line 346
} 
#line 349
inline error_code make_error_code(errc _Errno) noexcept 
#line 350
{ 
#line 351
return error_code((int)_Errno, generic_category()); 
#line 352
} 
#line 354
inline error_code make_error_code(io_errc _Errno) noexcept 
#line 355
{ 
#line 356
return error_code((int)_Errno, iostream_category()); 
#line 357
} 
#line 360
inline error_condition make_error_condition(errc _Errno) noexcept 
#line 361
{ 
#line 362
return error_condition((int)_Errno, generic_category()); 
#line 363
} 
#line 365
inline error_condition make_error_condition(io_errc _Errno) noexcept 
#line 366
{ 
#line 367
return error_condition((int)_Errno, iostream_category()); 
#line 368
} 
#line 372
template<> struct hash< error_code>  { 
#line 374
typedef error_code argument_type; 
#line 375
typedef size_t result_type; 
#line 377
size_t operator()(const error_code &_Keyval) const noexcept 
#line 378
{ 
#line 379
return std::hash< int> {}(_Keyval.value()); 
#line 380
} 
#line 381
}; 
#line 384
template<> struct hash< error_condition>  { 
#line 386
typedef error_condition argument_type; 
#line 387
typedef size_t result_type; 
#line 389
size_t operator()(const error_condition &_Keyval) const noexcept 
#line 390
{ 
#line 391
return std::hash< int> {}(_Keyval.value()); 
#line 392
} 
#line 393
}; 
#line 396
class _System_error : public runtime_error { 
#line 400
static string _Makestr(error_code _Errcode, string _Message) 
#line 401
{ 
#line 402
if (!_Message.empty()) 
#line 403
{ 
#line 404
_Message.append(": "); 
#line 405
}  
#line 407
_Message.append(_Errcode.message()); 
#line 408
return _Message; 
#line 409
} 
#line 412
protected: _System_error(error_code _Errcode, const string &_Message) : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) 
#line 415
{ 
#line 416
} 
#line 418
error_code _Mycode; 
#line 419
}; 
#line 421
class system_error : public _System_error { 
#line 425
typedef _System_error _Mybase; 
#line 428
public: system_error(error_code _Errcode) : _Mybase(_Errcode, "") 
#line 430
{ 
#line 431
} 
#line 433
system_error(error_code _Errcode, const string &_Message) : _Mybase(_Errcode, _Message) 
#line 435
{ 
#line 436
} 
#line 438
system_error(error_code _Errcode, const char *_Message) : _Mybase(_Errcode, _Message) 
#line 440
{ 
#line 441
} 
#line 443
system_error(int _Errval, const error_category &_Errcat) : _Mybase(error_code(_Errval, _Errcat), "") 
#line 445
{ 
#line 446
} 
#line 448
system_error(int _Errval, const error_category &_Errcat, const string &_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 450
{ 
#line 451
} 
#line 453
system_error(int _Errval, const error_category &_Errcat, const char *_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 455
{ 
#line 456
} 
#line 458
const error_code &code() const noexcept 
#line 459
{ 
#line 460
return _Mycode; 
#line 461
} 
#line 472 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\system_error"
}; 
#line 474
const char *__cdecl _Syserror_map(int); 
#line 475
int __cdecl _Winerror_map(int); 
#line 476
unsigned long __cdecl _Winerror_message(unsigned long _Message_id, char * _Narrow, unsigned long _Size); 
#line 480
class _Generic_error_category : public error_category { 
#line 484
public: _Generic_error_category() noexcept 
#line 485
{ 
#line 486
(_Addr) = (_Generic_addr); 
#line 487
} 
#line 489
virtual const char *name() const noexcept override 
#line 490
{ 
#line 491
return "generic"; 
#line 492
} 
#line 494
virtual string message(int _Errcode) const override 
#line 495
{ 
#line 496
return _Syserror_map(_Errcode); 
#line 497
} 
#line 498
}; 
#line 501
class _Iostream_error_category : public _Generic_error_category { 
#line 505
public: _Iostream_error_category() noexcept 
#line 506
{ 
#line 507
(_Addr) = (_Iostream_addr); 
#line 508
} 
#line 510
virtual const char *name() const noexcept override 
#line 511
{ 
#line 512
return "iostream"; 
#line 513
} 
#line 515
virtual string message(int _Errcode) const override 
#line 516
{ 
#line 517
if (_Errcode == ((int)io_errc::stream)) 
#line 518
{ 
#line 519
return "iostream stream error"; 
#line 520
} else 
#line 522
{ 
#line 523
return this->_Generic_error_category::message(_Errcode); 
#line 524
}  
#line 525
} 
#line 526
}; 
#line 529
class _System_error_category : public error_category { 
#line 533
public: _System_error_category() noexcept 
#line 534
{ 
#line 535
(_Addr) = (_System_addr); 
#line 536
} 
#line 538
virtual const char *name() const noexcept override 
#line 539
{ 
#line 540
return "system"; 
#line 541
} 
#line 543
virtual string message(int _Errcode) const override 
#line 544
{ 
#line 545
const unsigned long _Size = (32767); 
#line 546
string _Narrow(_Size, '\000'); 
#line 548
const unsigned long _Val = _Winerror_message(static_cast< unsigned long>(_Errcode), &_Narrow[0], _Size); 
#line 549
if (_Val == (0)) 
#line 550
{ 
#line 551
(_Narrow = ("unknown error")); 
#line 552
} else 
#line 554
{ 
#line 555
_Narrow.resize(_Val); 
#line 556
}  
#line 558
_Narrow.shrink_to_fit(); 
#line 559
return _Narrow; 
#line 560
} 
#line 562
virtual error_condition default_error_condition(int _Errval) const noexcept override 
#line 563
{ 
#line 564
const int _Posv = _Winerror_map(_Errval); 
#line 565
if (_Posv == 0) 
#line 566
{ 
#line 567
return error_condition(_Errval, system_category()); 
#line 568
} else 
#line 570
{ 
#line 571
return error_condition(_Posv, generic_category()); 
#line 572
}  
#line 573
} 
#line 574
}; 
#line 598
template < class _Ty > inline
 int __stdcall _Immortalize_impl ( void *, void * _Storage_ptr, void * * ) noexcept
 {
 :: new ( _Storage_ptr ) _Ty ( );
 return ( 1 );
 }
#line 605
template < class _Ty > inline
 _Ty & _Immortalize ( )
 {
 static_assert ( sizeof ( void * ) == sizeof ( once_flag ), "TRANSITION, VSO#406237" );
 static_assert ( alignof ( void * ) == alignof ( once_flag ), "TRANSITION, VSO#406237" );
 static void * _Flag = nullptr;
 static aligned_union_t < 1, _Ty > _Storage;
 if ( _Execute_once ( reinterpret_cast < once_flag & > ( _Flag ), _Immortalize_impl < _Ty >, & _Storage ) == 0 )
  {
  :: std :: terminate ( );
  }

 return ( reinterpret_cast < _Ty & > ( _Storage ) );
 }
#line 621 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\system_error"
inline const error_category &generic_category() noexcept 
#line 622
{ 
#line 623
return _Immortalize< _Generic_error_category> (); 
#line 624
} 
#line 626
inline const error_category &iostream_category() noexcept 
#line 627
{ 
#line 628
return _Immortalize< _Iostream_error_category> (); 
#line 629
} 
#line 631
inline const error_category &system_category() noexcept 
#line 632
{ 
#line 633
return _Immortalize< _System_error_category> (); 
#line 634
} 
#line 635
}
#line 638
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xiosbase"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 21
namespace std { 
#line 47
template< class _Dummy> 
#line 48
class _Iosb { 
#line 51
public: enum _Dummy_enum { _Dummy_enum_val = 1}; 
#line 52
enum _Fmtflags { 
#line 54
_Fmtmask = 65535, _Fmtzero = 0}; 
#line 56
static constexpr _Fmtflags skipws = ((_Fmtflags)1); 
#line 57
static constexpr _Fmtflags unitbuf = ((_Fmtflags)2); 
#line 58
static constexpr _Fmtflags uppercase = ((_Fmtflags)4); 
#line 59
static constexpr _Fmtflags showbase = ((_Fmtflags)8); 
#line 60
static constexpr _Fmtflags showpoint = ((_Fmtflags)16); 
#line 61
static constexpr _Fmtflags showpos = ((_Fmtflags)32); 
#line 62
static constexpr _Fmtflags left = ((_Fmtflags)64); 
#line 63
static constexpr _Fmtflags right = ((_Fmtflags)128); 
#line 64
static constexpr _Fmtflags internal = ((_Fmtflags)256); 
#line 65
static constexpr _Fmtflags dec = ((_Fmtflags)512); 
#line 66
static constexpr _Fmtflags oct = ((_Fmtflags)1024); 
#line 67
static constexpr _Fmtflags hex = ((_Fmtflags)2048); 
#line 68
static constexpr _Fmtflags scientific = ((_Fmtflags)4096); 
#line 69
static constexpr _Fmtflags fixed = ((_Fmtflags)8192); 
#line 71
static constexpr _Fmtflags hexfloat = ((_Fmtflags)12288); 
#line 74
static constexpr _Fmtflags boolalpha = ((_Fmtflags)16384); 
#line 75
static constexpr _Fmtflags _Stdio = ((_Fmtflags)32768); 
#line 76
static constexpr _Fmtflags adjustfield = ((_Fmtflags)((64 | 128) | 256)); 
#line 78
static constexpr _Fmtflags basefield = ((_Fmtflags)((512 | 1024) | 2048)); 
#line 80
static constexpr _Fmtflags floatfield = ((_Fmtflags)(4096 | 8192)); 
#line 83
enum _Iostate { 
#line 85
_Statmask = 23}; 
#line 87
static constexpr _Iostate goodbit = ((_Iostate)0); 
#line 88
static constexpr _Iostate eofbit = ((_Iostate)1); 
#line 89
static constexpr _Iostate failbit = ((_Iostate)2); 
#line 90
static constexpr _Iostate badbit = ((_Iostate)4); 
#line 92
enum _Openmode { 
#line 94
_Openmask = 255}; 
#line 96
static constexpr _Openmode in = ((_Openmode)1); 
#line 97
static constexpr _Openmode out = ((_Openmode)2); 
#line 98
static constexpr _Openmode ate = ((_Openmode)4); 
#line 99
static constexpr _Openmode app = ((_Openmode)8); 
#line 100
static constexpr _Openmode trunc = ((_Openmode)16); 
#line 101
static constexpr _Openmode _Nocreate = ((_Openmode)64); 
#line 102
static constexpr _Openmode _Noreplace = ((_Openmode)128); 
#line 103
static constexpr _Openmode binary = ((_Openmode)32); 
#line 105
enum _Seekdir { 
#line 107
_Seekbeg, 
#line 108
_Seekcur, 
#line 109
_Seekend
#line 110
}; 
#line 112
static constexpr _Seekdir beg = (_Seekbeg); 
#line 113
static constexpr _Seekdir cur = (_Seekcur); 
#line 114
static constexpr _Seekdir end = (_Seekend); 
#line 117
enum { 
#line 118
_Openprot = 64}; 
#line 119
}; 
#line 121
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::skipws; 
#line 123
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::unitbuf; 
#line 125
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::uppercase; 
#line 127
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::showbase; 
#line 129
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::showpoint; 
#line 131
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::showpos; 
#line 133
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::left; 
#line 135
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::right; 
#line 137
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::internal; 
#line 139
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::dec; 
#line 141
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::oct; 
#line 143
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::hex; 
#line 145
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::scientific; 
#line 147
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::fixed; 
#line 150
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::hexfloat; 
#line 154
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::boolalpha; 
#line 156
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::_Stdio; 
#line 158
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::adjustfield; 
#line 160
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::basefield; 
#line 162
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Fmtflags _Iosb< _Dummy> ::floatfield; 
#line 165
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::goodbit; 
#line 167
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::eofbit; 
#line 169
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::failbit; 
#line 171
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Iostate _Iosb< _Dummy> ::badbit; 
#line 174
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::in; 
#line 176
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::out; 
#line 178
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::ate; 
#line 180
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::app; 
#line 182
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::trunc; 
#line 184
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::_Nocreate; 
#line 186
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::_Noreplace; 
#line 188
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Openmode _Iosb< _Dummy> ::binary; 
#line 191
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Seekdir _Iosb< _Dummy> ::beg; 
#line 193
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Seekdir _Iosb< _Dummy> ::cur; 
#line 195
template< class _Dummy> constexpr const typename _Iosb< _Dummy> ::_Seekdir _Iosb< _Dummy> ::end; 
#line 199
class __declspec(dllimport) ios_base : public _Iosb< int>  { 
#line 203
public: typedef int fmtflags; 
#line 204
typedef int iostate; 
#line 205
typedef int openmode; 
#line 206
typedef int seekdir; 
#line 209
typedef std::streamoff streamoff; 
#line 210
typedef std::streampos streampos; 
#line 213 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xiosbase"
enum event { 
#line 215
erase_event, imbue_event, copyfmt_event}; 
#line 217
typedef void (__cdecl *event_callback)(event, ios_base &, int); 
#line 220
typedef unsigned io_state, open_mode, seek_dir; 
#line 224 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xiosbase"
class failure : public system_error { 
#line 229
public: explicit failure(const string &_Message, const error_code &
#line 230
_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 232
{ 
#line 233
} 
#line 235
explicit failure(const char *_Message, const error_code &
#line 236
_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 238
{ 
#line 239
} 
#line 251 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xiosbase"
}; 
#line 254
class __declspec(dllimport) Init { 
#line 257
public: Init() 
#line 258
{ 
#line 259
_Init_ctor(this); 
#line 260
} 
#line 262
~Init() noexcept 
#line 263
{ 
#line 264
_Init_dtor(this); 
#line 265
} 
#line 268
private: static void __cdecl _Init_ctor(Init *); 
#line 269
static void __cdecl _Init_dtor(Init *); 
#line 271
static int _Init_cnt; 
#line 273
static int &__cdecl _Init_cnt_func(); 
#line 274
}; 
#line 276
explicit operator bool() const 
#line 277
{ 
#line 278
return !this->fail(); 
#line 279
} 
#line 281
bool operator!() const 
#line 282
{ 
#line 283
return this->fail(); 
#line 284
} 
#line 286
void clear(iostate _State, bool _Reraise) 
#line 287
{ 
#line 288
_State &= (_Statmask); 
#line 289
(_Mystate) = _State; 
#line 290
const auto _Filtered = _State & (_Except); 
#line 291
if (_Filtered) 
#line 292
{ 
#line 293
if (_Reraise) 
#line 294
{ 
#line 295
throw; 
#line 296
}  
#line 298
const char *_Msg; 
#line 299
if (_Filtered & badbit) 
#line 300
{ 
#line 301
_Msg = ("ios_base::badbit set"); 
#line 302
} else { 
#line 303
if (_Filtered & failbit) 
#line 304
{ 
#line 305
_Msg = ("ios_base::failbit set"); 
#line 306
} else 
#line 308
{ 
#line 309
_Msg = ("ios_base::eofbit set"); 
#line 310
}  }  
#line 312
throw ((failure)(_Msg)); 
#line 313
}  
#line 314
} 
#line 316
void clear(iostate _State = goodbit) 
#line 317
{ 
#line 318
this->clear(_State, false); 
#line 319
} 
#line 322
void clear(io_state _State) 
#line 323
{ 
#line 324
this->clear((iostate)_State); 
#line 325
} 
#line 328 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xiosbase"
iostate rdstate() const 
#line 329
{ 
#line 330
return _Mystate; 
#line 331
} 
#line 333
void setstate(iostate _State, bool _Exreraise) 
#line 334
{ 
#line 335
this->clear(this->rdstate() | _State, _Exreraise); 
#line 336
} 
#line 338
void setstate(iostate _State) 
#line 339
{ 
#line 340
this->clear(this->rdstate() | _State, false); 
#line 341
} 
#line 344
void setstate(io_state _State) 
#line 345
{ 
#line 346
this->setstate((iostate)_State); 
#line 347
} 
#line 350 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xiosbase"
bool good() const 
#line 351
{ 
#line 352
return this->rdstate() == goodbit; 
#line 353
} 
#line 355
bool eof() const 
#line 356
{ 
#line 357
return this->rdstate() & eofbit; 
#line 358
} 
#line 360
bool fail() const 
#line 361
{ 
#line 362
return this->rdstate() & (badbit | failbit); 
#line 363
} 
#line 365
bool bad() const 
#line 366
{ 
#line 367
return this->rdstate() & badbit; 
#line 368
} 
#line 370
iostate exceptions() const 
#line 371
{ 
#line 372
return _Except; 
#line 373
} 
#line 375
void exceptions(iostate _Newexcept) 
#line 376
{ 
#line 377
(_Except) = (_Newexcept & (_Statmask)); 
#line 378
this->clear(this->rdstate()); 
#line 379
} 
#line 382
void exceptions(io_state _State) 
#line 383
{ 
#line 384
this->exceptions((iostate)_State); 
#line 385
} 
#line 388 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xiosbase"
fmtflags flags() const 
#line 389
{ 
#line 390
return _Fmtfl; 
#line 391
} 
#line 393
fmtflags flags(fmtflags _Newfmtflags) 
#line 394
{ 
#line 395
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 396
(_Fmtfl) = (_Newfmtflags & (_Fmtmask)); 
#line 397
return _Oldfmtflags; 
#line 398
} 
#line 400
fmtflags setf(fmtflags _Newfmtflags) 
#line 401
{ 
#line 402
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 403
(_Fmtfl) |= (_Newfmtflags & (_Fmtmask)); 
#line 404
return _Oldfmtflags; 
#line 405
} 
#line 407
fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask) 
#line 408
{ 
#line 409
const fmtflags _Oldfmtflags = _Fmtfl; 
#line 410
(_Fmtfl) = ((_Oldfmtflags & (~_Mask)) | ((_Newfmtflags & _Mask) & (_Fmtmask))); 
#line 411
return _Oldfmtflags; 
#line 412
} 
#line 414
void unsetf(fmtflags _Mask) 
#line 415
{ 
#line 416
(_Fmtfl) &= (~_Mask); 
#line 417
} 
#line 419
streamsize precision() const 
#line 420
{ 
#line 421
return _Prec; 
#line 422
} 
#line 424
streamsize precision(streamsize _Newprecision) 
#line 425
{ 
#line 426
const streamsize _Oldprecision = _Prec; 
#line 427
(_Prec) = _Newprecision; 
#line 428
return _Oldprecision; 
#line 429
} 
#line 431
streamsize width() const 
#line 432
{ 
#line 433
return _Wide; 
#line 434
} 
#line 436
streamsize width(streamsize _Newwidth) 
#line 437
{ 
#line 438
const streamsize _Oldwidth = _Wide; 
#line 439
(_Wide) = _Newwidth; 
#line 440
return _Oldwidth; 
#line 441
} 
#line 443
locale getloc() const 
#line 444
{ 
#line 445
return *(_Ploc); 
#line 446
} 
#line 448
locale imbue(const locale &_Loc) 
#line 449
{ 
#line 450
locale _Oldlocale = *(_Ploc); 
#line 451
((*(_Ploc)) = _Loc); 
#line 452
this->_Callfns(imbue_event); 
#line 453
return _Oldlocale; 
#line 454
} 
#line 456
static int __cdecl xalloc() 
#line 457
{ 
#line 458
{ _Lockit _Lock(2); 
#line 459
return _Index++; 
#line 460
} 
#line 461
} 
#line 463
long &iword(int _Idx) 
#line 464
{ 
#line 465
return this->_Findarr(_Idx)._Lo; 
#line 466
} 
#line 468
void *&pword(int _Idx) 
#line 469
{ 
#line 470
return this->_Findarr(_Idx)._Vp; 
#line 471
} 
#line 473
void register_callback(event_callback _Pfn, int 
#line 474
_Idx) 
#line 475
{ 
#line 476
(_Calls) = (new _Fnarray(_Idx, _Pfn, _Calls)); 
#line 477
} 
#line 479
ios_base &copyfmt(const ios_base &_Other) 
#line 480
{ 
#line 481
if (this != ::std::addressof(_Other)) 
#line 482
{ 
#line 483
this->_Tidy(); 
#line 484
((*(_Ploc)) = (*(_Other._Ploc))); 
#line 485
(_Fmtfl) = (_Other._Fmtfl); 
#line 486
(_Prec) = (_Other._Prec); 
#line 487
(_Wide) = (_Other._Wide); 
#line 488
_Iosarray *_Ptr = _Other._Arr; 
#line 490
for ((_Arr) = (nullptr); _Ptr != (nullptr); _Ptr = (_Ptr->_Next)) { 
#line 491
if (((_Ptr->_Lo) != (0)) || ((_Ptr->_Vp) != (nullptr))) 
#line 492
{ 
#line 493
this->iword(_Ptr->_Index) = (_Ptr->_Lo); 
#line 494
this->pword(_Ptr->_Index) = (_Ptr->_Vp); 
#line 495
}  }  
#line 497
for (_Fnarray *_Pfa = _Other._Calls; _Pfa != (nullptr); _Pfa = (_Pfa->_Next)) { 
#line 499
this->register_callback(_Pfa->_Pfn, _Pfa->_Index); }  
#line 501
this->_Callfns(copyfmt_event); 
#line 502
this->exceptions(_Other._Except); 
#line 503
}  
#line 504
return *this; 
#line 505
} 
#line 507
static bool __cdecl sync_with_stdio(bool _Newsync = true) 
#line 508
{ 
#line 509
{ _Lockit _Lock(2); 
#line 510
const bool _Oldsync = _Sync; 
#line 511
_Sync = _Newsync; 
#line 512
return _Oldsync; 
#line 513
} 
#line 514
} 
#line 516
void swap(ios_base &_Right) 
#line 517
{ 
#line 518
if (this != ::std::addressof(_Right)) 
#line 519
{ 
#line 520
::std::swap(_Mystate, _Right._Mystate); 
#line 521
::std::swap(_Except, _Right._Except); 
#line 522
::std::swap(_Fmtfl, _Right._Fmtfl); 
#line 523
::std::swap(_Prec, _Right._Prec); 
#line 524
::std::swap(_Wide, _Right._Wide); 
#line 526
::std::swap(_Arr, _Right._Arr); 
#line 527
::std::swap(_Calls, _Right._Calls); 
#line 528
::std::swap(_Ploc, _Right._Ploc); 
#line 529
}  
#line 530
} 
#line 532
virtual ~ios_base() noexcept 
#line 533
{ 
#line 534
_Ios_base_dtor(this); 
#line 535
} 
#line 538
static void __cdecl _Addstd(ios_base *); 
#line 540
size_t _Stdstr; 
#line 543
protected: ios_base() 
#line 544
{ 
#line 545
} 
#line 547
void _Init() 
#line 548
{ 
#line 549
(_Ploc) = (nullptr); 
#line 550
(_Stdstr) = (0); 
#line 551
(_Except) = goodbit; 
#line 552
(_Fmtfl) = ((fmtflags)(skipws | dec)); 
#line 553
(_Prec) = (6); 
#line 554
(_Wide) = (0); 
#line 555
(_Arr) = (nullptr); 
#line 556
(_Calls) = (nullptr); 
#line 557
this->clear(goodbit); 
#line 558
(_Ploc) = (new locale); 
#line 559
} 
#line 563
private: struct _Iosarray : public _Crt_new_delete { 
#line 567
_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo((0)), _Vp((nullptr)) 
#line 569
{ 
#line 570
} 
#line 572
_Iosarray *_Next; 
#line 573
int _Index; 
#line 574
long _Lo; 
#line 575
void *_Vp; 
#line 576
}; 
#line 579
struct _Fnarray : public _Crt_new_delete { 
#line 582
_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 
#line 584
{ 
#line 585
} 
#line 587
_Fnarray *_Next; 
#line 588
int _Index; 
#line 589
event_callback _Pfn; 
#line 590
}; 
#line 592
void _Callfns(event _Ev) 
#line 593
{ 
#line 594
for (_Fnarray *_Pfa = _Calls; _Pfa != (nullptr); _Pfa = (_Pfa->_Next)) { 
#line 595
(*(_Pfa->_Pfn))(_Ev, *this, _Pfa->_Index); }  
#line 596
} 
#line 598
_Iosarray &_Findarr(int _Idx) 
#line 599
{ 
#line 600
_Iosarray *_Ptr1, *_Ptr2; 
#line 602
for ((_Ptr1 = (_Arr)), (_Ptr2 = (nullptr)); _Ptr1 != (nullptr); _Ptr1 = (_Ptr1->_Next)) { 
#line 603
if ((_Ptr1->_Index) == _Idx) { 
#line 604
return *_Ptr1; } else { 
#line 605
if (((_Ptr2 == (nullptr)) && ((_Ptr1->_Lo) == (0))) && ((_Ptr1->_Vp) == (nullptr))) { 
#line 606
_Ptr2 = _Ptr1; }  }  }  
#line 608
if (_Ptr2 != (nullptr)) 
#line 609
{ 
#line 610
(_Ptr2->_Index) = _Idx; 
#line 611
return *_Ptr2; 
#line 612
}  
#line 614
(_Arr) = (new _Iosarray(_Idx, _Arr)); 
#line 615
return *(_Arr); 
#line 616
} 
#line 618
void _Tidy() 
#line 619
{ 
#line 620
this->_Callfns(erase_event); 
#line 621
_Iosarray *_Ptr1, *_Ptr2; 
#line 623
for (_Ptr1 = (_Arr); _Ptr1 != (nullptr); _Ptr1 = _Ptr2) 
#line 624
{ 
#line 625
_Ptr2 = (_Ptr1->_Next); 
#line 626
delete _Ptr1; 
#line 627
}  
#line 628
(_Arr) = (nullptr); 
#line 630
_Fnarray *_Pfa1, *_Pfa2; 
#line 631
for (_Pfa1 = (_Calls); _Pfa1 != (nullptr); _Pfa1 = _Pfa2) 
#line 632
{ 
#line 633
_Pfa2 = (_Pfa1->_Next); 
#line 634
delete _Pfa1; 
#line 635
}  
#line 636
(_Calls) = (nullptr); 
#line 637
} 
#line 639
iostate _Mystate; 
#line 640
iostate _Except; 
#line 641
fmtflags _Fmtfl; 
#line 642
streamsize _Prec; 
#line 643
streamsize _Wide; 
#line 644
_Iosarray *_Arr; 
#line 645
_Fnarray *_Calls; 
#line 646
locale *_Ploc; 
#line 648
static int _Index; 
#line 649
static bool _Sync; 
#line 652
static void __cdecl _Ios_base_dtor(ios_base *); 
#line 655
public: ios_base(const ios_base &) = delete;
#line 656
ios_base &operator=(const ios_base &) = delete;
#line 657
}; 
#line 658
}
#line 661
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\streambuf"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 17
template < class _Elem,
 class _Traits >
 class basic_streambuf
 {
protected :
  basic_streambuf ( )
  : _Plocale ( new locale )
  {
  _Init ( );
  }

  basic_streambuf ( _Uninitialized )
  {
  }

  basic_streambuf ( const basic_streambuf & _Right )
  : _Plocale ( new locale ( _Right . getloc ( ) ) )
  {
  _Init ( );
  setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
  setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
  }

 basic_streambuf & operator = ( const basic_streambuf & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   pubimbue ( _Right . getloc ( ) );
   }
  return ( * this );
  }

 void swap ( basic_streambuf & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Elem * _Pfirst0 = pbase ( );
   _Elem * _Pnext0 = pptr ( );
   _Elem * _Pend = epptr ( );
   _Elem * _Gfirst0 = eback ( );
   _Elem * _Gnext0 = gptr ( );
   _Elem * _Gend = egptr ( );

   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   _Right . setp ( _Pfirst0, _Pnext0, _Pend );

   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   _Right . setg ( _Gfirst0, _Gnext0, _Gend );

   :: std :: swap ( _Plocale, _Right . _Plocale );
   }
  }

public :
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~ basic_streambuf ( ) noexcept
  {
  delete _Plocale;
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 pos_type pubseekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekoff ( _Off, _Way, _Mode ) );
  }


 pos_type pubseekoff ( off_type _Off,
  ios_base :: seek_dir _Way,
  ios_base :: open_mode _Mode )
  {
  return ( pubseekoff ( _Off, ( ios_base :: seekdir ) _Way,
   ( ios_base :: openmode ) _Mode ) );
  }


 pos_type pubseekpos ( pos_type _Pos,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekpos ( _Pos, _Mode ) );
  }


 pos_type pubseekpos ( pos_type _Pos,
  ios_base :: open_mode _Mode )
  {
  return ( seekpos ( _Pos, ( ios_base :: openmode ) _Mode ) );
  }


 basic_streambuf * pubsetbuf ( _Elem * _Buffer,
  streamsize _Count )
  {
  return ( setbuf ( _Buffer, _Count ) );
  }

 locale pubimbue ( const locale & _Newlocale )
  {
  locale _Oldlocale = * _Plocale;
  imbue ( _Newlocale );
  * _Plocale = _Newlocale;
  return ( _Oldlocale );
  }

 locale getloc ( ) const
  {
  return ( * _Plocale );
  }

 streamsize in_avail ( )
  {
  streamsize _Res = _Gnavail ( );
  return ( 0 < _Res ? _Res : showmanyc ( ) );
  }

 int pubsync ( )
  {
  return ( sync ( ) );
  }

 int_type sbumpc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gninc ( ) ) : uflow ( ) );
  }

 int_type sgetc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * gptr ( ) ) : underflow ( ) );
  }

 streamsize sgetn ( _Elem * _Ptr,
  streamsize _Count )
  {
  return ( xsgetn ( _Ptr, _Count ) );
  }

 int_type snextc ( )
  {
  return ( 1 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gnpreinc ( ) )
   : _Traits :: eq_int_type ( _Traits :: eof ( ), sbumpc ( ) )
    ? _Traits :: eof ( ) : sgetc ( ) );
  }

 int_type sputbackc ( _Elem _Ch )
  {
  return ( gptr ( ) != nullptr && eback ( ) < gptr ( )
   && _Traits :: eq ( _Ch, gptr ( ) [ - 1 ] )
   ? _Traits :: to_int_type ( * _Gndec ( ) )
   : pbackfail ( _Traits :: to_int_type ( _Ch ) ) );
  }


 void stossc ( )
  {
  if ( 0 < _Gnavail ( ) )
   _Gninc ( );
  else
   uflow ( );
  }


 int_type sungetc ( )
  {
  return ( gptr ( ) != nullptr && eback ( ) < gptr ( )
   ? _Traits :: to_int_type ( * _Gndec ( ) ) : pbackfail ( ) );
  }

 int_type sputc ( _Elem _Ch )
  {
  return ( 0 < _Pnavail ( )
   ? _Traits :: to_int_type ( * _Pninc ( ) = _Ch )
   : overflow ( _Traits :: to_int_type ( _Ch ) ) );
  }

 streamsize sputn ( const _Elem * _Ptr,
  streamsize _Count )
  {
  return ( xsputn ( _Ptr, _Count ) );
  }

 virtual void _Lock ( )
  {
  }

 virtual void _Unlock ( )
  {
  }

protected :
 _Elem * eback ( ) const
  {
  return ( * _IGfirst );
  }

 _Elem * gptr ( ) const
  {
  return ( * _IGnext );
  }

 _Elem * pbase ( ) const
  {
  return ( * _IPfirst );
  }

 _Elem * pptr ( ) const
  {
  return ( * _IPnext );
  }

 _Elem * egptr ( ) const
  {
  return ( * _IGnext + * _IGcount );
  }

 void gbump ( int _Off )
  {
  * _IGcount -= _Off;
  * _IGnext += _Off;
  }

 void setg ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IGfirst = _First;
  * _IGnext = _Next;
  * _IGcount = ( int ) ( _Last - _Next );
  }

 _Elem * epptr ( ) const
  {
  return ( * _IPnext + * _IPcount );
  }

 _Elem * _Gndec ( )
  {
  ++ * _IGcount;
  return ( -- * _IGnext );
  }

 _Elem * _Gninc ( )
  {
  -- * _IGcount;
  return ( ( * _IGnext ) ++ );
  }

 _Elem * _Gnpreinc ( )
  {
  -- * _IGcount;
  return ( ++ ( * _IGnext ) );
  }

 streamsize _Gnavail ( ) const
  {
  return ( * _IGnext != nullptr ? * _IGcount : 0 );
  }

 void pbump ( int _Off )
  {
  * _IPcount -= _Off;
  * _IPnext += _Off;
  }

 void setp ( _Elem * _First, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _First;
  * _IPcount = ( int ) ( _Last - _First );
  }

 void setp ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _Next;
  * _IPcount = ( int ) ( _Last - _Next );
  }

 _Elem * _Pninc ( )
  {
  -- * _IPcount;
  return ( ( * _IPnext ) ++ );
  }

 streamsize _Pnavail ( ) const
  {
  return ( * _IPnext != nullptr ? * _IPcount : 0 );
  }

 void _Init ( )
  {
  _IGfirst = & _Gfirst;
  _IPfirst = & _Pfirst;
  _IGnext = & _Gnext;
  _IPnext = & _Pnext;
  _IGcount = & _Gcount;
  _IPcount = & _Pcount;
  setp ( nullptr, nullptr );
  setg ( nullptr, nullptr, nullptr );
  }

 void _Init ( _Elem * * _Gf, _Elem * * _Gn, int * _Gc,
  _Elem * * _Pf, _Elem * * _Pn, int * _Pc )
  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGcount = _Gc;
  _IPcount = _Pc;
  }

 virtual int_type overflow ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type pbackfail ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual streamsize showmanyc ( )
  {
  return ( 0 );
  }

 virtual int_type underflow ( )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type uflow ( )
  {
  return ( _Traits :: eq_int_type ( _Traits :: eof ( ), underflow ( ) )
   ? _Traits :: eof ( ) : _Traits :: to_int_type ( * _Gninc ( ) ) );
  }

 virtual streamsize xsgetn ( _Elem * _Ptr, streamsize _Count )
  {
  const streamsize _Start_count = _Count;

  while ( 0 < _Count )
   {
   streamsize _Size = _Gnavail ( );
   if ( 0 < _Size )
    {
    if ( _Count < _Size )
     {
     _Size = _Count;
     }

    _Traits :: copy ( _Ptr, gptr ( ), static_cast < size_t > ( _Size ) );
    _Ptr += _Size;
    _Count -= _Size;
    gbump ( static_cast < int > ( _Size ) );
    }
   else
    {
    const int_type _Meta = uflow ( );
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     break;
     }


    * _Ptr ++ = _Traits :: to_char_type ( _Meta );
    -- _Count;
    }
   }

  return ( _Start_count - _Count );
  }

 virtual streamsize xsputn ( const _Elem * _Ptr, streamsize _Count )
  {
  const streamsize _Start_count = _Count;
  while ( 0 < _Count )
   {
   streamsize _Size = _Pnavail ( );
   if ( 0 < _Size )
    {
    if ( _Count < _Size )
     {
     _Size = _Count;
     }

    _Traits :: copy ( pptr ( ), _Ptr, static_cast < size_t > ( _Size ) );
    _Ptr += _Size;
    _Count -= _Size;
    pbump ( static_cast < int > ( _Size ) );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), overflow ( _Traits :: to_int_type ( * _Ptr ) ) ) )
    {
    break;
    }
   else
    {
    ++ _Ptr;
    -- _Count;
    }
   }

  return ( _Start_count - _Count );
  }

 virtual pos_type seekoff ( off_type,
  ios_base :: seekdir,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( - 1 ) );
  }

 virtual pos_type seekpos ( pos_type,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( - 1 ) );
  }

 virtual basic_streambuf * setbuf ( _Elem *, streamsize )
  {
  return ( this );
  }

 virtual int sync ( )
  {
  return ( 0 );
  }

 virtual void imbue ( const locale & )
  {
  }

private :
 _Elem * _Gfirst;
 _Elem * _Pfirst;
 _Elem * * _IGfirst;
 _Elem * * _IPfirst;
 _Elem * _Gnext;
 _Elem * _Pnext;
 _Elem * * _IGnext;
 _Elem * * _IPnext;

 int _Gcount;
 int _Pcount;
 int * _IGcount;
 int * _IPcount;

protected :
 locale * _Plocale;
 };
#line 481 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\streambuf"
template class __declspec(dllimport) basic_streambuf< char, char_traits< char> > ;
#line 482
template class __declspec(dllimport) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ;
#line 492 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\streambuf"
template < class _Elem,
 class _Traits >
 class istreambuf_iterator
 {
public :
 using iterator_category = input_iterator_tag;
 using value_type = _Elem;
 using difference_type = typename _Traits :: off_type;
 using pointer = const _Elem *;
 using reference = _Elem;

 using char_type = _Elem;
 using traits_type = _Traits;
 using streambuf_type = basic_streambuf < _Elem, _Traits >;
 using istream_type = basic_istream < _Elem, _Traits >;

 using int_type = typename traits_type :: int_type;

 constexpr istreambuf_iterator ( ) noexcept
  : _Strbuf ( nullptr ),
  _Got ( true ),
  _Val ( )
  {
  }

 istreambuf_iterator ( streambuf_type * _Sb ) noexcept
  : _Strbuf ( _Sb ),
  _Got ( _Sb == nullptr ),
  _Val ( )
  {
  }

 istreambuf_iterator ( istream_type & _Istr ) noexcept
  : _Strbuf ( _Istr . rdbuf ( ) ),
  _Got ( _Strbuf == nullptr ),
  _Val ( )
  {
  }

private :
 class _Istreambuf_proxy
  {
 public :
   _Elem operator * ( ) const
   {
   return ( _Keep );
   }
 private :
  friend istreambuf_iterator;
  _Istreambuf_proxy ( streambuf_type * _Strbuf_, _Elem _Keep_ )
   : _Strbuf ( _Strbuf_ ),
   _Keep ( _Keep_ )
   {
   }

  streambuf_type * _Strbuf;
  _Elem _Keep;
  };

public :
 istreambuf_iterator ( const _Istreambuf_proxy & _Px ) noexcept
  : _Strbuf ( _Px . _Strbuf ),
  _Got ( _Strbuf == nullptr ),
  _Val ( )
  {
  }

  _Elem operator * ( ) const
  {
  if ( ! _Got )
   _Peek ( );


  do { if ( _Strbuf != nullptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\streambuf", 565, 0, "%s", "istreambuf_iterator is not dereferencable" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x73\x74\x72\x65\x61\x6d\x62\x75\x66\x5f\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x69\x73\x20\x6e\x6f\x74\x20\x64\x65\x72\x65" L"\x66\x65\x72\x65\x6e\x63\x61\x62\x6c\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x73\x74\x72\x65\x61\x6d\x62\x75\x66", 565, 0 ); } while ( false ); }; } while ( false );


  return ( _Val );
  }

 istreambuf_iterator & operator ++ ( )
  {

  do { if ( _Strbuf != nullptr ) { } else { do { ( void ) ( ( 1 != _CrtDbgReport ( 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\streambuf", 574, 0, "%s", "istreambuf_iterator is not incrementable" ) ) || ( __debugbreak ( ), 0 ) ); :: _invalid_parameter ( L"\x22\x69\x73\x74\x72\x65\x61\x6d\x62\x75\x66\x5f\x69\x74\x65\x72\x61\x74\x6f\x72\x20\x69\x73\x20\x6e\x6f\x74\x20\x69\x6e\x63\x72" L"\x65\x6d\x65\x6e\x74\x61\x62\x6c\x65\x22", __LPREFIX ( __FUNCTION__ ), L"\x43\x3a\x5c\x50\x72\x6f\x67\x72\x61\x6d\x20\x46\x69\x6c\x65\x73\x20\x28\x78\x38\x36\x29\x5c\x4d\x69\x63\x72\x6f\x73\x6f\x66\x74" L"\x20\x56\x69\x73\x75\x61\x6c\x20\x53\x74\x75\x64\x69\x6f\x5c\x32\x30\x31\x37\x5c\x43\x6f\x6d\x6d\x75\x6e\x69\x74\x79\x5c\x56\x43" L"\x5c\x54\x6f\x6f\x6c\x73\x5c\x4d\x53\x56\x43\x5c\x31\x34\x2e\x31\x36\x2e\x32\x37\x30\x32\x33\x5c\x69\x6e\x63\x6c\x75\x64\x65\x5c" L"\x73\x74\x72\x65\x61\x6d\x62\x75\x66", 574, 0 ); } while ( false ); }; } while ( false );


  _Inc ( );
  return ( * this );
  }

 _Istreambuf_proxy operator ++ ( int )
  {
  if ( ! _Got )
   _Peek ( );
  _Istreambuf_proxy _Tmp { _Strbuf, _Val };
  ++ * this;
  return ( _Tmp );
  }

  bool equal ( const istreambuf_iterator & _Right ) const
  {
  if ( ! _Got )
   _Peek ( );
  if ( ! _Right . _Got )
   _Right . _Peek ( );
  return ( ( _Strbuf == nullptr && _Right . _Strbuf == nullptr )
   || ( _Strbuf != nullptr && _Right . _Strbuf != nullptr ) );
  }

private :
 void _Inc ( )
  {
  if ( _Strbuf == nullptr
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Strbuf -> sbumpc ( ) ) )
   {
   _Strbuf = nullptr;
   _Got = true;
   }
  else
   {
   _Got = false;
   }
  }

 _Elem _Peek ( ) const
  {
  int_type _Meta;
  if ( _Strbuf == nullptr
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Meta = _Strbuf -> sgetc ( ) ) )
   _Strbuf = nullptr;
  else
   _Val = traits_type :: to_char_type ( _Meta );
  _Got = true;
  return ( _Val );
  }

 mutable streambuf_type * _Strbuf;
 mutable bool _Got;
 mutable _Elem _Val;
 };
#line 634 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\streambuf"
template < class _Elem,
 class _Traits >
  inline bool operator == (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( _Left . equal ( _Right ) );
 }
#line 643
template < class _Elem,
 class _Traits >
  inline bool operator != (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 653
template < class _Elem,
 class _Traits >
 class ostreambuf_iterator
 {
public :
 using iterator_category = output_iterator_tag;
 using value_type = void;
 using difference_type = void;
 using pointer = void;
 using reference = void;

 using char_type = _Elem;
 using traits_type = _Traits;
 using streambuf_type = basic_streambuf < _Elem, _Traits >;
 using ostream_type = basic_ostream < _Elem, _Traits >;

 ostreambuf_iterator ( streambuf_type * _Sb ) noexcept
  : _Failed ( false ), _Strbuf ( _Sb )
  {
  }

 ostreambuf_iterator ( ostream_type & _Ostr ) noexcept
  : _Failed ( false ), _Strbuf ( _Ostr . rdbuf ( ) )
  {
  }

 ostreambuf_iterator & operator = ( _Elem _Right )
  {
  if ( _Strbuf == nullptr
   || traits_type :: eq_int_type ( _Traits :: eof ( ),
    _Strbuf -> sputc ( _Right ) ) )
   _Failed = true;
  return ( * this );
  }

  ostreambuf_iterator & operator * ( )
  {
  return ( * this );
  }

 ostreambuf_iterator & operator ++ ( )
  {
  return ( * this );
  }

 ostreambuf_iterator & operator ++ ( int )
  {
  return ( * this );
  }

  bool failed ( ) const noexcept
  {
  return ( _Failed );
  }

private :
 bool _Failed;
 streambuf_type * _Strbuf;
 };
#line 712
}
#line 716
#pragma warning(pop)
#pragma pack ( pop )
#line 12 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocnum"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 22
extern "C" {
#line 25 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocnum"
extern float __cdecl _Stofx(const char *, char **, long, int *); 
#line 28
extern double __cdecl _Stodx(const char *, char **, long, int *); 
#line 31
extern long double __cdecl _Stoldx(const char *, char **, long, int *); 
#line 34
extern long __cdecl _Stolx(const char *, char **, int, int *); 
#line 37
extern unsigned long __cdecl _Stoulx(const char *, char **, int, int *); 
#line 40
extern __int64 __cdecl _Stollx(const char *, char **, int, int *); 
#line 43
extern unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *); 
#line 48
}
#line 51 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocnum"
namespace std { 
#line 54
inline double _Stodx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr) 
#line 55
{ 
#line 56
int &_Errno_ref = *_errno(); 
#line 57
const int _Orig = _Errno_ref; 
#line 59
_Errno_ref = 0; 
#line 60
double _Val = ::strtod(_Str, _Endptr); 
#line 61
(*_Perr) = _Errno_ref; 
#line 62
_Errno_ref = _Orig; 
#line 64
if (_Pten != 0) { 
#line 65
_Val *= ::pow((10.0), static_cast< double>(_Pten)); }  
#line 67
return _Val; 
#line 68
} 
#line 71
inline float _Stofx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr) 
#line 72
{ 
#line 73
int &_Errno_ref = *_errno(); 
#line 74
const int _Orig = _Errno_ref; 
#line 76
_Errno_ref = 0; 
#line 77
float _Val = ::strtof(_Str, _Endptr); 
#line 78
(*_Perr) = _Errno_ref; 
#line 79
_Errno_ref = _Orig; 
#line 81
if (_Pten != 0) { 
#line 82
_Val *= ::powf((10.0F), static_cast< float>(_Pten)); }  
#line 84
return _Val; 
#line 85
} 
#line 88
template < class _Elem,
 size_t _Base_size > inline
 size_t _Find_elem ( const _Elem ( & _Base ) [ _Base_size ], const _Elem _Ch )
 {

 return ( static_cast < size_t > ( _Find_unchecked ( _Base, _Base + ( _Base_size - 1 ), _Ch ) - _Base ) );
 }
#line 96
inline __wchar_t *_Maklocwcs(const __wchar_t *_Ptr) 
#line 97
{ 
#line 98
const size_t _Count = ::wcslen(_Ptr) + (1); 
#line 100
__wchar_t *_Ptrdest = (__wchar_t *)_calloc_dbg(_Count, sizeof(__wchar_t), 2, "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocnum", 101); 
#line 103
if (!_Ptrdest) { 
#line 104
_Xbad_alloc(); }  
#line 105
::wmemcpy(_Ptrdest, _Ptr, _Count); 
#line 106
return _Ptrdest; 
#line 107
} 
#line 110
template < class _Elem >
 class numpunct
  : public locale :: facet
 {
public :
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  string_type;
 typedef _Elem char_type;

  __declspec ( dllimport ) static locale :: id id;

 _Elem decimal_point ( ) const
  {
  return ( do_decimal_point ( ) );
  }

 _Elem thousands_sep ( ) const
  {
  return ( do_thousands_sep ( ) );
  }

 string grouping ( ) const
  {
  return ( do_grouping ( ) );
  }

 string_type falsename ( ) const
  {
  return ( do_falsename ( ) );
  }

 string_type truename ( ) const
  {
  return ( do_truename ( ) );
  }

 explicit numpunct ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
   if ( _Kseparator == 0 )
    _Kseparator =
     _Maklocchr ( ',', static_cast < _Elem * > ( nullptr ), _Lobj . _Getcvt ( ) );
  }
  }

 numpunct ( const _Locinfo & _Lobj, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj, _Isdef );
  }

 static size_t _Getcat ( const locale :: facet * * _Ppf = nullptr,
  const locale * _Ploc = nullptr )
  {
  if ( _Ppf != nullptr && * _Ppf == nullptr )
   * _Ppf = new numpunct < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ), 0, true );
  return ( 4 );
  }

protected :
 virtual ~ numpunct ( ) noexcept
  {
  _Tidy ( );
  }

 numpunct ( const char * _Locname, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj ( _Locname );
   _Init ( _Lobj, _Isdef );
  }
  }

 template < class _Elem2 >
  void _Getvals ( _Elem2, const lconv * _Ptr, _Locinfo :: _Cvtvec _Cvt )
  {
  _Dp = _Maklocchr ( _Ptr -> decimal_point [ 0 ], static_cast < _Elem2 * > ( nullptr ), _Cvt );
  _Kseparator = _Maklocchr ( _Ptr -> thousands_sep [ 0 ], static_cast < _Elem2 * > ( nullptr ), _Cvt );
  }

 void _Getvals ( wchar_t, const lconv * _Ptr, _Locinfo :: _Cvtvec )
  {
  _Dp = ( _Elem ) _Ptr -> _W_decimal_point [ 0 ];
  _Kseparator = ( _Elem ) _Ptr -> _W_thousands_sep [ 0 ];
  }

 void _Init ( const _Locinfo & _Lobj, bool _Isdef = false )
  {
  const lconv * _Ptr = _Lobj . _Getlconv ( );
  _Locinfo :: _Cvtvec _Cvt = _Lobj . _Getcvt ( );

  _Grouping = nullptr;
  _Falsename = nullptr;
  _Truename = nullptr;

  try {
  _Grouping = _Maklocstr ( _Isdef ? "" : _Ptr -> grouping, static_cast < char * > ( nullptr ), _Lobj . _Getcvt ( ) );
  _Falsename = _Maklocstr ( _Lobj . _Getfalse ( ), static_cast < _Elem * > ( nullptr ), _Cvt );
  _Truename = _Maklocstr ( _Lobj . _Gettrue ( ), static_cast < _Elem * > ( nullptr ), _Cvt );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }

  if ( _Isdef )
   {

   _Dp = _Maklocchr ( '.', static_cast < _Elem * > ( nullptr ), _Cvt );
   _Kseparator = _Maklocchr ( ',', static_cast < _Elem * > ( nullptr ), _Cvt );
   }
  else
   _Getvals ( ( _Elem ) 0, _Ptr, _Cvt );
  }

 virtual _Elem do_decimal_point ( ) const
  {
  return ( _Dp );
  }

 virtual _Elem do_thousands_sep ( ) const
  {
  return ( _Kseparator );
  }

 virtual string do_grouping ( ) const
  {
  return ( string ( _Grouping ) );
  }

 virtual string_type do_falsename ( ) const
  {
  return ( string_type ( _Falsename ) );
  }

 virtual string_type do_truename ( ) const
  {
  return ( string_type ( _Truename ) );
  }

private :
 void _Tidy ( )
  {
  :: free ( ( void * ) _Grouping );
  :: free ( ( void * ) _Falsename );
  :: free ( ( void * ) _Truename );
  }

 const char * _Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem * _Falsename;
 const _Elem * _Truename;
 };
#line 268
template < class _Elem >
 class numpunct_byname
  : public numpunct < _Elem >
 {
public :
 explicit numpunct_byname ( const char * _Locname, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Locname, _Refs )
  {
  }

 explicit numpunct_byname ( const string & _Str, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Str . c_str ( ), _Refs )
  {
  }

protected :
 virtual ~ numpunct_byname ( ) noexcept
  {
  }
 };
#line 296
template< class _Elem> locale::id 
#line 297
numpunct< _Elem> ::id; 
#line 305 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocnum"
template < class _Elem,
 class _InIt = istreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_get
  : public locale :: facet
 {
public :
 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr,
  const locale * _Ploc = nullptr )
  {
  if ( _Ppf != nullptr && * _Ppf == nullptr )
   * _Ppf = new num_get < _Elem, _InIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_get ( ) noexcept
  {
  }

 void _Init ( const _Locinfo & )
  {
  }

public :
 explicit num_get ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_get ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   bool & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

protected :
 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   bool & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  if ( _Iosbase . flags ( ) & ios_base :: boolalpha )
   {
   const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
   basic_string < _Elem > _Str ( static_cast < size_t > ( 1 ), _Elem { } );
   _Str += _Punct_fac . falsename ( );
   _Str . push_back ( _Elem { } );
   _Str += _Punct_fac . truename ( );
   switch ( _Getloctxt ( _First, _Last, 2, _Str . c_str ( ) ) )
    {
    case 0 :
     _Val = false;
     break;
    case 1 :
     _Val = true;
     break;
    default :
     _Val = false;
     _State = ios_base :: failbit;
     break;
    }
   }
  else
   {
   char _Ac [ 32 ];
   const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
   if ( _Ac [ 0 ] == '\000' )
    {





    _Val = false;
    _State = ios_base :: failbit;
    }
   else
    {
    char * _Ep;
    int _Errno;
    const long _Ans = :: _Stolx ( _Ac, & _Ep, _Base, & _Errno );
    if ( _Ep == _Ac || _Errno != 0 )
     {
     _Val = true;
     _State = ios_base :: failbit;
     }
    else
     {
     _Val = _Ans != 0;
     if ( _Ans != 0 && _Ans != 1 )
      {
      _State = ios_base :: failbit;
      }
     }
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ 32 ];
  const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = 0;
   }
  else
   {
   const bool _Minus = _Ac [ 0 ] == '-';
   const char * _Digits = _Ac;


   if ( _Minus )
    {
    ++ _Digits;
    }

   char * _Ep;
   int _Errno;
   const unsigned long _Tmp = :: _Stoulx ( _Digits, & _Ep, _Base, & _Errno );
   _Val = static_cast < unsigned short > ( _Tmp );
   if ( _Ep == _Digits || _Errno != 0 || _Tmp > 65535 )
    {
    _State = ios_base :: failbit;
    _Val = 65535;
    }
   else if ( _Minus )
    {

    _Val = static_cast < unsigned short > ( 0 - _Val );
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  static_assert ( sizeof ( unsigned int ) == sizeof ( unsigned long ),
   "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)" );
  unsigned long _Tmp;
  _First = num_get :: do_get ( _First, _Last, _Iosbase, _State, _Tmp );
  _Val = _Tmp;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ 32 ];
  const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = 0;
   }
  else
   {
   char * _Ep;
   int _Errno;
   _Val = :: _Stolx ( _Ac, & _Ep, _Base, & _Errno );
   if ( _Ep == _Ac || _Errno != 0 )
    {
    _State = ios_base :: failbit;
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ 32 ];
  const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = 0;
   }
  else
   {
   char * _Ep;
   int _Errno;
   _Val = :: _Stoulx ( _Ac, & _Ep, _Base, & _Errno );
   if ( _Ep == _Ac || _Errno != 0 )
    {
    _State = ios_base :: failbit;
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long long & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ 32 ];
  const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = 0;
   }
  else
   {
   char * _Ep;
   int _Errno;
   _Val = :: _Stollx ( _Ac, & _Ep, _Base, & _Errno );
   if ( _Ep == _Ac || _Errno != 0 )
    {
    _State = ios_base :: failbit;
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long long & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ 32 ];
  const int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ), _Iosbase . getloc ( ) );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = 0;
   }
  else
   {
   int _Errno;
   char * _Ep;
   _Val = :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno );
   if ( _Ep == _Ac || _Errno != 0 )
    {
    _State = ios_base :: failbit;
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }







 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ ( 8 + 768 + 16 ) ];
  int _Hexexp = 1000000000;
  const int _Base = _Getffld ( _Ac, _First, _Last, _Iosbase, & _Hexexp );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = (0.0F);
   }
  else
   {
   int _Errno;
   char * _Ep;
   _Val = _Stofx_v2 ( _Ac, & _Ep, _Base, & _Errno );
   if ( _Ep == _Ac || _Errno != 0 )
    {
    _State = ios_base :: failbit;
    _Val = (0.0F);
    }
   else if ( _Hexexp != 1000000000 && _Hexexp != 0 )
    {
    _Val = :: ldexpf ( _Val, 4 * _Hexexp );
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ ( 8 + 768 + 16 ) ];
  int _Hexexp = 1000000000;
  const int _Base = _Getffld ( _Ac, _First, _Last, _Iosbase, & _Hexexp );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = (0.0);
   }
  else
   {
   int _Errno;
   char * _Ep;
   _Val = _Stodx_v2 ( _Ac, & _Ep, _Base, & _Errno );
   if ( _Ep == _Ac || _Errno != 0 )
    {
    _State = ios_base :: failbit;
    _Val = (0.0);
    }
   else if ( _Hexexp != 1000000000 && _Hexexp != 0 )
    {
    _Val = :: ldexp ( _Val, 4 * _Hexexp );
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }


 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  static_assert ( sizeof ( double ) == sizeof ( long double ),
   "Bad assumption: sizeof(double) == sizeof(long double)." );
  double _Result;
  _First = num_get :: do_get ( _First, _Last, _Iosbase, _State, _Result );
  _Val = _Result;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  _Adl_verify_range ( _First, _Last );
  char _Ac [ 32 ];
  const int _Base = _Getifld ( _Ac, _First, _Last, ios_base :: hex, _Iosbase . getloc ( ) );
  if ( _Ac [ 0 ] == '\000' )
   {
   _State = ios_base :: failbit;
   _Val = nullptr;
   }
  else
   {
   int _Errno;
   char * _Ep;

   _Val = reinterpret_cast < void * > ( :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno ) );



   if ( _Ep == _Ac || _Errno != 0 )
    {
    _State = ios_base :: failbit;
    _Val = nullptr;
    }
   }

  if ( _First == _Last )
   {
   _State |= ios_base :: eofbit;
   }

  return ( _First );
  }

private :
 int __cdecl _Getifld ( char * _Ac,
  _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield,
   const locale & _Loc ) const
  {
  const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Loc );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Grouping . size ( ) == 0
   ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );

  constexpr int _Numget_signoff = 22;
  constexpr int _Numget_xoff = 24;
  static constexpr char _Src [ ] = { "0123456789ABCDEFabcdef-+Xx" };
  _Elem _Atoms [ sizeof ( _Src ) ];
  const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Loc );
  _Ctype_fac . widen ( & _Src [ 0 ], & _Src [ sizeof ( _Src ) ], _Atoms );

  char * _Ptr = _Ac;

  if ( _First != _Last )
   {
   if ( * _First == _Atoms [ _Numget_signoff + 1 ] )
    {
    * _Ptr ++ = '+';
    ++ _First;
    }
   else if ( * _First == _Atoms [ _Numget_signoff ] )
    {
    * _Ptr ++ = '-';
    ++ _First;
    }
   }

  _Basefield &= ios_base :: basefield;
  int _Base = _Basefield == ios_base :: oct ? 8
   : _Basefield == ios_base :: hex ? 16
   : _Basefield == ios_base :: _Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if ( _First != _Last && * _First == _Atoms [ 0 ] )
   {
   _Seendigit = true;
   ++ _First;
   if ( _First != _Last && ( * _First == _Atoms [ _Numget_xoff + 1 ]
     || * _First == _Atoms [ _Numget_xoff ] )
    && ( _Base == 0 || _Base == 16 ) )
    {
    _Base = 16;
    _Seendigit = false;
    ++ _First;
    }
   else if ( _Base == 0 )
    {
    _Base = 8;
    }
   }

  const auto _Dlen = static_cast < size_t > ( _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6 );
  string _Groups ( ( size_t ) 1, ( char ) _Seendigit );
  size_t _Group = 0;

  for ( char * const _Pe = & _Ac [ 32 - 1 ];
   _First != _Last; ++ _First )
   {
   size_t _Idx = _Find_elem ( _Atoms, * _First );
   if ( _Idx < _Dlen )
    {
    * _Ptr = _Src [ _Idx ];
    if ( ( _Nonzero || * _Ptr != '0' ) && _Ptr < _Pe )
     {
     ++ _Ptr;
     _Nonzero = true;
     }

    _Seendigit = true;
    if ( _Groups [ _Group ] != 127 )
     ++ _Groups [ _Group ];
    }
   else if ( _Groups [ _Group ] == '\000'
    || _Kseparator == ( _Elem ) 0
    || * _First != _Kseparator )
    break;
   else
    {
    _Groups . push_back ( '\000' );
    ++ _Group;
    }
   }

  if ( _Group != 0 )
   {
   if ( '\000' < _Groups [ _Group ] )
    {
    ++ _Group;
    }
   else
    {
    _Seendigit = false;
    }
   }

  for ( const char * _Pg = & _Grouping [ 0 ]; _Seendigit && 0 < _Group; )
   if ( * _Pg == 127 )
    break;
   else if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] )
    || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) )
    _Seendigit = false;
   else if ( '\000' < _Pg [ 1 ] )
    ++ _Pg;

  if ( _Seendigit && ! _Nonzero )
   * _Ptr ++ = '0';
  else if ( ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Base );
  }

 int __cdecl _Getffld ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const
  {
  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: hexfloat )
   return ( _Getffldx ( _Ac, _First, _Last,
    _Iosbase, _Phexexp ) );

  const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  char * _Ptr = _Ac;
  bool _Bad = false;
  bool _Sticky = false;

  constexpr int _Numget_signoff = 10;
  constexpr int _Numget_eoff = 12;
  static constexpr char _Src [ ] = { "0123456789-+Ee" };
  _Elem _Atoms [ sizeof ( _Src ) ];
  const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
  _Ctype_fac . widen ( & _Src [ 0 ], & _Src [ sizeof ( _Src ) ], _Atoms );

  if ( _First != _Last )
   {
   if ( * _First == _Atoms [ _Numget_signoff + 1 ] )
    {
    * _Ptr ++ = '+';
    ++ _First;
    }
   else if ( * _First == _Atoms [ _Numget_signoff ] )
    {
    * _Ptr ++ = '-';
    ++ _First;
    }
   }

  char * _Leading = _Ptr;
  * _Ptr ++ = '0';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;
  size_t _Idx;

  const int _Max_sig_dig = ( * _Phexexp == 1000000000 ? 768 : 36 );

  const char * _Pg = & _Grouping [ 0 ];
  if ( * _Pg == 127 || * _Pg <= '\000' )
   {
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10;
     _Seendigit = true, ( void ) ++ _First )
    {
    if ( _Max_sig_dig <= _Significant )
     {
     ++ _Pten;
     if ( 0 < _Idx )
      {
      _Sticky = true;
      }
     }
    else if ( _Idx != 0 || _Significant != 0 )
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
    }
   }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    {
    if ( ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10 )
     {
     _Seendigit = true;
     if ( _Max_sig_dig <= _Significant )
      {
      ++ _Pten;
      if ( 0 < _Idx )
       {
       _Sticky = true;
       }
      }
     else if ( _Idx != 0 || _Significant != 0 )
      {
      * _Ptr ++ = _Src [ _Idx ];
      ++ _Significant;
      }

     if ( _Groups [ _Group ] != 127 )
      {
      ++ _Groups [ _Group ];
      }
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     {
     break;
     }
    else
     {
     _Groups . push_back ( '\000' );
     ++ _Group;
     }
    }

   if ( _Group != 0 )
    {
    if ( '\000' < _Groups [ _Group ] )
     {
     ++ _Group;
     }
    else
     {
     _Bad = true;
     }
    }

   while ( ! _Bad && 0 < _Group )
    {
    if ( * _Pg == 127 )
     {
     break;
     }

    if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] )
     || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) )
     {
     _Bad = true;
     }
    else if ( '\000' < _Pg [ 1 ] )
     {
     ++ _Pg;
     }
    }
   }

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   {
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ];
   ++ _First;
   }

  if ( * _Phexexp != 1000000000 && _Significant == 0 )
   {
   for (; _First != _Last && * _First == _Atoms [ 0 ];
    _Seendigit = true, ( void ) ++ _First )
    -- _Pten;
   if ( _Pten < 0 )
    {
    * _Ptr ++ = '0';
    ++ _Pten;
    }
   }

  for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10;
    _Seendigit = true, ( void ) ++ _First )
   if ( _Significant < _Max_sig_dig )
    {
    * _Ptr ++ = _Src [ _Idx ];
    ++ _Significant;
    }
   else if ( 0 < _Idx )
    _Sticky = true;

  if ( _Sticky )
   {
   char * _Px = _Ptr;
   while ( -- _Px != _Leading )
    {
    if ( * _Px != localeconv ( ) -> decimal_point [ 0 ] )
     {
     if ( * _Px != '9' )
      {
      ++ * _Px;
      break;
      }

     * _Px = '0';
     }
    }

   if ( _Px == _Leading )
    {
    * _Px = '1';
    ++ _Pten;
    }
   }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Atoms [ _Numget_eoff + 1 ]
    || * _First == _Atoms [ _Numget_eoff ] ) )
   {
   * _Ptr ++ = 'e';
   ++ _First;
   _Seendigit = false;
   _Significant = 0;

   if ( _First != _Last )
    {
    if ( * _First == _Atoms [ _Numget_signoff + 1 ] )
     {
     * _Ptr ++ = '+';
     ++ _First;
     }
    else if ( * _First == _Atoms [ _Numget_signoff ] )
     {
     * _Ptr ++ = '-';
     ++ _First;
     }
    }

   for (; _First != _Last && * _First == _Atoms [ 0 ]; ++ _First )
    {
    _Seendigit = true;
    }

   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10;
    _Seendigit = true, ( void ) ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Pten );
  }

 int __cdecl _Getffldx ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const
  {
  const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );

  constexpr int _Numget_signoff = 22;
  constexpr int _Numget_xoff = 24;
  constexpr int _Numget_poff = 26;
  static constexpr char _Src [ ] = { "0123456789ABCDEFabcdef-+XxPp" };
  _Elem _Atoms [ sizeof ( _Src ) ];
  const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
  _Ctype_fac . widen ( & _Src [ 0 ], & _Src [ sizeof ( _Src ) ], _Atoms );

  char * _Ptr = _Ac;
  bool _Bad = false;
  size_t _Idx;

  if ( _First != _Last )
   {
   if ( * _First == _Atoms [ _Numget_signoff + 1 ] )
    {
    * _Ptr ++ = '+';
    ++ _First;
    }
   else if ( * _First == _Atoms [ _Numget_signoff ] )
    {
    * _Ptr ++ = '-';
    ++ _First;
    }
   }

  * _Ptr ++ = '0';
  * _Ptr ++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if ( _First != _Last && * _First == _Atoms [ 0 ] )
   {
   if ( ++ _First != _Last
    && ( * _First == _Atoms [ _Numget_xoff + 1 ]
     || * _First == _Atoms [ _Numget_xoff ] ) )
    {
    ++ _First;
    }
   else
    {
    _Seendigit = true;
    }
   }

  const int _Max_sig_dig = ( * _Phexexp == 1000000000 ? 768 : 36 );

  const char * _Pg = & _Grouping [ 0 ];
  if ( * _Pg == 127 || * _Pg <= '\000' )
   {
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff;
     _Seendigit = true, ( void ) ++ _First )
    {
    if ( _Max_sig_dig <= _Significant )
     {
     ++ _Phex;
     }
    else if ( _Idx != 0 || _Significant != 0 )
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
    }
   }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    {
    if ( ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff )
     {
     _Seendigit = true;
     if ( _Max_sig_dig <= _Significant )
      {
      ++ _Phex;
      }
     else if ( _Idx != 0 || _Significant != 0 )
      {
      * _Ptr ++ = _Src [ _Idx ];
      ++ _Significant;
      }

     if ( _Groups [ _Group ] != 127 )
      {
      ++ _Groups [ _Group ];
      }
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     {
     break;
     }
    else
     {
     _Groups . push_back ( '\000' );
     ++ _Group;
     }
    }

   if ( _Group != 0 )
    {
    if ( '\000' < _Groups [ _Group ] )
     {
     ++ _Group;
     }
    else
     {
     _Bad = true;
     }
    }

   while ( ! _Bad && 0 < _Group )
    {
    if ( * _Pg == 127 )
     {
     break;
     }

    if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] )
     || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) )
     {
     _Bad = true;
     }
    else if ( '\000' < _Pg [ 1 ] )
     {
     ++ _Pg;
     }
    }
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   {
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ];
   ++ _First;
   }

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _Atoms [ 0 ];
    _Seendigit = true, ( void ) ++ _First )
    -- _Phex;
   if ( _Phex < 0 )
    {
    * _Ptr ++ = '0';
    ++ _Phex;
    }
   }

  for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff;
    _Seendigit = true, ( void ) ++ _First )
   if ( _Significant < _Max_sig_dig )
    {
    * _Ptr ++ = _Src [ _Idx ];
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Atoms [ _Numget_poff + 1 ]
    || * _First == _Atoms [ _Numget_poff ] ) )
   {
   * _Ptr ++ = 'p';
   ++ _First;
   _Seendigit = false;
   _Significant = 0;

   if ( _First != _Last )
    {
    if ( * _First == _Atoms [ _Numget_signoff + 1 ] )
     {
     * _Ptr ++ = '+';
     ++ _First;
     }
    else if ( * _First == _Atoms [ _Numget_signoff ] )
     {
     * _Ptr ++ = '-';
     ++ _First;
     }
    }

   for (; _First != _Last && * _First == _Atoms [ 0 ]; ++ _First )
    {
    _Seendigit = true;
    }

   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _Numget_signoff;
    _Seendigit = true, ( void ) ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  * _Phexexp = _Phex;
  return ( 0 );
  }



 };
#line 1402 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocnum"
template< class _Elem, class 
#line 1403
_InIt> locale::id 
#line 1404
num_get< _Elem, _InIt> ::id; 
#line 1411
template < class _Elem,
 class _OutIt = ostreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_put
  : public locale :: facet
 {
public :
 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = nullptr,
  const locale * _Ploc = nullptr )
  {
  if ( _Ppf != nullptr && * _Ppf == nullptr )
   * _Ppf = new num_put < _Elem, _OutIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_put ( ) noexcept
  {
  }

 void _Init ( const _Locinfo & )
  {
  }

public :
 explicit num_put ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_put ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, bool _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

protected :
 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, bool _Val ) const
  {
  if ( ! ( _Iosbase . flags ( ) & ios_base :: boolalpha ) )
   return ( do_put ( _Dest, _Iosbase, _Fill, ( long ) _Val ) );
  else
   {
   const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
   basic_string < _Elem > _Str;
   if ( _Val )
    _Str . assign ( _Punct_fac . truename ( ) );
   else
    _Str . assign ( _Punct_fac . falsename ( ) );

   size_t _Fillcount = _Iosbase . width ( ) <= 0
    || ( size_t ) _Iosbase . width ( ) <= _Str . size ( )
     ? 0 : ( size_t ) _Iosbase . width ( ) - _Str . size ( );

   if ( ( _Iosbase . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
    {
    _Dest = _Rep ( _Dest, _Fill, _Fillcount );
    _Fillcount = 0;
    }
   _Dest = _Put ( _Dest, _Str . c_str ( ), _Str . size ( ) );
   _Iosbase . width ( 0 );
   return ( _Rep ( _Dest, _Fill, _Fillcount ) );
   }
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "ld",
    _Iosbase . flags ( ) ), _Val ) ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "lu",
    _Iosbase . flags ( ) ), _Val ) ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Ld",
    _Iosbase . flags ( ) ), _Val ) ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Lu",
    _Iosbase . flags ( ) ), _Val ) ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  string _Buf;
  char _Fmt [ 8 ];
  bool _Isfixed = ( _Iosbase . flags ( ) & ios_base :: floatfield )
   == ios_base :: fixed;
  streamsize _Precision = _Iosbase . precision ( ) <= 0 && ! _Isfixed
   ? 6 : _Iosbase . precision ( );
  size_t _Bufsize = ( size_t ) _Precision;
  if ( _Isfixed && (10000000000.0) < :: fabs ( _Val ) )
   {
   int _Ptwo;
   ( void ) :: frexp ( _Val, & _Ptwo );
   _Bufsize += :: abs ( _Ptwo ) * 30103L / 100000L;
   }

  _Buf . resize ( _Bufsize + 50 );
  const auto _Ngen = static_cast < size_t > ( :: sprintf_s ( ( char * ) _Buf . c_str ( ), _Buf . size ( ),
   _Ffmt ( _Fmt, 0, _Iosbase . flags ( ) ), ( int ) _Precision, _Val ) );

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf . c_str ( ), _Ngen ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  string _Buf;
  char _Fmt [ 8 ];
  bool _Isfixed = ( _Iosbase . flags ( ) & ios_base :: floatfield )
   == ios_base :: fixed;
  streamsize _Precision = _Iosbase . precision ( ) <= 0 && ! _Isfixed
   ? 6 : _Iosbase . precision ( );
  size_t _Bufsize = ( size_t ) _Precision;
  if ( _Isfixed && (10000000000.0) < :: fabsl ( _Val ) )
   {
   int _Ptwo;
   ( void ) :: frexpl ( _Val, & _Ptwo );
   _Bufsize += :: abs ( _Ptwo ) * 30103L / 100000L;
   }

  _Buf . resize ( _Bufsize + 50 );
  const auto _Ngen = static_cast < size_t > ( :: sprintf_s ( ( char * ) _Buf . c_str ( ), _Buf . size ( ),
   _Ffmt ( _Fmt, 'L', _Iosbase . flags ( ) ), ( int ) _Precision, _Val ) );

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf . c_str ( ), _Ngen ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  char _Buf [ 2 * 32 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   static_cast < size_t > ( :: sprintf_s ( _Buf, sizeof ( _Buf ), "%p", _Val ) ) ) );
  }

private :
 char * __cdecl _Ffmt ( char * _Fmt,
  char _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showpoint )
   * _Ptr ++ = '#';
  * _Ptr ++ = '.';
  * _Ptr ++ = '*';
  if ( _Spec != '\000' )
   * _Ptr ++ = _Spec;

  ios_base :: fmtflags _Ffl = _Flags & ios_base :: floatfield;
  if ( _Flags & ios_base :: uppercase )
   * _Ptr ++ = _Ffl == ios_base :: fixed ? 'f'
    : _Ffl == ios_base :: hexfloat ? 'A'
    : _Ffl == ios_base :: scientific ? 'E' : 'G';
  else
   * _Ptr ++ = _Ffl == ios_base :: fixed ? 'f'
    : _Ffl == ios_base :: hexfloat ? 'a'
    : _Ffl == ios_base :: scientific ? 'e' : 'g';

  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Fput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const char * _Buf,
   size_t _Count ) const
  {
  auto _Prefix = static_cast < size_t > ( 0 < _Count && ( * _Buf == '+' || * _Buf == '-' ) );
  const char * _Exps;
  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) != ios_base :: hexfloat )
   _Exps = "eE";
  else
   {
   _Exps = "pP";
   if ( _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
    && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) )
    _Prefix += 2;
   }
  const size_t _Eoff =
   :: strcspn ( & _Buf [ 0 ], _Exps );
  char _Dp [ 2 ] = { "." };
  _Dp [ 0 ] = :: localeconv ( ) -> decimal_point [ 0 ];
  const size_t _Poff =
   :: strcspn ( & _Buf [ 0 ], & _Dp [ 0 ] );

  const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
  basic_string < _Elem > _Groupstring ( _Count, _Elem ( 0 ) );
  _Ctype_fac . widen ( & _Buf [ 0 ], & _Buf [ _Count ], & _Groupstring [ 0 ] );

  const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Punct_fac . thousands_sep ( );

  if ( _Poff != _Count )
   _Groupstring [ _Poff ] = _Punct_fac . decimal_point ( );

  size_t _Off = _Poff == _Count ? _Eoff : _Poff;
  const char * _Pg = & _Grouping [ 0 ];
  while ( * _Pg != 127 && '\000' < * _Pg
   && ( size_t ) * _Pg < _Off - _Prefix )
   {
   _Groupstring . insert ( _Off -= * _Pg, ( size_t ) 1, _Kseparator );
   if ( '\000' < _Pg [ 1 ] )
    ++ _Pg;
   }

  _Count = _Groupstring . size ( );
  size_t _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Count
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Count;

  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );

  _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 char * __cdecl _Ifmt ( char * _Fmt,
  const char * _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showbase )
   * _Ptr ++ = '#';
  if ( _Spec [ 0 ] != 'L' )
   * _Ptr ++ = _Spec [ 0 ];
  else

   {
   * _Ptr ++ = 'I';
   * _Ptr ++ = '6';
   * _Ptr ++ = '4';
   }

  ios_base :: fmtflags _Basefield = _Flags & ios_base :: basefield;
  * _Ptr ++ = _Basefield == ios_base :: oct ? 'o'
   : _Basefield != ios_base :: hex ? _Spec [ 1 ]
   : _Flags & ios_base :: uppercase ? 'X' : 'x';
  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Iput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, char * _Buf, size_t _Count ) const
  {
  auto _Prefix = static_cast < size_t > ( 0 < _Count && ( * _Buf == '+' || * _Buf == '-' ) );
  if ( ( _Iosbase . flags ( ) & ios_base :: basefield ) == ios_base :: hex
   && _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
   && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) )
   {
   _Prefix += 2;
   }

  const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Iosbase . getloc ( ) );
  basic_string < _Elem > _Groupstring ( _Count, _Elem ( 0 ) );
  _Ctype_fac . widen ( & _Buf [ 0 ], & _Buf [ _Count ], & _Groupstring [ 0 ] );

  const auto & _Punct_fac = :: std :: use_facet < numpunct < _Elem >> ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const char * _Pg = & _Grouping [ 0 ];
  if ( * _Pg != 127 && '\000' < * _Pg )
   {
   const _Elem _Kseparator = _Punct_fac . thousands_sep ( );
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Count - _Prefix )
    {
    _Count -= * _Pg;
    _Groupstring . insert ( _Count, 1, _Kseparator );
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }
   }

  _Count = _Groupstring . size ( );
  size_t _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Count
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Count;

  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );

  _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 _OutIt __cdecl _Put ( _OutIt _Dest,
  const _Elem * _Ptr, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ( void ) ++ _Dest, ++ _Ptr )
   * _Dest = * _Ptr;
  return ( _Dest );
  }

 _OutIt __cdecl _Rep ( _OutIt _Dest,
  _Elem _Ch, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ( void ) ++ _Dest )
   * _Dest = _Ch;
  return ( _Dest );
  }
 };
#line 1841
template< class _Elem, class 
#line 1842
_OutIt> locale::id 
#line 1843
num_put< _Elem, _OutIt> ::id; 
#line 1848
template locale::id numpunct< char> ::id;
#line 1849
template class __declspec(dllimport) num_get< char, istreambuf_iterator< char, char_traits< char> > > ;
#line 1851
template class __declspec(dllimport) num_put< char, ostreambuf_iterator< char, char_traits< char> > > ;
#line 1854
template locale::id numpunct< __wchar_t> ::id;
#line 1855
template class __declspec(dllimport) num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;
#line 1857
template class __declspec(dllimport) num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;
#line 1873 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xlocnum"
}
#line 1876
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ios"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 17
template < class _Elem,
 class _Traits >
 class basic_ios
  : public ios_base
 {
public :
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ctype < _Elem > _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_ios ( _Mysb * _Strbuf )
  {
  init ( _Strbuf );
  }

 virtual ~ basic_ios ( ) noexcept
  {
  }

 void clear ( iostate _State = goodbit, bool _Reraise = false )
  {
  ios_base :: clear ( _Mystrbuf == nullptr ? ( _State | ios_base :: badbit ) : _State, _Reraise );
  }


 void clear ( io_state _State )
  {
  clear ( ( iostate ) _State );
  }


 void setstate ( iostate _State, bool _Reraise = false )
  {
  clear ( rdstate ( ) | _State, _Reraise );
  }


 void setstate ( io_state _State )
  {
  setstate ( ( iostate ) _State );
  }


 basic_ios & copyfmt ( const basic_ios & _Right )
  {
  _Tiestr = _Right . tie ( );
  _Fillch = _Right . fill ( );
  ios_base :: copyfmt ( _Right );
  return ( * this );
  }

 _Myos * tie ( ) const
  {
  return ( _Tiestr );
  }

 _Myos * tie ( _Myos * _Newtie )
  {
  _Myos * _Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return ( _Oldtie );
  }

  _Mysb * rdbuf ( ) const
  {
  return ( _Mystrbuf );
  }

 _Mysb * rdbuf ( _Mysb * _Strbuf )
  {
  _Mysb * _Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear ( );
  return ( _Oldstrbuf );
  }

 locale imbue ( const locale & _Loc )
  {
  locale _Oldlocale = ios_base :: imbue ( _Loc );
  if ( rdbuf ( ) != nullptr )
   rdbuf ( ) -> pubimbue ( _Loc );
  return ( _Oldlocale );
  }

 _Elem fill ( ) const
  {
  return ( _Fillch );
  }

 _Elem fill ( _Elem _Newfill )
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return ( _Oldfill );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  return ( :: std :: use_facet < _Ctype > ( getloc ( ) ) . narrow ( _Ch, _Dflt ) );
  }

 _Elem widen ( char _Byte ) const
  {
  return ( :: std :: use_facet < _Ctype > ( getloc ( ) ) . widen ( _Byte ) );
  }

 void move ( basic_ios & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mystrbuf = nullptr;
   _Tiestr = nullptr;
   this -> swap ( _Right );
   }
  }

 void move ( basic_ios && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mystrbuf = nullptr;
   _Tiestr = nullptr;
   this -> swap ( _Right );
   }
  }

 void swap ( basic_ios & _Right ) noexcept
  {
  ios_base :: swap ( _Right );
  :: std :: swap ( _Fillch, _Right . _Fillch );
  :: std :: swap ( _Tiestr, _Right . _Tiestr );
  }

 void set_rdbuf ( _Mysb * _Strbuf )
  {
  _Mystrbuf = _Strbuf;
  }

protected :
 void init ( _Mysb * _Strbuf = nullptr,
  bool _Isstd = false )
  {
  _Init ( );
  _Mystrbuf = _Strbuf;
  _Tiestr = nullptr;
  _Fillch = widen ( ' ' );

  if ( _Mystrbuf == nullptr )
   setstate ( badbit );

  if ( _Isstd )
   _Addstd ( this );
  }

  basic_ios ( )
  {
  }

private :
 _Mysb * _Mystrbuf;
 _Myos * _Tiestr;
 _Elem _Fillch;

public :
  basic_ios ( const basic_ios & ) = delete;
 basic_ios & operator = ( const basic_ios & ) = delete;
 };
#line 193 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ios"
template class __declspec(dllimport) basic_ios< char, char_traits< char> > ;
#line 195
template class __declspec(dllimport) basic_ios< __wchar_t, char_traits< __wchar_t> > ;
#line 206 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ios"
inline ios_base &__cdecl boolalpha(ios_base &_Iosbase) 
#line 207
{ 
#line 208
_Iosbase.setf(_Iosb< int> ::boolalpha); 
#line 209
return _Iosbase; 
#line 210
} 
#line 212
inline ios_base &__cdecl dec(ios_base &_Iosbase) 
#line 213
{ 
#line 214
_Iosbase.setf(_Iosb< int> ::dec, _Iosb< int> ::basefield); 
#line 215
return _Iosbase; 
#line 216
} 
#line 218
inline ios_base &__cdecl defaultfloat(ios_base &_Iosbase) 
#line 219
{ 
#line 220
_Iosbase.unsetf(_Iosb< int> ::floatfield); 
#line 221
return _Iosbase; 
#line 222
} 
#line 224
inline ios_base &__cdecl fixed(ios_base &_Iosbase) 
#line 225
{ 
#line 226
_Iosbase.setf(_Iosb< int> ::fixed, _Iosb< int> ::floatfield); 
#line 227
return _Iosbase; 
#line 228
} 
#line 230
inline ios_base &__cdecl hex(ios_base &_Iosbase) 
#line 231
{ 
#line 232
_Iosbase.setf(_Iosb< int> ::hex, _Iosb< int> ::basefield); 
#line 233
return _Iosbase; 
#line 234
} 
#line 236
inline ios_base &__cdecl hexfloat(ios_base &_Iosbase) 
#line 237
{ 
#line 238
_Iosbase.setf(_Iosb< int> ::hexfloat, _Iosb< int> ::floatfield); 
#line 239
return _Iosbase; 
#line 240
} 
#line 242
inline ios_base &__cdecl internal(ios_base &_Iosbase) 
#line 243
{ 
#line 244
_Iosbase.setf(_Iosb< int> ::internal, _Iosb< int> ::adjustfield); 
#line 245
return _Iosbase; 
#line 246
} 
#line 248
inline ios_base &__cdecl left(ios_base &_Iosbase) 
#line 249
{ 
#line 250
_Iosbase.setf(_Iosb< int> ::left, _Iosb< int> ::adjustfield); 
#line 251
return _Iosbase; 
#line 252
} 
#line 254
inline ios_base &__cdecl noboolalpha(ios_base &_Iosbase) 
#line 255
{ 
#line 256
_Iosbase.unsetf(_Iosb< int> ::boolalpha); 
#line 257
return _Iosbase; 
#line 258
} 
#line 260
inline ios_base &__cdecl noshowbase(ios_base &_Iosbase) 
#line 261
{ 
#line 262
_Iosbase.unsetf(_Iosb< int> ::showbase); 
#line 263
return _Iosbase; 
#line 264
} 
#line 266
inline ios_base &__cdecl noshowpoint(ios_base &_Iosbase) 
#line 267
{ 
#line 268
_Iosbase.unsetf(_Iosb< int> ::showpoint); 
#line 269
return _Iosbase; 
#line 270
} 
#line 272
inline ios_base &__cdecl noshowpos(ios_base &_Iosbase) 
#line 273
{ 
#line 274
_Iosbase.unsetf(_Iosb< int> ::showpos); 
#line 275
return _Iosbase; 
#line 276
} 
#line 278
inline ios_base &__cdecl noskipws(ios_base &_Iosbase) 
#line 279
{ 
#line 280
_Iosbase.unsetf(_Iosb< int> ::skipws); 
#line 281
return _Iosbase; 
#line 282
} 
#line 284
inline ios_base &__cdecl nounitbuf(ios_base &_Iosbase) 
#line 285
{ 
#line 286
_Iosbase.unsetf(_Iosb< int> ::unitbuf); 
#line 287
return _Iosbase; 
#line 288
} 
#line 290
inline ios_base &__cdecl nouppercase(ios_base &_Iosbase) 
#line 291
{ 
#line 292
_Iosbase.unsetf(_Iosb< int> ::uppercase); 
#line 293
return _Iosbase; 
#line 294
} 
#line 296
inline ios_base &__cdecl oct(ios_base &_Iosbase) 
#line 297
{ 
#line 298
_Iosbase.setf(_Iosb< int> ::oct, _Iosb< int> ::basefield); 
#line 299
return _Iosbase; 
#line 300
} 
#line 302
inline ios_base &__cdecl right(ios_base &_Iosbase) 
#line 303
{ 
#line 304
_Iosbase.setf(_Iosb< int> ::right, _Iosb< int> ::adjustfield); 
#line 305
return _Iosbase; 
#line 306
} 
#line 308
inline ios_base &__cdecl scientific(ios_base &_Iosbase) 
#line 309
{ 
#line 310
_Iosbase.setf(_Iosb< int> ::scientific, _Iosb< int> ::floatfield); 
#line 311
return _Iosbase; 
#line 312
} 
#line 314
inline ios_base &__cdecl showbase(ios_base &_Iosbase) 
#line 315
{ 
#line 316
_Iosbase.setf(_Iosb< int> ::showbase); 
#line 317
return _Iosbase; 
#line 318
} 
#line 320
inline ios_base &__cdecl showpoint(ios_base &_Iosbase) 
#line 321
{ 
#line 322
_Iosbase.setf(_Iosb< int> ::showpoint); 
#line 323
return _Iosbase; 
#line 324
} 
#line 326
inline ios_base &__cdecl showpos(ios_base &_Iosbase) 
#line 327
{ 
#line 328
_Iosbase.setf(_Iosb< int> ::showpos); 
#line 329
return _Iosbase; 
#line 330
} 
#line 332
inline ios_base &__cdecl skipws(ios_base &_Iosbase) 
#line 333
{ 
#line 334
_Iosbase.setf(_Iosb< int> ::skipws); 
#line 335
return _Iosbase; 
#line 336
} 
#line 338
inline ios_base &__cdecl unitbuf(ios_base &_Iosbase) 
#line 339
{ 
#line 340
_Iosbase.setf(_Iosb< int> ::unitbuf); 
#line 341
return _Iosbase; 
#line 342
} 
#line 344
inline ios_base &__cdecl uppercase(ios_base &_Iosbase) 
#line 345
{ 
#line 346
_Iosbase.setf(_Iosb< int> ::uppercase); 
#line 347
return _Iosbase; 
#line 348
} 
#line 351
namespace [[deprecated("warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can define _" "SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1 { 
#line 352
using std::hexfloat;
#line 353
}
#line 356 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ios"
}
#line 360
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ostream"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#line 35 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ostream"
#pragma vtordisp(push, 2)
#line 38
template < class _Elem,
 class _Traits >
 class basic_ostream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ostreambuf_iterator < _Elem, _Traits > _Iter;
 typedef num_put < _Elem, _Iter > _Nput;

 explicit basic_ostream (
  basic_streambuf < _Elem, _Traits > * _Strbuf,

  bool _Isstd = false )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_ostream ( _Uninitialized, bool _Addit = true )
  {
  if ( _Addit )
   this -> _Addstd ( this );
  }

protected :
  basic_ostream ( basic_ostream && _Right )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  }

 basic_ostream & operator = ( basic_ostream && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( basic_ostream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   _Myios :: swap ( _Right );
  }

public :
  basic_ostream ( const basic_ostream & ) = delete;
 basic_ostream & operator = ( const basic_ostream & ) = delete;

 virtual ~ basic_ostream ( ) noexcept
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 class _Sentry_base
  {
 public :
   _Sentry_base ( basic_ostream & _Ostr )
   : _Myostr ( _Ostr )
   {
   if ( _Myostr . rdbuf ( ) != nullptr )
    _Myostr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( ) noexcept
   {
   if ( _Myostr . rdbuf ( ) != nullptr )
    _Myostr . rdbuf ( ) -> _Unlock ( );
   }

  basic_ostream & _Myostr;

  _Sentry_base & operator = ( const _Sentry_base & ) = delete;
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( basic_ostream & _Ostr )
   : _Sentry_base ( _Ostr )
   {
   if ( _Ostr . good ( ) && _Ostr . tie ( ) != nullptr && _Ostr . tie ( ) != & _Ostr )
    _Ostr . tie ( ) -> flush ( );
   _Ok = _Ostr . good ( );
   }





  #pragma warning(push)
  #pragma warning(disable: 4996)

   ~ sentry ( ) noexcept
   {

   if ( ! :: std :: uncaught_exception ( ) )
    {
    this -> _Myostr . _Osfx ( );
    }



   }



  #pragma warning(pop)


  explicit operator bool ( ) const
   {
   return ( _Ok );
   }

   sentry ( const sentry & ) = delete;
  sentry & operator = ( const sentry & ) = delete;

 private :
  bool _Ok;
  };

 bool opfx ( )
  {
  if ( this -> good ( ) && _Myios :: tie ( ) != nullptr && _Myios :: tie ( ) != this )
   _Myios :: tie ( ) -> flush ( );
  return ( this -> good ( ) );
  }

 void osfx ( )
  {
  _Osfx ( );
  }

 void _Osfx ( )
  {
  try {
  if ( this -> good ( ) && this -> flags ( ) & ios_base :: unitbuf )
   if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
    _Myios :: setstate ( ios_base :: badbit );
  } catch ( ... ) {
  }
  }




















 basic_ostream & operator << ( basic_ostream & ( __cdecl * _Pfn ) ( basic_ostream & ) )
  {
  return ( ( * _Pfn ) ( * this ) );
  }

 basic_ostream & operator << ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 basic_ostream & operator << ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

 basic_ostream & operator << ( bool _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );
   ios_base :: fmtflags _Bfl =
    this -> flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned short ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }










 basic_ostream & operator << ( unsigned short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );
   ios_base :: fmtflags _Bfl =
    this -> flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned int ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( unsigned int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( unsigned long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( long long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( unsigned long long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( float _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( double ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( long double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & operator << ( const void * _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = :: std :: use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }









 basic_ostream & operator << ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != nullptr )
   for ( int_type _Meta = _Traits :: eof ( );; _Copied = true )
    {
    try {
    _Meta = _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
     ? _Strbuf -> sgetc ( ) : _Strbuf -> snextc ( );
    } catch ( ... ) {
     _Myios :: setstate ( ios_base :: failbit );
     throw;
    }

    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     break;

    try {
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
      _Myios :: rdbuf ( ) -> sputc (
       _Traits :: to_char_type ( _Meta ) ) ) )
      {
      _State |= ios_base :: badbit;
      break;
      }
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

  this -> width ( 0 );
  _Myios :: setstate ( _Strbuf == nullptr ? ios_base :: badbit
   : ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 basic_ostream & put ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & write ( const _Elem * _Str,
  streamsize _Count )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else if ( 0 < _Count )
   {
   try {
   if ( _Myios :: rdbuf ( ) -> sputn ( _Str, _Count ) != _Count )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_ostream & flush ( )
  {
  if ( _Myios :: rdbuf ( ) != nullptr )
   {
   const sentry _Ok ( * this );

   if ( _Ok && _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
    _Myios :: setstate ( ios_base :: badbit );
   }
  return ( * this );
  }

 basic_ostream & seekp ( pos_type _Pos )
  {
  const sentry _Ok ( * this );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: out ) == - 1 )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 basic_ostream & seekp ( off_type _Off, ios_base :: seekdir _Way )
  {
  const sentry _Ok ( * this );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: out ) == - 1 )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 pos_type tellp ( )
  {
  const sentry _Ok ( * this );

  if ( ! this -> fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: out ) );
  else
   return ( pos_type ( - 1 ) );
  }
 };
#line 631 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ostream"
#pragma vtordisp(pop)
#line 686
template class __declspec(dllimport) basic_ostream< char, char_traits< char> > ;
#line 688
template class __declspec(dllimport) basic_ostream< __wchar_t, char_traits< __wchar_t> > ;
#line 700 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\ostream"
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const char * _Val )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) :: strlen ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Ostr . getloc ( ) );
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  for (; _State == ios_base :: goodbit && 0 < _Count; -- _Count, ++ _Val )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( * _Val ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 747
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, char _Ch )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  const ctype < _Elem > & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Ostr . getloc ( ) );
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( _Ch ) ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 786
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr,
  const char * _Val )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 833
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, char _Ch )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 872
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * _Val )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 919
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, _Elem _Ch )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 959
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const signed char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }
#line 966
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, signed char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }
#line 973
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const unsigned char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }
#line 980
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, unsigned char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }
#line 987
template< class _Ostr, class 
#line 988
_Ty, class 
#line 989
 = void> 
#line 990
struct _Can_stream_out : public false_type { 
#line 993
}; 
#line 995
template< class _Ostr, class 
#line 996
_Ty> 
#line 997
struct _Can_stream_out< _Ostr, _Ty, void_t< decltype((std::declval< _Ostr &> () << std::declval< const _Ty &> ()))> >  : public true_type { 
#line 1000
}; 
#line 1002
template < class _Ostr,
 class _Ty,
 enable_if_t < conjunction_v <
  negation < is_lvalue_reference < _Ostr > >,
  is_base_of < ios_base, _Ostr >,
  _Can_stream_out < _Ostr, _Ty > >, int > = 0 > inline
 _Ostr && operator << ( _Ostr && _Os, const _Ty & _Val )
 {
 _Os << _Val;
 return ( :: std :: move ( _Os ) );
 }
#line 1015
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl endl ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Ostr . widen ( '\n' ) );
 _Ostr . flush ( );
 return ( _Ostr );
 }
#line 1025
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl ends ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Elem ( ) );
 return ( _Ostr );
 }
#line 1034
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl flush ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . flush ( );
 return ( _Ostr );
 }
#line 1044
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
   const error_code & _Errcode )
 {
 return ( _Ostr << _Errcode . category ( ) . name ( ) << ':' << _Errcode . value ( ) );
 }
#line 1052
}
#line 1056
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\istream"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 15
namespace std { 
#pragma vtordisp(push, 2)
#line 19
template < class _Elem,
 class _Traits >
 class basic_istream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef istreambuf_iterator < _Elem, _Traits > _Iter;
 typedef ctype < _Elem > _Ctype;
 typedef num_get < _Elem, _Iter > _Nget;











 explicit basic_istream ( _Mysb * _Strbuf,
  bool _Isstd = false )

  : _Chcount ( 0 )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_istream ( _Uninitialized )
  {
  this -> _Addstd ( this );
  }

protected :
  basic_istream ( basic_istream && _Right )
  : _Chcount ( _Right . _Chcount )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  _Right . _Chcount = 0;
  }

 basic_istream & operator = ( basic_istream && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( basic_istream & _Right )
  {
  _Myios :: swap ( _Right );
  :: std :: swap ( _Chcount, _Right . _Chcount );
  }

public :
  basic_istream ( const basic_istream & ) = delete;
 basic_istream & operator = ( const basic_istream & ) = delete;

 virtual ~ basic_istream ( ) noexcept
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;


 class _Sentry_base
  {
 public :
   _Sentry_base ( basic_istream & _Istr )
   : _Myistr ( _Istr )
   {
   if ( _Myistr . rdbuf ( ) != nullptr )
    _Myistr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( ) noexcept
   {
   if ( _Myistr . rdbuf ( ) != nullptr )
    _Myistr . rdbuf ( ) -> _Unlock ( );
   }

  basic_istream & _Myistr;

  _Sentry_base & operator = ( const _Sentry_base & ) = delete;
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( basic_istream & _Istr, bool _Noskip = false )
   : _Sentry_base ( _Istr )
   {
   _Ok = this -> _Myistr . _Ipfx ( _Noskip );
   }

  explicit operator bool ( ) const
   {
   return ( _Ok );
   }

   sentry ( const sentry & ) = delete;
  sentry & operator = ( const sentry & ) = delete;

 private :
  bool _Ok;
  };

 bool _Ipfx ( bool _Noskip = false )
  {
  if ( this -> good ( ) )
   {
   if ( _Myios :: tie ( ) != nullptr )
    _Myios :: tie ( ) -> flush ( );

   if ( ! _Noskip && this -> flags ( ) & ios_base :: skipws )
    {
    const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( this -> getloc ( ) );

    try {
    int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

    for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
      {
      _Myios :: setstate ( ios_base :: eofbit );
      break;
      }
     else if ( ! _Ctype_fac . is ( _Ctype :: space,
      _Traits :: to_char_type ( _Meta ) ) )
      break;
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

   if ( this -> good ( ) )
    return ( true );
   }
  _Myios :: setstate ( ios_base :: failbit );
  return ( false );
  }

 bool ipfx ( bool _Noskip = false )
  {
  return ( _Ipfx ( _Noskip ) );
  }

 void isfx ( )
  {
  }




















 basic_istream & operator >> ( basic_istream & ( __cdecl * _Pfn ) ( basic_istream & ) )
  {
  return ( ( * _Pfn ) ( * this ) );
  }

 basic_istream & operator >> ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 basic_istream & operator >> ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

private :
 template < class _Ty >
  basic_istream & _Common_extract_with_num_get ( _Ty & _Val )
  {
  ios_base :: iostate _Err = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   try {
   :: std :: use_facet < _Nget > ( this -> getloc ( ) ) . get ( * this, { }, * this, _Err, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _Err );
  return ( * this );
  }

public :
 basic_istream & operator >> ( bool & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( short & _Val )
  {
  ios_base :: iostate _Err = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   try {
   long _Lval;
   :: std :: use_facet < _Nget > ( this -> getloc ( ) ) . get ( * this, { }, * this, _Err, _Lval );
   if ( _Lval < ( - 32768 ) )
    {
    _Err |= ios_base :: failbit;
    _Val = ( - 32768 );
    }
   else if ( _Lval > 32767 )
    {
    _Err |= ios_base :: failbit;
    _Val = 32767;
    }
   else
    {
    _Val = static_cast < short > ( _Lval );
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _Err );
  return ( * this );
  }










 basic_istream & operator >> ( unsigned short & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( int & _Val )
  {
  static_assert ( sizeof ( int ) == sizeof ( long ),
   "Bad overflow assumptions due to sizeof(int) != sizeof(long)" );
  long _Result = _Val;
  _Common_extract_with_num_get ( _Result );
  _Val = _Result;
  return ( * this );
  }

 basic_istream & operator >> ( unsigned int & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( long & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( unsigned long & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( long long & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( unsigned long long & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( float & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( double & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( long double & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( void * & _Val )
  {
  return ( _Common_extract_with_num_get ( _Val ) );
  }

 basic_istream & operator >> ( _Mysb * _Strbuf )
  {
  _Chcount = 0;
  const sentry _Ok ( * this, true );
  ios_base :: iostate _State = ios_base :: goodbit;
  if ( _Ok && _Strbuf != nullptr )
   {
   try {
   for ( int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    {
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }

    try {
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Strbuf -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) )
      {
      break;
      }

    } catch ( ... ) {
     break;
    }

    ++ _Chcount;
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  if ( _Chcount == 0 )
   {
   _State = ios_base :: failbit;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 int_type get ( )
  {
  int_type _Meta = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   else
    {
    _Myios :: rdbuf ( ) -> sbumpc ( );
    ++ _Chcount;
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 basic_istream & get ( _Elem * _Str, streamsize _Count )
  {
  return ( get ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 basic_istream & get ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (; 0 < -- _Count; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Traits :: to_char_type ( _Meta ) == _Delim )
     break;
    else
     {
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _Chcount == 0
   ? _State | ios_base :: failbit : _State );
  * _Str = _Elem ( );
  return ( * this );
  }

 basic_istream & get ( _Elem & _Ch )
  {
  int_type _Meta = get ( );
  if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _Ch = _Traits :: to_char_type ( _Meta );
  return ( * this );
  }

 basic_istream & get ( _Mysb & _Strbuf )
  {
  return ( get ( _Strbuf, _Myios :: widen ( '\n' ) ) );
  }

 basic_istream & get ( _Mysb & _Strbuf, _Elem _Delim )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      _Elem _Ch = _Traits :: to_char_type ( _Meta );
      if ( _Ch == _Delim
       || _Traits :: eq_int_type ( _Traits :: eof ( ),
        _Strbuf . sputc ( _Ch ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  if ( _Chcount == 0 )
   _State |= ios_base :: failbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_istream & getline ( _Elem * _Str, streamsize _Count )
  {
  return ( getline ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 basic_istream & getline ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   int_type _Metadelim = _Traits :: to_int_type ( _Delim );

   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Meta == _Metadelim )
     {
     ++ _Chcount;
     _Myios :: rdbuf ( ) -> sbumpc ( );
     break;
     }
    else if ( -- _Count <= 0 )
     {
     _State |= ios_base :: failbit;
     break;
     }
    else
     {
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  * _Str = _Elem ( );
  _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 basic_istream & ignore ( streamsize _Count = 1,
  int_type _Metadelim = _Traits :: eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   for (;; )
    {
    int_type _Meta;
    if ( _Count != ( numeric_limits < streamsize > :: max ) ( )
     && -- _Count < 0 )
     break;
    else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Meta = _Myios :: rdbuf ( ) -> sbumpc ( ) ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     ++ _Chcount;
     if ( _Meta == _Metadelim )
      break;
     }
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_istream & read ( _Elem * _Str, streamsize _Count )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   const streamsize _Num = _Myios :: rdbuf ( ) -> sgetn ( _Str, _Count );
   _Chcount += _Num;
   if ( _Num != _Count )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 streamsize readsome ( _Elem * _Str,
  streamsize _Count )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );
  streamsize _Num;

  if ( ! _Ok )
   _State |= ios_base :: failbit;
  else if ( ( _Num = _Myios :: rdbuf ( ) -> in_avail ( ) ) < 0 )
   _State |= ios_base :: eofbit;
  else if ( 0 < _Count && 0 < _Num )
   {
   read ( _Str, _Num < _Count ? _Num : _Count );
   }

  _Myios :: setstate ( _State );
  return ( gcount ( ) );
  }

 int_type peek ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Meta = _Myios :: rdbuf ( ) -> sgetc ( ) ) )
    _State |= ios_base :: eofbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 basic_istream & putback ( _Elem _Ch )
  {
  _Chcount = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputbackc ( _Ch ) ) )
    _State |= ios_base :: badbit | _Oldstate;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 basic_istream & unget ( )
  {
  _Chcount = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sungetc ( ) ) )
    _State |= ios_base :: badbit | _Oldstate;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

  streamsize gcount ( ) const
  {
  return ( _Chcount );
  }

 int sync ( )
  {
  const sentry _Ok ( * this, true );

  if ( _Myios :: rdbuf ( ) == nullptr )
   return ( - 1 );
  else if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   {
   _Myios :: setstate ( ios_base :: badbit );
   return ( - 1 );
   }
  else
   return ( 0 );
  }

 basic_istream & seekg ( pos_type _Pos )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: in ) == - 1 )
   _Myios :: setstate ( _State | ios_base :: failbit );
  return ( * this );
  }

 basic_istream & seekg ( off_type _Off, ios_base :: seekdir _Way )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: in ) == - 1 )
   _Myios :: setstate ( _State | ios_base :: failbit );
  return ( * this );
  }

 pos_type tellg ( )
  {
  const sentry _Ok ( * this, true );

  if ( ! this -> fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: in ) );
  else
   return ( pos_type ( - 1 ) );
  }

private :
 streamsize _Chcount;
 };
#line 745 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\istream"
#pragma vtordisp(pop)
#line 773
template class __declspec(dllimport) basic_istream< char, char_traits< char> > ;
#line 774
template class __declspec(dllimport) basic_istream< __wchar_t, char_traits< __wchar_t> > ;
#line 784 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\istream"
template < class _Elem,
 class _Traits >
 class basic_iostream
 : public basic_istream < _Elem, _Traits >,
  public basic_ostream < _Elem, _Traits >
 {
public :
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_iostream ( basic_streambuf < _Elem, _Traits > * _Strbuf )
  : _Myis ( _Strbuf, false ),
   _Myos ( _Noinit, false )
  {
  }

protected :
  basic_iostream ( basic_iostream && _Right )
  : _Myis ( _Right . rdbuf ( ), false ),
   _Myos ( _Noinit, false )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  }

 basic_iostream & operator = ( basic_iostream && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( basic_iostream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   _Myios :: swap ( _Right );
  }

public :
  basic_iostream ( const basic_iostream & ) = delete;
 basic_iostream & operator = ( const basic_iostream & ) = delete;

 virtual ~ basic_iostream ( ) noexcept
  {
  }
 };
#line 839
template class __declspec(dllimport) basic_iostream< char, char_traits< char> > ;
#line 840
template class __declspec(dllimport) basic_iostream< __wchar_t, char_traits< __wchar_t> > ;
#line 851 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\istream"
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem * _Str )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;
 ios_base :: iostate _State = ios_base :: goodbit;
 _Elem * _Str0 = _Str;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( _Istr . getloc ( ) );

  try {
  streamsize _Count = 0 < _Istr . width ( ) ? _Istr . width ( )
   : ( numeric_limits < streamsize > :: max ) ( );
  typename _Myis :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );
  _Elem _Ch;
  for (; 0 < -- _Count; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Ch = _Traits :: to_char_type ( _Meta ) )
     || _Ch == _Elem ( ) )
    break;
   else
    * _Str ++ = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 * _Str = _Elem ( );
 _Istr . width ( 0 );
 _Istr . setstate ( _Str == _Str0 ? _State | ios_base :: failbit : _State );
 return ( _Istr );
 }
#line 892
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem & _Ch )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;

 typename _Myis :: int_type _Meta;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  try {
  _Meta = _Istr . rdbuf ( ) -> sbumpc ( );
  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _State |= ios_base :: eofbit | ios_base :: failbit;
  else
   _Ch = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 918
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }
#line 925
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }
#line 932
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }
#line 939
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }
#line 946
template< class _Istr, class 
#line 947
_Ty, class 
#line 948
 = void> 
#line 949
struct _Can_stream_in : public false_type { 
#line 952
}; 
#line 954
template< class _Istr, class 
#line 955
_Ty> 
#line 956
struct _Can_stream_in< _Istr, _Ty, void_t< decltype((std::declval< _Istr &> () >> std::declval< _Ty> ()))> >  : public true_type { 
#line 959
}; 
#line 961
template < class _Istr,
 class _Ty,
 enable_if_t < conjunction_v <
  negation < is_lvalue_reference < _Istr > >,
  is_base_of < ios_base, _Istr >,
  _Can_stream_in < _Istr, _Ty > >, int > = 0 > inline
 _Istr && operator >> ( _Istr && _Is, _Ty && _Val )
 {
 _Is >> :: std :: forward < _Ty > ( _Val );
 return ( :: std :: move ( _Is ) );
 }
#line 974
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > &
  __cdecl ws ( basic_istream < _Elem, _Traits > & _Istr )
 {
 const typename basic_istream < _Elem, _Traits > :: sentry _Ok ( _Istr, true );

 if ( _Ok )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const auto & _Ctype_fac = :: std :: use_facet < ctype < _Elem >> ( _Istr . getloc ( ) );

  try {
  for ( typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( ! _Ctype_fac . is ( ctype < _Elem > :: space, _Traits :: to_char_type ( _Meta ) ) )
    {
    break;
    }
   }
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  _Istr . setstate ( _State );
  }

 return ( _Istr );
 }
#line 1005
}
#line 1009
#pragma warning(pop)
#pragma pack ( pop )
#line 10 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\xstring_insert.h"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 17
namespace std { 
#line 19
template < class _Elem,
 class _Traits,
 class _SizeT > inline
 basic_ostream < _Elem, _Traits > & _Insert_string (
  basic_ostream < _Elem, _Traits > & _Ostr,
  const _Elem * const _Data, const _SizeT _Size )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 _SizeT _Pad = _Ostr . width ( ) <= 0 || static_cast < _SizeT > ( _Ostr . width ( ) ) <= _Size
  ? 0 : static_cast < _SizeT > ( _Ostr . width ( ) ) - _Size;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Data, ( streamsize ) _Size )
    != ( streamsize ) _Size )
    _State |= ios_base :: badbit;
  else
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 65
}
#line 69
#pragma warning(pop)
#pragma pack ( pop )
#line 13 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\string"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 20
namespace std { 
#line 22
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 typedef ctype < _Elem > _Ctype;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef typename _Mystr :: size_type _Mysizt;

 ios_base :: iostate _State = ios_base :: goodbit;
 bool _Changed = false;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = :: std :: use_facet < _Ctype > ( _Istr . getloc ( ) );
  _Str . erase ( );

  try {
  _Mysizt _Size = 0 < _Istr . width ( )
   && ( _Mysizt ) _Istr . width ( ) < _Str . max_size ( )
    ? ( _Mysizt ) _Istr . width ( ) : _Str . max_size ( );
  typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

  for (; 0 < _Size; -- _Size, _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Traits :: to_char_type ( _Meta ) ) )
    break;
   else
    {
    _Str . push_back ( _Traits :: to_char_type ( _Meta ) );
    _Changed = true;
    }
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . width ( 0 );
 if ( ! _Changed )
  _State |= ios_base :: failbit;
 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 73
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str,
  const _Elem _Delim )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;

 ios_base :: iostate _State = ios_base :: goodbit;
 bool _Changed = false;
 const typename _Myis :: sentry _Ok ( _Istr, true );

 if ( _Ok )
  {
  try {
  _Str . erase ( );
  const typename _Traits :: int_type _Metadelim =
   _Traits :: to_int_type ( _Delim );
  typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

  for (;; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Traits :: eq_int_type ( _Meta, _Metadelim ) )
    {
    _Changed = true;
    _Istr . rdbuf ( ) -> sbumpc ( );
    break;
    }
   else if ( _Str . max_size ( ) <= _Str . size ( ) )
    {
    _State |= ios_base :: failbit;
    break;
    }
   else
    {
    _Str += _Traits :: to_char_type ( _Meta );
    _Changed = true;
    }
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 if ( ! _Changed )
  _State |= ios_base :: failbit;
 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 126
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( getline ( _Istr, _Str, _Istr . widen ( '\n' ) ) );
 }
#line 136
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( :: std :: move ( _Istr ) >> _Str );
 }
#line 146
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str,
  const _Elem _Delim )
 {
 return ( getline ( :: std :: move ( _Istr ), _Str, _Delim ) );
 }
#line 157
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( getline ( :: std :: move ( _Istr ), _Str, _Istr . widen ( '\n' ) ) );
 }
#line 167
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr,
  const basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( _Insert_string ( _Ostr, _Str . data ( ), _Str . size ( ) ) );
 }
#line 179
inline int stoi(const string &_Str, size_t *_Idx = 0, int 
#line 180
_Base = 10) 
#line 181
{ 
#line 182
int &_Errno_ref = *_errno(); 
#line 183
const char *_Ptr = _Str.c_str(); 
#line 184
char *_Eptr; 
#line 185
_Errno_ref = 0; 
#line 186
const long _Ans = ::strtol(_Ptr, &_Eptr, _Base); 
#line 188
if (_Ptr == _Eptr) { 
#line 189
_Xinvalid_argument("invalid stoi argument"); }  
#line 190
if (((_Errno_ref == 34) || (_Ans < ((-2147483647) - 1))) || ((2147483647) < _Ans)) { 
#line 191
_Xout_of_range("stoi argument out of range"); }  
#line 192
if (_Idx != (nullptr)) { 
#line 193
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 194
return (int)_Ans; 
#line 195
} 
#line 197
inline long stol(const string &_Str, size_t *_Idx = 0, int 
#line 198
_Base = 10) 
#line 199
{ 
#line 200
int &_Errno_ref = *_errno(); 
#line 201
const char *_Ptr = _Str.c_str(); 
#line 202
char *_Eptr; 
#line 203
_Errno_ref = 0; 
#line 204
const long _Ans = ::strtol(_Ptr, &_Eptr, _Base); 
#line 206
if (_Ptr == _Eptr) { 
#line 207
_Xinvalid_argument("invalid stol argument"); }  
#line 208
if (_Errno_ref == 34) { 
#line 209
_Xout_of_range("stol argument out of range"); }  
#line 210
if (_Idx != (nullptr)) { 
#line 211
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 212
return _Ans; 
#line 213
} 
#line 215
inline unsigned long stoul(const string &_Str, size_t *_Idx = 0, int 
#line 216
_Base = 10) 
#line 217
{ 
#line 218
int &_Errno_ref = *_errno(); 
#line 219
const char *_Ptr = _Str.c_str(); 
#line 220
char *_Eptr; 
#line 221
_Errno_ref = 0; 
#line 222
const unsigned long _Ans = ::strtoul(_Ptr, &_Eptr, _Base); 
#line 224
if (_Ptr == _Eptr) { 
#line 225
_Xinvalid_argument("invalid stoul argument"); }  
#line 226
if (_Errno_ref == 34) { 
#line 227
_Xout_of_range("stoul argument out of range"); }  
#line 228
if (_Idx != (nullptr)) { 
#line 229
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 230
return _Ans; 
#line 231
} 
#line 233
inline __int64 stoll(const string &_Str, size_t *_Idx = 0, int 
#line 234
_Base = 10) 
#line 235
{ 
#line 236
int &_Errno_ref = *_errno(); 
#line 237
const char *_Ptr = _Str.c_str(); 
#line 238
char *_Eptr; 
#line 239
_Errno_ref = 0; 
#line 240
const __int64 _Ans = ::strtoll(_Ptr, &_Eptr, _Base); 
#line 242
if (_Ptr == _Eptr) { 
#line 243
_Xinvalid_argument("invalid stoll argument"); }  
#line 244
if (_Errno_ref == 34) { 
#line 245
_Xout_of_range("stoll argument out of range"); }  
#line 246
if (_Idx != (nullptr)) { 
#line 247
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 248
return _Ans; 
#line 249
} 
#line 251
inline unsigned __int64 stoull(const string &_Str, size_t *_Idx = 0, int 
#line 252
_Base = 10) 
#line 253
{ 
#line 254
int &_Errno_ref = *_errno(); 
#line 255
const char *_Ptr = _Str.c_str(); 
#line 256
char *_Eptr; 
#line 257
_Errno_ref = 0; 
#line 258
const unsigned __int64 _Ans = ::strtoull(_Ptr, &_Eptr, _Base); 
#line 260
if (_Ptr == _Eptr) { 
#line 261
_Xinvalid_argument("invalid stoull argument"); }  
#line 262
if (_Errno_ref == 34) { 
#line 263
_Xout_of_range("stoull argument out of range"); }  
#line 264
if (_Idx != (nullptr)) { 
#line 265
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 266
return _Ans; 
#line 267
} 
#line 269
inline float stof(const string &_Str, size_t *_Idx = 0) 
#line 270
{ 
#line 271
int &_Errno_ref = *_errno(); 
#line 272
const char *_Ptr = _Str.c_str(); 
#line 273
char *_Eptr; 
#line 274
_Errno_ref = 0; 
#line 275
const float _Ans = ::strtof(_Ptr, &_Eptr); 
#line 277
if (_Ptr == _Eptr) { 
#line 278
_Xinvalid_argument("invalid stof argument"); }  
#line 279
if (_Errno_ref == 34) { 
#line 280
_Xout_of_range("stof argument out of range"); }  
#line 281
if (_Idx != (nullptr)) { 
#line 282
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 283
return _Ans; 
#line 284
} 
#line 286
inline double stod(const string &_Str, size_t *_Idx = 0) 
#line 287
{ 
#line 288
int &_Errno_ref = *_errno(); 
#line 289
const char *_Ptr = _Str.c_str(); 
#line 290
char *_Eptr; 
#line 291
_Errno_ref = 0; 
#line 292
const double _Ans = ::strtod(_Ptr, &_Eptr); 
#line 294
if (_Ptr == _Eptr) { 
#line 295
_Xinvalid_argument("invalid stod argument"); }  
#line 296
if (_Errno_ref == 34) { 
#line 297
_Xout_of_range("stod argument out of range"); }  
#line 298
if (_Idx != (nullptr)) { 
#line 299
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 300
return _Ans; 
#line 301
} 
#line 303
inline long double stold(const string &_Str, size_t *_Idx = 0) 
#line 304
{ 
#line 305
int &_Errno_ref = *_errno(); 
#line 306
const char *_Ptr = _Str.c_str(); 
#line 307
char *_Eptr; 
#line 308
_Errno_ref = 0; 
#line 309
const long double _Ans = ::strtold(_Ptr, &_Eptr); 
#line 311
if (_Ptr == _Eptr) { 
#line 312
_Xinvalid_argument("invalid stold argument"); }  
#line 313
if (_Errno_ref == 34) { 
#line 314
_Xout_of_range("stold argument out of range"); }  
#line 315
if (_Idx != (nullptr)) { 
#line 316
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 317
return _Ans; 
#line 318
} 
#line 321
inline int stoi(const wstring &_Str, size_t *_Idx = 0, int 
#line 322
_Base = 10) 
#line 323
{ 
#line 324
int &_Errno_ref = *_errno(); 
#line 325
const __wchar_t *_Ptr = _Str.c_str(); 
#line 326
__wchar_t *_Eptr; 
#line 327
_Errno_ref = 0; 
#line 328
const long _Ans = ::wcstol(_Ptr, &_Eptr, _Base); 
#line 330
if (_Ptr == _Eptr) { 
#line 331
_Xinvalid_argument("invalid stoi argument"); }  
#line 332
if (((_Errno_ref == 34) || (_Ans < ((-2147483647) - 1))) || ((2147483647) < _Ans)) { 
#line 333
_Xout_of_range("stoi argument out of range"); }  
#line 334
if (_Idx != (nullptr)) { 
#line 335
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 336
return (int)_Ans; 
#line 337
} 
#line 339
inline long stol(const wstring &_Str, size_t *_Idx = 0, int 
#line 340
_Base = 10) 
#line 341
{ 
#line 342
int &_Errno_ref = *_errno(); 
#line 343
const __wchar_t *_Ptr = _Str.c_str(); 
#line 344
__wchar_t *_Eptr; 
#line 345
_Errno_ref = 0; 
#line 346
const long _Ans = ::wcstol(_Ptr, &_Eptr, _Base); 
#line 348
if (_Ptr == _Eptr) { 
#line 349
_Xinvalid_argument("invalid stol argument"); }  
#line 350
if (_Errno_ref == 34) { 
#line 351
_Xout_of_range("stol argument out of range"); }  
#line 352
if (_Idx != (nullptr)) { 
#line 353
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 354
return _Ans; 
#line 355
} 
#line 357
inline unsigned long stoul(const wstring &_Str, size_t *_Idx = 0, int 
#line 358
_Base = 10) 
#line 359
{ 
#line 360
int &_Errno_ref = *_errno(); 
#line 361
const __wchar_t *_Ptr = _Str.c_str(); 
#line 362
__wchar_t *_Eptr; 
#line 363
_Errno_ref = 0; 
#line 364
const unsigned long _Ans = ::wcstoul(_Ptr, &_Eptr, _Base); 
#line 366
if (_Ptr == _Eptr) { 
#line 367
_Xinvalid_argument("invalid stoul argument"); }  
#line 368
if (_Errno_ref == 34) { 
#line 369
_Xout_of_range("stoul argument out of range"); }  
#line 370
if (_Idx != (nullptr)) { 
#line 371
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 372
return _Ans; 
#line 373
} 
#line 375
inline __int64 stoll(const wstring &_Str, size_t *_Idx = 0, int 
#line 376
_Base = 10) 
#line 377
{ 
#line 378
int &_Errno_ref = *_errno(); 
#line 379
const __wchar_t *_Ptr = _Str.c_str(); 
#line 380
__wchar_t *_Eptr; 
#line 381
_Errno_ref = 0; 
#line 382
const __int64 _Ans = ::wcstoll(_Ptr, &_Eptr, _Base); 
#line 384
if (_Ptr == _Eptr) { 
#line 385
_Xinvalid_argument("invalid stoll argument"); }  
#line 386
if (_Errno_ref == 34) { 
#line 387
_Xout_of_range("stoll argument out of range"); }  
#line 388
if (_Idx != (nullptr)) { 
#line 389
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 390
return _Ans; 
#line 391
} 
#line 393
inline unsigned __int64 stoull(const wstring &_Str, size_t *_Idx = 0, int 
#line 394
_Base = 10) 
#line 395
{ 
#line 396
int &_Errno_ref = *_errno(); 
#line 397
const __wchar_t *_Ptr = _Str.c_str(); 
#line 398
__wchar_t *_Eptr; 
#line 399
_Errno_ref = 0; 
#line 400
const unsigned __int64 _Ans = ::wcstoull(_Ptr, &_Eptr, _Base); 
#line 402
if (_Ptr == _Eptr) { 
#line 403
_Xinvalid_argument("invalid stoull argument"); }  
#line 404
if (_Errno_ref == 34) { 
#line 405
_Xout_of_range("stoull argument out of range"); }  
#line 406
if (_Idx != (nullptr)) { 
#line 407
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 408
return _Ans; 
#line 409
} 
#line 411
inline float stof(const wstring &_Str, size_t *_Idx = 0) 
#line 412
{ 
#line 413
int &_Errno_ref = *_errno(); 
#line 414
const __wchar_t *_Ptr = _Str.c_str(); 
#line 415
__wchar_t *_Eptr; 
#line 416
_Errno_ref = 0; 
#line 417
const float _Ans = ::wcstof(_Ptr, &_Eptr); 
#line 419
if (_Ptr == _Eptr) { 
#line 420
_Xinvalid_argument("invalid stof argument"); }  
#line 421
if (_Errno_ref == 34) { 
#line 422
_Xout_of_range("stof argument out of range"); }  
#line 423
if (_Idx != (nullptr)) { 
#line 424
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 425
return _Ans; 
#line 426
} 
#line 428
inline double stod(const wstring &_Str, size_t *_Idx = 0) 
#line 429
{ 
#line 430
int &_Errno_ref = *_errno(); 
#line 431
const __wchar_t *_Ptr = _Str.c_str(); 
#line 432
__wchar_t *_Eptr; 
#line 433
_Errno_ref = 0; 
#line 434
const double _Ans = ::wcstod(_Ptr, &_Eptr); 
#line 436
if (_Ptr == _Eptr) { 
#line 437
_Xinvalid_argument("invalid stod argument"); }  
#line 438
if (_Errno_ref == 34) { 
#line 439
_Xout_of_range("stod argument out of range"); }  
#line 440
if (_Idx != (nullptr)) { 
#line 441
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 442
return _Ans; 
#line 443
} 
#line 445
inline long double stold(const wstring &_Str, size_t *_Idx = 0) 
#line 446
{ 
#line 447
int &_Errno_ref = *_errno(); 
#line 448
const __wchar_t *_Ptr = _Str.c_str(); 
#line 449
__wchar_t *_Eptr; 
#line 450
_Errno_ref = 0; 
#line 451
const long double _Ans = ::wcstold(_Ptr, &_Eptr); 
#line 453
if (_Ptr == _Eptr) { 
#line 454
_Xinvalid_argument("invalid stold argument"); }  
#line 455
if (_Errno_ref == 34) { 
#line 456
_Xout_of_range("stold argument out of range"); }  
#line 457
if (_Idx != (nullptr)) { 
#line 458
(*_Idx) = ((size_t)(_Eptr - _Ptr)); }  
#line 459
return _Ans; 
#line 460
} 
#line 463
template < class _Elem,
 class _UTy > inline
 _Elem * _UIntegral_to_buff ( _Elem * _RNext, _UTy _UVal )
 {
 static_assert ( is_unsigned_v < _UTy >, "_UTy must be unsigned" );


 auto _UVal_trunc = _UVal;























 do
  {
  * -- _RNext = static_cast < _Elem > ( '0' + _UVal_trunc % 10 );
  _UVal_trunc /= 10;
  }
 while ( _UVal_trunc != 0 );
 return ( _RNext );
 }
#line 503 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\string"
template < class _Elem,
 class _Ty > inline
 basic_string < _Elem > _Integral_to_string ( const _Ty _Val )
 {
 static_assert ( is_integral_v < _Ty >, "_Ty must be integral" );
 using _UTy = make_unsigned_t < _Ty >;
 _Elem _Buff [ 21 ];
 _Elem * const _Buff_end = :: std :: end ( _Buff );
 _Elem * _RNext = _Buff_end;
 const auto _UVal = static_cast < _UTy > ( _Val );
 if ( _Val < 0 )
  {
  _RNext = _UIntegral_to_buff ( _RNext, 0 - _UVal );
  * -- _RNext = '-';
  }
 else
  _RNext = _UIntegral_to_buff ( _RNext, _UVal );

 return ( basic_string < _Elem > ( _RNext, _Buff_end ) );
 }
#line 524
template < class _Ty > inline
 string _Floating_to_string ( const char * _Fmt, _Ty _Val )
 {
 static_assert ( is_floating_point_v < _Ty >,
  "_Ty must be floating point" );

 const auto _Len = static_cast < size_t > ( :: _scprintf ( _Fmt, _Val ) );
 string _Str ( _Len, '\000' );
 :: sprintf_s ( & _Str [ 0 ], _Len + 1, _Fmt, _Val );
 return ( _Str );
 }
#line 536
template < class _Ty > inline
 wstring _Floating_to_wstring ( const wchar_t * _Fmt, _Ty _Val )
 {
 static_assert ( is_floating_point_v < _Ty >,
  "_Ty must be floating point" );

 const auto _Len = static_cast < size_t > ( :: _scwprintf ( _Fmt, _Val ) );
 wstring _Str ( _Len, L'\x0' );
 :: swprintf_s ( & _Str [ 0 ], _Len + 1, _Fmt, _Val );
 return ( _Str );
 }
#line 551
inline string to_string(int _Val) 
#line 552
{ 
#line 553
return _Integral_to_string< char> (_Val); 
#line 554
} 
#line 556
inline string to_string(unsigned _Val) 
#line 557
{ 
#line 558
return _Integral_to_string< char> (_Val); 
#line 559
} 
#line 561
inline string to_string(long _Val) 
#line 562
{ 
#line 563
return _Integral_to_string< char> (_Val); 
#line 564
} 
#line 566
inline string to_string(unsigned long _Val) 
#line 567
{ 
#line 568
return _Integral_to_string< char> (_Val); 
#line 569
} 
#line 571
inline string to_string(__int64 _Val) 
#line 572
{ 
#line 573
return _Integral_to_string< char> (_Val); 
#line 574
} 
#line 576
inline string to_string(unsigned __int64 _Val) 
#line 577
{ 
#line 578
return _Integral_to_string< char> (_Val); 
#line 579
} 
#line 581
inline string to_string(float _Val) 
#line 582
{ 
#line 583
return _Floating_to_string("%f", _Val); 
#line 584
} 
#line 586
inline string to_string(double _Val) 
#line 587
{ 
#line 588
return _Floating_to_string("%f", _Val); 
#line 589
} 
#line 591
inline string to_string(long double _Val) 
#line 592
{ 
#line 593
return _Floating_to_string("%Lf", _Val); 
#line 594
} 
#line 597
inline wstring to_wstring(int _Val) 
#line 598
{ 
#line 599
return _Integral_to_string< __wchar_t> (_Val); 
#line 600
} 
#line 602
inline wstring to_wstring(unsigned _Val) 
#line 603
{ 
#line 604
return _Integral_to_string< __wchar_t> (_Val); 
#line 605
} 
#line 607
inline wstring to_wstring(long _Val) 
#line 608
{ 
#line 609
return _Integral_to_string< __wchar_t> (_Val); 
#line 610
} 
#line 612
inline wstring to_wstring(unsigned long _Val) 
#line 613
{ 
#line 614
return _Integral_to_string< __wchar_t> (_Val); 
#line 615
} 
#line 617
inline wstring to_wstring(__int64 _Val) 
#line 618
{ 
#line 619
return _Integral_to_string< __wchar_t> (_Val); 
#line 620
} 
#line 622
inline wstring to_wstring(unsigned __int64 _Val) 
#line 623
{ 
#line 624
return _Integral_to_string< __wchar_t> (_Val); 
#line 625
} 
#line 627
inline wstring to_wstring(float _Val) 
#line 628
{ 
#line 629
return _Floating_to_wstring(L"\x25\x66", _Val); 
#line 630
} 
#line 632
inline wstring to_wstring(double _Val) 
#line 633
{ 
#line 634
return _Floating_to_wstring(L"\x25\x66", _Val); 
#line 635
} 
#line 637
inline wstring to_wstring(long double _Val) 
#line 638
{ 
#line 639
return _Floating_to_wstring(L"\x25\x4c\x66", _Val); 
#line 640
} 
#line 643
inline namespace literals { 
#line 644
inline namespace string_literals { 
#line 645
inline string operator ""s(const char *_Str, size_t _Len) 
#line 646
{ 
#line 647
return string(_Str, _Len); 
#line 648
} 
#line 650
inline wstring operator ""s(const __wchar_t *_Str, size_t _Len) 
#line 651
{ 
#line 652
return wstring(_Str, _Len); 
#line 653
} 
#line 655
inline u16string operator ""s(const char16_t *_Str, size_t _Len) 
#line 656
{ 
#line 657
return u16string(_Str, _Len); 
#line 658
} 
#line 660
inline u32string operator ""s(const char32_t *_Str, size_t _Len) 
#line 661
{ 
#line 662
return u32string(_Str, _Len); 
#line 663
} 
#line 664
}
#line 665
}
#line 680 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\string"
}
#line 684
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\sstream"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 14
namespace std { 
#line 17
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_stringbuf
  : public basic_streambuf < _Elem, _Traits >
 {
public :
 typedef _Alloc allocator_type;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef typename _Mystr :: size_type _Mysize_type;

 explicit basic_stringbuf ( ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  : _Seekhigh ( nullptr ),
  _Mystate ( _Getstate ( _Mode ) ),
  _Al ( )
  {
  }

 explicit basic_stringbuf ( const _Mystr & _Str, ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  : _Al ( _Str . get_allocator ( ) )
  {
  _Init ( _Str . c_str ( ), _Str . size ( ), _Getstate ( _Mode ) );
  }

 basic_stringbuf ( basic_stringbuf && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_stringbuf & operator = ( basic_stringbuf && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_stringbuf && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Tidy ( );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_stringbuf & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mysb :: swap ( _Right );
   :: std :: swap ( _Seekhigh, _Right . _Seekhigh );
   :: std :: swap ( _Mystate, _Right . _Mystate );
   _Swap_adl ( _Al, _Right . _Al );
   }
  }

 basic_stringbuf ( const basic_stringbuf & ) = delete;
 basic_stringbuf & operator = ( const basic_stringbuf & ) = delete;

 virtual ~ basic_stringbuf ( ) noexcept
  {
  _Tidy ( );
  }

 enum
  {
  _Allocated = 1,
  _Constant = 2,
  _Noread = 4,
  _Append = 8,
  _Atend = 16
  };

 using int_type = typename _Traits :: int_type;
 using pos_type = typename _Traits :: pos_type;
 using off_type = typename _Traits :: off_type;

  _Mystr str ( ) const
  {
  _Mystr _Result ( _Al );
  if ( ! ( _Mystate & _Constant ) && _Mysb :: pptr ( ) != nullptr )
   {
   const auto _Base = _Mysb :: pbase ( );
   _Result . assign ( _Base, static_cast < _Mysize_type > ( _Max_value ( _Mysb :: pptr ( ), _Seekhigh ) - _Base ) );
   }
  else if ( ! ( _Mystate & _Noread ) && _Mysb :: gptr ( ) != nullptr )
   {
   const auto _Base = _Mysb :: eback ( );
   _Result . assign ( _Base, static_cast < _Mysize_type > ( _Mysb :: egptr ( ) - _Base ) );
   }

  return ( _Result );
  }

 void str ( const _Mystr & _Newstr )
  {
  _Tidy ( );
  _Init ( _Newstr . c_str ( ), _Newstr . size ( ), _Mystate );
  }

protected :
 virtual int_type overflow ( int_type _Meta = _Traits :: eof ( ) )
  {
  if ( _Mystate & _Constant )
   {
   return ( _Traits :: eof ( ) );
   }

  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   {
   return ( _Traits :: not_eof ( _Meta ) );
   }

  const auto _Pptr = _Mysb :: pptr ( );
  const auto _Epptr = _Mysb :: epptr ( );
  if ( _Pptr != nullptr && _Pptr < _Epptr )
   {
   * _Mysb :: _Pninc ( ) = _Traits :: to_char_type ( _Meta );
   _Seekhigh = _Pptr + 1;
   return ( _Meta );
   }


  size_t _Oldsize = 0;
  const auto _Oldptr = _Mysb :: eback ( );
  if ( _Pptr != nullptr )
   {
   _Oldsize = static_cast < size_t > ( _Epptr - _Oldptr );
   }

  size_t _Newsize;
  if ( _Oldsize < _MINSIZE )
   {
   _Newsize = _MINSIZE;
   }
  else if ( _Oldsize < 2147483647 / 2 )
   {
   _Newsize = _Oldsize << 1;
   }
  else if ( _Oldsize < 2147483647 )
   {
   _Newsize = 2147483647;
   }
  else
   {
   return ( _Traits :: eof ( ) );
   }

  const auto _Newptr = _Unfancy ( _Al . allocate ( _Newsize ) );
  _Traits :: copy ( _Newptr, _Oldptr, _Oldsize );

  const auto _New_pnext = _Newptr + _Oldsize;
  _Seekhigh = _New_pnext + 1;

  _Mysb :: setp ( _Newptr, _New_pnext, _Newptr + _Newsize );
  if ( _Mystate & _Noread )
   {
   _Mysb :: setg ( _Newptr, nullptr, _Newptr );
   }
  else
   {
   _Mysb :: setg ( _Newptr,
    _Newptr + ( _Mysb :: gptr ( ) - _Oldptr ),
    _Seekhigh );
   }

  if ( _Mystate & _Allocated )
   {
   _Al . deallocate ( _Ptr_traits :: pointer_to ( * _Oldptr ), _Oldsize );
   }

  _Mystate |= _Allocated;
  * _Mysb :: _Pninc ( ) = _Traits :: to_char_type ( _Meta );
  return ( _Meta );
  }

 virtual int_type pbackfail ( int_type _Meta = _Traits :: eof ( ) )
  {
  const auto _Gptr = _Mysb :: gptr ( );
  if ( _Gptr == nullptr
   || _Gptr <= _Mysb :: eback ( )
   || ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
    && ! _Traits :: eq ( _Traits :: to_char_type ( _Meta ), _Gptr [ - 1 ] )
    && ( _Mystate & _Constant ) ) )
   {
   return ( _Traits :: eof ( ) );
   }


  _Mysb :: gbump ( - 1 );
  if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   {
   * _Mysb :: gptr ( ) = _Traits :: to_char_type ( _Meta );
   }

  return ( _Traits :: not_eof ( _Meta ) );
  }

 virtual int_type underflow ( )
  {
  const auto _Gptr = _Mysb :: gptr ( );
  if ( _Gptr == nullptr )
   {
   return ( _Traits :: eof ( ) );
   }

  if ( _Gptr < _Mysb :: egptr ( ) )
   {
   return ( _Traits :: to_int_type ( * _Gptr ) );
   }


  const auto _Pptr = _Mysb :: pptr ( );
  if ( ! _Pptr || ( _Mystate & _Noread ) )
   {
   return ( _Traits :: eof ( ) );
   }

  const auto _Local_highwater = _Max_value ( _Seekhigh, _Pptr );
  if ( _Local_highwater <= _Gptr )
   {
   return ( _Traits :: eof ( ) );
   }

  _Seekhigh = _Local_highwater;
  _Mysb :: setg ( _Mysb :: eback ( ), _Mysb :: gptr ( ), _Local_highwater );
  return ( _Traits :: to_int_type ( * _Mysb :: gptr ( ) ) );
  }

 virtual pos_type seekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  const auto _Gptr_old = _Mysb :: gptr ( );
  const auto _Pptr_old = _Mysb :: pptr ( );
  if ( _Pptr_old != nullptr && _Seekhigh < _Pptr_old )
   {
   _Seekhigh = _Pptr_old;
   }

  const auto _Seeklow = _Mysb :: eback ( );
  const auto _Seekdist = _Seekhigh - _Seeklow;
  off_type _Newoff;
  switch ( _Way )
   {
   case ios_base :: beg :
    _Newoff = 0;
    break;
   case ios_base :: end :
    _Newoff = _Seekdist;
    break;
   case ios_base :: cur :
    {
    constexpr auto _Both = ios_base :: in | ios_base :: out;
    if ( ( _Mode & _Both ) != _Both )
     {
     if ( _Mode & ios_base :: in )
      {
      if ( _Gptr_old != nullptr || _Seeklow == nullptr )
       {
       _Newoff = _Gptr_old - _Seeklow;
       break;
       }
      }
     else if ( ( _Mode & ios_base :: out ) && ( _Pptr_old != nullptr || _Seeklow == nullptr ) )
      {
      _Newoff = _Pptr_old - _Seeklow;
      break;
      }
     }
    }


   default :
    return ( pos_type ( off_type ( - 1 ) ) );
   }

  if ( static_cast < unsigned long long > ( _Off ) + _Newoff > static_cast < unsigned long long > ( _Seekdist ) )
   {
   return ( pos_type ( off_type ( - 1 ) ) );
   }

  _Off += _Newoff;
  if ( _Off != 0
   && ( ( ( _Mode & ios_base :: in ) && _Gptr_old == nullptr )
    || ( ( _Mode & ios_base :: out ) && _Pptr_old == nullptr ) ) )
   {
   return ( pos_type ( off_type ( - 1 ) ) );
   }

  const auto _Newptr = _Seeklow + _Off;
  if ( ( _Mode & ios_base :: in ) && _Gptr_old != nullptr )
   {
   _Mysb :: setg ( _Seeklow, _Newptr, _Seekhigh );
   }

  if ( ( _Mode & ios_base :: out ) && _Pptr_old != nullptr )
   {
   _Mysb :: setp ( _Seeklow, _Newptr, _Mysb :: epptr ( ) );
   }

  return ( pos_type ( _Off ) );
  }

 virtual pos_type seekpos ( pos_type _Pos,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  const auto _Off = static_cast < streamoff > ( _Pos );
  const auto _Gptr_old = _Mysb :: gptr ( );
  const auto _Pptr_old = _Mysb :: pptr ( );
  if ( _Pptr_old != nullptr && _Seekhigh < _Pptr_old )
   {
   _Seekhigh = _Pptr_old;
   }

  const auto _Seeklow = _Mysb :: eback ( );
  const auto _Seekdist = _Seekhigh - _Seeklow;
  if ( static_cast < unsigned long long > ( _Off ) > static_cast < unsigned long long > ( _Seekdist ) )
   {
   return ( pos_type ( off_type ( - 1 ) ) );
   }

  if ( _Off != 0
   && ( ( ( _Mode & ios_base :: in ) && _Gptr_old == nullptr )
    || ( ( _Mode & ios_base :: out ) && _Pptr_old == nullptr ) ) )
   {
   return ( pos_type ( off_type ( - 1 ) ) );
   }

  const auto _Newptr = _Seeklow + _Off;
  if ( ( _Mode & ios_base :: in ) && _Gptr_old != nullptr )
   {
   _Mysb :: setg ( _Seeklow, _Newptr, _Seekhigh );
   }

  if ( ( _Mode & ios_base :: out ) && _Pptr_old != nullptr )
   {
   _Mysb :: setp ( _Seeklow, _Newptr, _Mysb :: epptr ( ) );
   }

  return ( pos_type ( _Off ) );
  }

 void _Init ( const _Elem * _Ptr, _Mysize_type _Count, int _State )
  {
  if ( _Count > 2147483647 )
   {
   _Xbad_alloc ( );
   }

  if ( _Count != 0 && ( _State & ( _Noread | _Constant ) ) != ( _Noread | _Constant ) )
   {
   const auto _Pnew = _Unfancy ( _Al . allocate ( _Count ) );
   _Traits :: copy ( _Pnew, _Ptr, _Count );
   _Seekhigh = _Pnew + _Count;

   if ( ! ( _State & _Noread ) )
    {
    _Mysb :: setg ( _Pnew, _Pnew, _Seekhigh );
    }

   if ( ! ( _State & _Constant ) )
    {
    _Mysb :: setp ( _Pnew,
     ( _State & ( _Atend | _Append ) ) ? _Seekhigh : _Pnew,
     _Seekhigh );

    if ( _State & _Noread )
     {
     _Mysb :: setg ( _Pnew, nullptr, _Pnew );
     }
    }

   _State |= _Allocated;
   }
  else
   {
   _Seekhigh = nullptr;
   }

  _Mystate = _State;
  }

 void _Tidy ( )
  {
  if ( _Mystate & _Allocated )
   {
   _Al . deallocate ( _Ptr_traits :: pointer_to ( * _Mysb :: eback ( ) ),
    static_cast < typename allocator_traits < allocator_type > :: size_type > (
     ( _Mysb :: pptr ( ) != nullptr ? _Mysb :: epptr ( ) : _Mysb :: egptr ( ) ) - _Mysb :: eback ( ) ) );
   }

  _Mysb :: setg ( nullptr, nullptr, nullptr );
  _Mysb :: setp ( nullptr, nullptr );
  _Seekhigh = nullptr;
  _Mystate &= ~ _Allocated;
  }

private :
 using _Ptr_traits = pointer_traits < typename allocator_traits < allocator_type > :: pointer >;

 enum
  {
  _MINSIZE = 32
  };

 static int _Getstate ( ios_base :: openmode _Mode )
  {
  int _State = 0;
  if ( ! ( _Mode & ios_base :: in ) )
   {
   _State |= _Noread;
   }

  if ( ! ( _Mode & ios_base :: out ) )
   {
   _State |= _Constant;
   }

  if ( _Mode & ios_base :: app )
   {
   _State |= _Append;
   }

  if ( _Mode & ios_base :: ate )
   {
   _State |= _Atend;
   }

  return ( _State );
  }

 _Elem * _Seekhigh;
 int _Mystate;
 allocator_type _Al;
 };
#line 454
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringbuf < _Elem, _Traits, _Alloc > & _Left,
  basic_stringbuf < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 464
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_istringstream
  : public basic_istream < _Elem, _Traits >
 {
public :
 typedef basic_istream < _Elem, _Traits > _Mybase;
 typedef _Alloc allocator_type;
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;

 explicit basic_istringstream ( ios_base :: openmode _Mode = ios_base :: in )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Mode | ios_base :: in )
  {
  }

 explicit basic_istringstream ( const _Mystr & _Str,
  ios_base :: openmode _Mode = ios_base :: in )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Str, _Mode | ios_base :: in )
  {
  }

 basic_istringstream ( basic_istringstream && _Right )
  : _Mybase ( & _Stringbuffer )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_istringstream & operator = ( basic_istringstream && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_istringstream && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Stringbuffer . str ( _Mystr ( ) );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_istringstream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mybase :: swap ( _Right );
   _Stringbuffer . swap ( _Right . _Stringbuffer );
   }
  }

 basic_istringstream ( const basic_istringstream & ) = delete;
 basic_istringstream & operator = ( const basic_istringstream & ) = delete;

 virtual ~ basic_istringstream ( ) noexcept
  {
  }

  _Mysb * rdbuf ( ) const
  {
  return ( ( _Mysb * ) & _Stringbuffer );
  }

  _Mystr str ( ) const
  {
  return ( _Stringbuffer . str ( ) );
  }

 void str ( const _Mystr & _Newstr )
  {
  _Stringbuffer . str ( _Newstr );
  }

private :
 _Mysb _Stringbuffer;
 };
#line 545
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_istringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_istringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 555
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_ostringstream
  : public basic_ostream < _Elem, _Traits >
 {
public :
 typedef basic_ostream < _Elem, _Traits > _Mybase;
 typedef _Alloc allocator_type;
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;

 explicit basic_ostringstream ( ios_base :: openmode _Mode = ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Mode | ios_base :: out )
  {
  }

 explicit basic_ostringstream ( const _Mystr & _Str,
  ios_base :: openmode _Mode = ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Str, _Mode | ios_base :: out )
  {
  }

 basic_ostringstream ( basic_ostringstream && _Right )
  : _Mybase ( & _Stringbuffer )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_ostringstream & operator = ( basic_ostringstream && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_ostringstream && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Stringbuffer . str ( _Mystr ( ) );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_ostringstream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mybase :: swap ( _Right );
   _Stringbuffer . swap ( _Right . _Stringbuffer );
   }
  }

 basic_ostringstream ( const basic_ostringstream & ) = delete;
 basic_ostringstream & operator = ( const basic_ostringstream & ) = delete;

 virtual ~ basic_ostringstream ( ) noexcept
  {
  }

  _Mysb * rdbuf ( ) const
  {
  return ( ( _Mysb * ) & _Stringbuffer );
  }

  _Mystr str ( ) const
  {
  return ( _Stringbuffer . str ( ) );
  }

 void str ( const _Mystr & _Newstr )
  {
  _Stringbuffer . str ( _Newstr );
  }

private :
 _Mysb _Stringbuffer;
 };
#line 636
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_ostringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_ostringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 646
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_stringstream
  : public basic_iostream < _Elem, _Traits >
 {
public :
 typedef basic_iostream < _Elem, _Traits > _Mybase;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;
 typedef basic_stringbuf < _Elem, _Traits, _Alloc > _Mysb;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;

 explicit basic_stringstream ( ios_base :: openmode _Mode =
  ios_base :: in | ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Mode )
  {
  }

 explicit basic_stringstream ( const _Mystr & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  : _Mybase ( & _Stringbuffer ),
   _Stringbuffer ( _Str, _Mode )
  {
  }

 basic_stringstream ( basic_stringstream && _Right )
  : _Mybase ( & _Stringbuffer )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_stringstream & operator = ( basic_stringstream && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_stringstream && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Stringbuffer . str ( _Mystr ( ) );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_stringstream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mybase :: swap ( _Right );
   _Stringbuffer . swap ( _Right . _Stringbuffer );
   }
  }

 basic_stringstream ( const basic_stringstream & ) = delete;
 basic_stringstream & operator = ( const basic_stringstream & ) = delete;

 virtual ~ basic_stringstream ( ) noexcept
  {
  }

  _Mysb * rdbuf ( ) const
  {
  return ( ( _Mysb * ) & _Stringbuffer );
  }

  _Mystr str ( ) const
  {
  return ( _Stringbuffer . str ( ) );
  }

 void str ( const _Mystr & _Newstr )
  {
  _Stringbuffer . str ( _Newstr );
  }

private :
 _Mysb _Stringbuffer;
 };
#line 733
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_stringstream < _Elem, _Traits, _Alloc > & _Left,
  basic_stringstream < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 741
}
#line 744
#pragma warning(pop)
#pragma pack ( pop )
#line 8 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
#pragma pack ( push, 8 )
#pragma warning(push,3)
#pragma warning(disable: 4455 4494 4619 4643 4702 4984 4988 )
#line 21
namespace std { 
#line 29 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
namespace experimental { 
#line 31
namespace filesystem { 
#line 33
inline namespace v1 { 
#line 35
class path; 
#line 36
}}}
#line 38
extern FILE *__cdecl _Fiopen(const char *, ios_base::openmode, int); 
#line 41
extern FILE *__cdecl _Fiopen(const __wchar_t *, ios_base::openmode, int); 
#line 46
extern FILE *__cdecl _Fiopen(const unsigned short *, ios_base::openmode, int); 
#line 52 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem > inline
 bool _Fgetc ( _Elem & _Ch, FILE * _File )
 {
 return ( :: fread ( & _Ch, sizeof ( _Elem ), 1, _File ) == 1 );
 }
#line 58
template<> inline bool _Fgetc(char &_Byte, FILE *_File) 
#line 59
{ 
#line 60
int _Meta; 
#line 61
if ((_Meta = ::fgetc(_File)) == (-1)) { 
#line 62
return false; } else 
#line 64
{ 
#line 65
_Byte = ((char)_Meta); 
#line 66
return true; 
#line 67
}  
#line 68
} 
#line 70
template<> inline bool _Fgetc(__wchar_t &_Wchar, FILE *_File) 
#line 71
{ 
#line 72
wint_t _Meta; 
#line 73
if ((_Meta = ::fgetwc(_File)) == ((wint_t)65535)) { 
#line 74
return false; } else 
#line 76
{ 
#line 77
_Wchar = ((__wchar_t)_Meta); 
#line 78
return true; 
#line 79
}  
#line 80
} 
#line 83
template<> inline bool _Fgetc(unsigned short &_Wchar, FILE *_File) 
#line 84
{ 
#line 85
wint_t _Meta; 
#line 86
if ((_Meta = ::fgetwc(_File)) == ((wint_t)65535)) { 
#line 87
return false; } else 
#line 89
{ 
#line 90
_Wchar = ((unsigned short)_Meta); 
#line 91
return true; 
#line 92
}  
#line 93
} 
#line 97 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem > inline
 bool _Fputc ( _Elem _Ch, FILE * _File )
 {
 return ( :: fwrite ( & _Ch, 1, sizeof ( _Elem ), _File ) == sizeof ( _Elem ) );
 }
#line 103
template<> inline bool _Fputc(char _Byte, FILE *_File) 
#line 104
{ 
#line 105
return ::fputc(_Byte, _File) != (-1); 
#line 106
} 
#line 108
template<> inline bool _Fputc(__wchar_t _Wchar, FILE *_File) 
#line 109
{ 
#line 110
return (::fputwc(_Wchar, _File)) != ((wint_t)65535); 
#line 111
} 
#line 114
template<> inline bool _Fputc(unsigned short _Wchar, FILE *_File) 
#line 115
{ 
#line 116
return (::fputwc(_Wchar, _File)) != ((wint_t)65535); 
#line 117
} 
#line 121 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem > inline
 bool _Ungetc ( const _Elem &, FILE * )
 {
 return ( false );
 }
#line 127
template<> inline bool _Ungetc(const char &_Byte, FILE *_File) 
#line 128
{ 
#line 129
return ::ungetc((unsigned char)_Byte, _File) != (-1); 
#line 130
} 
#line 132
template<> inline bool _Ungetc(const signed char &_Byte, FILE *_File) 
#line 133
{ 
#line 134
return ::ungetc((unsigned char)_Byte, _File) != (-1); 
#line 135
} 
#line 137
template<> inline bool _Ungetc(const unsigned char &_Byte, FILE *_File) 
#line 138
{ 
#line 139
return ::ungetc(_Byte, _File) != (-1); 
#line 140
} 
#line 142
template<> inline bool _Ungetc(const __wchar_t &_Wchar, FILE *_File) 
#line 143
{ 
#line 144
return (::ungetwc(_Wchar, _File)) != ((wint_t)65535); 
#line 145
} 
#line 148
template<> inline bool _Ungetc(const unsigned short &_Wchar, FILE *_File) 
#line 149
{ 
#line 150
return (::ungetwc(_Wchar, _File)) != ((wint_t)65535); 
#line 151
} 
#line 155 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem,
 class _Traits >
 class basic_filebuf
  : public basic_streambuf < _Elem, _Traits >
 {
public :
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef typename _Traits :: state_type _Myst;
 typedef codecvt < _Elem, char, typename _Traits :: state_type > _Cvt;

 basic_filebuf ( FILE * _File = nullptr )
  : _Mysb ( )
  {
  _Init ( _File, _Newfl );
  }

 virtual ~ basic_filebuf ( ) noexcept
  {
  if ( _Myfile != nullptr )
   _Reset_back ( );
  if ( _Closef )
   close ( );
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 basic_filebuf ( _Uninitialized )
  : _Mysb ( _Noinit )
  {
  }

 basic_filebuf ( basic_filebuf && _Right )
  {
  _Init ( _Right . _Myfile, _Newfl );
  _Init ( static_cast < FILE * > ( nullptr ), _Closefl );
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_filebuf & operator = ( basic_filebuf && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_filebuf && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_filebuf & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {

   FILE * _Myfile_sav = _Myfile;
   const _Cvt * _Pcvt_sav = _Pcvt;
   typename _Traits :: state_type _State_sav = _State;
   bool _Wrotesome_sav = _Wrotesome;
   bool _Closef_sav = _Closef;
   bool _Set_eback_sav = _Mysb :: eback ( ) == & _Mychar;
   bool _Set_eback_live = _Mysb :: gptr ( ) == & _Mychar;

   _Elem * _Pfirst0 = _Mysb :: pbase ( );
   _Elem * _Pnext0 = _Mysb :: pptr ( );
   _Elem * _Pend = _Mysb :: epptr ( );
   _Elem * _Gfirst0 = _Mysb :: eback ( );
   _Elem * _Gnext0 = _Mysb :: gptr ( );
   _Elem * _Gend = _Mysb :: egptr ( );


   _Init ( _Right . _Myfile, _Right . _Myfile != nullptr ? _Openfl : _Newfl );
   _Mysb :: setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   if ( _Right . eback ( ) != & _Right . _Mychar )
    _Mysb :: setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   else if ( _Right . gptr ( ) != & _Right . _Mychar )
    _Mysb :: setg ( & _Mychar, & _Mychar + 1, & _Mychar + 1 );
   else
    _Mysb :: setg ( & _Mychar, & _Mychar, & _Mychar + 1 );

   _Pcvt = _Right . _Pcvt;
   _State = _Right . _State;
   _Wrotesome = _Right . _Wrotesome;
   _Closef = _Right . _Closef;


   _Right . _Init ( _Myfile_sav, _Myfile_sav != nullptr ? _Openfl : _Newfl );
   _Right . setp ( _Pfirst0, _Pnext0, _Pend );
   if ( ! _Set_eback_sav )
    _Right . setg ( _Gfirst0, _Gnext0, _Gend );
   else if ( ! _Set_eback_live )
    _Right . setg ( & _Right . _Mychar, & _Right . _Mychar + 1,
     & _Right . _Mychar + 1 );
   else
    _Right . setg ( & _Right . _Mychar, & _Right . _Mychar,
     & _Right . _Mychar + 1 );

   _Right . _Pcvt = _Pcvt_sav;
   _Right . _State = _State_sav;
   _Right . _Wrotesome = _Wrotesome_sav;
   _Right . _Closef = _Closef_sav;


   :: std :: swap ( _Set_eback, _Right . _Set_eback );
   :: std :: swap ( _Set_egptr, _Right . _Set_egptr );

   :: std :: swap ( _Mychar, _Right . _Mychar );
   :: std :: swap ( _Mysb :: _Plocale, _Right . _Plocale );
   }
  }

 basic_filebuf ( const basic_filebuf & ) = delete;
 basic_filebuf & operator = ( const basic_filebuf & ) = delete;

 enum _Initfl
  {
  _Newfl, _Openfl, _Closefl };

  bool is_open ( ) const
  {
  return ( _Myfile != nullptr );
  }

 basic_filebuf * open ( const char * _Filename,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  FILE * _File;
  if ( _Myfile != nullptr || ( _File = _Fiopen ( _Filename, _Mode, _Prot ) ) == nullptr )
   return ( nullptr );

  _Init ( _File, _Openfl );
  _Initcvt ( :: std :: use_facet < _Cvt > ( _Mysb :: getloc ( ) ) );
  return ( this );
  }

 basic_filebuf * open ( const string & _Str,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  return ( open ( _Str . c_str ( ), _Mode, _Prot ) );
  }


 basic_filebuf * open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  return ( open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) ) );
  }


 basic_filebuf * open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  FILE * _File;
  if ( _Myfile != nullptr || ( _File = _Fiopen ( _Filename, _Mode, _Prot ) ) == nullptr )
   return ( nullptr );

  _Init ( _File, _Openfl );
  _Initcvt ( :: std :: use_facet < _Cvt > ( _Mysb :: getloc ( ) ) );
  return ( this );
  }

 basic_filebuf * open ( const wstring & _Str,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  return ( open ( _Str . c_str ( ), _Mode, _Prot ) );
  }

 template < class _Path_ish = experimental :: filesystem :: path >
  basic_filebuf * open ( const _Identity_t < _Path_ish > & _Path,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  return ( open ( _Path . c_str ( ), _Mode, _Prot ) );
  }













 basic_filebuf * open ( const wchar_t * _Filename, ios_base :: open_mode _Mode )
  {
  return ( open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) ) );
  }



 basic_filebuf * open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  FILE * _File;
  if ( _Myfile != nullptr || ( _File = _Fiopen ( _Filename, _Mode, _Prot ) ) == nullptr )
   return ( nullptr );

  _Init ( _File, _Openfl );
  _Initcvt ( :: std :: use_facet < _Cvt > ( _Mysb :: getloc ( ) ) );
  return ( this );
  }


 basic_filebuf * open ( const unsigned short * _Filename, ios_base :: open_mode _Mode )
  {
  return ( open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) ) );
  }



 basic_filebuf * close ( )
  {
  basic_filebuf * _Ans = this;
  if ( _Myfile == nullptr )
   _Ans = nullptr;
  else
   {
   if ( ! _Endwrite ( ) )
    _Ans = nullptr;
   if ( :: fclose ( _Myfile ) != 0 )
    _Ans = nullptr;
   }
  _Init ( nullptr, _Closefl );
  return ( _Ans );
  }

 virtual void _Lock ( )
  {
  if ( _Myfile )
   :: _lock_file ( _Myfile );
  }

 virtual void _Unlock ( )
  {
  if ( _Myfile )
   :: _unlock_file ( _Myfile );
  }

protected :
 virtual int_type overflow ( int_type _Meta = _Traits :: eof ( ) )
  {
  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   {
   return ( _Traits :: not_eof ( _Meta ) );
   }

  if ( _Mysb :: pptr ( ) != nullptr && _Mysb :: pptr ( ) < _Mysb :: epptr ( ) )
   {
   * _Mysb :: _Pninc ( ) = _Traits :: to_char_type ( _Meta );
   return ( _Meta );
   }

  if ( _Myfile == nullptr )
   {
   return ( _Traits :: eof ( ) );
   }

  _Reset_back ( );
  if ( _Pcvt == nullptr )
   {
   return ( _Fputc ( _Traits :: to_char_type ( _Meta ), _Myfile ) ? _Meta : _Traits :: eof ( ) );
   }


  constexpr size_t _Codecvt_temp_buf = 32;
  char _Str [ _Codecvt_temp_buf ];
  const _Elem _Ch = _Traits :: to_char_type ( _Meta );
  const _Elem * _Src;
  char * _Dest;
  switch ( _Pcvt -> out ( _State, & _Ch, & _Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest ) )
   {
   case codecvt_base :: partial :
   case codecvt_base :: ok :
    {
    const auto _Count = static_cast < size_t > ( _Dest - _Str );
    if ( 0 < _Count && _Count != static_cast < size_t > ( :: fwrite ( _Str, 1, _Count, _Myfile ) ) )
     {
     return ( _Traits :: eof ( ) );
     }

    _Wrotesome = true;
    if ( _Src != & _Ch )
     {
     return ( _Meta );
     }

    return ( _Traits :: eof ( ) );
    }

   case codecvt_base :: noconv :

    return ( _Fputc ( _Ch, _Myfile ) ? _Meta : _Traits :: eof ( ) );

   default :
    return ( _Traits :: eof ( ) );
   }
  }

 virtual int_type pbackfail ( int_type _Meta =
  _Traits :: eof ( ) )
  {
  if ( _Mysb :: gptr ( ) != nullptr
   && _Mysb :: eback ( ) < _Mysb :: gptr ( )
   && ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
   || _Traits :: eq_int_type ( _Traits :: to_int_type ( _Mysb :: gptr ( ) [ - 1 ] ),
    _Meta ) ) )
   {
   _Mysb :: _Gndec ( );
   return ( _Traits :: not_eof ( _Meta ) );
   }
  else if ( _Myfile == nullptr || _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   return ( _Traits :: eof ( ) );
  else if ( _Pcvt == nullptr && _Ungetc ( _Traits :: to_char_type ( _Meta ), _Myfile ) )
   return ( _Meta );
  else if ( _Mysb :: gptr ( ) != & _Mychar )
   {
   _Mychar = _Traits :: to_char_type ( _Meta );
   _Set_back ( );
   return ( _Meta );
   }
  else
   return ( _Traits :: eof ( ) );
 }

 virtual int_type underflow ( )
  {
  int_type _Meta;
  if ( _Mysb :: gptr ( ) != nullptr
   && _Mysb :: gptr ( ) < _Mysb :: egptr ( ) )
   return ( _Traits :: to_int_type ( * _Mysb :: gptr ( ) ) );
  else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = uflow ( ) ) )
   return ( _Meta );
  else
   {
   pbackfail ( _Meta );
   return ( _Meta );
   }
  }

 virtual int_type uflow ( )
  {
  if ( _Mysb :: gptr ( ) != nullptr && _Mysb :: gptr ( ) < _Mysb :: egptr ( ) )
   {
   return ( _Traits :: to_int_type ( * _Mysb :: _Gninc ( ) ) );
   }

  if ( _Myfile == nullptr )
   {
   return ( _Traits :: eof ( ) );
   }

  _Reset_back ( );
  if ( _Pcvt == nullptr )
   {
   _Elem _Ch;
   return ( _Fgetc ( _Ch, _Myfile ) ? _Traits :: to_int_type ( _Ch ) : _Traits :: eof ( ) );
   }


  string _Str;

  for (;; )
   {
   const char * _Src;
   int _Meta = :: fgetc ( _Myfile );

   if ( _Meta == ( - 1 ) )
    {
    return ( _Traits :: eof ( ) );
    }

   _Str . push_back ( static_cast < char > ( _Meta ) );

   _Elem _Ch;
   _Elem * _Dest;
   switch ( _Pcvt -> in ( _State, _Str . data ( ), _Str . data ( ) + _Str . size ( ), _Src, & _Ch, & _Ch + 1, _Dest ) )
    {
    case codecvt_base :: partial :
    case codecvt_base :: ok :
     if ( _Dest != & _Ch )
      {
      auto _Nleft = _Str . data ( ) + _Str . size ( ) - _Src;
      while ( 0 < _Nleft )
       {
       :: ungetc ( _Src [ -- _Nleft ], _Myfile );
       }

      return ( _Traits :: to_int_type ( _Ch ) );
      }

     _Str . erase ( 0, static_cast < size_t > ( _Src - _Str . data ( ) ) );
     break;

    case codecvt_base :: noconv :

     return ( static_cast < int_type > ( _Str . front ( ) ) );

    default :
     return ( _Traits :: eof ( ) );
    }
   }
  }

#pragma warning(push)
#pragma warning(disable: 4127)
 virtual streamsize xsgetn ( _Elem * _Ptr, streamsize _Count ) override
  {
  if ( sizeof ( _Elem ) == 1 )
   {
   if ( _Pcvt )
    {
    return ( _Mysb :: xsgetn ( _Ptr, _Count ) );
    }

   const streamsize _Start_count = _Count;
   streamsize _Size = _Mysb :: _Gnavail ( );
   if ( 0 < _Count && 0 < _Size )
    {
    if ( _Count < _Size )
     {
     _Size = _Count;
     }

    _Traits :: copy ( _Ptr, _Mysb :: gptr ( ), static_cast < size_t > ( _Size ) );
    _Ptr += _Size;
    _Count -= _Size;
    _Mysb :: gbump ( static_cast < int > ( _Size ) );
    }

   if ( 0 < _Count && _Myfile )
    {
    _Reset_back ( );
    _Count -= :: fread ( _Ptr, sizeof ( _Elem ), static_cast < size_t > ( _Count ), _Myfile );
    }

   return ( _Start_count - _Count );
   }
  else
   {
   return ( _Mysb :: xsgetn ( _Ptr, _Count ) );
   }
  }

 virtual streamsize xsputn ( const _Elem * _Ptr, streamsize _Count ) override
  {
  if ( sizeof ( _Elem ) == 1 )
   {
   if ( _Pcvt )
    {
    return ( _Mysb :: xsputn ( _Ptr, _Count ) );
    }

   const streamsize _Start_count = _Count;
   streamsize _Size = _Mysb :: _Pnavail ( );
   if ( 0 < _Count && 0 < _Size )
    {
    if ( _Count < _Size )
     {
     _Size = _Count;
     }

    _Traits :: copy ( _Mysb :: pptr ( ), _Ptr, static_cast < size_t > ( _Size ) );
    _Ptr += _Size;
    _Count -= _Size;
    _Mysb :: pbump ( static_cast < int > ( _Size ) );
    }

   if ( 0 < _Count && _Myfile )
    {
    _Count -= :: fwrite ( _Ptr, sizeof ( _Elem ), static_cast < size_t > ( _Count ), _Myfile );
    }

   return ( _Start_count - _Count );
   }
  else
   {
   return ( _Mysb :: xsputn ( _Ptr, _Count ) );
   }
  }
#pragma warning(pop)

 virtual pos_type seekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  fpos_t _Fileposition;

  if ( _Mysb :: gptr ( ) == & _Mychar
   && _Way == ios_base :: cur
   && _Pcvt == nullptr )
   {
   _Off -= static_cast < off_type > ( sizeof ( _Elem ) );
   }

  if ( _Myfile == nullptr || ! _Endwrite ( )
   || ( ( _Off != 0 || _Way != ios_base :: cur )
    && :: _fseeki64 ( _Myfile, _Off, _Way ) != 0 )
   || :: fgetpos ( _Myfile, & _Fileposition ) != 0 )
   {
   return ( pos_type ( - 1 ) );
   }

  _Reset_back ( );
  return ( pos_type ( _State, _Fileposition ) );
  }

 virtual pos_type seekpos ( pos_type _Pos, ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  off_type _Off = static_cast < off_type > ( _Pos );

  if ( _Myfile == nullptr || ! _Endwrite ( ) || :: fsetpos ( _Myfile, & _Off ) != 0 )
   {
   return ( pos_type ( - 1 ) );
   }

  _State = _Pos . state ( );
  _Reset_back ( );
  return ( pos_type ( _State, _Off ) );
  }

 virtual _Mysb * setbuf ( _Elem * _Buffer, streamsize _Count )
  {
  if ( _Myfile == nullptr || :: setvbuf ( _Myfile, ( char * ) _Buffer,
   _Buffer == nullptr && _Count == 0 ? 4 : 0,
   ( size_t ) _Count * sizeof ( _Elem ) ) != 0 )
   return ( nullptr );
  else
   {
   _Init ( _Myfile, _Openfl );
   return ( this );
   }
  }

 virtual int sync ( )
  {
  return ( _Myfile == nullptr
   || _Traits :: eq_int_type ( _Traits :: eof ( ), overflow ( ) )
   || 0 <= :: fflush ( _Myfile ) ? 0 : - 1 );
  }

 virtual void imbue ( const locale & _Loc )
  {
  _Initcvt ( :: std :: use_facet < _Cvt > ( _Loc ) );
  }

 void _Init ( FILE * _File, _Initfl _Which )
  {
   static _Myst _Stinit;

  _Closef = _Which == _Openfl;
  _Wrotesome = false;

  _Mysb :: _Init ( );

  if ( _File != nullptr && sizeof ( _Elem ) == 1 )
   {
   _Elem * * _Pb = nullptr;
   _Elem * * _Pn = nullptr;
   int * _Nr = nullptr;

   :: _get_stream_buffer_pointers (
    _File,
    reinterpret_cast < char * * * > ( & _Pb ),
    reinterpret_cast < char * * * > ( & _Pn ),
    & _Nr );
   int * _Nw = _Nr;

   _Mysb :: _Init ( _Pb, _Pn, _Nr, _Pb, _Pn, _Nw );
   }

  _Myfile = _File;
  _State = _Stinit;
  _Pcvt = nullptr;
  }

 bool _Endwrite ( )
  {
  if ( _Pcvt == nullptr || ! _Wrotesome )
   {
   return ( true );
   }


  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), overflow ( ) ) )
   {
   return ( false );
   }

  constexpr size_t _Codecvt_temp_buf = 32;
  char _Str [ _Codecvt_temp_buf ];
  char * _Dest;
  switch ( _Pcvt -> unshift ( _State, _Str, _Str + _Codecvt_temp_buf, _Dest ) )
   {
   case codecvt_base :: ok :
    _Wrotesome = false;

   case codecvt_base :: partial :
    {
    const auto _Count = static_cast < size_t > ( _Dest - _Str );
    if ( 0 < _Count && _Count != static_cast < size_t > ( :: fwrite ( _Str, 1, _Count, _Myfile ) ) )
     {
     return ( false );
     }

    return ( ! _Wrotesome );
    }

   case codecvt_base :: noconv :
    return ( true );

   default :
    return ( false );
   }
  }

 void _Initcvt ( const _Cvt & _Newcvt )
  {
  if ( _Newcvt . always_noconv ( ) )
   _Pcvt = nullptr;
  else
   {
   _Pcvt = :: std :: addressof ( _Newcvt );
   _Mysb :: _Init ( );
   }
  }

private :
 const _Cvt * _Pcvt;
 _Elem _Mychar;
 bool _Wrotesome;
 typename _Traits :: state_type _State;
 bool _Closef;
 FILE * _Myfile;

 void _Reset_back ( )
  {
  if ( _Mysb :: eback ( ) == & _Mychar )
   _Mysb :: setg ( _Set_eback, _Set_eback, _Set_egptr );
  }

 void _Set_back ( )
  {
  if ( _Mysb :: eback ( ) != & _Mychar )
   {
   _Set_eback = _Mysb :: eback ( );
   _Set_egptr = _Mysb :: egptr ( );
   }
  _Mysb :: setg ( & _Mychar, & _Mychar, & _Mychar + 1 );
  }

 _Elem * _Set_eback;
 _Elem * _Set_egptr;
 };
#line 822 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_filebuf < _Elem, _Traits > & _Left,
  basic_filebuf < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 831
template < class _Elem,
 class _Traits >
 class basic_ifstream
  : public basic_istream < _Elem, _Traits >
 {
public :
 typedef basic_istream < _Elem, _Traits > _Mybase;
 typedef basic_filebuf < _Elem, _Traits > _Myfb;
 typedef basic_ios < _Elem, _Traits > _Myios;

 basic_ifstream ( )
  : _Mybase ( & _Filebuffer )
  {
  }

 explicit basic_ifstream ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

 explicit basic_ifstream ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_ifstream ( _Str . c_str ( ), _Mode, _Prot )
  {
  }

 explicit basic_ifstream ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

 explicit basic_ifstream ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_ifstream ( _Str . c_str ( ), _Mode, _Prot )
  {
  }

 template < class _Path_ish = experimental :: filesystem :: path >
  explicit basic_ifstream ( const _Identity_t < _Path_ish > & _Path,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_ifstream ( _Path . c_str ( ), _Mode, _Prot )
  {
  }













 explicit basic_ifstream ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ifstream ( FILE * _File )
  : _Mybase ( & _Filebuffer ),
   _Filebuffer ( _File )
  {
  }

 basic_ifstream ( basic_ifstream && _Right )
  : _Mybase ( & _Filebuffer )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_ifstream & operator = ( basic_ifstream && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_ifstream && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Filebuffer . close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_ifstream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mybase :: swap ( _Right );
   _Filebuffer . swap ( _Right . _Filebuffer );
   }
  }

 basic_ifstream ( const basic_ifstream & ) = delete;
 basic_ifstream & operator = ( const basic_ifstream & ) = delete;

 void open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }

 template < class _Path_ish = experimental :: filesystem :: path >
  void open ( const _Identity_t < _Path_ish > & _Path,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Path . c_str ( ), _Mode, _Prot );
  }













 void open ( const wchar_t * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }



 void open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const unsigned short * _Filename,
  ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }



 virtual ~ basic_ifstream ( ) noexcept
  {
  }

  _Myfb * rdbuf ( ) const
  {
  return ( ( _Myfb * ) & _Filebuffer );
  }

  bool is_open ( ) const
  {
  return ( _Filebuffer . is_open ( ) );
  }

 void open ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: in, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }


 void close ( )
  {
  if ( _Filebuffer . close ( ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

private :
 _Myfb _Filebuffer;
 };
#line 1058 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ifstream < _Elem, _Traits > & _Left,
  basic_ifstream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 1067
template < class _Elem,
 class _Traits >
 class basic_ofstream
  : public basic_ostream < _Elem, _Traits >
 {
public :
 typedef basic_ostream < _Elem, _Traits > _Mybase;
 typedef basic_filebuf < _Elem, _Traits > _Myfb;
 typedef basic_ios < _Elem, _Traits > _Myios;

 basic_ofstream ( )
  : _Mybase ( & _Filebuffer )
  {
  }

 explicit basic_ofstream ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

 explicit basic_ofstream ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_ofstream ( _Str . c_str ( ), _Mode, _Prot )
  {
  }

 explicit basic_ofstream ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

 explicit basic_ofstream ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_ofstream ( _Str . c_str ( ), _Mode, _Prot )
  {
  }

 template < class _Path_ish = experimental :: filesystem :: path >
  explicit basic_ofstream ( const _Identity_t < _Path_ish > & _Path,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_ofstream ( _Path . c_str ( ), _Mode, _Prot )
  {
  }













 explicit basic_ofstream ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_ofstream ( FILE * _File )
  : _Mybase ( & _Filebuffer ),
   _Filebuffer ( _File )
  {
  }

 basic_ofstream ( basic_ofstream && _Right )
  : _Mybase ( & _Filebuffer )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_ofstream & operator = ( basic_ofstream && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_ofstream && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Filebuffer . close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_ofstream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mybase :: swap ( _Right );
   _Filebuffer . swap ( _Right . _Filebuffer );
   }
  }

 basic_ofstream ( const basic_ofstream & ) = delete;
 basic_ofstream & operator = ( const basic_ofstream & ) = delete;

 void open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }

 template < class _Path_ish = experimental :: filesystem :: path >
  void open ( const _Identity_t < _Path_ish > & _Path,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Path . c_str ( ), _Mode, _Prot );
  }













 void open ( const wchar_t * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }



 void open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const unsigned short * _Filename,
  ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }



 virtual ~ basic_ofstream ( ) noexcept
  {
  }

  _Myfb * rdbuf ( ) const
  {
  return ( ( _Myfb * ) & _Filebuffer );
  }

  bool is_open ( ) const
  {
  return ( _Filebuffer . is_open ( ) );
  }

 void open ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode | ios_base :: out, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }


 void close ( )
  {
  if ( _Filebuffer . close ( ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

private :
 _Myfb _Filebuffer;
 };
#line 1294 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_ofstream < _Elem, _Traits > & _Left,
  basic_ofstream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 1303
template < class _Elem,
 class _Traits >
 class basic_fstream
  : public basic_iostream < _Elem, _Traits >
 {
public :
 typedef basic_iostream < _Elem, _Traits > _Mybase;
 typedef basic_filebuf < _Elem, _Traits > _Myfb;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 basic_fstream ( )
  : _Mybase ( & _Filebuffer )
  {
  }

 explicit basic_fstream ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

 explicit basic_fstream ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_fstream ( _Str . c_str ( ), _Mode, _Prot )
  {
  }

 explicit basic_fstream ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  }

 explicit basic_fstream ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_fstream ( _Str . c_str ( ), _Mode, _Prot )
  {
  }

 template < class _Path_ish = experimental :: filesystem :: path >
  explicit basic_fstream ( const _Identity_t < _Path_ish > & _Path,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : basic_fstream ( _Path . c_str ( ), _Mode, _Prot )
  {
  }













 explicit basic_fstream ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  : _Mybase ( & _Filebuffer )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  }


 explicit basic_fstream ( FILE * _File )
  : _Mybase ( & _Filebuffer ),
   _Filebuffer ( _File )
  {
  }

 basic_fstream ( basic_fstream && _Right )
  : _Mybase ( & _Filebuffer )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  }

 basic_fstream & operator = ( basic_fstream && _Right )
  {
  _Assign_rv ( :: std :: move ( _Right ) );
  return ( * this );
  }

 void _Assign_rv ( basic_fstream && _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Filebuffer . close ( );
   this -> swap ( _Right );
   }
  }

 void swap ( basic_fstream & _Right )
  {
  if ( this != :: std :: addressof ( _Right ) )
   {
   _Mybase :: swap ( _Right );
   _Filebuffer . swap ( _Right . _Filebuffer );
   }
  }

 basic_fstream ( const basic_fstream & ) = delete;
 basic_fstream & operator = ( const basic_fstream & ) = delete;

 void open ( const wchar_t * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const wstring & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }

 template < class _Path_ish = experimental :: filesystem :: path >
  void open ( const _Identity_t < _Path_ish > & _Path,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Path . c_str ( ), _Mode, _Prot );
  }













 void open ( const wchar_t * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }



 void open ( const unsigned short * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == 0 )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }


 void open ( const unsigned short * _Filename,
  ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }



 virtual ~ basic_fstream ( ) noexcept
  {
  }

  _Myfb * rdbuf ( ) const
  {
  return ( ( _Myfb * ) & _Filebuffer );
  }

  bool is_open ( ) const
  {
  return ( _Filebuffer . is_open ( ) );
  }

 void open ( const char * _Filename,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  if ( _Filebuffer . open ( _Filename, _Mode, _Prot ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
  else
   _Myios :: clear ( );
  }

 void open ( const string & _Str,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out,
  int _Prot = ( int ) ios_base :: _Openprot )
  {
  open ( _Str . c_str ( ), _Mode, _Prot );
  }


 void open ( const char * _Filename, ios_base :: open_mode _Mode )
  {
  open ( _Filename, static_cast < ios_base :: openmode > ( _Mode ) );
  }


 void close ( )
  {
  if ( _Filebuffer . close ( ) == nullptr )
   _Myios :: setstate ( ios_base :: failbit );
 }

private :
 _Myfb _Filebuffer;
 };
#line 1535 "C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.16.27023\\include\\fstream"
template < class _Elem,
 class _Traits > inline
 void swap ( basic_fstream < _Elem, _Traits > & _Left,
  basic_fstream < _Elem, _Traits > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 1542
}
#line 1546
#pragma warning(pop)
#pragma pack ( pop )
#line 112 "e:\\workspace\\singleprec\\pyneurogpu_win2\\neurogpu6\\Util.h"
typedef 
#line 70 "e:\\workspace\\singleprec\\pyneurogpu_win2\\neurogpu6\\Util.h"
struct { 
#line 71
double *e; 
#line 72
double *f; 
#line 73
short N; 
#line 75
short *Ks; 
#line 76
double *Cms; 
#line 77
short NModels; 
#line 78
short NComps; 
#line 79
short *boolModel; 
#line 81
short Depth; 
#line 82
short LognDepth; 
#line 83
short nFathers; 
#line 84
short nCallForFather; 
#line 85
short *Fathers; 
#line 87
short *SonNoVec; 
#line 89
short *RelStarts; 
#line 90
short *RelEnds; 
#line 91
short *RelVec; 
#line 92
short *SegStartI; 
#line 93
short *SegEndI; 
#line 94
short *SegToComp; 
#line 95
short *MidComps; 
#line 97
short *FIdxs; 
#line 100 "e:\\workspace\\singleprec\\pyneurogpu_win2\\neurogpu6\\Util.h"
short *CompByLevel32; 
#line 101
short *CompByFLevel32; 
#line 102
short nLRel; 
#line 103
short *LRelStarts; 
#line 104
short *LRelEnds; 
#line 105
short nFLRel; 
#line 106
short *FLRelStarts; 
#line 107
short *FLRelEnds; 
#line 112
} HMat; 
#line 126
typedef 
#line 115
struct { 
#line 116
short NStimuli; 
#line 117
short loc; 
#line 118
short comp; 
#line 119
short numofdts; 
#line 120
double area; 
#line 121
short *dtInds; 
#line 122
double *amps; 
#line 123
double *durs; 
#line 124
double *dels; 
#line 125
double Nt; 
#line 126
} Stim; 
#line 137
typedef 
#line 130
struct { 
#line 131
double *Vs; 
#line 132
double dt; 
#line 133
double TFinal; 
#line 134
double Celsius; 
#line 135
short NRecSites; 
#line 136
short *RecSites; 
#line 137
} Sim; 
#line 140
void RunByModelSerial(); 
#line 141
void RunByModelP(); 
#line 142
void freeRunByModelP(); 
#line 144
void solveByNeuron(const HMat & InMat, double * B, double * D); 
#line 145
double maxf(double a, double b); 
#line 146
double MaxAbsDiffVec(double * A, double * B, int n); 
#line 148
void CopyVec(double * A, double * B, int n); 
#line 149
void CopyVecTwoTypes(double * B, double * A, int n); 
#line 150
void FlipVec(double * A, double * B, int n); 
#line 151
void CompareArrays(const double * App, const double * Real, int n, char * Prefix); 
#line 152
double diffclock(clock_t clock1, clock_t clock2); 
#line 157 "e:\\workspace\\singleprec\\pyneurogpu_win2\\neurogpu6\\Util.h"
void ReadSerialNeuronData(const char * FN, HMat & TheMat); 
#line 158
void ReadParallelNeuronData(const char * FN, HMat & TheMat, short * CompDepth, short * CompFDepth); 
#line 159
void FreeSerialNeuronData(HMat & InMat); 
#line 160
void ReadStimData(const char * FN, Stim & stim, short Nx); 
#line 161
void CreateStimData(Stim & stim); 
#line 162
void ReadSimData(const char * FN, short N, Sim & sim); 
#line 163
void ReadStimFromFile(const char * FN, Stim & stim); 
#line 164
void ReadCSVStim(Stim & stim); 
#line 165
void FreeStimData(Stim & stim); 
#line 166
void FreeSimData(Sim & sim); 
#line 168
void SaveArrayToFile(const char * FN, const int N, const double * Arr); 
#line 169
void SaveVHots(const char * FN, double ** VHotsHost, short Nt, short NStimuli); 
#line 170
void ReadDebugData(const char * FN, double ** DebugData, short Nsegs, short Nt); 
#line 171
void ReadRHSData(const char * FN, double ** DebugData, short Nsegs, short Nt); 
#line 172
void ReadDData(const char * FN, double ** DebugData, short Nsegs, short Nt); 
#line 173
void SetStatesFromDebug(double ** StatesM, double ** DebugData, short i, short N); 
#line 174
void SetRHSFromNeuron(double * rhs, double ** DebugData, short i, short N); 
#line 175
void SetDFromNeuron(double * D, double ** DebugData, short i, short N); 
#line 176
void ReadVData(const char * FN, double ** DebugData, short Nsegs, short Nt); 
#line 177
void SetVFromNeuron(double * vs, double ** DebugData, short i, short N); 
#line 178
void debugPrintMYFTYPE(double * A, short N, FILE * fdebug); 
#line 179
void debugPrintMYSECONDFTYPE(double * A, short N, FILE * fdebug); 
#line 180
void ReadShortFromCSV(char * line, short * ans, int n); 
#line 181
void ReadDoubleFromCSV(char * line, double * ans, int n); 
#line 182
void ReadFloatFromCSV(char * line, double * ans, int n); 
#line 183
double *ReadAllParams(const char * FN, short NParams, short Nx, int & ntemp); 
#line 184
double *ReadInitStates(const char * FN, short NSTATES, short Nx, short Nsets); 
#line 185
int *checkPeerAccess(int & np2p); 
#line 186
void enablePeerAccess(int * p2pCapableGPUs, int np2p); 
#line 187
double *transposeMat(double * Arr, short width, short length); 
#line 72 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuComplex.h"
extern "C" {
#line 77 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuComplex.h"
typedef float2 cuFloatComplex; 
#line 79
static __inline float cuCrealf(cuFloatComplex x) 
#line 80
{ 
#line 81
return x.x; 
#line 82
} 
#line 84
static __inline float cuCimagf(cuFloatComplex x) 
#line 85
{ 
#line 86
return x.y; 
#line 87
} 
#line 89
static __inline cuFloatComplex make_cuFloatComplex(float 
#line 90
r, float i) 
#line 91
{ 
#line 92
cuFloatComplex res; 
#line 93
(res.x) = r; 
#line 94
(res.y) = i; 
#line 95
return res; 
#line 96
} 
#line 98
static __inline cuFloatComplex cuConjf(cuFloatComplex x) 
#line 99
{ 
#line 100
return make_cuFloatComplex(cuCrealf(x), -cuCimagf(x)); 
#line 101
} 
#line 102
static __inline cuFloatComplex cuCaddf(cuFloatComplex x, cuFloatComplex 
#line 103
y) 
#line 104
{ 
#line 105
return make_cuFloatComplex(cuCrealf(x) + cuCrealf(y), cuCimagf(x) + cuCimagf(y)); 
#line 107
} 
#line 109
static __inline cuFloatComplex cuCsubf(cuFloatComplex x, cuFloatComplex 
#line 110
y) 
#line 111
{ 
#line 112
return make_cuFloatComplex(cuCrealf(x) - cuCrealf(y), cuCimagf(x) - cuCimagf(y)); 
#line 114
} 
#line 121
static __inline cuFloatComplex cuCmulf(cuFloatComplex x, cuFloatComplex 
#line 122
y) 
#line 123
{ 
#line 124
cuFloatComplex prod; 
#line 125
prod = make_cuFloatComplex((cuCrealf(x) * cuCrealf(y)) - (cuCimagf(x) * cuCimagf(y)), (cuCrealf(x) * cuCimagf(y)) + (cuCimagf(x) * cuCrealf(y))); 
#line 129
return prod; 
#line 130
} 
#line 137
static __inline cuFloatComplex cuCdivf(cuFloatComplex x, cuFloatComplex 
#line 138
y) 
#line 139
{ 
#line 140
cuFloatComplex quot; 
#line 141
float s = fabsf(cuCrealf(y)) + fabsf(cuCimagf(y)); 
#line 142
float oos = (1.0F) / s; 
#line 143
float ars = cuCrealf(x) * oos; 
#line 144
float ais = cuCimagf(x) * oos; 
#line 145
float brs = cuCrealf(y) * oos; 
#line 146
float bis = cuCimagf(y) * oos; 
#line 147
s = ((brs * brs) + (bis * bis)); 
#line 148
oos = ((1.0F) / s); 
#line 149
quot = make_cuFloatComplex(((ars * brs) + (ais * bis)) * oos, ((ais * brs) - (ars * bis)) * oos); 
#line 151
return quot; 
#line 152
} 
#line 162
static __inline float cuCabsf(cuFloatComplex x) 
#line 163
{ 
#line 164
float a = cuCrealf(x); 
#line 165
float b = cuCimagf(x); 
#line 166
float v, w, t; 
#line 167
a = fabsf(a); 
#line 168
b = fabsf(b); 
#line 169
if (a > b) { 
#line 170
v = a; 
#line 171
w = b; 
#line 172
} else { 
#line 173
v = b; 
#line 174
w = a; 
#line 175
}  
#line 176
t = (w / v); 
#line 177
t = ((1.0F) + (t * t)); 
#line 178
t = (v * sqrtf(t)); 
#line 179
if (((v == (0.0F)) || (v > (3.402823466e+38F))) || (w > (3.402823466e+38F))) { 
#line 180
t = (v + w); 
#line 181
}  
#line 182
return t; 
#line 183
} 
#line 186
typedef double2 cuDoubleComplex; 
#line 188
static __inline double cuCreal(cuDoubleComplex x) 
#line 189
{ 
#line 190
return x.x; 
#line 191
} 
#line 193
static __inline double cuCimag(cuDoubleComplex x) 
#line 194
{ 
#line 195
return x.y; 
#line 196
} 
#line 198
static __inline cuDoubleComplex make_cuDoubleComplex(double 
#line 199
r, double i) 
#line 200
{ 
#line 201
cuDoubleComplex res; 
#line 202
(res.x) = r; 
#line 203
(res.y) = i; 
#line 204
return res; 
#line 205
} 
#line 207
static __inline cuDoubleComplex cuConj(cuDoubleComplex x) 
#line 208
{ 
#line 209
return make_cuDoubleComplex(cuCreal(x), -cuCimag(x)); 
#line 210
} 
#line 212
static __inline cuDoubleComplex cuCadd(cuDoubleComplex x, cuDoubleComplex 
#line 213
y) 
#line 214
{ 
#line 215
return make_cuDoubleComplex(cuCreal(x) + cuCreal(y), cuCimag(x) + cuCimag(y)); 
#line 217
} 
#line 219
static __inline cuDoubleComplex cuCsub(cuDoubleComplex x, cuDoubleComplex 
#line 220
y) 
#line 221
{ 
#line 222
return make_cuDoubleComplex(cuCreal(x) - cuCreal(y), cuCimag(x) - cuCimag(y)); 
#line 224
} 
#line 231
static __inline cuDoubleComplex cuCmul(cuDoubleComplex x, cuDoubleComplex 
#line 232
y) 
#line 233
{ 
#line 234
cuDoubleComplex prod; 
#line 235
prod = make_cuDoubleComplex((cuCreal(x) * cuCreal(y)) - (cuCimag(x) * cuCimag(y)), (cuCreal(x) * cuCimag(y)) + (cuCimag(x) * cuCreal(y))); 
#line 239
return prod; 
#line 240
} 
#line 247
static __inline cuDoubleComplex cuCdiv(cuDoubleComplex x, cuDoubleComplex 
#line 248
y) 
#line 249
{ 
#line 250
cuDoubleComplex quot; 
#line 251
double s = fabs(cuCreal(y)) + fabs(cuCimag(y)); 
#line 252
double oos = (1.0) / s; 
#line 253
double ars = cuCreal(x) * oos; 
#line 254
double ais = cuCimag(x) * oos; 
#line 255
double brs = cuCreal(y) * oos; 
#line 256
double bis = cuCimag(y) * oos; 
#line 257
s = ((brs * brs) + (bis * bis)); 
#line 258
oos = ((1.0) / s); 
#line 259
quot = make_cuDoubleComplex(((ars * brs) + (ais * bis)) * oos, ((ais * brs) - (ars * bis)) * oos); 
#line 261
return quot; 
#line 262
} 
#line 270
static __inline double cuCabs(cuDoubleComplex x) 
#line 271
{ 
#line 272
double a = cuCreal(x); 
#line 273
double b = cuCimag(x); 
#line 274
double v, w, t; 
#line 275
a = fabs(a); 
#line 276
b = fabs(b); 
#line 277
if (a > b) { 
#line 278
v = a; 
#line 279
w = b; 
#line 280
} else { 
#line 281
v = b; 
#line 282
w = a; 
#line 283
}  
#line 284
t = (w / v); 
#line 285
t = ((1.0) + (t * t)); 
#line 286
t = (v * sqrt(t)); 
#line 287
if (((v == (0.0)) || (v > (1.797693134862315708e+308))) || (w > (1.797693134862315708e+308))) 
#line 288
{ 
#line 289
t = (v + w); 
#line 290
}  
#line 291
return t; 
#line 292
} 
#line 295
}
#line 299 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuComplex.h"
typedef cuFloatComplex cuComplex; 
#line 300
static __inline cuComplex make_cuComplex(float x, float 
#line 301
y) 
#line 302
{ 
#line 303
return make_cuFloatComplex(x, y); 
#line 304
} 
#line 307
static __inline cuDoubleComplex cuComplexFloatToDouble(cuFloatComplex 
#line 308
c) 
#line 309
{ 
#line 310
return make_cuDoubleComplex((double)cuCrealf(c), (double)cuCimagf(c)); 
#line 311
} 
#line 313
static __inline cuFloatComplex cuComplexDoubleToFloat(cuDoubleComplex 
#line 314
c) 
#line 315
{ 
#line 316
return make_cuFloatComplex((float)cuCreal(c), (float)cuCimag(c)); 
#line 317
} 
#line 320
static __inline cuComplex cuCfmaf(cuComplex x, cuComplex y, cuComplex d) 
#line 321
{ 
#line 322
float real_res; 
#line 323
float imag_res; 
#line 325
real_res = ((cuCrealf(x) * cuCrealf(y)) + cuCrealf(d)); 
#line 326
imag_res = ((cuCrealf(x) * cuCimagf(y)) + cuCimagf(d)); 
#line 328
real_res = ((-(cuCimagf(x) * cuCimagf(y))) + real_res); 
#line 329
imag_res = ((cuCimagf(x) * cuCrealf(y)) + imag_res); 
#line 331
return make_cuComplex(real_res, imag_res); 
#line 332
} 
#line 334
static __inline cuDoubleComplex cuCfma(cuDoubleComplex x, cuDoubleComplex y, cuDoubleComplex d) 
#line 335
{ 
#line 336
double real_res; 
#line 337
double imag_res; 
#line 339
real_res = ((cuCreal(x) * cuCreal(y)) + cuCreal(d)); 
#line 340
imag_res = ((cuCreal(x) * cuCimag(y)) + cuCimag(d)); 
#line 342
real_res = ((-(cuCimag(x) * cuCimag(y))) + real_res); 
#line 343
imag_res = ((cuCimag(x) * cuCreal(y)) + imag_res); 
#line 345
return make_cuDoubleComplex(real_res, imag_res); 
#line 346
} 
#line 129 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_fp16.h"
struct __half; 
#line 140
struct __half2; 
#line 155
static __inline __half __float2half(const float a); 
#line 169
static __inline __half __float2half_rn(const float a); 
#line 183
static __inline __half __float2half_rz(const float a); 
#line 198
static __inline __half __float2half_rd(const float a); 
#line 213
static __inline __half __float2half_ru(const float a); 
#line 227
static __inline float __half2float(const __half a); 
#line 244
static __inline __half2 __float2half2_rn(const float a); 
#line 264
static __inline __half2 __floats2half2_rn(const float a, const float b); 
#line 279
static __inline float __low2float(const __half2 a); 
#line 294
static __inline float __high2float(const __half2 a); 
#line 315
static __inline __half2 __float22half2_rn(const float2 a); 
#line 330
static __inline float2 __half22float2(const __half2 a); 
#line 345
static __inline int __half2int_rn(__half h); 
#line 360
static __inline int __half2int_rz(__half h); 
#line 375
static __inline int __half2int_rd(__half h); 
#line 390
static __inline int __half2int_ru(__half h); 
#line 406
static __inline __half __int2half_rn(int i); 
#line 421
static __inline __half __int2half_rz(int i); 
#line 436
static __inline __half __int2half_rd(int i); 
#line 451
static __inline __half __int2half_ru(int i); 
#line 468
static __inline short __half2short_rn(__half h); 
#line 483
static __inline short __half2short_rz(__half h); 
#line 498
static __inline short __half2short_rd(__half h); 
#line 513
static __inline short __half2short_ru(__half h); 
#line 530
static __inline __half __short2half_rn(short i); 
#line 545
static __inline __half __short2half_rz(short i); 
#line 560
static __inline __half __short2half_rd(short i); 
#line 575
static __inline __half __short2half_ru(short i); 
#line 591
static __inline unsigned __half2uint_rn(__half h); 
#line 606
static __inline unsigned __half2uint_rz(__half h); 
#line 621
static __inline unsigned __half2uint_rd(__half h); 
#line 636
static __inline unsigned __half2uint_ru(__half h); 
#line 652
static __inline __half __uint2half_rn(unsigned i); 
#line 667
static __inline __half __uint2half_rz(unsigned i); 
#line 682
static __inline __half __uint2half_rd(unsigned i); 
#line 697
static __inline __half __uint2half_ru(unsigned i); 
#line 714
static __inline unsigned short __half2ushort_rn(__half h); 
#line 730
static __inline unsigned short __half2ushort_rz(__half h); 
#line 743
static __inline unsigned short __half2ushort_rd(__half h); 
#line 756
static __inline unsigned short __half2ushort_ru(__half h); 
#line 773
static __inline __half __ushort2half_rn(unsigned short i); 
#line 789
static __inline __half __ushort2half_rz(unsigned short i); 
#line 804
static __inline __half __ushort2half_rd(unsigned short i); 
#line 819
static __inline __half __ushort2half_ru(unsigned short i); 
#line 836
static __inline unsigned __int64 __half2ull_rn(__half h); 
#line 852
static __inline unsigned __int64 __half2ull_rz(__half h); 
#line 867
static __inline unsigned __int64 __half2ull_rd(__half h); 
#line 882
static __inline unsigned __int64 __half2ull_ru(__half h); 
#line 899
static __inline __half __ull2half_rn(unsigned __int64 i); 
#line 915
static __inline __half __ull2half_rz(unsigned __int64 i); 
#line 930
static __inline __half __ull2half_rd(unsigned __int64 i); 
#line 945
static __inline __half __ull2half_ru(unsigned __int64 i); 
#line 962
static __inline __int64 __half2ll_rn(__half h); 
#line 977
static __inline __int64 __half2ll_rz(__half h); 
#line 992
static __inline __int64 __half2ll_rd(__half h); 
#line 1007
static __inline __int64 __half2ll_ru(__half h); 
#line 1024
static __inline __half __ll2half_rn(__int64 i); 
#line 1037
static __inline __half __ll2half_rz(__int64 i); 
#line 1052
static __inline __half __ll2half_rd(__int64 i); 
#line 1067
static __inline __half __ll2half_ru(__int64 i); 
#line 1083
static __inline __half htrunc(const __half h); 
#line 1097
static __inline __half hceil(const __half h); 
#line 1111
static __inline __half hfloor(const __half h); 
#line 1127
static __inline __half hrint(const __half h); 
#line 1143
static __inline __half2 h2trunc(const __half2 h); 
#line 1158
static __inline __half2 h2ceil(const __half2 h); 
#line 1173
static __inline __half2 h2floor(const __half2 h); 
#line 1190
static __inline __half2 h2rint(const __half2 h); 
#line 1206
static __inline __half2 __half2half2(const __half a); 
#line 1221
static __inline __half2 __lowhigh2highlow(const __half2 a); 
#line 1240
static __inline __half2 __lows2half2(const __half2 a, const __half2 b); 
#line 1259
static __inline __half2 __highs2half2(const __half2 a, const __half2 b); 
#line 1273
static __inline __half __high2half(const __half2 a); 
#line 1287
static __inline __half __low2half(const __half2 a); 
#line 1303
static __inline int __hisinf(const __half a); 
#line 1320
static __inline __half2 __halves2half2(const __half a, const __half b); 
#line 1335
static __inline __half2 __low2half2(const __half2 a); 
#line 1350
static __inline __half2 __high2half2(const __half2 a); 
#line 1366
static __inline short __half_as_short(const __half h); 
#line 1381
static __inline unsigned short __half_as_ushort(const __half h); 
#line 1396
static __inline __half __short_as_half(const short i); 
#line 1411
static __inline __half __ushort_as_half(const unsigned short i); 
#line 1430 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_fp16.h"
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline __half2 __shfl(__half2 var, int delta, int width = 32); 
#line 1431
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline __half2 __shfl_up(__half2 var, unsigned delta, int width = 32); 
#line 1432
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline __half2 __shfl_down(__half2 var, unsigned delta, int width = 32); 
#line 1433
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline __half2 __shfl_xor(__half2 var, int delta, int width = 32); 
#line 1434
__declspec(deprecated("__shfl() is deprecated in favor of __shfl_sync() and may be removed in a future release (Use -Wno-deprecated-declarations to sup" "press this warning).")) static __inline __half __shfl(__half var, int delta, int width = 32); 
#line 1435
__declspec(deprecated("__shfl_up() is deprecated in favor of __shfl_up_sync() and may be removed in a future release (Use -Wno-deprecated-declarations " "to suppress this warning).")) static __inline __half __shfl_up(__half var, unsigned delta, int width = 32); 
#line 1436
__declspec(deprecated("__shfl_down() is deprecated in favor of __shfl_down_sync() and may be removed in a future release (Use -Wno-deprecated-declarati" "ons to suppress this warning).")) static __inline __half __shfl_down(__half var, unsigned delta, int width = 32); 
#line 1437
__declspec(deprecated("__shfl_xor() is deprecated in favor of __shfl_xor_sync() and may be removed in a future release (Use -Wno-deprecated-declaration" "s to suppress this warning).")) static __inline __half __shfl_xor(__half var, int delta, int width = 32); 
#line 1462 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_fp16.h"
static __inline __half2 __shfl_sync(unsigned mask, __half2 var, int delta, int width = 32); 
#line 1484
static __inline __half2 __shfl_up_sync(unsigned mask, __half2 var, unsigned delta, int width = 32); 
#line 1506
static __inline __half2 __shfl_down_sync(unsigned mask, __half2 var, unsigned delta, int width = 32); 
#line 1527
static __inline __half2 __shfl_xor_sync(unsigned mask, __half2 var, int delta, int width = 32); 
#line 1549
static __inline __half __shfl_sync(unsigned mask, __half var, int delta, int width = 32); 
#line 1570
static __inline __half __shfl_up_sync(unsigned mask, __half var, unsigned delta, int width = 32); 
#line 1592
static __inline __half __shfl_down_sync(unsigned mask, __half var, unsigned delta, int width = 32); 
#line 1613
static __inline __half __shfl_xor_sync(unsigned mask, __half var, int delta, int width = 32); 
#line 1622 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_fp16.h"
static __inline __half2 __ldg(const __half2 * ptr); 
#line 1623
static __inline __half __ldg(const __half * ptr); 
#line 1624
static __inline __half2 __ldcg(const __half2 * ptr); 
#line 1625
static __inline __half __ldcg(const __half * ptr); 
#line 1626
static __inline __half2 __ldca(const __half2 * ptr); 
#line 1627
static __inline __half __ldca(const __half * ptr); 
#line 1628
static __inline __half2 __ldcs(const __half2 * ptr); 
#line 1629
static __inline __half __ldcs(const __half * ptr); 
#line 1649 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_fp16.h"
static __inline __half2 __heq2(const __half2 a, const __half2 b); 
#line 1666
static __inline __half2 __hne2(const __half2 a, const __half2 b); 
#line 1683
static __inline __half2 __hle2(const __half2 a, const __half2 b); 
#line 1700
static __inline __half2 __hge2(const __half2 a, const __half2 b); 
#line 1717
static __inline __half2 __hlt2(const __half2 a, const __half2 b); 
#line 1734
static __inline __half2 __hgt2(const __half2 a, const __half2 b); 
#line 1751
static __inline __half2 __hequ2(const __half2 a, const __half2 b); 
#line 1768
static __inline __half2 __hneu2(const __half2 a, const __half2 b); 
#line 1785
static __inline __half2 __hleu2(const __half2 a, const __half2 b); 
#line 1802
static __inline __half2 __hgeu2(const __half2 a, const __half2 b); 
#line 1819
static __inline __half2 __hltu2(const __half2 a, const __half2 b); 
#line 1836
static __inline __half2 __hgtu2(const __half2 a, const __half2 b); 
#line 1851
static __inline __half2 __hisnan2(const __half2 a); 
#line 1867
static __inline __half2 __hadd2(const __half2 a, const __half2 b); 
#line 1883
static __inline __half2 __hsub2(const __half2 a, const __half2 b); 
#line 1899
static __inline __half2 __hmul2(const __half2 a, const __half2 b); 
#line 1915
static __inline __half2 __h2div(const __half2 a, const __half2 b); 
#line 1933
static __inline __half2 __hadd2_sat(const __half2 a, const __half2 b); 
#line 1951
static __inline __half2 __hsub2_sat(const __half2 a, const __half2 b); 
#line 1970
static __inline __half2 __hmul2_sat(const __half2 a, const __half2 b); 
#line 1989
static __inline __half2 __hfma2(const __half2 a, const __half2 b, const __half2 c); 
#line 2010
static __inline __half2 __hfma2_sat(const __half2 a, const __half2 b, const __half2 c); 
#line 2025
static __inline __half2 __hneg2(const __half2 a); 
#line 2041
static __inline __half __hadd(const __half a, const __half b); 
#line 2057
static __inline __half __hsub(const __half a, const __half b); 
#line 2071
static __inline __half __hmul(const __half a, const __half b); 
#line 2087
static __inline __half __hdiv(const __half a, const __half b); 
#line 2104
static __inline __half __hadd_sat(const __half a, const __half b); 
#line 2122
static __inline __half __hsub_sat(const __half a, const __half b); 
#line 2140
static __inline __half __hmul_sat(const __half a, const __half b); 
#line 2159
static __inline __half __hfma(const __half a, const __half b, const __half c); 
#line 2180
static __inline __half __hfma_sat(const __half a, const __half b, const __half c); 
#line 2194
static __inline __half __hneg(const __half a); 
#line 2215
static __inline bool __hbeq2(const __half2 a, const __half2 b); 
#line 2236
static __inline bool __hbne2(const __half2 a, const __half2 b); 
#line 2257
static __inline bool __hble2(const __half2 a, const __half2 b); 
#line 2278
static __inline bool __hbge2(const __half2 a, const __half2 b); 
#line 2299
static __inline bool __hblt2(const __half2 a, const __half2 b); 
#line 2320
static __inline bool __hbgt2(const __half2 a, const __half2 b); 
#line 2341
static __inline bool __hbequ2(const __half2 a, const __half2 b); 
#line 2362
static __inline bool __hbneu2(const __half2 a, const __half2 b); 
#line 2383
static __inline bool __hbleu2(const __half2 a, const __half2 b); 
#line 2405
static __inline bool __hbgeu2(const __half2 a, const __half2 b); 
#line 2426
static __inline bool __hbltu2(const __half2 a, const __half2 b); 
#line 2448
static __inline bool __hbgtu2(const __half2 a, const __half2 b); 
#line 2464
static __inline bool __heq(const __half a, const __half b); 
#line 2480
static __inline bool __hne(const __half a, const __half b); 
#line 2496
static __inline bool __hle(const __half a, const __half b); 
#line 2512
static __inline bool __hge(const __half a, const __half b); 
#line 2528
static __inline bool __hlt(const __half a, const __half b); 
#line 2544
static __inline bool __hgt(const __half a, const __half b); 
#line 2561
static __inline bool __hequ(const __half a, const __half b); 
#line 2578
static __inline bool __hneu(const __half a, const __half b); 
#line 2595
static __inline bool __hleu(const __half a, const __half b); 
#line 2612
static __inline bool __hgeu(const __half a, const __half b); 
#line 2629
static __inline bool __hltu(const __half a, const __half b); 
#line 2646
static __inline bool __hgtu(const __half a, const __half b); 
#line 2660
static __inline bool __hisnan(const __half a); 
#line 2674
static __inline __half hsqrt(const __half a); 
#line 2690
static __inline __half hrsqrt(const __half a); 
#line 2704
static __inline __half hrcp(const __half a); 
#line 2719
static __inline __half hlog(const __half a); 
#line 2734
static __inline __half hlog2(const __half a); 
#line 2749
static __inline __half hlog10(const __half a); 
#line 2765
static __inline __half hexp(const __half a); 
#line 2781
static __inline __half hexp2(const __half a); 
#line 2797
static __inline __half hexp10(const __half a); 
#line 2811
static __inline __half hcos(const __half a); 
#line 2825
static __inline __half hsin(const __half a); 
#line 2840
static __inline __half2 h2sqrt(const __half2 a); 
#line 2856
static __inline __half2 h2rsqrt(const __half2 a); 
#line 2871
static __inline __half2 h2rcp(const __half2 a); 
#line 2887
static __inline __half2 h2log(const __half2 a); 
#line 2903
static __inline __half2 h2log2(const __half2 a); 
#line 2919
static __inline __half2 h2log10(const __half2 a); 
#line 2935
static __inline __half2 h2exp(const __half2 a); 
#line 2951
static __inline __half2 h2exp2(const __half2 a); 
#line 2967
static __inline __half2 h2exp10(const __half2 a); 
#line 2982
static __inline __half2 h2cos(const __half2 a); 
#line 2996
static __inline __half2 h2sin(const __half2 a); 
#line 3002 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_fp16.h"
static __inline __half2 atomicAdd(__half2 * address, __half2 val); 
#line 3008 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cuda_fp16.h"
static __inline __half atomicAdd(__half * address, __half val); 
#line 117 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
typedef 
#line 115
struct __declspec(align(2)) { 
#line 116
unsigned short x; 
#line 117
} __half_raw; 
#line 122
typedef 
#line 119
struct __declspec(align(4)) { 
#line 120
unsigned short x; 
#line 121
unsigned short y; 
#line 122
} __half2_raw; 
#line 139 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
#pragma warning( push )
#pragma warning( disable:4522 )
#line 143 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
struct __declspec(align(2)) __half { 
#line 145
protected: unsigned short __x; 
#line 151 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
public: __half() { } 
#line 155 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half(const __half_raw &hr) : __x(hr.x) { } 
#line 156
__half &operator=(const __half_raw &hr) { (__x) = (hr.x); return *this; } 
#line 157
volatile __half &operator=(const __half_raw &hr) volatile { (__x) = (hr.x); return *this; } 
#line 158
volatile __half &operator=(const volatile __half_raw &hr) volatile { (__x) = (hr.x); return *this; } 
#line 159
operator __half_raw() const { __half_raw ret; (ret.x) = (__x); return ret; } 
#line 160
operator volatile __half_raw() const volatile { __half_raw ret; (ret.x) = (__x); return ret; } 
#line 165
__half(const float f) { (__x) = (__float2half(f).__x); } 
#line 166
__half(const double f) { (__x) = (__float2half(static_cast< float>(f)).__x); } 
#line 168
operator float() const { return __half2float(*this); } 
#line 169
__half &operator=(const float f) { (__x) = (__float2half(f).__x); return *this; } 
#line 172
__half &operator=(const double f) { (__x) = (__float2half(static_cast< float>(f)).__x); return *this; } 
#line 178
__half(short val) {int *volatile ___ = 0;(void)val;::free(___);}
#if 0
#line 178
{ (__x) = (__short2half_rn(val).__x); } 
#endif
#line 179 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half(unsigned short val) {int *volatile ___ = 0;(void)val;::free(___);}
#if 0
#line 179
{ (__x) = (__ushort2half_rn(val).__x); } 
#endif
#line 180 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half(int val) {int *volatile ___ = 0;(void)val;::free(___);}
#if 0
#line 180
{ (__x) = (__int2half_rn(val).__x); } 
#endif
#line 181 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half(unsigned val) {int *volatile ___ = 0;(void)val;::free(___);}
#if 0
#line 181
{ (__x) = (__uint2half_rn(val).__x); } 
#endif
#line 182 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half(__int64 val) {int *volatile ___ = 0;(void)val;::free(___);}
#if 0
#line 182
{ (__x) = (__ll2half_rn(val).__x); } 
#endif
#line 183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half(unsigned __int64 val) {int *volatile ___ = 0;(void)val;::free(___);}
#if 0
#line 183
{ (__x) = (__ull2half_rn(val).__x); } 
#endif
#line 186 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
operator short() const {int volatile ___ = 1;::exit(___);}
#if 0
#line 186
{ return __half2short_rn(*this); } 
#endif
#line 187 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half &operator=(short val) {int volatile ___ = 1;(void)val;::exit(___);}
#if 0
#line 187
{ (__x) = (__short2half_rn(val).__x); return *this; } 
#endif
#line 189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
operator unsigned short() const {int volatile ___ = 1;::exit(___);}
#if 0
#line 189
{ return __half2ushort_rn(*this); } 
#endif
#line 190 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half &operator=(unsigned short val) {int volatile ___ = 1;(void)val;::exit(___);}
#if 0
#line 190
{ (__x) = (__ushort2half_rn(val).__x); return *this; } 
#endif
#line 192 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
operator int() const {int volatile ___ = 1;::exit(___);}
#if 0
#line 192
{ return __half2int_rn(*this); } 
#endif
#line 193 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half &operator=(int val) {int volatile ___ = 1;(void)val;::exit(___);}
#if 0
#line 193
{ (__x) = (__int2half_rn(val).__x); return *this; } 
#endif
#line 195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
operator unsigned() const {int volatile ___ = 1;::exit(___);}
#if 0
#line 195
{ return __half2uint_rn(*this); } 
#endif
#line 196 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half &operator=(unsigned val) {int volatile ___ = 1;(void)val;::exit(___);}
#if 0
#line 196
{ (__x) = (__uint2half_rn(val).__x); return *this; } 
#endif
#line 198 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
operator __int64() const {int volatile ___ = 1;::exit(___);}
#if 0
#line 198
{ return __half2ll_rn(*this); } 
#endif
#line 199 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half &operator=(__int64 val) {int volatile ___ = 1;(void)val;::exit(___);}
#if 0
#line 199
{ (__x) = (__ll2half_rn(val).__x); return *this; } 
#endif
#line 201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
operator unsigned __int64() const {int volatile ___ = 1;::exit(___);}
#if 0
#line 201
{ return __half2ull_rn(*this); } 
#endif
#line 202 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half &operator=(unsigned __int64 val) {int volatile ___ = 1;(void)val;::exit(___);}
#if 0
#line 202
{ (__x) = (__ull2half_rn(val).__x); return *this; } 
#endif
#line 205 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
operator bool() const {int volatile ___ = 1;::exit(___);}
#if 0
#line 205
{ return ((__x) & 32767) != 0; } 
#endif
#line 208 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
}; 
#line 217
__forceinline __half operator+(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 217
{ return __hadd(lh, rh); } 
#endif
#line 218 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half operator-(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 218
{ return __hsub(lh, rh); } 
#endif
#line 219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half operator*(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 219
{ return __hmul(lh, rh); } 
#endif
#line 220 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half operator/(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 220
{ return __hdiv(lh, rh); } 
#endif
#line 222 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half &operator+=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 222
{ lh = __hadd(lh, rh); return lh; } 
#endif
#line 223 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half &operator-=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 223
{ lh = __hsub(lh, rh); return lh; } 
#endif
#line 224 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half &operator*=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 224
{ lh = __hmul(lh, rh); return lh; } 
#endif
#line 225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half &operator/=(__half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 225
{ lh = __hdiv(lh, rh); return lh; } 
#endif
#line 228 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half &operator++(__half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 228
{ __half_raw one; (one.x) = (15360); (h += one); return h; } 
#endif
#line 229 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half &operator--(__half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 229
{ __half_raw one; (one.x) = (15360); (h -= one); return h; } 
#endif
#line 230 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half operator++(__half &h, int) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 230
{ __half ret = h; __half_raw one; (one.x) = (15360); (h += one); return ret; } 
#endif
#line 231 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half operator--(__half &h, int) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 231
{ __half ret = h; __half_raw one; (one.x) = (15360); (h -= one); return ret; } 
#endif
#line 234 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half operator+(const __half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 234
{ return h; } 
#endif
#line 235 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half operator-(const __half &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 235
{ return __hneg(h); } 
#endif
#line 238 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator==(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 238
{ return __heq(lh, rh); } 
#endif
#line 239 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator!=(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 239
{ return __hne(lh, rh); } 
#endif
#line 240 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator>(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 240
{ return __hgt(lh, rh); } 
#endif
#line 241 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator<(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 241
{ return __hlt(lh, rh); } 
#endif
#line 242 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator>=(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 242
{ return __hge(lh, rh); } 
#endif
#line 243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator<=(const __half &lh, const __half &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 243
{ return __hle(lh, rh); } 
#endif
#line 249 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
struct __declspec(align(4)) __half2 { 
#line 250
__half x; 
#line 251
__half y; 
#line 260 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half2() { } 
#line 262 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half2(const __half &a, const __half &b) : x(a), y(b) { } 
#line 263
__half2(const __half2 &src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&src))); } 
#line 264
__half2 &operator=(const __half2 &src) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&src))); return *this; } 
#line 267
__half2(const __half2_raw &h2r) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&h2r))); } 
#line 268
__half2 &operator=(const __half2_raw &h2r) { (*(reinterpret_cast< unsigned *>(&(*this)))) = (*(reinterpret_cast< const unsigned *>(&h2r))); return *this; } 
#line 269
operator __half2_raw() const { __half2_raw ret; (*(reinterpret_cast< unsigned *>(&ret))) = (*(reinterpret_cast< const unsigned *>(&(*this)))); return ret; } 
#line 270
}; 
#line 278
__forceinline __half2 operator+(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 278
{ return __hadd2(lh, rh); } 
#endif
#line 279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 operator-(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 279
{ return __hsub2(lh, rh); } 
#endif
#line 280 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 operator*(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 280
{ return __hmul2(lh, rh); } 
#endif
#line 281 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 operator/(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 281
{ return __h2div(lh, rh); } 
#endif
#line 283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 &operator+=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 283
{ (lh = (__hadd2(lh, rh))); return lh; } 
#endif
#line 284 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 &operator-=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 284
{ (lh = (__hsub2(lh, rh))); return lh; } 
#endif
#line 285 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 &operator*=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 285
{ (lh = (__hmul2(lh, rh))); return lh; } 
#endif
#line 286 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 &operator/=(__half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 286
{ (lh = (__h2div(lh, rh))); return lh; } 
#endif
#line 288 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 &operator++(__half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 288
{ __half2_raw one; (one.x) = (15360); (one.y) = (15360); (h = (__hadd2(h, one))); return h; } 
#endif
#line 289 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 &operator--(__half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 289
{ __half2_raw one; (one.x) = (15360); (one.y) = (15360); (h = (__hsub2(h, one))); return h; } 
#endif
#line 290 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 operator++(__half2 &h, int) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 290
{ __half2 ret = h; __half2_raw one; (one.x) = (15360); (one.y) = (15360); (h = (__hadd2(h, one))); return ret; } 
#endif
#line 291 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 operator--(__half2 &h, int) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 291
{ __half2 ret = h; __half2_raw one; (one.x) = (15360); (one.y) = (15360); (h = (__hsub2(h, one))); return ret; } 
#endif
#line 293 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 operator+(const __half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 293
{ return h; } 
#endif
#line 294 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline __half2 operator-(const __half2 &h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 294
{ return __hneg2(h); } 
#endif
#line 296 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator==(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 296
{ return __hbeq2(lh, rh); } 
#endif
#line 297 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator!=(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 297
{ return __hbne2(lh, rh); } 
#endif
#line 298 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator>(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 298
{ return __hbgt2(lh, rh); } 
#endif
#line 299 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator<(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 299
{ return __hblt2(lh, rh); } 
#endif
#line 300 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator>=(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 300
{ return __hbge2(lh, rh); } 
#endif
#line 301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__forceinline bool operator<=(const __half2 &lh, const __half2 &rh) {int volatile ___ = 1;(void)lh;(void)rh;::exit(___);}
#if 0
#line 301
{ return __hble2(lh, rh); } 
#endif
#line 308 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
#pragma warning( pop )
#line 322 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static unsigned short __internal_float2half(const float f, unsigned &sign, unsigned &remainder) 
#line 323
{ 
#line 324
unsigned x; 
#line 325
unsigned u; 
#line 326
unsigned result = 0U; 
#line 328
(void)memcpy(&x, &f, sizeof f); 
#line 332 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
u = (x & 2147483647U); 
#line 333
sign = ((x >> 16U) & 32768U); 
#line 335
if (u >= 2139095040U) { 
#line 336
remainder = 0U; 
#line 337
result = ((u == 2139095040U) ? sign | 31744U : 32767U); 
#line 338
} else { if (u > 1199566847U) { 
#line 339
remainder = 2147483648U; 
#line 340
result = (sign | 31743U); 
#line 341
} else { if (u >= 947912704U) { 
#line 342
remainder = (u << 19U); 
#line 343
u -= 939524096U; 
#line 344
result = (sign | (u >> 13U)); 
#line 345
} else { if (u < 855638017U) { 
#line 346
remainder = u; 
#line 347
result = sign; 
#line 348
} else { 
#line 349
const unsigned exponent = u >> 23U; 
#line 350
const unsigned shift = 126U - exponent; 
#line 351
unsigned mantissa = u & 8388607U; 
#line 352
mantissa |= 8388608U; 
#line 353
remainder = (mantissa << (32U - shift)); 
#line 354
result = (sign | (mantissa >> shift)); 
#line 355
}  }  }  }  
#line 356
return static_cast< unsigned short>(result); 
#line 357
} 
#line 360 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __float2half(const float a) 
#line 361
{ 
#line 362
__half val; 
#line 366 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half_raw r; 
#line 367
unsigned sign; 
#line 368
unsigned remainder; 
#line 369
(r.x) = __internal_float2half(a, sign, remainder); 
#line 370
if ((remainder > 2147483648U) || ((remainder == 2147483648U) && (((r.x) & 1U) != 0U))) { 
#line 371
(r.x)++; 
#line 372
}  
#line 373
(val = r); 
#line 375 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 376
} 
#line 377
static __inline __half __float2half_rn(const float a) 
#line 378
{ 
#line 379
__half val; 
#line 383 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half_raw r; 
#line 384
unsigned sign; 
#line 385
unsigned remainder; 
#line 386
(r.x) = __internal_float2half(a, sign, remainder); 
#line 387
if ((remainder > 2147483648U) || ((remainder == 2147483648U) && (((r.x) & 1U) != 0U))) { 
#line 388
(r.x)++; 
#line 389
}  
#line 390
(val = r); 
#line 392 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 393
} 
#line 394
static __inline __half __float2half_rz(const float a) 
#line 395
{ 
#line 396
__half val; 
#line 400 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half_raw r; 
#line 401
unsigned sign; 
#line 402
unsigned remainder; 
#line 403
(r.x) = __internal_float2half(a, sign, remainder); 
#line 404
(val = r); 
#line 406 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 407
} 
#line 408
static __inline __half __float2half_rd(const float a) 
#line 409
{ 
#line 410
__half val; 
#line 414 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half_raw r; 
#line 415
unsigned sign; 
#line 416
unsigned remainder; 
#line 417
(r.x) = __internal_float2half(a, sign, remainder); 
#line 418
if ((remainder != 0U) && (sign != 0U)) { 
#line 419
(r.x)++; 
#line 420
}  
#line 421
(val = r); 
#line 423 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 424
} 
#line 425
static __inline __half __float2half_ru(const float a) 
#line 426
{ 
#line 427
__half val; 
#line 431 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
__half_raw r; 
#line 432
unsigned sign; 
#line 433
unsigned remainder; 
#line 434
(r.x) = __internal_float2half(a, sign, remainder); 
#line 435
if ((remainder != 0U) && (sign == 0U)) { 
#line 436
(r.x)++; 
#line 437
}  
#line 438
(val = r); 
#line 440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 441
} 
#line 442
static __inline __half2 __float2half2_rn(const float a) 
#line 443
{ 
#line 444
__half2 val; 
#line 450 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
(val = __half2(__float2half_rn(a), __float2half_rn(a))); 
#line 452 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 453
} 
#line 454
static __inline __half2 __floats2half2_rn(const float a, const float b) 
#line 455
{ 
#line 456
__half2 val; 
#line 463 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
(val = __half2(__float2half_rn(a), __float2half_rn(b))); 
#line 465 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 466
} 
#line 469
static float __internal_half2float(const unsigned short h) 
#line 470
{ 
#line 471
unsigned sign = ((static_cast< unsigned>(h)) >> 15U) & 1U; 
#line 472
unsigned exponent = ((static_cast< unsigned>(h)) >> 10U) & 31U; 
#line 473
unsigned mantissa = ((static_cast< unsigned>(h)) & 1023U) << 13U; 
#line 474
float f; 
#line 475
if (exponent == 31U) { 
#line 476
sign = ((mantissa != 0U) ? 0U : sign); 
#line 477
mantissa = ((mantissa != 0U) ? 8388607U : 0U); 
#line 478
exponent = 255U; 
#line 479
} else { if (exponent == 0U) { 
#line 480
if (mantissa != 0U) { 
#line 481
unsigned msb; 
#line 482
exponent = 113U; 
#line 483
do { 
#line 484
msb = (mantissa & 4194304U); 
#line 485
mantissa <<= 1U; 
#line 486
--exponent; 
#line 487
} while (msb == 0U); 
#line 488
mantissa &= 8388607U; 
#line 489
}  
#line 490
} else { 
#line 491
exponent += 112U; 
#line 492
}  }  
#line 493
unsigned u = ((sign << 31U) | (exponent << 23U)) | mantissa; 
#line 495
(void)memcpy(&f, &u, sizeof u); 
#line 499 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return f; 
#line 500
} 
#line 503 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline float __half2float(const __half a) 
#line 504
{ 
#line 505
float val; 
#line 509 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
val = __internal_half2float(((__half_raw)a).x); 
#line 511 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 512
} 
#line 513
static __inline float __low2float(const __half2 a) 
#line 514
{ 
#line 515
float val; 
#line 521 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
val = __internal_half2float(((__half2_raw)a).x); 
#line 523 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 524
} 
#line 525
static __inline float __high2float(const __half2 a) 
#line 526
{ 
#line 527
float val; 
#line 533 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
val = __internal_half2float(((__half2_raw)a).y); 
#line 535 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return val; 
#line 536
} 
#line 542
static __inline __half2 make_half2(__half x, __half y) 
#line 543
{ 
#line 544
__half2 t; (t.x) = x; (t.y) = y; return t; 
#line 545
} 
#line 550
static __inline __half2 __float22half2_rn(const float2 f) 
#line 551
{ 
#line 552
__half2 val = __floats2half2_rn(f.x, f.y); 
#line 553
return val; 
#line 554
} 
#line 555
static __inline float2 __half22float2(const __half2 l) 
#line 556
{ 
#line 557
float hi_float; 
#line 558
float lo_float; 
#line 568 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
lo_float = __internal_half2float(((__half2_raw)l).x); 
#line 569
hi_float = __internal_half2float(((__half2_raw)l).y); 
#line 571 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
return make_float2(lo_float, hi_float); 
#line 572
} 
#line 573
static __inline int __half2int_rn(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 574
{ 
#line 575
int i; 
#line 576
__asm cvt.rni.s32.f16 %0, %1;
return i; 
#line 578
} 
#endif
#line 579 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline int __half2int_rz(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 580
{ 
#line 581
int i; 
#line 582
__asm cvt.rzi.s32.f16 %0, %1;
return i; 
#line 584
} 
#endif
#line 585 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline int __half2int_rd(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 586
{ 
#line 587
int i; 
#line 588
__asm cvt.rmi.s32.f16 %0, %1;
return i; 
#line 590
} 
#endif
#line 591 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline int __half2int_ru(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 592
{ 
#line 593
int i; 
#line 594
__asm cvt.rpi.s32.f16 %0, %1;
return i; 
#line 596
} 
#endif
#line 597 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __int2half_rn(int i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 598
{ 
#line 599
__half h; 
#line 600
__asm cvt.rn.f16.s32 %0, %1;
return h; 
#line 602
} 
#endif
#line 603 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __int2half_rz(int i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 604
{ 
#line 605
__half h; 
#line 606
__asm cvt.rz.f16.s32 %0, %1;
return h; 
#line 608
} 
#endif
#line 609 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __int2half_rd(int i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 610
{ 
#line 611
__half h; 
#line 612
__asm cvt.rm.f16.s32 %0, %1;
return h; 
#line 614
} 
#endif
#line 615 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __int2half_ru(int i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 616
{ 
#line 617
__half h; 
#line 618
__asm cvt.rp.f16.s32 %0, %1;
return h; 
#line 620
} 
#endif
#line 622 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline short __half2short_rn(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 623
{ 
#line 624
short i; 
#line 625
__asm cvt.rni.s16.f16 %0, %1;
return i; 
#line 627
} 
#endif
#line 628 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline short __half2short_rz(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 629
{ 
#line 630
short i; 
#line 631
__asm cvt.rzi.s16.f16 %0, %1;
return i; 
#line 633
} 
#endif
#line 634 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline short __half2short_rd(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 635
{ 
#line 636
short i; 
#line 637
__asm cvt.rmi.s16.f16 %0, %1;
return i; 
#line 639
} 
#endif
#line 640 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline short __half2short_ru(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 641
{ 
#line 642
short i; 
#line 643
__asm cvt.rpi.s16.f16 %0, %1;
return i; 
#line 645
} 
#endif
#line 646 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __short2half_rn(short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 647
{ 
#line 648
__half h; 
#line 649
__asm cvt.rn.f16.s16 %0, %1;
return h; 
#line 651
} 
#endif
#line 652 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __short2half_rz(short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 653
{ 
#line 654
__half h; 
#line 655
__asm cvt.rz.f16.s16 %0, %1;
return h; 
#line 657
} 
#endif
#line 658 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __short2half_rd(short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 659
{ 
#line 660
__half h; 
#line 661
__asm cvt.rm.f16.s16 %0, %1;
return h; 
#line 663
} 
#endif
#line 664 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __short2half_ru(short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 665
{ 
#line 666
__half h; 
#line 667
__asm cvt.rp.f16.s16 %0, %1;
return h; 
#line 669
} 
#endif
#line 671 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __half2uint_rn(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 672
{ 
#line 673
unsigned i; 
#line 674
__asm cvt.rni.u32.f16 %0, %1;
return i; 
#line 676
} 
#endif
#line 677 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __half2uint_rz(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 678
{ 
#line 679
unsigned i; 
#line 680
__asm cvt.rzi.u32.f16 %0, %1;
return i; 
#line 682
} 
#endif
#line 683 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __half2uint_rd(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 684
{ 
#line 685
unsigned i; 
#line 686
__asm cvt.rmi.u32.f16 %0, %1;
return i; 
#line 688
} 
#endif
#line 689 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __half2uint_ru(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 690
{ 
#line 691
unsigned i; 
#line 692
__asm cvt.rpi.u32.f16 %0, %1;
return i; 
#line 694
} 
#endif
#line 695 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __uint2half_rn(unsigned i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 696
{ 
#line 697
__half h; 
#line 698
__asm cvt.rn.f16.u32 %0, %1;
return h; 
#line 700
} 
#endif
#line 701 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __uint2half_rz(unsigned i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 702
{ 
#line 703
__half h; 
#line 704
__asm cvt.rz.f16.u32 %0, %1;
return h; 
#line 706
} 
#endif
#line 707 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __uint2half_rd(unsigned i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 708
{ 
#line 709
__half h; 
#line 710
__asm cvt.rm.f16.u32 %0, %1;
return h; 
#line 712
} 
#endif
#line 713 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __uint2half_ru(unsigned i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 714
{ 
#line 715
__half h; 
#line 716
__asm cvt.rp.f16.u32 %0, %1;
return h; 
#line 718
} 
#endif
#line 720 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned short __half2ushort_rn(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 721
{ 
#line 722
unsigned short i; 
#line 723
__asm cvt.rni.u16.f16 %0, %1;
return i; 
#line 725
} 
#endif
#line 726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned short __half2ushort_rz(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 727
{ 
#line 728
unsigned short i; 
#line 729
__asm cvt.rzi.u16.f16 %0, %1;
return i; 
#line 731
} 
#endif
#line 732 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned short __half2ushort_rd(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 733
{ 
#line 734
unsigned short i; 
#line 735
__asm cvt.rmi.u16.f16 %0, %1;
return i; 
#line 737
} 
#endif
#line 738 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned short __half2ushort_ru(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 739
{ 
#line 740
unsigned short i; 
#line 741
__asm cvt.rpi.u16.f16 %0, %1;
return i; 
#line 743
} 
#endif
#line 744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ushort2half_rn(unsigned short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 745
{ 
#line 746
__half h; 
#line 747
__asm cvt.rn.f16.u16 %0, %1;
return h; 
#line 749
} 
#endif
#line 750 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ushort2half_rz(unsigned short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 751
{ 
#line 752
__half h; 
#line 753
__asm cvt.rz.f16.u16 %0, %1;
return h; 
#line 755
} 
#endif
#line 756 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ushort2half_rd(unsigned short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 757
{ 
#line 758
__half h; 
#line 759
__asm cvt.rm.f16.u16 %0, %1;
return h; 
#line 761
} 
#endif
#line 762 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ushort2half_ru(unsigned short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 763
{ 
#line 764
__half h; 
#line 765
__asm cvt.rp.f16.u16 %0, %1;
return h; 
#line 767
} 
#endif
#line 769 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __int64 __half2ull_rn(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 770
{ 
#line 771
unsigned __int64 i; 
#line 772
__asm cvt.rni.u64.f16 %0, %1;
return i; 
#line 774
} 
#endif
#line 775 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __int64 __half2ull_rz(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 776
{ 
#line 777
unsigned __int64 i; 
#line 778
__asm cvt.rzi.u64.f16 %0, %1;
return i; 
#line 780
} 
#endif
#line 781 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __int64 __half2ull_rd(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 782
{ 
#line 783
unsigned __int64 i; 
#line 784
__asm cvt.rmi.u64.f16 %0, %1;
return i; 
#line 786
} 
#endif
#line 787 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned __int64 __half2ull_ru(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 788
{ 
#line 789
unsigned __int64 i; 
#line 790
__asm cvt.rpi.u64.f16 %0, %1;
return i; 
#line 792
} 
#endif
#line 793 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ull2half_rn(unsigned __int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 794
{ 
#line 795
__half h; 
#line 796
__asm cvt.rn.f16.u64 %0, %1;
return h; 
#line 798
} 
#endif
#line 799 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ull2half_rz(unsigned __int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 800
{ 
#line 801
__half h; 
#line 802
__asm cvt.rz.f16.u64 %0, %1;
return h; 
#line 804
} 
#endif
#line 805 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ull2half_rd(unsigned __int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 806
{ 
#line 807
__half h; 
#line 808
__asm cvt.rm.f16.u64 %0, %1;
return h; 
#line 810
} 
#endif
#line 811 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ull2half_ru(unsigned __int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 812
{ 
#line 813
__half h; 
#line 814
__asm cvt.rp.f16.u64 %0, %1;
return h; 
#line 816
} 
#endif
#line 818 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __int64 __half2ll_rn(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 819
{ 
#line 820
__int64 i; 
#line 821
__asm cvt.rni.s64.f16 %0, %1;
return i; 
#line 823
} 
#endif
#line 824 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __int64 __half2ll_rz(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 825
{ 
#line 826
__int64 i; 
#line 827
__asm cvt.rzi.s64.f16 %0, %1;
return i; 
#line 829
} 
#endif
#line 830 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __int64 __half2ll_rd(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 831
{ 
#line 832
__int64 i; 
#line 833
__asm cvt.rmi.s64.f16 %0, %1;
return i; 
#line 835
} 
#endif
#line 836 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __int64 __half2ll_ru(__half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 837
{ 
#line 838
__int64 i; 
#line 839
__asm cvt.rpi.s64.f16 %0, %1;
return i; 
#line 841
} 
#endif
#line 842 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ll2half_rn(__int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 843
{ 
#line 844
__half h; 
#line 845
__asm cvt.rn.f16.s64 %0, %1;
return h; 
#line 847
} 
#endif
#line 848 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ll2half_rz(__int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 849
{ 
#line 850
__half h; 
#line 851
__asm cvt.rz.f16.s64 %0, %1;
return h; 
#line 853
} 
#endif
#line 854 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ll2half_rd(__int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 855
{ 
#line 856
__half h; 
#line 857
__asm cvt.rm.f16.s64 %0, %1;
return h; 
#line 859
} 
#endif
#line 860 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ll2half_ru(__int64 i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 861
{ 
#line 862
__half h; 
#line 863
__asm cvt.rp.f16.s64 %0, %1;
return h; 
#line 865
} 
#endif
#line 867 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half htrunc(const __half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 868
{ 
#line 869
__half r; 
#line 870
__asm cvt.rzi.f16.f16 %0, %1;
return r; 
#line 872
} 
#endif
#line 873 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hceil(const __half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 874
{ 
#line 875
__half r; 
#line 876
__asm cvt.rpi.f16.f16 %0, %1;
return r; 
#line 878
} 
#endif
#line 879 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hfloor(const __half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 880
{ 
#line 881
__half r; 
#line 882
__asm cvt.rmi.f16.f16 %0, %1;
return r; 
#line 884
} 
#endif
#line 885 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hrint(const __half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 886
{ 
#line 887
__half r; 
#line 888
__asm cvt.rni.f16.f16 %0, %1;
return r; 
#line 890
} 
#endif
#line 892 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2trunc(const __half2 h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 893
{ 
#line 894
__half2 val; 
#line 895
__asm {.reg .f16 low,high;
  mov.b32 {low,high}, %1;
  cvt.rzi.f16.f16 low, low;
  cvt.rzi.f16.f16 high, high;
  mov.b32 %0, {low,high};}

#line 900
return val; 
#line 901
} 
#endif
#line 902 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2ceil(const __half2 h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 903
{ 
#line 904
__half2 val; 
#line 905
__asm {.reg .f16 low,high;
  mov.b32 {low,high}, %1;
  cvt.rpi.f16.f16 low, low;
  cvt.rpi.f16.f16 high, high;
  mov.b32 %0, {low,high};}

#line 910
return val; 
#line 911
} 
#endif
#line 912 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2floor(const __half2 h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 913
{ 
#line 914
__half2 val; 
#line 915
__asm {.reg .f16 low,high;
  mov.b32 {low,high}, %1;
  cvt.rmi.f16.f16 low, low;
  cvt.rmi.f16.f16 high, high;
  mov.b32 %0, {low,high};}

#line 920
return val; 
#line 921
} 
#endif
#line 922 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2rint(const __half2 h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 923
{ 
#line 924
__half2 val; 
#line 925
__asm {.reg .f16 low,high;
  mov.b32 {low,high}, %1;
  cvt.rni.f16.f16 low, low;
  cvt.rni.f16.f16 high, high;
  mov.b32 %0, {low,high};}

#line 930
return val; 
#line 931
} 
#endif
#line 932 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __lows2half2(const __half2 l, const __half2 h) {int volatile ___ = 1;(void)l;(void)h;::exit(___);}
#if 0
#line 933
{ 
#line 934
__half2 val; 
#line 935
__asm {.reg .f16 alow,ahigh,blow,bhigh;
  mov.b32 {alow,ahigh}, %1;
  mov.b32 {blow,bhigh}, %2;
  mov.b32 %0, {alow,blow};}

#line 939
return val; 
#line 940
} 
#endif
#line 941 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __highs2half2(const __half2 l, const __half2 h) {int volatile ___ = 1;(void)l;(void)h;::exit(___);}
#if 0
#line 942
{ 
#line 943
__half2 val; 
#line 944
__asm {.reg .f16 alow,ahigh,blow,bhigh;
  mov.b32 {alow,ahigh}, %1;
  mov.b32 {blow,bhigh}, %2;
  mov.b32 %0, {ahigh,bhigh};}

#line 948
return val; 
#line 949
} 
#endif
#line 950 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __low2half(const __half2 h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 951
{ 
#line 952
__half ret; 
#line 953
__asm {.reg .f16 low,high;
 mov.b32 {low,high}, %1;
 mov.b16 %0, low;}
return ret; 
#line 957
} 
#endif
#line 958 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline int __hisinf(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 959
{ 
#line 960
if ((*(reinterpret_cast< const unsigned short *>(&a))) == 64512) { 
#line 961
return -1; 
#line 962
}  
#line 963
if ((*(reinterpret_cast< const unsigned short *>(&a))) == 31744) { 
#line 964
return 1; 
#line 965
}  
#line 966
return 0; 
#line 967
} 
#endif
#line 968 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __low2half2(const __half2 l) {int volatile ___ = 1;(void)l;::exit(___);}
#if 0
#line 969
{ 
#line 970
__half2 val; 
#line 971
__asm {.reg .f16 low,high;
  mov.b32 {low,high}, %1;
  mov.b32 %0, {low,low};}

#line 974
return val; 
#line 975
} 
#endif
#line 976 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __high2half2(const __half2 l) {int volatile ___ = 1;(void)l;::exit(___);}
#if 0
#line 977
{ 
#line 978
__half2 val; 
#line 979
__asm {.reg .f16 low,high;
  mov.b32 {low,high}, %1;
  mov.b32 %0, {high,high};}

#line 982
return val; 
#line 983
} 
#endif
#line 984 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __high2half(const __half2 h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 985
{ 
#line 986
__half ret; 
#line 987
__asm {.reg .f16 low,high;
 mov.b32 {low,high}, %1;
 mov.b16 %0, high;}
return ret; 
#line 991
} 
#endif
#line 992 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __halves2half2(const __half l, const __half h) {int volatile ___ = 1;(void)l;(void)h;::exit(___);}
#if 0
#line 993
{ 
#line 994
__half2 val; 
#line 995
__asm {  mov.b32 %0, {%1,%2};}

return val; 
#line 998
} 
#endif
#line 999 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __half2half2(const __half lh) {int volatile ___ = 1;(void)lh;::exit(___);}
#if 0
#line 1000
{ 
#line 1001
__half2 val; 
#line 1002
__asm {  mov.b32 %0, {%1,%1};}

return val; 
#line 1005
} 
#endif
#line 1006 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __lowhigh2highlow(const __half2 lh) {int volatile ___ = 1;(void)lh;::exit(___);}
#if 0
#line 1007
{ 
#line 1008
__half2 val; 
#line 1009
__asm {.reg .f16 low,high;
  mov.b32 {low,high}, %1;
  mov.b32 %0, {high,low};}

#line 1012
return val; 
#line 1013
} 
#endif
#line 1014 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline short __half_as_short(const __half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 1015
{ 
#line 1016
return (short)(*(reinterpret_cast< const unsigned short *>(&h))); 
#line 1017
} 
#endif
#line 1018 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline unsigned short __half_as_ushort(const __half h) {int volatile ___ = 1;(void)h;::exit(___);}
#if 0
#line 1019
{ 
#line 1020
return *(reinterpret_cast< const unsigned short *>(&h)); 
#line 1021
} 
#endif
#line 1022 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __short_as_half(const short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 1023
{ 
#line 1024
__half h; 
#line 1025
(*(reinterpret_cast< unsigned short *>(&h))) = ((unsigned short)i); 
#line 1026
return h; 
#line 1027
} 
#endif
#line 1028 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ushort_as_half(const unsigned short i) {int volatile ___ = 1;(void)i;::exit(___);}
#if 0
#line 1029
{ 
#line 1030
__half h; 
#line 1031
(*(reinterpret_cast< unsigned short *>(&h))) = i; 
#line 1032
return h; 
#line 1033
} 
#endif
#line 1055 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl(__half2 var, int delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1056
{ 
#line 1057
int warpSize; 
#line 1058
__asm {mov.u32 %0, WARP_SZ;
}
#line 1059
int c = ((warpSize - width) << 8) | 31; 
#line 1060
do { __half2 r; __asm {shfl.idx.b32 %0,%1,%2,%3;
}
#line 1060
return r; } while (0); 
#line 1061
} 
#endif
#line 1062 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl_up(__half2 var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1063
{ 
#line 1064
int warpSize; 
#line 1065
__asm {mov.u32 %0, WARP_SZ;
}
#line 1066
int c = (warpSize - width) << 8; 
#line 1067
do { __half2 r; __asm {shfl.up.b32 %0,%1,%2,%3;
}
#line 1067
return r; } while (0); 
#line 1068
} 
#endif
#line 1069 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl_down(__half2 var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1070
{ 
#line 1071
int warpSize; 
#line 1072
__asm {mov.u32 %0, WARP_SZ;
}
#line 1073
int c = ((warpSize - width) << 8) | 31; 
#line 1074
do { __half2 r; __asm {shfl.down.b32 %0,%1,%2,%3;
}
#line 1074
return r; } while (0); 
#line 1075
} 
#endif
#line 1076 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl_xor(__half2 var, int delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1077
{ 
#line 1078
int warpSize; 
#line 1079
__asm {mov.u32 %0, WARP_SZ;
}
#line 1080
int c = ((warpSize - width) << 8) | 31; 
#line 1081
do { __half2 r; __asm {shfl.bfly.b32 %0,%1,%2,%3;
}
#line 1081
return r; } while (0); 
#line 1082
} 
#endif
#line 1086 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl_sync(unsigned mask, __half2 var, int delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1087
{ 
#line 1088
int warpSize; 
#line 1089
__asm {mov.u32 %0, WARP_SZ;
}
#line 1090
int c = ((warpSize - width) << 8) | 31; 
#line 1091
do { __half2 r; __asm {shfl.sync.idx.b32 %0,%1,%2,%3,%4;
}
#line 1091
return r; } while (0); 
#line 1092
} 
#endif
#line 1093 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl_up_sync(unsigned mask, __half2 var, unsigned delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1094
{ 
#line 1095
int warpSize; 
#line 1096
__asm {mov.u32 %0, WARP_SZ;
}
#line 1097
int c = (warpSize - width) << 8; 
#line 1098
do { __half2 r; __asm {shfl.sync.up.b32 %0,%1,%2,%3,%4;
}
#line 1098
return r; } while (0); 
#line 1099
} 
#endif
#line 1100 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl_down_sync(unsigned mask, __half2 var, unsigned delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1101
{ 
#line 1102
int warpSize; 
#line 1103
__asm {mov.u32 %0, WARP_SZ;
}
#line 1104
int c = ((warpSize - width) << 8) | 31; 
#line 1105
do { __half2 r; __asm {shfl.sync.down.b32 %0,%1,%2,%3,%4;
}
#line 1105
return r; } while (0); 
#line 1106
} 
#endif
#line 1107 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __shfl_xor_sync(unsigned mask, __half2 var, int delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1108
{ 
#line 1109
int warpSize; 
#line 1110
__asm {mov.u32 %0, WARP_SZ;
}
#line 1111
int c = ((warpSize - width) << 8) | 31; 
#line 1112
do { __half2 r; __asm {shfl.sync.bfly.b32 %0,%1,%2,%3,%4;
}
#line 1112
return r; } while (0); 
#line 1113
} 
#endif
#line 1120 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl(__half var, int delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1121
{ 
#line 1122
__half2 temp1 = __halves2half2(var, var); 
#line 1123
__half2 temp2 = __shfl(temp1, delta, width); 
#line 1124
return __low2half(temp2); 
#line 1125
} 
#endif
#line 1126 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl_up(__half var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1127
{ 
#line 1128
__half2 temp1 = __halves2half2(var, var); 
#line 1129
__half2 temp2 = __shfl_up(temp1, delta, width); 
#line 1130
return __low2half(temp2); 
#line 1131
} 
#endif
#line 1132 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl_down(__half var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1133
{ 
#line 1134
__half2 temp1 = __halves2half2(var, var); 
#line 1135
__half2 temp2 = __shfl_down(temp1, delta, width); 
#line 1136
return __low2half(temp2); 
#line 1137
} 
#endif
#line 1138 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl_xor(__half var, int delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1139
{ 
#line 1140
__half2 temp1 = __halves2half2(var, var); 
#line 1141
__half2 temp2 = __shfl_xor(temp1, delta, width); 
#line 1142
return __low2half(temp2); 
#line 1143
} 
#endif
#line 1147 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl_sync(unsigned mask, __half var, int delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1148
{ 
#line 1149
__half2 temp1 = __halves2half2(var, var); 
#line 1150
__half2 temp2 = __shfl_sync(mask, temp1, delta, width); 
#line 1151
return __low2half(temp2); 
#line 1152
} 
#endif
#line 1153 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl_up_sync(unsigned mask, __half var, unsigned delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1154
{ 
#line 1155
__half2 temp1 = __halves2half2(var, var); 
#line 1156
__half2 temp2 = __shfl_up_sync(mask, temp1, delta, width); 
#line 1157
return __low2half(temp2); 
#line 1158
} 
#endif
#line 1159 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl_down_sync(unsigned mask, __half var, unsigned delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1160
{ 
#line 1161
__half2 temp1 = __halves2half2(var, var); 
#line 1162
__half2 temp2 = __shfl_down_sync(mask, temp1, delta, width); 
#line 1163
return __low2half(temp2); 
#line 1164
} 
#endif
#line 1165 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __shfl_xor_sync(unsigned mask, __half var, int delta, int width) {int volatile ___ = 1;(void)mask;(void)var;(void)delta;(void)width;::exit(___);}
#if 0
#line 1166
{ 
#line 1167
__half2 temp1 = __halves2half2(var, var); 
#line 1168
__half2 temp2 = __shfl_xor_sync(mask, temp1, delta, width); 
#line 1169
return __low2half(temp2); 
#line 1170
} 
#endif
#line 1183 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __ldg(const __half2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1184
{ 
#line 1185
__half2 ret; 
#line 1186
__asm ld.global.nc.b32 %0, [%1];
return ret; 
#line 1188
} 
#endif
#line 1189 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ldg(const __half *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1190
{ 
#line 1191
__half ret; 
#line 1192
__asm ld.global.nc.b16 %0, [%1];
return ret; 
#line 1194
} 
#endif
#line 1195 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __ldcg(const __half2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1196
{ 
#line 1197
__half2 ret; 
#line 1198
__asm ld.global.cg.b32 %0, [%1];
return ret; 
#line 1200
} 
#endif
#line 1201 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ldcg(const __half *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1202
{ 
#line 1203
__half ret; 
#line 1204
__asm ld.global.cg.b16 %0, [%1];
return ret; 
#line 1206
} 
#endif
#line 1207 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __ldca(const __half2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1208
{ 
#line 1209
__half2 ret; 
#line 1210
__asm ld.global.ca.b32 %0, [%1];
return ret; 
#line 1212
} 
#endif
#line 1213 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ldca(const __half *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1214
{ 
#line 1215
__half ret; 
#line 1216
__asm ld.global.ca.b16 %0, [%1];
return ret; 
#line 1218
} 
#endif
#line 1219 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __ldcs(const __half2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1220
{ 
#line 1221
__half2 ret; 
#line 1222
__asm ld.global.cs.b32 %0, [%1];
return ret; 
#line 1224
} 
#endif
#line 1225 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __ldcs(const __half *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 1226
{ 
#line 1227
__half ret; 
#line 1228
__asm ld.global.cs.b16 %0, [%1];
return ret; 
#line 1230
} 
#endif
#line 1243 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __heq2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1244
{ 
#line 1245
do { __half2 val; __asm { set.eq.f16x2.f16x2 %0,%1,%2;
}
#line 1245
return val; } while (0); 
#line 1246
} 
#endif
#line 1247 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hne2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1248
{ 
#line 1249
do { __half2 val; __asm { set.ne.f16x2.f16x2 %0,%1,%2;
}
#line 1249
return val; } while (0); 
#line 1250
} 
#endif
#line 1251 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hle2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1252
{ 
#line 1253
do { __half2 val; __asm { set.le.f16x2.f16x2 %0,%1,%2;
}
#line 1253
return val; } while (0); 
#line 1254
} 
#endif
#line 1255 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hge2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1256
{ 
#line 1257
do { __half2 val; __asm { set.ge.f16x2.f16x2 %0,%1,%2;
}
#line 1257
return val; } while (0); 
#line 1258
} 
#endif
#line 1259 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hlt2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1260
{ 
#line 1261
do { __half2 val; __asm { set.lt.f16x2.f16x2 %0,%1,%2;
}
#line 1261
return val; } while (0); 
#line 1262
} 
#endif
#line 1263 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hgt2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1264
{ 
#line 1265
do { __half2 val; __asm { set.gt.f16x2.f16x2 %0,%1,%2;
}
#line 1265
return val; } while (0); 
#line 1266
} 
#endif
#line 1267 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hequ2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1268
{ 
#line 1269
do { __half2 val; __asm { set.equ.f16x2.f16x2 %0,%1,%2;
}
#line 1269
return val; } while (0); 
#line 1270
} 
#endif
#line 1271 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hneu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1272
{ 
#line 1273
do { __half2 val; __asm { set.neu.f16x2.f16x2 %0,%1,%2;
}
#line 1273
return val; } while (0); 
#line 1274
} 
#endif
#line 1275 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hleu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1276
{ 
#line 1277
do { __half2 val; __asm { set.leu.f16x2.f16x2 %0,%1,%2;
}
#line 1277
return val; } while (0); 
#line 1278
} 
#endif
#line 1279 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hgeu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1280
{ 
#line 1281
do { __half2 val; __asm { set.geu.f16x2.f16x2 %0,%1,%2;
}
#line 1281
return val; } while (0); 
#line 1282
} 
#endif
#line 1283 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hltu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1284
{ 
#line 1285
do { __half2 val; __asm { set.ltu.f16x2.f16x2 %0,%1,%2;
}
#line 1285
return val; } while (0); 
#line 1286
} 
#endif
#line 1287 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hgtu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1288
{ 
#line 1289
do { __half2 val; __asm { set.gtu.f16x2.f16x2 %0,%1,%2;
}
#line 1289
return val; } while (0); 
#line 1290
} 
#endif
#line 1301 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbeq2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1302
{ 
#line 1303
do { __half2 val; __asm { set.eq.f16x2.f16x2 %0,%1,%2;
}
#line 1303
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1304
} 
#endif
#line 1305 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbne2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1306
{ 
#line 1307
do { __half2 val; __asm { set.ne.f16x2.f16x2 %0,%1,%2;
}
#line 1307
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1308
} 
#endif
#line 1309 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hble2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1310
{ 
#line 1311
do { __half2 val; __asm { set.le.f16x2.f16x2 %0,%1,%2;
}
#line 1311
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1312
} 
#endif
#line 1313 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbge2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1314
{ 
#line 1315
do { __half2 val; __asm { set.ge.f16x2.f16x2 %0,%1,%2;
}
#line 1315
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1316
} 
#endif
#line 1317 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hblt2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1318
{ 
#line 1319
do { __half2 val; __asm { set.lt.f16x2.f16x2 %0,%1,%2;
}
#line 1319
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1320
} 
#endif
#line 1321 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbgt2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1322
{ 
#line 1323
do { __half2 val; __asm { set.gt.f16x2.f16x2 %0,%1,%2;
}
#line 1323
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1324
} 
#endif
#line 1325 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbequ2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1326
{ 
#line 1327
do { __half2 val; __asm { set.equ.f16x2.f16x2 %0,%1,%2;
}
#line 1327
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1328
} 
#endif
#line 1329 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbneu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1330
{ 
#line 1331
do { __half2 val; __asm { set.neu.f16x2.f16x2 %0,%1,%2;
}
#line 1331
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1332
} 
#endif
#line 1333 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbleu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1334
{ 
#line 1335
do { __half2 val; __asm { set.leu.f16x2.f16x2 %0,%1,%2;
}
#line 1335
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1336
} 
#endif
#line 1337 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbgeu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1338
{ 
#line 1339
do { __half2 val; __asm { set.geu.f16x2.f16x2 %0,%1,%2;
}
#line 1339
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1340
} 
#endif
#line 1341 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbltu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1342
{ 
#line 1343
do { __half2 val; __asm { set.ltu.f16x2.f16x2 %0,%1,%2;
}
#line 1343
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1344
} 
#endif
#line 1345 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hbgtu2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1346
{ 
#line 1347
do { __half2 val; __asm { set.gtu.f16x2.f16x2 %0,%1,%2;
}
#line 1347
if ((*(reinterpret_cast< const unsigned *>(&val))) == (1006648320)) { return true; } else { return false; }  } while (0); 
#line 1348
} 
#endif
#line 1361 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __heq(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1362
{ 
#line 1363
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.eq.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1363
return (val) ? true : false; } while (0); 
#line 1364
} 
#endif
#line 1365 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hne(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1366
{ 
#line 1367
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.ne.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1367
return (val) ? true : false; } while (0); 
#line 1368
} 
#endif
#line 1369 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hle(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1370
{ 
#line 1371
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.le.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1371
return (val) ? true : false; } while (0); 
#line 1372
} 
#endif
#line 1373 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hge(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1374
{ 
#line 1375
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.ge.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1375
return (val) ? true : false; } while (0); 
#line 1376
} 
#endif
#line 1377 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hlt(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1378
{ 
#line 1379
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.lt.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1379
return (val) ? true : false; } while (0); 
#line 1380
} 
#endif
#line 1381 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hgt(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1382
{ 
#line 1383
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.gt.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1383
return (val) ? true : false; } while (0); 
#line 1384
} 
#endif
#line 1385 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hequ(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1386
{ 
#line 1387
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.equ.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1387
return (val) ? true : false; } while (0); 
#line 1388
} 
#endif
#line 1389 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hneu(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1390
{ 
#line 1391
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.neu.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1391
return (val) ? true : false; } while (0); 
#line 1392
} 
#endif
#line 1393 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hleu(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1394
{ 
#line 1395
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.leu.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1395
return (val) ? true : false; } while (0); 
#line 1396
} 
#endif
#line 1397 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hgeu(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1398
{ 
#line 1399
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.geu.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1399
return (val) ? true : false; } while (0); 
#line 1400
} 
#endif
#line 1401 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hltu(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1402
{ 
#line 1403
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.ltu.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1403
return (val) ? true : false; } while (0); 
#line 1404
} 
#endif
#line 1405 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hgtu(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1406
{ 
#line 1407
do { unsigned short val; __asm { .reg .pred __$temp3;
  setp.gtu.f16  __$temp3, %1, %2;
  selp.u16 %0, 1, 0, __$temp3;}
#line 1407
return (val) ? true : false; } while (0); 
#line 1408
} 
#endif
#line 1420 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hadd2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1421
{ 
#line 1422
do { __half2 val; __asm {add.f16x2 %0,%1,%2;
}
#line 1422
return val; } while (0); 
#line 1423
} 
#endif
#line 1424 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hsub2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1425
{ 
#line 1426
do { __half2 val; __asm {sub.f16x2 %0,%1,%2;
}
#line 1426
return val; } while (0); 
#line 1427
} 
#endif
#line 1428 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hmul2(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1429
{ 
#line 1430
do { __half2 val; __asm {mul.f16x2 %0,%1,%2;
}
#line 1430
return val; } while (0); 
#line 1431
} 
#endif
#line 1432 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hadd2_sat(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1433
{ 
#line 1434
do { __half2 val; __asm {add.sat.f16x2 %0,%1,%2;
}
#line 1434
return val; } while (0); 
#line 1435
} 
#endif
#line 1436 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hsub2_sat(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1437
{ 
#line 1438
do { __half2 val; __asm {sub.sat.f16x2 %0,%1,%2;
}
#line 1438
return val; } while (0); 
#line 1439
} 
#endif
#line 1440 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hmul2_sat(const __half2 a, const __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1441
{ 
#line 1442
do { __half2 val; __asm {mul.sat.f16x2 %0,%1,%2;
}
#line 1442
return val; } while (0); 
#line 1443
} 
#endif
#line 1451 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hfma2(const __half2 a, const __half2 b, const __half2 c) {int volatile ___ = 1;(void)a;(void)b;(void)c;::exit(___);}
#if 0
#line 1452
{ 
#line 1453
do { __half2 val; __asm {fma.rn.f16x2 %0,%1,%2,%3;
}
#line 1453
return val; } while (0); 
#line 1454
} 
#endif
#line 1455 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hfma2_sat(const __half2 a, const __half2 b, const __half2 c) {int volatile ___ = 1;(void)a;(void)b;(void)c;::exit(___);}
#if 0
#line 1456
{ 
#line 1457
do { __half2 val; __asm {fma.rn.sat.f16x2 %0,%1,%2,%3;
}
#line 1457
return val; } while (0); 
#line 1458
} 
#endif
#line 1460 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __h2div(__half2 a, __half2 b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1460
{ 
#line 1461
__half ha, hb; 
#line 1463
ha = __low2half(a); 
#line 1464
hb = __low2half(b); 
#line 1466
__half v1 = __hdiv(ha, hb); 
#line 1468
ha = __high2half(a); 
#line 1469
hb = __high2half(b); 
#line 1471
__half v2 = __hdiv(ha, hb); 
#line 1473
return __halves2half2(v1, v2); 
#line 1474
} 
#endif
#line 1484 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hadd(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1485
{ 
#line 1486
do { __half val; __asm {add.f16 %0,%1,%2;
}
#line 1486
return val; } while (0); 
#line 1487
} 
#endif
#line 1488 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hsub(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1489
{ 
#line 1490
do { __half val; __asm {sub.f16 %0,%1,%2;
}
#line 1490
return val; } while (0); 
#line 1491
} 
#endif
#line 1492 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hmul(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1493
{ 
#line 1494
do { __half val; __asm {mul.f16 %0,%1,%2;
}
#line 1494
return val; } while (0); 
#line 1495
} 
#endif
#line 1496 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hadd_sat(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1497
{ 
#line 1498
do { __half val; __asm {add.sat.f16 %0,%1,%2;
}
#line 1498
return val; } while (0); 
#line 1499
} 
#endif
#line 1500 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hsub_sat(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1501
{ 
#line 1502
do { __half val; __asm {sub.sat.f16 %0,%1,%2;
}
#line 1502
return val; } while (0); 
#line 1503
} 
#endif
#line 1504 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hmul_sat(const __half a, const __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1505
{ 
#line 1506
do { __half val; __asm {mul.sat.f16 %0,%1,%2;
}
#line 1506
return val; } while (0); 
#line 1507
} 
#endif
#line 1515 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hfma(const __half a, const __half b, const __half c) {int volatile ___ = 1;(void)a;(void)b;(void)c;::exit(___);}
#if 0
#line 1516
{ 
#line 1517
do { __half val; __asm {fma.rn.f16 %0,%1,%2,%3;
}
#line 1517
return val; } while (0); 
#line 1518
} 
#endif
#line 1519 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hfma_sat(const __half a, const __half b, const __half c) {int volatile ___ = 1;(void)a;(void)b;(void)c;::exit(___);}
#if 0
#line 1520
{ 
#line 1521
do { __half val; __asm {fma.rn.sat.f16 %0,%1,%2,%3;
}
#line 1521
return val; } while (0); 
#line 1522
} 
#endif
#line 1524 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hdiv(__half a, __half b) {int volatile ___ = 1;(void)a;(void)b;::exit(___);}
#if 0
#line 1524
{ 
#line 1525
__half v, abs, den; 
#line 1526
(*(reinterpret_cast< unsigned short *>(&den))) = (143); 
#line 1527
float fa, fb, fv, rcp; 
#line 1529
fa = __half2float(a); 
#line 1530
fb = __half2float(b); 
#line 1532
__asm {rcp.approx.f32 %0, %1;
}
fv = (rcp * fa); 
#line 1536
v = __float2half(fv); 
#line 1537
(*(reinterpret_cast< unsigned short *>(&abs))) = ((unsigned short)(((unsigned)(*(reinterpret_cast< const unsigned short *>(&v)))) & (32767))); 
#line 1538
if (__hlt(abs, den) && (!((*(reinterpret_cast< const unsigned short *>(&abs))) == 0))) { 
#line 1539
float err = __fmaf_rn(-fb, fv, fa); 
#line 1540
fv = __fmaf_rn(rcp, err, fv); 
#line 1541
v = __float2half(fv); 
#line 1542
}  
#line 1543
return v; 
#line 1544
} 
#endif
#line 1588 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __forceinline float __float_simpl_sinf(float); 
#line 1589
static __forceinline float __float_simpl_cosf(float); 
#line 1590
static __inline __half __hsin_internal(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1590
{ 
#line 1591
float f = __half2float(a); 
#line 1592
f = __float_simpl_sinf(f); 
#line 1593
return __float2half_rn(f); 
#line 1594
} 
#endif
#line 1595 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hsin(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1595
{ 
#line 1596
__half r = __hsin_internal(a); 
#line 1597
__asm {
	  .reg.b16 i,r,t;     
	  mov.b16 r, %0;      
	  mov.b16 i, %1;      
	  mov.b16 t, 0x8000;  
	  and.b16 t,r,t;      
	{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X32B3;
  mov.b16 ulp,0x0800;
  set.eq.f16.f16 p,i, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X5CB0;
  mov.b16 ulp,0x1000;
  set.eq.f16.f16 p,i, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0XB2B3;
  mov.b16 ulp,0x8800;
  set.eq.f16.f16 p,i, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0XDCB0;
  mov.b16 ulp,0x9000;
  set.eq.f16.f16 p,i, spc;
  fma.rn.f16 r,p,ulp,r;
}
  or.b16  r,r,t;      
	  mov.b16 %0, r;      
}

#line 1610
return r; 
#line 1611
} 
#endif
#line 1612 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2sin(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1612
{ 
#line 1613
__half l = __low2half(a); 
#line 1614
__half h = __high2half(a); 
#line 1615
__half2 r = __halves2half2(__hsin_internal(l), __hsin_internal(h)); 
#line 1616
__asm {
	  .reg.b32 i,r,t;             
	  mov.b32 r, %0;              
	  mov.b32 i, %1;              
	  and.b32 t, r, 0x80008000;   
	{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X32B332B3;
  mov.b32 ulp,0x08000800;
  set.eq.f16x2.f16x2 p,i, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X5CB05CB0;
  mov.b32 ulp,0x10001000;
  set.eq.f16x2.f16x2 p,i, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0XB2B3B2B3;
  mov.b32 ulp,0x88008800;
  set.eq.f16x2.f16x2 p,i, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0XDCB0DCB0;
  mov.b32 ulp,0x90009000;
  set.eq.f16x2.f16x2 p,i, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
  or.b32  r, r, t;            
	  mov.b32 %0, r;              
}

#line 1628
return r; 
#line 1629
} 
#endif
#line 1630 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hcos_internal(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1630
{ 
#line 1631
float f = __half2float(a); 
#line 1632
f = __float_simpl_cosf(f); 
#line 1633
return __float2half_rn(f); 
#line 1634
} 
#endif
#line 1635 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hcos(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1635
{ 
#line 1636
__half r = __hcos_internal(a); 
#line 1637
__asm {
	  .reg.b16 i,r;        
	  mov.b16 r, %0;       
	  mov.b16 i, %1;       
	{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X2B7C;
  mov.b16 ulp,0x1000;
  set.eq.f16.f16 p,i, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0XAB7C;
  mov.b16 ulp,0x1000;
  set.eq.f16.f16 p,i, spc;
  fma.rn.f16 r,p,ulp,r;
}
  mov.b16 %0, r;       
}

#line 1645
return r; 
#line 1646
} 
#endif
#line 1647 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2cos(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1647
{ 
#line 1648
__half l = __low2half(a); 
#line 1649
__half h = __high2half(a); 
#line 1650
__half2 r = __halves2half2(__hcos_internal(l), __hcos_internal(h)); 
#line 1651
__asm {
	  .reg.b32 i,r;   
	  mov.b32 r, %0;  
	  mov.b32 i, %1;  
	{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X2B7C2B7C;
  mov.b32 ulp,0x10001000;
  set.eq.f16x2.f16x2 p,i, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0XAB7CAB7C;
  mov.b32 ulp,0x10001000;
  set.eq.f16x2.f16x2 p,i, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
  mov.b32 %0, r;  
}

#line 1659
return r; 
#line 1660
} 
#endif
#line 1661 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __forceinline float __internal_trig_reduction_kernel(float a, int *quadrant) {int volatile ___ = 1;(void)a;(void)quadrant;::exit(___);}
#if 0
#line 1662
{ 
#line 1663
float j, t; 
#line 1664
int q; 
#line 1665
q = __float2int_rn(a * (0.6366197467F)); 
#line 1666
j = ((float)q); 
#line 1667
t = __fmaf_rn(-j, (1.570796251F), a); 
#line 1668
t = __fmaf_rn(-j, (7.549789416e-08F), t); 
#line 1669
(*quadrant) = q; 
#line 1670
return t; 
#line 1671
} 
#endif
#line 1672 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __forceinline float __internal_sin_cos_kernel(float x, int i) {int volatile ___ = 1;(void)x;(void)i;::exit(___);}
#if 0
#line 1673
{ 
#line 1674
float x2, z; 
#line 1675
x2 = (x * x); 
#line 1677
if (i & 1) { 
#line 1678
z = (2.44331568e-05F); 
#line 1679
z = __fmaf_rn(z, x2, -(0.001388731645F)); 
#line 1680
} else 
#line 1681
{ 
#line 1682
z = (-(0.0001951529557F)); 
#line 1683
z = __fmaf_rn(z, x2, (0.008332161233F)); 
#line 1684
}  
#line 1685
if (i & 1) { 
#line 1686
z = __fmaf_rn(z, x2, (0.04166664556F)); 
#line 1687
z = __fmaf_rn(z, x2, -(0.5F)); 
#line 1688
} else 
#line 1689
{ 
#line 1690
z = __fmaf_rn(z, x2, -(0.1666665524F)); 
#line 1691
z = __fmaf_rn(z, x2, (0.0F)); 
#line 1692
}  
#line 1693
x = __fmaf_rn(z, x, x); 
#line 1694
if (i & 1) { 
#line 1695
x = __fmaf_rn(z, x2, (1.0F)); 
#line 1696
}  
#line 1697
if (i & 2) { 
#line 1698
x = __fmaf_rn(x, -(1.0F), (0.0F)); 
#line 1699
}  
#line 1700
return x; 
#line 1701
} 
#endif
#line 1702 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __forceinline float __float_simpl_sinf(float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1703
{ 
#line 1704
float z; 
#line 1705
int i; 
#line 1706
if (::isinf(a)) { 
#line 1707
a = (a * (0.0F)); 
#line 1708
}  
#line 1709
a = __internal_trig_reduction_kernel(a, &i); 
#line 1710
z = __internal_sin_cos_kernel(a, i); 
#line 1711
return z; 
#line 1712
} 
#endif
#line 1713 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __forceinline float __float_simpl_cosf(float a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1714
{ 
#line 1715
float z; 
#line 1716
int i; 
#line 1717
if (::isinf(a)) { 
#line 1718
a = (a * (0.0F)); 
#line 1719
}  
#line 1720
a = __internal_trig_reduction_kernel(a, &i); 
#line 1721
i++; 
#line 1722
z = __internal_sin_cos_kernel(a, i); 
#line 1723
return z; 
#line 1724
} 
#endif
#line 1726 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hexp(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1726
{ 
#line 1727
__half val; 
#line 1728
__asm {.reg.b32         f, C;           
 .reg.b16         h,r;            
  mov.b16         h,%1;           
  cvt.f32.f16     f,h;            
  mov.b32         C, 0x3fb8aa3b;  
  mul.f32         f,f,C;          
  ex2.approx.f32      f,f;        
  cvt.rn.f16.f32      r,f;        
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X1F79;
  mov.b16 ulp,0x9400;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X25CF;
  mov.b16 ulp,0x9400;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0XC13B;
  mov.b16 ulp,0x0400;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0XC1EF;
  mov.b16 ulp,0x0200;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
  mov.b16         %0,r;           
}
#line 1742
return val; 
#line 1743
} 
#endif
#line 1744 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2exp(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1744
{ 
#line 1745
__half2 val; 
#line 1746
__asm {.reg.b16         hl, hu;         
 .reg.b32         h,r,fl,fu, C;   
  mov.b32         {hl, hu}, %1;   
  mov.b32         h, %1;          
  cvt.f32.f16     fl, hl;         
  cvt.f32.f16     fu, hu;         
  mov.b32         C, 0x3fb8aa3b;  
  mul.f32         fl,fl,C;        
  mul.f32         fu,fu,C;        
  ex2.approx.f32      fl, fl;     
  ex2.approx.f32      fu, fu;     
  cvt.rn.f16.f32      hl, fl;     
  cvt.rn.f16.f32      hu, fu;     
  mov.b32         r, {hl, hu};    
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X1F791F79;
  mov.b32 ulp,0x94009400;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X25CF25CF;
  mov.b32 ulp,0x94009400;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0XC13BC13B;
  mov.b32 ulp,0x04000400;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0XC1EFC1EF;
  mov.b32 ulp,0x02000200;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
  mov.b32         %0, r;  
}
#line 1766
return val; 
#line 1767
} 
#endif
#line 1768 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hexp2(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1768
{ 
#line 1769
__half val; 
#line 1770
__asm {.reg.b32         f, ULP;         
 .reg.b16         r;              
  mov.b16         r,%1;           
  cvt.f32.f16     f,r;            
  ex2.approx.f32      f,f;        
  mov.b32         ULP, 0x33800000;
  fma.rn.f32      f,f,ULP,f;      
  cvt.rn.f16.f32      r,f;        
  mov.b16         %0,r;           
}
return val; 
#line 1781
} 
#endif
#line 1782 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2exp2(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1782
{ 
#line 1783
__half2 val; 
#line 1784
__asm {.reg.b16         hl, hu;         
 .reg.b32         fl, fu, ULP;    
  mov.b32         {hl, hu}, %1;   
  cvt.f32.f16     fl, hl;         
  cvt.f32.f16     fu, hu;         
  ex2.approx.f32      fl, fl;     
  ex2.approx.f32      fu, fu;     
  mov.b32         ULP, 0x33800000;
  fma.rn.f32      fl,fl,ULP,fl;   
  fma.rn.f32      fu,fu,ULP,fu;   
  cvt.rn.f16.f32      hl, fl;     
  cvt.rn.f16.f32      hu, fu;     
  mov.b32         %0, {hl, hu};   
}
return val; 
#line 1799
} 
#endif
#line 1800 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hexp10(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1800
{ 
#line 1801
__half val; 
#line 1802
__asm {.reg.b16         h,r;            
 .reg.b32         f, C;           
  mov.b16         h, %1;          
  cvt.f32.f16     f, h;           
  mov.b32         C, 0x40549A78;  
  mul.f32         f,f,C;          
  ex2.approx.f32      f, f;       
  cvt.rn.f16.f32      r, f;       
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0x34DE;
  mov.b16 ulp,0x9800;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0x9766;
  mov.b16 ulp,0x9000;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0x9972;
  mov.b16 ulp,0x1000;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0xA5C4;
  mov.b16 ulp,0x1000;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0xBF0A;
  mov.b16 ulp,0x8100;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
  mov.b16         %0, r;          
}
#line 1817
return val; 
#line 1818
} 
#endif
#line 1819 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2exp10(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1819
{ 
#line 1820
__half2 val; 
#line 1821
__asm {.reg.b16         hl, hu;         
 .reg.b32         h,r,fl,fu, C;   
  mov.b32         {hl, hu}, %1;   
  mov.b32         h, %1;          
  cvt.f32.f16     fl, hl;         
  cvt.f32.f16     fu, hu;         
  mov.b32         C, 0x40549A78;  
  mul.f32         fl,fl,C;        
  mul.f32         fu,fu,C;        
  ex2.approx.f32      fl, fl;     
  ex2.approx.f32      fu, fu;     
  cvt.rn.f16.f32      hl, fl;     
  cvt.rn.f16.f32      hu, fu;     
  mov.b32         r, {hl, hu};    
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0x34DE34DE;
  mov.b32 ulp,0x98009800;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0x97669766;
  mov.b32 ulp,0x90009000;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0x99729972;
  mov.b32 ulp,0x10001000;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0xA5C4A5C4;
  mov.b32 ulp,0x10001000;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0xBF0ABF0A;
  mov.b32 ulp,0x81008100;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
  mov.b32         %0, r;  
}
#line 1842
return val; 
#line 1843
} 
#endif
#line 1844 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hlog2(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1844
{ 
#line 1845
__half val; 
#line 1846
__asm {.reg.b16         h, r;           
 .reg.b32         f;              
  mov.b16         h, %1;          
  cvt.f32.f16     f, h;           
  lg2.approx.f32      f, f;       
  cvt.rn.f16.f32      r, f;       
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0xA2E2;
  mov.b16 ulp,0x8080;
  set.eq.f16.f16 p,r, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0xBF46;
  mov.b16 ulp,0x9400;
  set.eq.f16.f16 p,r, spc;
  fma.rn.f16 r,p,ulp,r;
}
  mov.b16         %0, r;          
}
#line 1856
return val; 
#line 1857
} 
#endif
#line 1858 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2log2(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1858
{ 
#line 1859
__half2 val; 
#line 1860
__asm {.reg.b16         hl, hu;         
 .reg.b32         fl, fu, r, p;   
  mov.b32         {hl, hu}, %1;   
  cvt.f32.f16     fl, hl;         
  cvt.f32.f16     fu, hu;         
  lg2.approx.f32      fl, fl;     
  lg2.approx.f32      fu, fu;     
  cvt.rn.f16.f32      hl, fl;     
  cvt.rn.f16.f32      hu, fu;     
  mov.b32         r, {hl, hu};    
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0xA2E2A2E2;
  mov.b32 ulp,0x80808080;
  set.eq.f16x2.f16x2 p,r, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0xBF46BF46;
  mov.b32 ulp,0x94009400;
  set.eq.f16x2.f16x2 p,r, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
  mov.b32         %0, r;          
}
#line 1874
return val; 
#line 1875
} 
#endif
#line 1876 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hlog(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1876
{ 
#line 1877
__half val; 
#line 1878
__asm {.reg.b32         f, C;           
 .reg.b16         r,h;            
  mov.b16         h,%1;           
  cvt.f32.f16     f,h;            
  lg2.approx.f32      f,f;        
  mov.b32         C, 0x3f317218;  
  mul.f32         f,f,C;          
  cvt.rn.f16.f32      r,f;        
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X160D;
  mov.b16 ulp,0x9C00;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X3BFE;
  mov.b16 ulp,0x8010;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X3C0B;
  mov.b16 ulp,0x8080;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0X6051;
  mov.b16 ulp,0x1C00;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
  mov.b16         %0,r;           
}
#line 1892
return val; 
#line 1893
} 
#endif
#line 1894 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2log(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1894
{ 
#line 1895
__half2 val; 
#line 1896
__asm {.reg.b16         hl, hu;             
 .reg.b32         r, fl, fu, C, h;    
  mov.b32         {hl, hu}, %1;       
  mov.b32         h, %1;              
  cvt.f32.f16     fl, hl;             
  cvt.f32.f16     fu, hu;             
  lg2.approx.f32      fl, fl;         
  lg2.approx.f32      fu, fu;         
  mov.b32         C, 0x3f317218;      
  mul.f32         fl,fl,C;            
  mul.f32         fu,fu,C;            
  cvt.rn.f16.f32      hl, fl;         
  cvt.rn.f16.f32      hu, fu;         
  mov.b32         r, {hl, hu};        
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X160D160D;
  mov.b32 ulp,0x9C009C00;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X3BFE3BFE;
  mov.b32 ulp,0x80108010;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X3C0B3C0B;
  mov.b32 ulp,0x80808080;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0X60516051;
  mov.b32 ulp,0x1C001C00;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
  mov.b32         %0, r;              
}
#line 1916
return val; 
#line 1917
} 
#endif
#line 1918 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hlog10(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1918
{ 
#line 1919
__half val; 
#line 1920
__asm {.reg.b16         h, r;           
 .reg.b32         f, C;           
  mov.b16         h, %1;          
  cvt.f32.f16     f, h;           
  lg2.approx.f32      f, f;       
  mov.b32         C, 0x3E9A209B;  
  mul.f32         f,f,C;          
  cvt.rn.f16.f32      r, f;       
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0x338F;
  mov.b16 ulp,0x1000;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0x33F8;
  mov.b16 ulp,0x9000;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0x57E1;
  mov.b16 ulp,0x9800;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
{.reg.b16 spc, ulp, p;
  mov.b16 spc,0x719D;
  mov.b16 ulp,0x9C00;
  set.eq.f16.f16 p,h, spc;
  fma.rn.f16 r,p,ulp,r;
}
  mov.b16         %0, r;          
}
#line 1934
return val; 
#line 1935
} 
#endif
#line 1936 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2log10(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1936
{ 
#line 1937
__half2 val; 
#line 1938
__asm {.reg.b16         hl, hu;             
 .reg.b32         r, fl, fu, C, h;    
  mov.b32         {hl, hu}, %1;       
  mov.b32         h, %1;              
  cvt.f32.f16     fl, hl;             
  cvt.f32.f16     fu, hu;             
  lg2.approx.f32      fl, fl;         
  lg2.approx.f32      fu, fu;         
  mov.b32         C, 0x3E9A209B;      
  mul.f32         fl,fl,C;            
  mul.f32         fu,fu,C;            
  cvt.rn.f16.f32      hl, fl;         
  cvt.rn.f16.f32      hu, fu;         
  mov.b32         r, {hl, hu};        
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0x338F338F;
  mov.b32 ulp,0x10001000;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0x33F833F8;
  mov.b32 ulp,0x90009000;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0x57E157E1;
  mov.b32 ulp,0x98009800;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
{.reg.b32 spc, ulp, p;
  mov.b32 spc,0x719D719D;
  mov.b32 ulp,0x9C009C00;
  set.eq.f16x2.f16x2 p,h, spc;
  fma.rn.f16x2 r,p,ulp,r;
}
  mov.b32         %0, r;              
}
#line 1958
return val; 
#line 1959
} 
#endif
#line 1962 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2rcp(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1962
{ 
#line 1963
do { __half2 val; __asm {.reg.b16         hl, hu;         
 .reg.b32         fl, fu;         
  mov.b32         {hl, hu}, %1;   
  cvt.f32.f16     fl, hl;         
  cvt.f32.f16     fu, hu;         
  rcp.approx.f32   fl, fl;     
  rcp.approx.f32   fu, fu;     
  cvt.rn.f16.f32      hl, fl;     
  cvt.rn.f16.f32      hu, fu;     
  mov.b32         %0, {hl, hu};   
}
#line 1963
return val; } while (0); 
#line 1964
} 
#endif
#line 1965 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hrcp(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1965
{ 
#line 1966
do { __half val; __asm {.reg.b32         f;        
 .reg.b16         r;        
  mov.b16         r,%1;     
  cvt.f32.f16     f,r;      
  rcp.approx.f32   f,f;  
  cvt.rn.f16.f32      r,f;  
  mov.b16         %0,r;     
}
#line 1966
return val; } while (0); 
#line 1967
} 
#endif
#line 1968 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2rsqrt(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1968
{ 
#line 1969
do { __half2 val; __asm {.reg.b16         hl, hu;         
 .reg.b32         fl, fu;         
  mov.b32         {hl, hu}, %1;   
  cvt.f32.f16     fl, hl;         
  cvt.f32.f16     fu, hu;         
  rsqrt.approx.f32   fl, fl;     
  rsqrt.approx.f32   fu, fu;     
  cvt.rn.f16.f32      hl, fl;     
  cvt.rn.f16.f32      hu, fu;     
  mov.b32         %0, {hl, hu};   
}
#line 1969
return val; } while (0); 
#line 1970
} 
#endif
#line 1971 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hrsqrt(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1971
{ 
#line 1972
do { __half val; __asm {.reg.b32         f;        
 .reg.b16         r;        
  mov.b16         r,%1;     
  cvt.f32.f16     f,r;      
  rsqrt.approx.f32   f,f;  
  cvt.rn.f16.f32      r,f;  
  mov.b16         %0,r;     
}
#line 1972
return val; } while (0); 
#line 1973
} 
#endif
#line 1974 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 h2sqrt(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1974
{ 
#line 1975
do { __half2 val; __asm {.reg.b16         hl, hu;         
 .reg.b32         fl, fu;         
  mov.b32         {hl, hu}, %1;   
  cvt.f32.f16     fl, hl;         
  cvt.f32.f16     fu, hu;         
  sqrt.approx.f32   fl, fl;     
  sqrt.approx.f32   fu, fu;     
  cvt.rn.f16.f32      hl, fl;     
  cvt.rn.f16.f32      hu, fu;     
  mov.b32         %0, {hl, hu};   
}
#line 1975
return val; } while (0); 
#line 1976
} 
#endif
#line 1977 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half hsqrt(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1977
{ 
#line 1978
do { __half val; __asm {.reg.b32         f;        
 .reg.b16         r;        
  mov.b16         r,%1;     
  cvt.f32.f16     f,r;      
  sqrt.approx.f32   f,f;  
  cvt.rn.f16.f32      r,f;  
  mov.b16         %0,r;     
}
#line 1978
return val; } while (0); 
#line 1979
} 
#endif
#line 1982 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hisnan2(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1983
{ 
#line 1984
__half2 r; 
#line 1985
__asm {set.nan.f16x2.f16x2 %0,%1,%2;
}
return r; 
#line 1988
} 
#endif
#line 1989 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline bool __hisnan(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1990
{ 
#line 1991
__half r; 
#line 1992
__asm {set.nan.f16.f16 %0,%1,%2;
}
return (*(reinterpret_cast< const unsigned short *>(&r))) != 0U; 
#line 1995
} 
#endif
#line 1996 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 __hneg2(const __half2 a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 1997
{ 
#line 1998
__half2 zero = __float2half2_rn((0.0)); 
#line 1999
return __hsub2(zero, a); 
#line 2000
} 
#endif
#line 2001 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half __hneg(const __half a) {int volatile ___ = 1;(void)a;::exit(___);}
#if 0
#line 2002
{ 
#line 2003
__half zero; 
#line 2004
zero = __float2half((0.0)); 
#line 2005
return __hsub(zero, a); 
#line 2006
} 
#endif
#line 2018 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half2 atomicAdd(__half2 *address, __half2 val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 2018
{ 
#line 2019
__half2 r; 
#line 2020
__asm { atom.add.noftz.f16x2 %0,[%1],%2; }

#line 2023
return r; 
#line 2024
} 
#endif
#line 2030 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
static __inline __half atomicAdd(__half *address, __half val) {int volatile ___ = 1;(void)address;(void)val;::exit(___);}
#if 0
#line 2030
{ 
#line 2031
__half r; 
#line 2032
__asm { atom.add.noftz.f16 %0,[%1],%2; }

#line 2036
return r; 
#line 2037
} 
#endif
#line 2053 "c:\\program files\\nvidia gpu computing toolkit\\cuda\\v10.1\\include\\cuda_fp16.hpp"
typedef __half half; 
#line 2054
typedef __half2 half2; 
#line 69 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
extern "C" {
#line 84 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
typedef 
#line 73
enum { 
#line 74
CUSPARSE_STATUS_SUCCESS, 
#line 75
CUSPARSE_STATUS_NOT_INITIALIZED, 
#line 76
CUSPARSE_STATUS_ALLOC_FAILED, 
#line 77
CUSPARSE_STATUS_INVALID_VALUE, 
#line 78
CUSPARSE_STATUS_ARCH_MISMATCH, 
#line 79
CUSPARSE_STATUS_MAPPING_ERROR, 
#line 80
CUSPARSE_STATUS_EXECUTION_FAILED, 
#line 81
CUSPARSE_STATUS_INTERNAL_ERROR, 
#line 82
CUSPARSE_STATUS_MATRIX_TYPE_NOT_SUPPORTED, 
#line 83
CUSPARSE_STATUS_ZERO_PIVOT
#line 84
} cusparseStatus_t; 
#line 87
struct cusparseContext; 
#line 88
typedef cusparseContext *cusparseHandle_t; 
#line 91
struct cusparseMatDescr; 
#line 92
typedef cusparseMatDescr *cusparseMatDescr_t; 
#line 95
struct cusparseSolveAnalysisInfo; 
#line 96
typedef cusparseSolveAnalysisInfo *cusparseSolveAnalysisInfo_t; 
#line 99
struct csrsv2Info; 
#line 100
typedef csrsv2Info *csrsv2Info_t; 
#line 102
struct csrsm2Info; 
#line 103
typedef csrsm2Info *csrsm2Info_t; 
#line 105
struct bsrsv2Info; 
#line 106
typedef bsrsv2Info *bsrsv2Info_t; 
#line 108
struct bsrsm2Info; 
#line 109
typedef bsrsm2Info *bsrsm2Info_t; 
#line 112
struct csric02Info; 
#line 113
typedef csric02Info *csric02Info_t; 
#line 115
struct bsric02Info; 
#line 116
typedef bsric02Info *bsric02Info_t; 
#line 119
struct csrilu02Info; 
#line 120
typedef csrilu02Info *csrilu02Info_t; 
#line 122
struct bsrilu02Info; 
#line 123
typedef bsrilu02Info *bsrilu02Info_t; 
#line 126
struct cusparseHybMat; 
#line 127
typedef cusparseHybMat *cusparseHybMat_t; 
#line 130
struct csrgemm2Info; 
#line 131
typedef csrgemm2Info *csrgemm2Info_t; 
#line 134
struct csru2csrInfo; 
#line 135
typedef csru2csrInfo *csru2csrInfo_t; 
#line 138
struct cusparseColorInfo; 
#line 139
typedef cusparseColorInfo *cusparseColorInfo_t; 
#line 142
struct pruneInfo; 
#line 143
typedef pruneInfo *pruneInfo_t; 
#line 149
typedef 
#line 146
enum { 
#line 147
CUSPARSE_POINTER_MODE_HOST, 
#line 148
CUSPARSE_POINTER_MODE_DEVICE
#line 149
} cusparsePointerMode_t; 
#line 154
typedef 
#line 151
enum { 
#line 152
CUSPARSE_ACTION_SYMBOLIC, 
#line 153
CUSPARSE_ACTION_NUMERIC
#line 154
} cusparseAction_t; 
#line 161
typedef 
#line 156
enum { 
#line 157
CUSPARSE_MATRIX_TYPE_GENERAL, 
#line 158
CUSPARSE_MATRIX_TYPE_SYMMETRIC, 
#line 159
CUSPARSE_MATRIX_TYPE_HERMITIAN, 
#line 160
CUSPARSE_MATRIX_TYPE_TRIANGULAR
#line 161
} cusparseMatrixType_t; 
#line 166
typedef 
#line 163
enum { 
#line 164
CUSPARSE_FILL_MODE_LOWER, 
#line 165
CUSPARSE_FILL_MODE_UPPER
#line 166
} cusparseFillMode_t; 
#line 171
typedef 
#line 168
enum { 
#line 169
CUSPARSE_DIAG_TYPE_NON_UNIT, 
#line 170
CUSPARSE_DIAG_TYPE_UNIT
#line 171
} cusparseDiagType_t; 
#line 176
typedef 
#line 173
enum { 
#line 174
CUSPARSE_INDEX_BASE_ZERO, 
#line 175
CUSPARSE_INDEX_BASE_ONE
#line 176
} cusparseIndexBase_t; 
#line 182
typedef 
#line 178
enum { 
#line 179
CUSPARSE_OPERATION_NON_TRANSPOSE, 
#line 180
CUSPARSE_OPERATION_TRANSPOSE, 
#line 181
CUSPARSE_OPERATION_CONJUGATE_TRANSPOSE
#line 182
} cusparseOperation_t; 
#line 187
typedef 
#line 184
enum { 
#line 185
CUSPARSE_DIRECTION_ROW, 
#line 186
CUSPARSE_DIRECTION_COLUMN
#line 187
} cusparseDirection_t; 
#line 193
typedef 
#line 189
enum { 
#line 190
CUSPARSE_HYB_PARTITION_AUTO, 
#line 191
CUSPARSE_HYB_PARTITION_USER, 
#line 192
CUSPARSE_HYB_PARTITION_MAX
#line 193
} cusparseHybPartition_t; 
#line 199
typedef 
#line 196
enum { 
#line 197
CUSPARSE_SOLVE_POLICY_NO_LEVEL, 
#line 198
CUSPARSE_SOLVE_POLICY_USE_LEVEL
#line 199
} cusparseSolvePolicy_t; 
#line 204
typedef 
#line 201
enum { 
#line 202
CUSPARSE_SIDE_LEFT, 
#line 203
CUSPARSE_SIDE_RIGHT
#line 204
} cusparseSideMode_t; 
#line 209
typedef 
#line 206
enum { 
#line 207
CUSPARSE_COLOR_ALG0, 
#line 208
CUSPARSE_COLOR_ALG1
#line 209
} cusparseColorAlg_t; 
#line 216
typedef 
#line 211
enum { 
#line 212
CUSPARSE_ALG0, 
#line 213
CUSPARSE_ALG1, 
#line 214
CUSPARSE_ALG_NAIVE = 0, 
#line 215
CUSPARSE_ALG_MERGE_PATH
#line 216
} cusparseAlgMode_t; 
#line 219
cusparseStatus_t __stdcall cusparseCreate(cusparseHandle_t * handle); 
#line 220
cusparseStatus_t __stdcall cusparseDestroy(cusparseHandle_t handle); 
#line 221
cusparseStatus_t __stdcall cusparseGetVersion(cusparseHandle_t handle, int * version); 
#line 222
cusparseStatus_t __stdcall cusparseGetProperty(libraryPropertyType type, int * value); 
#line 223
cusparseStatus_t __stdcall cusparseSetStream(cusparseHandle_t handle, cudaStream_t streamId); 
#line 224
cusparseStatus_t __stdcall cusparseGetStream(cusparseHandle_t handle, cudaStream_t * streamId); 
#line 228
cusparseStatus_t __stdcall cusparseGetPointerMode(cusparseHandle_t handle, cusparsePointerMode_t * mode); 
#line 229
cusparseStatus_t __stdcall cusparseSetPointerMode(cusparseHandle_t handle, cusparsePointerMode_t mode); 
#line 237
cusparseStatus_t __stdcall cusparseCreateMatDescr(cusparseMatDescr_t * descrA); 
#line 238
cusparseStatus_t __stdcall cusparseDestroyMatDescr(cusparseMatDescr_t descrA); 
#line 240
cusparseStatus_t __stdcall cusparseCopyMatDescr(cusparseMatDescr_t dest, const cusparseMatDescr_t src); 
#line 242
cusparseStatus_t __stdcall cusparseSetMatType(cusparseMatDescr_t descrA, cusparseMatrixType_t type); 
#line 243
cusparseMatrixType_t __stdcall cusparseGetMatType(const cusparseMatDescr_t descrA); 
#line 245
cusparseStatus_t __stdcall cusparseSetMatFillMode(cusparseMatDescr_t descrA, cusparseFillMode_t fillMode); 
#line 246
cusparseFillMode_t __stdcall cusparseGetMatFillMode(const cusparseMatDescr_t descrA); 
#line 248
cusparseStatus_t __stdcall cusparseSetMatDiagType(cusparseMatDescr_t descrA, cusparseDiagType_t diagType); 
#line 249
cusparseDiagType_t __stdcall cusparseGetMatDiagType(const cusparseMatDescr_t descrA); 
#line 251
cusparseStatus_t __stdcall cusparseSetMatIndexBase(cusparseMatDescr_t descrA, cusparseIndexBase_t base); 
#line 252
cusparseIndexBase_t __stdcall cusparseGetMatIndexBase(const cusparseMatDescr_t descrA); 
#line 255
cusparseStatus_t __stdcall cusparseCreateSolveAnalysisInfo(cusparseSolveAnalysisInfo_t * info); 
#line 256
cusparseStatus_t __stdcall cusparseDestroySolveAnalysisInfo(cusparseSolveAnalysisInfo_t info); 
#line 257
cusparseStatus_t __stdcall cusparseGetLevelInfo(cusparseHandle_t handle, cusparseSolveAnalysisInfo_t info, int * nlevels, int ** levelPtr, int ** levelInd); 
#line 264
cusparseStatus_t __stdcall cusparseCreateCsrsv2Info(csrsv2Info_t * info); 
#line 265
cusparseStatus_t __stdcall cusparseDestroyCsrsv2Info(csrsv2Info_t info); 
#line 268
cusparseStatus_t __stdcall cusparseCreateCsric02Info(csric02Info_t * info); 
#line 269
cusparseStatus_t __stdcall cusparseDestroyCsric02Info(csric02Info_t info); 
#line 271
cusparseStatus_t __stdcall cusparseCreateBsric02Info(bsric02Info_t * info); 
#line 272
cusparseStatus_t __stdcall cusparseDestroyBsric02Info(bsric02Info_t info); 
#line 275
cusparseStatus_t __stdcall cusparseCreateCsrilu02Info(csrilu02Info_t * info); 
#line 276
cusparseStatus_t __stdcall cusparseDestroyCsrilu02Info(csrilu02Info_t info); 
#line 278
cusparseStatus_t __stdcall cusparseCreateBsrilu02Info(bsrilu02Info_t * info); 
#line 279
cusparseStatus_t __stdcall cusparseDestroyBsrilu02Info(bsrilu02Info_t info); 
#line 282
cusparseStatus_t __stdcall cusparseCreateBsrsv2Info(bsrsv2Info_t * info); 
#line 283
cusparseStatus_t __stdcall cusparseDestroyBsrsv2Info(bsrsv2Info_t info); 
#line 285
cusparseStatus_t __stdcall cusparseCreateBsrsm2Info(bsrsm2Info_t * info); 
#line 286
cusparseStatus_t __stdcall cusparseDestroyBsrsm2Info(bsrsm2Info_t info); 
#line 289
cusparseStatus_t __stdcall cusparseCreateHybMat(cusparseHybMat_t * hybA); 
#line 290
cusparseStatus_t __stdcall cusparseDestroyHybMat(cusparseHybMat_t hybA); 
#line 293
cusparseStatus_t __stdcall cusparseCreateCsru2csrInfo(csru2csrInfo_t * info); 
#line 294
cusparseStatus_t __stdcall cusparseDestroyCsru2csrInfo(csru2csrInfo_t info); 
#line 297
cusparseStatus_t __stdcall cusparseCreateColorInfo(cusparseColorInfo_t * info); 
#line 298
cusparseStatus_t __stdcall cusparseDestroyColorInfo(cusparseColorInfo_t info); 
#line 300
cusparseStatus_t __stdcall cusparseSetColorAlgs(cusparseColorInfo_t info, cusparseColorAlg_t alg); 
#line 301
cusparseStatus_t __stdcall cusparseGetColorAlgs(cusparseColorInfo_t info, cusparseColorAlg_t * alg); 
#line 304
cusparseStatus_t __stdcall cusparseCreatePruneInfo(pruneInfo_t * info); 
#line 306
cusparseStatus_t __stdcall cusparseDestroyPruneInfo(pruneInfo_t info); 
#line 313
cusparseStatus_t __stdcall cusparseSaxpyi(cusparseHandle_t handle, int nnz, const float * alpha, const float * xVal, const int * xInd, float * y, cusparseIndexBase_t idxBase); 
#line 321
cusparseStatus_t __stdcall cusparseDaxpyi(cusparseHandle_t handle, int nnz, const double * alpha, const double * xVal, const int * xInd, double * y, cusparseIndexBase_t idxBase); 
#line 329
cusparseStatus_t __stdcall cusparseCaxpyi(cusparseHandle_t handle, int nnz, const cuComplex * alpha, const cuComplex * xVal, const int * xInd, cuComplex * y, cusparseIndexBase_t idxBase); 
#line 337
cusparseStatus_t __stdcall cusparseZaxpyi(cusparseHandle_t handle, int nnz, const cuDoubleComplex * alpha, const cuDoubleComplex * xVal, const int * xInd, cuDoubleComplex * y, cusparseIndexBase_t idxBase); 
#line 346
cusparseStatus_t __stdcall cusparseSdoti(cusparseHandle_t handle, int nnz, const float * xVal, const int * xInd, const float * y, float * resultDevHostPtr, cusparseIndexBase_t idxBase); 
#line 354
cusparseStatus_t __stdcall cusparseDdoti(cusparseHandle_t handle, int nnz, const double * xVal, const int * xInd, const double * y, double * resultDevHostPtr, cusparseIndexBase_t idxBase); 
#line 362
cusparseStatus_t __stdcall cusparseCdoti(cusparseHandle_t handle, int nnz, const cuComplex * xVal, const int * xInd, const cuComplex * y, cuComplex * resultDevHostPtr, cusparseIndexBase_t idxBase); 
#line 370
cusparseStatus_t __stdcall cusparseZdoti(cusparseHandle_t handle, int nnz, const cuDoubleComplex * xVal, const int * xInd, const cuDoubleComplex * y, cuDoubleComplex * resultDevHostPtr, cusparseIndexBase_t idxBase); 
#line 380
cusparseStatus_t __stdcall cusparseCdotci(cusparseHandle_t handle, int nnz, const cuComplex * xVal, const int * xInd, const cuComplex * y, cuComplex * resultDevHostPtr, cusparseIndexBase_t idxBase); 
#line 388
cusparseStatus_t __stdcall cusparseZdotci(cusparseHandle_t handle, int nnz, const cuDoubleComplex * xVal, const int * xInd, const cuDoubleComplex * y, cuDoubleComplex * resultDevHostPtr, cusparseIndexBase_t idxBase); 
#line 399
cusparseStatus_t __stdcall cusparseSgthr(cusparseHandle_t handle, int nnz, const float * y, float * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 406
cusparseStatus_t __stdcall cusparseDgthr(cusparseHandle_t handle, int nnz, const double * y, double * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 413
cusparseStatus_t __stdcall cusparseCgthr(cusparseHandle_t handle, int nnz, const cuComplex * y, cuComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 420
cusparseStatus_t __stdcall cusparseZgthr(cusparseHandle_t handle, int nnz, const cuDoubleComplex * y, cuDoubleComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 429
cusparseStatus_t __stdcall cusparseSgthrz(cusparseHandle_t handle, int nnz, float * y, float * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 436
cusparseStatus_t __stdcall cusparseDgthrz(cusparseHandle_t handle, int nnz, double * y, double * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 443
cusparseStatus_t __stdcall cusparseCgthrz(cusparseHandle_t handle, int nnz, cuComplex * y, cuComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 450
cusparseStatus_t __stdcall cusparseZgthrz(cusparseHandle_t handle, int nnz, cuDoubleComplex * y, cuDoubleComplex * xVal, const int * xInd, cusparseIndexBase_t idxBase); 
#line 459
cusparseStatus_t __stdcall cusparseSsctr(cusparseHandle_t handle, int nnz, const float * xVal, const int * xInd, float * y, cusparseIndexBase_t idxBase); 
#line 466
cusparseStatus_t __stdcall cusparseDsctr(cusparseHandle_t handle, int nnz, const double * xVal, const int * xInd, double * y, cusparseIndexBase_t idxBase); 
#line 473
cusparseStatus_t __stdcall cusparseCsctr(cusparseHandle_t handle, int nnz, const cuComplex * xVal, const int * xInd, cuComplex * y, cusparseIndexBase_t idxBase); 
#line 480
cusparseStatus_t __stdcall cusparseZsctr(cusparseHandle_t handle, int nnz, const cuDoubleComplex * xVal, const int * xInd, cuDoubleComplex * y, cusparseIndexBase_t idxBase); 
#line 489
cusparseStatus_t __stdcall cusparseSroti(cusparseHandle_t handle, int nnz, float * xVal, const int * xInd, float * y, const float * c, const float * s, cusparseIndexBase_t idxBase); 
#line 498
cusparseStatus_t __stdcall cusparseDroti(cusparseHandle_t handle, int nnz, double * xVal, const int * xInd, double * y, const double * c, const double * s, cusparseIndexBase_t idxBase); 
#line 510
cusparseStatus_t __stdcall cusparseSgemvi(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const float * alpha, const float * A, int lda, int nnz, const float * xVal, const int * xInd, const float * beta, float * y, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 525
cusparseStatus_t __stdcall cusparseSgemvi_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize); 
#line 532
cusparseStatus_t __stdcall cusparseDgemvi(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const double * alpha, const double * A, int lda, int nnz, const double * xVal, const int * xInd, const double * beta, double * y, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 547
cusparseStatus_t __stdcall cusparseDgemvi_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize); 
#line 554
cusparseStatus_t __stdcall cusparseCgemvi(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuComplex * alpha, const cuComplex * A, int lda, int nnz, const cuComplex * xVal, const int * xInd, const cuComplex * beta, cuComplex * y, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 569
cusparseStatus_t __stdcall cusparseCgemvi_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize); 
#line 576
cusparseStatus_t __stdcall cusparseZgemvi(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, int nnz, const cuDoubleComplex * xVal, const int * xInd, const cuDoubleComplex * beta, cuDoubleComplex * y, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 591
cusparseStatus_t __stdcall cusparseZgemvi_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, int * pBufferSize); 
#line 601
cusparseStatus_t __stdcall cusparseScsrmv(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * x, const float * beta, float * y); 
#line 615
cusparseStatus_t __stdcall cusparseDcsrmv(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * x, const double * beta, double * y); 
#line 629
cusparseStatus_t __stdcall cusparseCcsrmv(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * x, const cuComplex * beta, cuComplex * y); 
#line 643
cusparseStatus_t __stdcall cusparseZcsrmv(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y); 
#line 658
cusparseStatus_t __stdcall cusparseCsrmvEx_bufferSize(cusparseHandle_t handle, cusparseAlgMode_t alg, cusparseOperation_t transA, int m, int n, int nnz, const void * alpha, cudaDataType alphatype, const cusparseMatDescr_t descrA, const void * csrValA, cudaDataType csrValAtype, const int * csrRowPtrA, const int * csrColIndA, const void * x, cudaDataType xtype, const void * beta, cudaDataType betatype, void * y, cudaDataType ytype, cudaDataType executiontype, size_t * bufferSizeInBytes); 
#line 680
cusparseStatus_t __stdcall cusparseCsrmvEx(cusparseHandle_t handle, cusparseAlgMode_t alg, cusparseOperation_t transA, int m, int n, int nnz, const void * alpha, cudaDataType alphatype, const cusparseMatDescr_t descrA, const void * csrValA, cudaDataType csrValAtype, const int * csrRowPtrA, const int * csrColIndA, const void * x, cudaDataType xtype, const void * beta, cudaDataType betatype, void * y, cudaDataType ytype, cudaDataType executiontype, void * buffer); 
#line 705
cusparseStatus_t __stdcall cusparseScsrmv_mp(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * x, const float * beta, float * y); 
#line 719
cusparseStatus_t __stdcall cusparseDcsrmv_mp(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * x, const double * beta, double * y); 
#line 733
cusparseStatus_t __stdcall cusparseCcsrmv_mp(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * x, const cuComplex * beta, cuComplex * y); 
#line 747
cusparseStatus_t __stdcall cusparseZcsrmv_mp(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y); 
#line 763
cusparseStatus_t __stdcall cusparseShybmv(cusparseHandle_t handle, cusparseOperation_t transA, const float * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, const float * x, const float * beta, float * y); 
#line 772
cusparseStatus_t __stdcall cusparseDhybmv(cusparseHandle_t handle, cusparseOperation_t transA, const double * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, const double * x, const double * beta, double * y); 
#line 781
cusparseStatus_t __stdcall cusparseChybmv(cusparseHandle_t handle, cusparseOperation_t transA, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, const cuComplex * x, const cuComplex * beta, cuComplex * y); 
#line 790
cusparseStatus_t __stdcall cusparseZhybmv(cusparseHandle_t handle, cusparseOperation_t transA, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y); 
#line 801
cusparseStatus_t __stdcall cusparseSbsrmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const float * alpha, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const float * x, const float * beta, float * y); 
#line 817
cusparseStatus_t __stdcall cusparseDbsrmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const double * alpha, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const double * x, const double * beta, double * y); 
#line 833
cusparseStatus_t __stdcall cusparseCbsrmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cuComplex * x, const cuComplex * beta, cuComplex * y); 
#line 849
cusparseStatus_t __stdcall cusparseZbsrmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nb, int nnzb, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y); 
#line 868
cusparseStatus_t __stdcall cusparseSbsrxmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const float * alpha, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const float * x, const float * beta, float * y); 
#line 888
cusparseStatus_t __stdcall cusparseDbsrxmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const double * alpha, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const double * x, const double * beta, double * y); 
#line 907
cusparseStatus_t __stdcall cusparseCbsrxmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const cuComplex * x, const cuComplex * beta, cuComplex * y); 
#line 927
cusparseStatus_t __stdcall cusparseZbsrxmv(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int sizeOfMask, int mb, int nb, int nnzb, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedMaskPtrA, const int * bsrSortedRowPtrA, const int * bsrSortedEndPtrA, const int * bsrSortedColIndA, int blockDim, const cuDoubleComplex * x, const cuDoubleComplex * beta, cuDoubleComplex * y); 
#line 949
cusparseStatus_t __stdcall cusparseCsrsv_analysisEx(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const void * csrSortedValA, cudaDataType csrSortedValAtype, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, cudaDataType executiontype); 
#line 961
cusparseStatus_t __stdcall cusparseScsrsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 971
cusparseStatus_t __stdcall cusparseDcsrsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 981
cusparseStatus_t __stdcall cusparseCcsrsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 991
cusparseStatus_t __stdcall cusparseZcsrsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 1001
cusparseStatus_t __stdcall cusparseCsrsv_solveEx(cusparseHandle_t handle, cusparseOperation_t transA, int m, const void * alpha, cudaDataType alphatype, const cusparseMatDescr_t descrA, const void * csrSortedValA, cudaDataType csrSortedValAtype, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const void * f, cudaDataType ftype, void * x, cudaDataType xtype, cudaDataType executiontype); 
#line 1018
cusparseStatus_t __stdcall cusparseScsrsv_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const float * f, float * x); 
#line 1030
cusparseStatus_t __stdcall cusparseDcsrsv_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const double * f, double * x); 
#line 1042
cusparseStatus_t __stdcall cusparseCcsrsv_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuComplex * f, cuComplex * x); 
#line 1054
cusparseStatus_t __stdcall cusparseZcsrsv_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuDoubleComplex * f, cuDoubleComplex * x); 
#line 1070
cusparseStatus_t __stdcall cusparseXcsrsv2_zeroPivot(cusparseHandle_t handle, csrsv2Info_t info, int * position); 
#line 1074
cusparseStatus_t __stdcall cusparseScsrsv2_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1085
cusparseStatus_t __stdcall cusparseDcsrsv2_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1096
cusparseStatus_t __stdcall cusparseCcsrsv2_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1107
cusparseStatus_t __stdcall cusparseZcsrsv2_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1118
cusparseStatus_t __stdcall cusparseScsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, size_t * pBufferSize); 
#line 1129
cusparseStatus_t __stdcall cusparseDcsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, size_t * pBufferSize); 
#line 1140
cusparseStatus_t __stdcall cusparseCcsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, size_t * pBufferSize); 
#line 1151
cusparseStatus_t __stdcall cusparseZcsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, size_t * pBufferSize); 
#line 1163
cusparseStatus_t __stdcall cusparseScsrsv2_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1175
cusparseStatus_t __stdcall cusparseDcsrsv2_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1187
cusparseStatus_t __stdcall cusparseCcsrsv2_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1199
cusparseStatus_t __stdcall cusparseZcsrsv2_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1211
cusparseStatus_t __stdcall cusparseScsrsv2_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const float * f, float * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1226
cusparseStatus_t __stdcall cusparseDcsrsv2_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const double * f, double * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1241
cusparseStatus_t __stdcall cusparseCcsrsv2_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const cuComplex * f, cuComplex * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1256
cusparseStatus_t __stdcall cusparseZcsrsv2_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrsv2Info_t info, const cuDoubleComplex * f, cuDoubleComplex * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1275
cusparseStatus_t __stdcall cusparseXbsrsv2_zeroPivot(cusparseHandle_t handle, bsrsv2Info_t info, int * position); 
#line 1280
cusparseStatus_t __stdcall cusparseSbsrsv2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1293
cusparseStatus_t __stdcall cusparseDbsrsv2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1306
cusparseStatus_t __stdcall cusparseCbsrsv2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1319
cusparseStatus_t __stdcall cusparseZbsrsv2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, int * pBufferSizeInBytes); 
#line 1332
cusparseStatus_t __stdcall cusparseSbsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockSize, bsrsv2Info_t info, size_t * pBufferSize); 
#line 1345
cusparseStatus_t __stdcall cusparseDbsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockSize, bsrsv2Info_t info, size_t * pBufferSize); 
#line 1358
cusparseStatus_t __stdcall cusparseCbsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockSize, bsrsv2Info_t info, size_t * pBufferSize); 
#line 1371
cusparseStatus_t __stdcall cusparseZbsrsv2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockSize, bsrsv2Info_t info, size_t * pBufferSize); 
#line 1385
cusparseStatus_t __stdcall cusparseSbsrsv2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1399
cusparseStatus_t __stdcall cusparseDbsrsv2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1413
cusparseStatus_t __stdcall cusparseCbsrsv2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1427
cusparseStatus_t __stdcall cusparseZbsrsv2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1442
cusparseStatus_t __stdcall cusparseSbsrsv2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const float * alpha, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const float * f, float * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1460
cusparseStatus_t __stdcall cusparseDbsrsv2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const double * alpha, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const double * f, double * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1478
cusparseStatus_t __stdcall cusparseCbsrsv2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const cuComplex * f, cuComplex * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1496
cusparseStatus_t __stdcall cusparseZbsrsv2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, int mb, int nnzb, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, bsrsv2Info_t info, const cuDoubleComplex * f, cuDoubleComplex * x, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 1516
cusparseStatus_t __stdcall cusparseShybsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, const cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info); 
#line 1522
cusparseStatus_t __stdcall cusparseDhybsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, const cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info); 
#line 1528
cusparseStatus_t __stdcall cusparseChybsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, const cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info); 
#line 1534
cusparseStatus_t __stdcall cusparseZhybsv_analysis(cusparseHandle_t handle, cusparseOperation_t transA, const cusparseMatDescr_t descrA, cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info); 
#line 1540
cusparseStatus_t __stdcall cusparseShybsv_solve(cusparseHandle_t handle, cusparseOperation_t trans, const float * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const float * f, float * x); 
#line 1549
cusparseStatus_t __stdcall cusparseChybsv_solve(cusparseHandle_t handle, cusparseOperation_t trans, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const cuComplex * f, cuComplex * x); 
#line 1558
cusparseStatus_t __stdcall cusparseDhybsv_solve(cusparseHandle_t handle, cusparseOperation_t trans, const double * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const double * f, double * x); 
#line 1567
cusparseStatus_t __stdcall cusparseZhybsv_solve(cusparseHandle_t handle, cusparseOperation_t trans, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cusparseSolveAnalysisInfo_t info, const cuDoubleComplex * f, cuDoubleComplex * x); 
#line 1581
cusparseStatus_t __stdcall cusparseScsrmm(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * B, int ldb, const float * beta, float * C, int ldc); 
#line 1598
cusparseStatus_t __stdcall cusparseDcsrmm(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * B, int ldb, const double * beta, double * C, int ldc); 
#line 1615
cusparseStatus_t __stdcall cusparseCcsrmm(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
#line 1632
cusparseStatus_t __stdcall cusparseZcsrmm(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, int k, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
#line 1652
cusparseStatus_t __stdcall cusparseScsrmm2(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * B, int ldb, const float * beta, float * C, int ldc); 
#line 1670
cusparseStatus_t __stdcall cusparseDcsrmm2(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * B, int ldb, const double * beta, double * C, int ldc); 
#line 1688
cusparseStatus_t __stdcall cusparseCcsrmm2(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * B, int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
#line 1706
cusparseStatus_t __stdcall cusparseZcsrmm2(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * B, int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
#line 1727
cusparseStatus_t __stdcall cusparseSbsrmm(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const float * alpha, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const float * B, const int ldb, const float * beta, float * C, int ldc); 
#line 1747
cusparseStatus_t __stdcall cusparseDbsrmm(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const double * alpha, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const double * B, const int ldb, const double * beta, double * C, int ldc); 
#line 1767
cusparseStatus_t __stdcall cusparseCbsrmm(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const cuComplex * B, const int ldb, const cuComplex * beta, cuComplex * C, int ldc); 
#line 1787
cusparseStatus_t __stdcall cusparseZbsrmm(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int kb, int nnzb, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, const int blockSize, const cuDoubleComplex * B, const int ldb, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
#line 1811
cusparseStatus_t __stdcall cusparseSgemmi(cusparseHandle_t handle, int m, int n, int k, int nnz, const float * alpha, const float * A, int lda, const float * cscValB, const int * cscColPtrB, const int * cscRowIndB, const float * beta, float * C, int ldc); 
#line 1826
cusparseStatus_t __stdcall cusparseDgemmi(cusparseHandle_t handle, int m, int n, int k, int nnz, const double * alpha, const double * A, int lda, const double * cscValB, const int * cscColPtrB, const int * cscRowIndB, const double * beta, double * C, int ldc); 
#line 1841
cusparseStatus_t __stdcall cusparseCgemmi(cusparseHandle_t handle, int m, int n, int k, int nnz, const cuComplex * alpha, const cuComplex * A, int lda, const cuComplex * cscValB, const int * cscColPtrB, const int * cscRowIndB, const cuComplex * beta, cuComplex * C, int ldc); 
#line 1856
cusparseStatus_t __stdcall cusparseZgemmi(cusparseHandle_t handle, int m, int n, int k, int nnz, const cuDoubleComplex * alpha, const cuDoubleComplex * A, int lda, const cuDoubleComplex * cscValB, const int * cscColPtrB, const int * cscRowIndB, const cuDoubleComplex * beta, cuDoubleComplex * C, int ldc); 
#line 1876
cusparseStatus_t __stdcall cusparseScsrsm_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 1886
cusparseStatus_t __stdcall cusparseDcsrsm_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 1896
cusparseStatus_t __stdcall cusparseCcsrsm_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 1906
cusparseStatus_t __stdcall cusparseZcsrsm_analysis(cusparseHandle_t handle, cusparseOperation_t transA, int m, int nnz, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 1917
cusparseStatus_t __stdcall cusparseScsrsm_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const float * B, int ldb, float * X, int ldx); 
#line 1932
cusparseStatus_t __stdcall cusparseDcsrsm_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const double * B, int ldb, double * X, int ldx); 
#line 1947
cusparseStatus_t __stdcall cusparseCcsrsm_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuComplex * B, int ldb, cuComplex * X, int ldx); 
#line 1962
cusparseStatus_t __stdcall cusparseZcsrsm_solve(cusparseHandle_t handle, cusparseOperation_t transA, int m, int n, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, const cuDoubleComplex * B, int ldb, cuDoubleComplex * X, int ldx); 
#line 1977
cusparseStatus_t __stdcall cusparseCreateCsrsm2Info(csrsm2Info_t * info); 
#line 1980
cusparseStatus_t __stdcall cusparseDestroyCsrsm2Info(csrsm2Info_t info); 
#line 1983
cusparseStatus_t __stdcall cusparseXcsrsm2_zeroPivot(cusparseHandle_t handle, csrsm2Info_t info, int * position); 
#line 1988
cusparseStatus_t __stdcall cusparseScsrsm2_bufferSizeExt(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, size_t * pBufferSize); 
#line 2007
cusparseStatus_t __stdcall cusparseDcsrsm2_bufferSizeExt(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, size_t * pBufferSize); 
#line 2026
cusparseStatus_t __stdcall cusparseCcsrsm2_bufferSizeExt(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, size_t * pBufferSize); 
#line 2045
cusparseStatus_t __stdcall cusparseZcsrsm2_bufferSizeExt(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, size_t * pBufferSize); 
#line 2064
cusparseStatus_t __stdcall cusparseScsrsm2_analysis(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2083
cusparseStatus_t __stdcall cusparseDcsrsm2_analysis(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2102
cusparseStatus_t __stdcall cusparseCcsrsm2_analysis(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2121
cusparseStatus_t __stdcall cusparseZcsrsm2_analysis(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2140
cusparseStatus_t __stdcall cusparseScsrsm2_solve(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const float * alpha, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2159
cusparseStatus_t __stdcall cusparseDcsrsm2_solve(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const double * alpha, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, double * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2178
cusparseStatus_t __stdcall cusparseCcsrsm2_solve(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cuComplex * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2197
cusparseStatus_t __stdcall cusparseZcsrsm2_solve(cusparseHandle_t handle, int algo, cusparseOperation_t transA, cusparseOperation_t transB, int m, int nrhs, int nnz, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cuDoubleComplex * B, int ldb, csrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2221
cusparseStatus_t __stdcall cusparseXbsrsm2_zeroPivot(cusparseHandle_t handle, bsrsm2Info_t info, int * position); 
#line 2225
cusparseStatus_t __stdcall cusparseSbsrsm2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes); 
#line 2240
cusparseStatus_t __stdcall cusparseDbsrsm2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes); 
#line 2255
cusparseStatus_t __stdcall cusparseCbsrsm2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes); 
#line 2270
cusparseStatus_t __stdcall cusparseZbsrsm2_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, int * pBufferSizeInBytes); 
#line 2286
cusparseStatus_t __stdcall cusparseSbsrsm2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, size_t * pBufferSize); 
#line 2301
cusparseStatus_t __stdcall cusparseDbsrsm2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, size_t * pBufferSize); 
#line 2316
cusparseStatus_t __stdcall cusparseCbsrsm2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, size_t * pBufferSize); 
#line 2331
cusparseStatus_t __stdcall cusparseZbsrsm2_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transB, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, size_t * pBufferSize); 
#line 2347
cusparseStatus_t __stdcall cusparseSbsrsm2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2363
cusparseStatus_t __stdcall cusparseDbsrsm2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2379
cusparseStatus_t __stdcall cusparseCbsrsm2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2395
cusparseStatus_t __stdcall cusparseZbsrsm2_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2412
cusparseStatus_t __stdcall cusparseSbsrsm2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const float * alpha, const cusparseMatDescr_t descrA, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const float * B, int ldb, float * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2433
cusparseStatus_t __stdcall cusparseDbsrsm2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const double * alpha, const cusparseMatDescr_t descrA, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const double * B, int ldb, double * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2454
cusparseStatus_t __stdcall cusparseCbsrsm2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cuComplex * alpha, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const cuComplex * B, int ldb, cuComplex * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2475
cusparseStatus_t __stdcall cusparseZbsrsm2_solve(cusparseHandle_t handle, cusparseDirection_t dirA, cusparseOperation_t transA, cusparseOperation_t transXY, int mb, int n, int nnzb, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrsm2Info_t info, const cuDoubleComplex * B, int ldb, cuDoubleComplex * X, int ldx, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2503
cusparseStatus_t __stdcall cusparseCsrilu0Ex(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, void * csrSortedValA_ValM, cudaDataType csrSortedValA_ValMtype, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info, cudaDataType executiontype); 
#line 2516
cusparseStatus_t __stdcall cusparseScsrilu0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, float * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 2527
cusparseStatus_t __stdcall cusparseDcsrilu0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, double * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 2538
cusparseStatus_t __stdcall cusparseCcsrilu0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 2549
cusparseStatus_t __stdcall cusparseZcsrilu0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 2564
cusparseStatus_t __stdcall cusparseScsrilu02_numericBoost(cusparseHandle_t handle, csrilu02Info_t info, int enable_boost, double * tol, float * boost_val); 
#line 2570
cusparseStatus_t __stdcall cusparseDcsrilu02_numericBoost(cusparseHandle_t handle, csrilu02Info_t info, int enable_boost, double * tol, double * boost_val); 
#line 2576
cusparseStatus_t __stdcall cusparseCcsrilu02_numericBoost(cusparseHandle_t handle, csrilu02Info_t info, int enable_boost, double * tol, cuComplex * boost_val); 
#line 2582
cusparseStatus_t __stdcall cusparseZcsrilu02_numericBoost(cusparseHandle_t handle, csrilu02Info_t info, int enable_boost, double * tol, cuDoubleComplex * boost_val); 
#line 2588
cusparseStatus_t __stdcall cusparseXcsrilu02_zeroPivot(cusparseHandle_t handle, csrilu02Info_t info, int * position); 
#line 2592
cusparseStatus_t __stdcall cusparseScsrilu02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2602
cusparseStatus_t __stdcall cusparseDcsrilu02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2612
cusparseStatus_t __stdcall cusparseCcsrilu02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2622
cusparseStatus_t __stdcall cusparseZcsrilu02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2632
cusparseStatus_t __stdcall cusparseScsrilu02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csrilu02Info_t info, size_t * pBufferSize); 
#line 2642
cusparseStatus_t __stdcall cusparseDcsrilu02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csrilu02Info_t info, size_t * pBufferSize); 
#line 2652
cusparseStatus_t __stdcall cusparseCcsrilu02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csrilu02Info_t info, size_t * pBufferSize); 
#line 2662
cusparseStatus_t __stdcall cusparseZcsrilu02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csrilu02Info_t info, size_t * pBufferSize); 
#line 2672
cusparseStatus_t __stdcall cusparseScsrilu02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2683
cusparseStatus_t __stdcall cusparseDcsrilu02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2694
cusparseStatus_t __stdcall cusparseCcsrilu02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2705
cusparseStatus_t __stdcall cusparseZcsrilu02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2716
cusparseStatus_t __stdcall cusparseScsrilu02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2729
cusparseStatus_t __stdcall cusparseDcsrilu02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2742
cusparseStatus_t __stdcall cusparseCcsrilu02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2755
cusparseStatus_t __stdcall cusparseZcsrilu02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2772
cusparseStatus_t __stdcall cusparseSbsrilu02_numericBoost(cusparseHandle_t handle, bsrilu02Info_t info, int enable_boost, double * tol, float * boost_val); 
#line 2778
cusparseStatus_t __stdcall cusparseDbsrilu02_numericBoost(cusparseHandle_t handle, bsrilu02Info_t info, int enable_boost, double * tol, double * boost_val); 
#line 2784
cusparseStatus_t __stdcall cusparseCbsrilu02_numericBoost(cusparseHandle_t handle, bsrilu02Info_t info, int enable_boost, double * tol, cuComplex * boost_val); 
#line 2790
cusparseStatus_t __stdcall cusparseZbsrilu02_numericBoost(cusparseHandle_t handle, bsrilu02Info_t info, int enable_boost, double * tol, cuDoubleComplex * boost_val); 
#line 2796
cusparseStatus_t __stdcall cusparseXbsrilu02_zeroPivot(cusparseHandle_t handle, bsrilu02Info_t info, int * position); 
#line 2800
cusparseStatus_t __stdcall cusparseSbsrilu02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2812
cusparseStatus_t __stdcall cusparseDbsrilu02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2824
cusparseStatus_t __stdcall cusparseCbsrilu02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2836
cusparseStatus_t __stdcall cusparseZbsrilu02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, int * pBufferSizeInBytes); 
#line 2848
cusparseStatus_t __stdcall cusparseSbsrilu02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrilu02Info_t info, size_t * pBufferSize); 
#line 2860
cusparseStatus_t __stdcall cusparseDbsrilu02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrilu02Info_t info, size_t * pBufferSize); 
#line 2872
cusparseStatus_t __stdcall cusparseCbsrilu02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrilu02Info_t info, size_t * pBufferSize); 
#line 2884
cusparseStatus_t __stdcall cusparseZbsrilu02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsrilu02Info_t info, size_t * pBufferSize); 
#line 2897
cusparseStatus_t __stdcall cusparseSbsrilu02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2910
cusparseStatus_t __stdcall cusparseDbsrilu02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2923
cusparseStatus_t __stdcall cusparseCbsrilu02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2936
cusparseStatus_t __stdcall cusparseZbsrilu02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2950
cusparseStatus_t __stdcall cusparseSbsrilu02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2963
cusparseStatus_t __stdcall cusparseDbsrilu02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2976
cusparseStatus_t __stdcall cusparseCbsrilu02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 2989
cusparseStatus_t __stdcall cusparseZbsrilu02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsrilu02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3006
cusparseStatus_t __stdcall cusparseScsric0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, float * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 3017
cusparseStatus_t __stdcall cusparseDcsric0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, double * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 3028
cusparseStatus_t __stdcall cusparseCcsric0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 3039
cusparseStatus_t __stdcall cusparseZcsric0(cusparseHandle_t handle, cusparseOperation_t trans, int m, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA_ValM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseSolveAnalysisInfo_t info); 
#line 3054
cusparseStatus_t __stdcall cusparseXcsric02_zeroPivot(cusparseHandle_t handle, csric02Info_t info, int * position); 
#line 3058
cusparseStatus_t __stdcall cusparseScsric02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, int * pBufferSizeInBytes); 
#line 3068
cusparseStatus_t __stdcall cusparseDcsric02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, int * pBufferSizeInBytes); 
#line 3078
cusparseStatus_t __stdcall cusparseCcsric02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, int * pBufferSizeInBytes); 
#line 3088
cusparseStatus_t __stdcall cusparseZcsric02_bufferSize(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, int * pBufferSizeInBytes); 
#line 3098
cusparseStatus_t __stdcall cusparseScsric02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csric02Info_t info, size_t * pBufferSize); 
#line 3108
cusparseStatus_t __stdcall cusparseDcsric02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csric02Info_t info, size_t * pBufferSize); 
#line 3118
cusparseStatus_t __stdcall cusparseCcsric02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csric02Info_t info, size_t * pBufferSize); 
#line 3128
cusparseStatus_t __stdcall cusparseZcsric02_bufferSizeExt(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, csric02Info_t info, size_t * pBufferSize); 
#line 3139
cusparseStatus_t __stdcall cusparseScsric02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3151
cusparseStatus_t __stdcall cusparseDcsric02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3162
cusparseStatus_t __stdcall cusparseCcsric02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3173
cusparseStatus_t __stdcall cusparseZcsric02_analysis(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3184
cusparseStatus_t __stdcall cusparseScsric02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, float * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3197
cusparseStatus_t __stdcall cusparseDcsric02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, double * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3210
cusparseStatus_t __stdcall cusparseCcsric02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3223
cusparseStatus_t __stdcall cusparseZcsric02(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrSortedValA_valM, const int * csrSortedRowPtrA, const int * csrSortedColIndA, csric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3240
cusparseStatus_t __stdcall cusparseXbsric02_zeroPivot(cusparseHandle_t handle, bsric02Info_t info, int * position); 
#line 3244
cusparseStatus_t __stdcall cusparseSbsric02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, int * pBufferSizeInBytes); 
#line 3256
cusparseStatus_t __stdcall cusparseDbsric02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, int * pBufferSizeInBytes); 
#line 3268
cusparseStatus_t __stdcall cusparseCbsric02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, int * pBufferSizeInBytes); 
#line 3280
cusparseStatus_t __stdcall cusparseZbsric02_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, int * pBufferSizeInBytes); 
#line 3292
cusparseStatus_t __stdcall cusparseSbsric02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsric02Info_t info, size_t * pBufferSize); 
#line 3304
cusparseStatus_t __stdcall cusparseDbsric02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsric02Info_t info, size_t * pBufferSize); 
#line 3316
cusparseStatus_t __stdcall cusparseCbsric02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsric02Info_t info, size_t * pBufferSize); 
#line 3328
cusparseStatus_t __stdcall cusparseZbsric02_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockSize, bsric02Info_t info, size_t * pBufferSize); 
#line 3342
cusparseStatus_t __stdcall cusparseSbsric02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pInputBuffer); 
#line 3355
cusparseStatus_t __stdcall cusparseDbsric02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pInputBuffer); 
#line 3368
cusparseStatus_t __stdcall cusparseCbsric02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pInputBuffer); 
#line 3381
cusparseStatus_t __stdcall cusparseZbsric02_analysis(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pInputBuffer); 
#line 3394
cusparseStatus_t __stdcall cusparseSbsric02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3407
cusparseStatus_t __stdcall cusparseDbsric02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3420
cusparseStatus_t __stdcall cusparseCbsric02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3433
cusparseStatus_t __stdcall cusparseZbsric02(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nnzb, const cusparseMatDescr_t descrA, cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int blockDim, bsric02Info_t info, cusparseSolvePolicy_t policy, void * pBuffer); 
#line 3452
cusparseStatus_t __stdcall cusparseSgtsv(cusparseHandle_t handle, int m, int n, const float * dl, const float * d, const float * du, float * B, int ldb); 
#line 3462
cusparseStatus_t __stdcall cusparseDgtsv(cusparseHandle_t handle, int m, int n, const double * dl, const double * d, const double * du, double * B, int ldb); 
#line 3472
cusparseStatus_t __stdcall cusparseCgtsv(cusparseHandle_t handle, int m, int n, const cuComplex * dl, const cuComplex * d, const cuComplex * du, cuComplex * B, int ldb); 
#line 3482
cusparseStatus_t __stdcall cusparseZgtsv(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, cuDoubleComplex * B, int ldb); 
#line 3493
cusparseStatus_t __stdcall cusparseSgtsv2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const float * dl, const float * d, const float * du, const float * B, int ldb, size_t * bufferSizeInBytes); 
#line 3504
cusparseStatus_t __stdcall cusparseDgtsv2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const double * dl, const double * d, const double * du, const double * B, int ldb, size_t * bufferSizeInBytes); 
#line 3515
cusparseStatus_t __stdcall cusparseCgtsv2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const cuComplex * dl, const cuComplex * d, const cuComplex * du, const cuComplex * B, int ldb, size_t * bufferSizeInBytes); 
#line 3526
cusparseStatus_t __stdcall cusparseZgtsv2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, const cuDoubleComplex * B, int ldb, size_t * bufferSizeInBytes); 
#line 3537
cusparseStatus_t __stdcall cusparseSgtsv2(cusparseHandle_t handle, int m, int n, const float * dl, const float * d, const float * du, float * B, int ldb, void * pBuffer); 
#line 3548
cusparseStatus_t __stdcall cusparseDgtsv2(cusparseHandle_t handle, int m, int n, const double * dl, const double * d, const double * du, double * B, int ldb, void * pBuffer); 
#line 3559
cusparseStatus_t __stdcall cusparseCgtsv2(cusparseHandle_t handle, int m, int n, const cuComplex * dl, const cuComplex * d, const cuComplex * du, cuComplex * B, int ldb, void * pBuffer); 
#line 3570
cusparseStatus_t __stdcall cusparseZgtsv2(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, cuDoubleComplex * B, int ldb, void * pBuffer); 
#line 3587
cusparseStatus_t __stdcall cusparseSgtsv_nopivot(cusparseHandle_t handle, int m, int n, const float * dl, const float * d, const float * du, float * B, int ldb); 
#line 3597
cusparseStatus_t __stdcall cusparseDgtsv_nopivot(cusparseHandle_t handle, int m, int n, const double * dl, const double * d, const double * du, double * B, int ldb); 
#line 3607
cusparseStatus_t __stdcall cusparseCgtsv_nopivot(cusparseHandle_t handle, int m, int n, const cuComplex * dl, const cuComplex * d, const cuComplex * du, cuComplex * B, int ldb); 
#line 3617
cusparseStatus_t __stdcall cusparseZgtsv_nopivot(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, cuDoubleComplex * B, int ldb); 
#line 3628
cusparseStatus_t __stdcall cusparseSgtsv2_nopivot_bufferSizeExt(cusparseHandle_t handle, int m, int n, const float * dl, const float * d, const float * du, const float * B, int ldb, size_t * bufferSizeInBytes); 
#line 3639
cusparseStatus_t __stdcall cusparseDgtsv2_nopivot_bufferSizeExt(cusparseHandle_t handle, int m, int n, const double * dl, const double * d, const double * du, const double * B, int ldb, size_t * bufferSizeInBytes); 
#line 3650
cusparseStatus_t __stdcall cusparseCgtsv2_nopivot_bufferSizeExt(cusparseHandle_t handle, int m, int n, const cuComplex * dl, const cuComplex * d, const cuComplex * du, const cuComplex * B, int ldb, size_t * bufferSizeInBytes); 
#line 3661
cusparseStatus_t __stdcall cusparseZgtsv2_nopivot_bufferSizeExt(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, const cuDoubleComplex * B, int ldb, size_t * bufferSizeInBytes); 
#line 3672
cusparseStatus_t __stdcall cusparseSgtsv2_nopivot(cusparseHandle_t handle, int m, int n, const float * dl, const float * d, const float * du, float * B, int ldb, void * pBuffer); 
#line 3683
cusparseStatus_t __stdcall cusparseDgtsv2_nopivot(cusparseHandle_t handle, int m, int n, const double * dl, const double * d, const double * du, double * B, int ldb, void * pBuffer); 
#line 3694
cusparseStatus_t __stdcall cusparseCgtsv2_nopivot(cusparseHandle_t handle, int m, int n, const cuComplex * dl, const cuComplex * d, const cuComplex * du, cuComplex * B, int ldb, void * pBuffer); 
#line 3705
cusparseStatus_t __stdcall cusparseZgtsv2_nopivot(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, cuDoubleComplex * B, int ldb, void * pBuffer); 
#line 3721
cusparseStatus_t __stdcall cusparseSgtsvStridedBatch(cusparseHandle_t handle, int m, const float * dl, const float * d, const float * du, float * x, int batchCount, int batchStride); 
#line 3731
cusparseStatus_t __stdcall cusparseDgtsvStridedBatch(cusparseHandle_t handle, int m, const double * dl, const double * d, const double * du, double * x, int batchCount, int batchStride); 
#line 3741
cusparseStatus_t __stdcall cusparseCgtsvStridedBatch(cusparseHandle_t handle, int m, const cuComplex * dl, const cuComplex * d, const cuComplex * du, cuComplex * x, int batchCount, int batchStride); 
#line 3751
cusparseStatus_t __stdcall cusparseZgtsvStridedBatch(cusparseHandle_t handle, int m, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, cuDoubleComplex * x, int batchCount, int batchStride); 
#line 3762
cusparseStatus_t __stdcall cusparseSgtsv2StridedBatch_bufferSizeExt(cusparseHandle_t handle, int m, const float * dl, const float * d, const float * du, const float * x, int batchCount, int batchStride, size_t * bufferSizeInBytes); 
#line 3773
cusparseStatus_t __stdcall cusparseDgtsv2StridedBatch_bufferSizeExt(cusparseHandle_t handle, int m, const double * dl, const double * d, const double * du, const double * x, int batchCount, int batchStride, size_t * bufferSizeInBytes); 
#line 3784
cusparseStatus_t __stdcall cusparseCgtsv2StridedBatch_bufferSizeExt(cusparseHandle_t handle, int m, const cuComplex * dl, const cuComplex * d, const cuComplex * du, const cuComplex * x, int batchCount, int batchStride, size_t * bufferSizeInBytes); 
#line 3795
cusparseStatus_t __stdcall cusparseZgtsv2StridedBatch_bufferSizeExt(cusparseHandle_t handle, int m, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, const cuDoubleComplex * x, int batchCount, int batchStride, size_t * bufferSizeInBytes); 
#line 3806
cusparseStatus_t __stdcall cusparseSgtsv2StridedBatch(cusparseHandle_t handle, int m, const float * dl, const float * d, const float * du, float * x, int batchCount, int batchStride, void * pBuffer); 
#line 3817
cusparseStatus_t __stdcall cusparseDgtsv2StridedBatch(cusparseHandle_t handle, int m, const double * dl, const double * d, const double * du, double * x, int batchCount, int batchStride, void * pBuffer); 
#line 3828
cusparseStatus_t __stdcall cusparseCgtsv2StridedBatch(cusparseHandle_t handle, int m, const cuComplex * dl, const cuComplex * d, const cuComplex * du, cuComplex * x, int batchCount, int batchStride, void * pBuffer); 
#line 3839
cusparseStatus_t __stdcall cusparseZgtsv2StridedBatch(cusparseHandle_t handle, int m, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, cuDoubleComplex * x, int batchCount, int batchStride, void * pBuffer); 
#line 3851
cusparseStatus_t __stdcall cusparseSgtsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const float * dl, const float * d, const float * du, const float * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3862
cusparseStatus_t __stdcall cusparseDgtsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const double * dl, const double * d, const double * du, const double * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3873
cusparseStatus_t __stdcall cusparseCgtsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const cuComplex * dl, const cuComplex * d, const cuComplex * du, const cuComplex * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3884
cusparseStatus_t __stdcall cusparseZgtsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, const cuDoubleComplex * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3896
cusparseStatus_t __stdcall cusparseSgtsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, float * dl, float * d, float * du, float * x, int batchCount, void * pBuffer); 
#line 3907
cusparseStatus_t __stdcall cusparseDgtsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, double * dl, double * d, double * du, double * x, int batchCount, void * pBuffer); 
#line 3918
cusparseStatus_t __stdcall cusparseCgtsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, cuComplex * dl, cuComplex * d, cuComplex * du, cuComplex * x, int batchCount, void * pBuffer); 
#line 3929
cusparseStatus_t __stdcall cusparseZgtsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, cuDoubleComplex * dl, cuDoubleComplex * d, cuDoubleComplex * du, cuDoubleComplex * x, int batchCount, void * pBuffer); 
#line 3946
cusparseStatus_t __stdcall cusparseSgpsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const float * ds, const float * dl, const float * d, const float * du, const float * dw, const float * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3959
cusparseStatus_t __stdcall cusparseDgpsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const double * ds, const double * dl, const double * d, const double * du, const double * dw, const double * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3972
cusparseStatus_t __stdcall cusparseCgpsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const cuComplex * ds, const cuComplex * dl, const cuComplex * d, const cuComplex * du, const cuComplex * dw, const cuComplex * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3985
cusparseStatus_t __stdcall cusparseZgpsvInterleavedBatch_bufferSizeExt(cusparseHandle_t handle, int algo, int m, const cuDoubleComplex * ds, const cuDoubleComplex * dl, const cuDoubleComplex * d, const cuDoubleComplex * du, const cuDoubleComplex * dw, const cuDoubleComplex * x, int batchCount, size_t * pBufferSizeInBytes); 
#line 3998
cusparseStatus_t __stdcall cusparseSgpsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, float * ds, float * dl, float * d, float * du, float * dw, float * x, int batchCount, void * pBuffer); 
#line 4011
cusparseStatus_t __stdcall cusparseDgpsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, double * ds, double * dl, double * d, double * du, double * dw, double * x, int batchCount, void * pBuffer); 
#line 4024
cusparseStatus_t __stdcall cusparseCgpsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, cuComplex * ds, cuComplex * dl, cuComplex * d, cuComplex * du, cuComplex * dw, cuComplex * x, int batchCount, void * pBuffer); 
#line 4037
cusparseStatus_t __stdcall cusparseZgpsvInterleavedBatch(cusparseHandle_t handle, int algo, int m, cuDoubleComplex * ds, cuDoubleComplex * dl, cuDoubleComplex * d, cuDoubleComplex * du, cuDoubleComplex * dw, cuDoubleComplex * x, int batchCount, void * pBuffer); 
#line 4057
cusparseStatus_t __stdcall cusparseXcsrgemmNnz(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, const cusparseMatDescr_t descrA, const int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, const int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr); 
#line 4075
cusparseStatus_t __stdcall cusparseScsrgemm(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, const cusparseMatDescr_t descrA, const int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, const int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4096
cusparseStatus_t __stdcall cusparseDcsrgemm(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, const cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4117
cusparseStatus_t __stdcall cusparseCcsrgemm(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, const cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, cuComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4138
cusparseStatus_t __stdcall cusparseZcsrgemm(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, int m, int n, int k, const cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4162
cusparseStatus_t __stdcall cusparseCreateCsrgemm2Info(csrgemm2Info_t * info); 
#line 4164
cusparseStatus_t __stdcall cusparseDestroyCsrgemm2Info(csrgemm2Info_t info); 
#line 4166
cusparseStatus_t __stdcall cusparseScsrgemm2_bufferSizeExt(cusparseHandle_t handle, int m, int n, int k, const float * alpha, const cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const float * beta, const cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes); 
#line 4187
cusparseStatus_t __stdcall cusparseDcsrgemm2_bufferSizeExt(cusparseHandle_t handle, int m, int n, int k, const double * alpha, const cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const double * beta, const cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes); 
#line 4208
cusparseStatus_t __stdcall cusparseCcsrgemm2_bufferSizeExt(cusparseHandle_t handle, int m, int n, int k, const cuComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuComplex * beta, const cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes); 
#line 4229
cusparseStatus_t __stdcall cusparseZcsrgemm2_bufferSizeExt(cusparseHandle_t handle, int m, int n, int k, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuDoubleComplex * beta, const cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, csrgemm2Info_t info, size_t * pBufferSizeInBytes); 
#line 4251
cusparseStatus_t __stdcall cusparseXcsrgemm2Nnz(cusparseHandle_t handle, int m, int n, int k, const cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrD, int nnzD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, const csrgemm2Info_t info, void * pBuffer); 
#line 4274
cusparseStatus_t __stdcall cusparseScsrgemm2(cusparseHandle_t handle, int m, int n, int k, const float * alpha, const cusparseMatDescr_t descrA, int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const float * beta, const cusparseMatDescr_t descrD, int nnzD, const float * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, const cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, const csrgemm2Info_t info, void * pBuffer); 
#line 4302
cusparseStatus_t __stdcall cusparseDcsrgemm2(cusparseHandle_t handle, int m, int n, int k, const double * alpha, const cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const double * beta, const cusparseMatDescr_t descrD, int nnzD, const double * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, const cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, const csrgemm2Info_t info, void * pBuffer); 
#line 4331
cusparseStatus_t __stdcall cusparseCcsrgemm2(cusparseHandle_t handle, int m, int n, int k, const cuComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuComplex * beta, const cusparseMatDescr_t descrD, int nnzD, const cuComplex * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, const cusparseMatDescr_t descrC, cuComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, const csrgemm2Info_t info, void * pBuffer); 
#line 4360
cusparseStatus_t __stdcall cusparseZcsrgemm2(cusparseHandle_t handle, int m, int n, int k, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cuDoubleComplex * beta, const cusparseMatDescr_t descrD, int nnzD, const cuDoubleComplex * csrSortedValD, const int * csrSortedRowPtrD, const int * csrSortedColIndD, const cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, const csrgemm2Info_t info, void * pBuffer); 
#line 4391
cusparseStatus_t __stdcall cusparseXcsrgeamNnz(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr); 
#line 4406
cusparseStatus_t __stdcall cusparseScsrgeam(cusparseHandle_t handle, int m, int n, const float * alpha, const cusparseMatDescr_t descrA, int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * beta, const cusparseMatDescr_t descrB, int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, float * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4426
cusparseStatus_t __stdcall cusparseDcsrgeam(cusparseHandle_t handle, int m, int n, const double * alpha, const cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * beta, const cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, double * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4446
cusparseStatus_t __stdcall cusparseCcsrgeam(cusparseHandle_t handle, int m, int n, const cuComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * beta, const cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, cuComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4466
cusparseStatus_t __stdcall cusparseZcsrgeam(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * beta, const cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 4486
cusparseStatus_t __stdcall cusparseScsrgeam2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const float * alpha, const cusparseMatDescr_t descrA, int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * beta, const cusparseMatDescr_t descrB, int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, const float * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 4508
cusparseStatus_t __stdcall cusparseDcsrgeam2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const double * alpha, const cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * beta, const cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, const double * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 4530
cusparseStatus_t __stdcall cusparseCcsrgeam2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const cuComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * beta, const cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, const cuComplex * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 4552
cusparseStatus_t __stdcall cusparseZcsrgeam2_bufferSizeExt(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * beta, const cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, const cuDoubleComplex * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 4574
cusparseStatus_t __stdcall cusparseXcsrgeam2Nnz(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, int nnzA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrB, int nnzB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, void * workspace); 
#line 4591
cusparseStatus_t __stdcall cusparseScsrgeam2(cusparseHandle_t handle, int m, int n, const float * alpha, const cusparseMatDescr_t descrA, int nnzA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * beta, const cusparseMatDescr_t descrB, int nnzB, const float * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, float * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 4613
cusparseStatus_t __stdcall cusparseDcsrgeam2(cusparseHandle_t handle, int m, int n, const double * alpha, const cusparseMatDescr_t descrA, int nnzA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * beta, const cusparseMatDescr_t descrB, int nnzB, const double * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, double * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 4635
cusparseStatus_t __stdcall cusparseCcsrgeam2(cusparseHandle_t handle, int m, int n, const cuComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuComplex * beta, const cusparseMatDescr_t descrB, int nnzB, const cuComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, cuComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 4657
cusparseStatus_t __stdcall cusparseZcsrgeam2(cusparseHandle_t handle, int m, int n, const cuDoubleComplex * alpha, const cusparseMatDescr_t descrA, int nnzA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cuDoubleComplex * beta, const cusparseMatDescr_t descrB, int nnzB, const cuDoubleComplex * csrSortedValB, const int * csrSortedRowPtrB, const int * csrSortedColIndB, const cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 4683
cusparseStatus_t __stdcall cusparseScsrcolor(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * fractionToColor, int * ncolors, int * coloring, int * reordering, const cusparseColorInfo_t info); 
#line 4696
cusparseStatus_t __stdcall cusparseDcsrcolor(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * fractionToColor, int * ncolors, int * coloring, int * reordering, const cusparseColorInfo_t info); 
#line 4709
cusparseStatus_t __stdcall cusparseCcsrcolor(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * fractionToColor, int * ncolors, int * coloring, int * reordering, const cusparseColorInfo_t info); 
#line 4722
cusparseStatus_t __stdcall cusparseZcsrcolor(cusparseHandle_t handle, int m, int nnz, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * fractionToColor, int * ncolors, int * coloring, int * reordering, const cusparseColorInfo_t info); 
#line 4739
cusparseStatus_t __stdcall cusparseSnnz(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const float * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr); 
#line 4749
cusparseStatus_t __stdcall cusparseDnnz(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const double * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr); 
#line 4759
cusparseStatus_t __stdcall cusparseCnnz(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr); 
#line 4769
cusparseStatus_t __stdcall cusparseZnnz(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, int * nnzPerRowCol, int * nnzTotalDevHostPtr); 
#line 4783
cusparseStatus_t __stdcall cusparseSnnz_compress(cusparseHandle_t handle, int m, const cusparseMatDescr_t descr, const float * csrSortedValA, const int * csrSortedRowPtrA, int * nnzPerRow, int * nnzC, float tol); 
#line 4792
cusparseStatus_t __stdcall cusparseDnnz_compress(cusparseHandle_t handle, int m, const cusparseMatDescr_t descr, const double * csrSortedValA, const int * csrSortedRowPtrA, int * nnzPerRow, int * nnzC, double tol); 
#line 4801
cusparseStatus_t __stdcall cusparseCnnz_compress(cusparseHandle_t handle, int m, const cusparseMatDescr_t descr, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, int * nnzPerRow, int * nnzC, cuComplex tol); 
#line 4810
cusparseStatus_t __stdcall cusparseZnnz_compress(cusparseHandle_t handle, int m, const cusparseMatDescr_t descr, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, int * nnzPerRow, int * nnzC, cuDoubleComplex tol); 
#line 4820
cusparseStatus_t __stdcall cusparseScsr2csr_compress(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedColIndA, const int * csrSortedRowPtrA, int nnzA, const int * nnzPerRow, float * csrSortedValC, int * csrSortedColIndC, int * csrSortedRowPtrC, float tol); 
#line 4834
cusparseStatus_t __stdcall cusparseDcsr2csr_compress(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedColIndA, const int * csrSortedRowPtrA, int nnzA, const int * nnzPerRow, double * csrSortedValC, int * csrSortedColIndC, int * csrSortedRowPtrC, double tol); 
#line 4848
cusparseStatus_t __stdcall cusparseCcsr2csr_compress(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedColIndA, const int * csrSortedRowPtrA, int nnzA, const int * nnzPerRow, cuComplex * csrSortedValC, int * csrSortedColIndC, int * csrSortedRowPtrC, cuComplex tol); 
#line 4862
cusparseStatus_t __stdcall cusparseZcsr2csr_compress(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedColIndA, const int * csrSortedRowPtrA, int nnzA, const int * nnzPerRow, cuDoubleComplex * csrSortedValC, int * csrSortedColIndC, int * csrSortedRowPtrC, cuDoubleComplex tol); 
#line 4879
cusparseStatus_t __stdcall cusparseSdense2csr(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * A, int lda, const int * nnzPerRow, float * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 4890
cusparseStatus_t __stdcall cusparseDdense2csr(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * A, int lda, const int * nnzPerRow, double * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 4901
cusparseStatus_t __stdcall cusparseCdense2csr(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * A, int lda, const int * nnzPerRow, cuComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 4912
cusparseStatus_t __stdcall cusparseZdense2csr(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, const int * nnzPerRow, cuDoubleComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 4925
cusparseStatus_t __stdcall cusparseScsr2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float * A, int lda); 
#line 4935
cusparseStatus_t __stdcall cusparseDcsr2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, double * A, int lda); 
#line 4945
cusparseStatus_t __stdcall cusparseCcsr2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cuComplex * A, int lda); 
#line 4955
cusparseStatus_t __stdcall cusparseZcsr2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cuDoubleComplex * A, int lda); 
#line 4968
cusparseStatus_t __stdcall cusparseSdense2csc(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * A, int lda, const int * nnzPerCol, float * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA); 
#line 4979
cusparseStatus_t __stdcall cusparseDdense2csc(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * A, int lda, const int * nnzPerCol, double * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA); 
#line 4990
cusparseStatus_t __stdcall cusparseCdense2csc(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * A, int lda, const int * nnzPerCol, cuComplex * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA); 
#line 5001
cusparseStatus_t __stdcall cusparseZdense2csc(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, const int * nnzPerCol, cuDoubleComplex * cscSortedValA, int * cscSortedRowIndA, int * cscSortedColPtrA); 
#line 5014
cusparseStatus_t __stdcall cusparseScsc2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, float * A, int lda); 
#line 5024
cusparseStatus_t __stdcall cusparseDcsc2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, double * A, int lda); 
#line 5034
cusparseStatus_t __stdcall cusparseCcsc2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cuComplex * A, int lda); 
#line 5044
cusparseStatus_t __stdcall cusparseZcsc2dense(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cuDoubleComplex * A, int lda); 
#line 5057
cusparseStatus_t __stdcall cusparseXcoo2csr(cusparseHandle_t handle, const int * cooRowInd, int nnz, int m, int * csrSortedRowPtr, cusparseIndexBase_t idxBase); 
#line 5067
cusparseStatus_t __stdcall cusparseXcsr2coo(cusparseHandle_t handle, const int * csrSortedRowPtr, int nnz, int m, int * cooRowInd, cusparseIndexBase_t idxBase); 
#line 5077
cusparseStatus_t __stdcall cusparseCsr2cscEx(cusparseHandle_t handle, int m, int n, int nnz, const void * csrSortedVal, cudaDataType csrSortedValtype, const int * csrSortedRowPtr, const int * csrSortedColInd, void * cscSortedVal, cudaDataType cscSortedValtype, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, cudaDataType executiontype); 
#line 5093
cusparseStatus_t __stdcall cusparseScsr2csc(cusparseHandle_t handle, int m, int n, int nnz, const float * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, float * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase); 
#line 5106
cusparseStatus_t __stdcall cusparseDcsr2csc(cusparseHandle_t handle, int m, int n, int nnz, const double * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, double * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase); 
#line 5119
cusparseStatus_t __stdcall cusparseCcsr2csc(cusparseHandle_t handle, int m, int n, int nnz, const cuComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, cuComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase); 
#line 5132
cusparseStatus_t __stdcall cusparseZcsr2csc(cusparseHandle_t handle, int m, int n, int nnz, const cuDoubleComplex * csrSortedVal, const int * csrSortedRowPtr, const int * csrSortedColInd, cuDoubleComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase); 
#line 5147
cusparseStatus_t __stdcall cusparseSdense2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5158
cusparseStatus_t __stdcall cusparseDdense2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5169
cusparseStatus_t __stdcall cusparseCdense2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5180
cusparseStatus_t __stdcall cusparseZdense2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * A, int lda, const int * nnzPerRow, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5193
cusparseStatus_t __stdcall cusparseShyb2dense(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, float * A, int lda); 
#line 5199
cusparseStatus_t __stdcall cusparseDhyb2dense(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, double * A, int lda); 
#line 5205
cusparseStatus_t __stdcall cusparseChyb2dense(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cuComplex * A, int lda); 
#line 5211
cusparseStatus_t __stdcall cusparseZhyb2dense(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cuDoubleComplex * A, int lda); 
#line 5219
cusparseStatus_t __stdcall cusparseScsr2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5230
cusparseStatus_t __stdcall cusparseDcsr2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5241
cusparseStatus_t __stdcall cusparseCcsr2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5252
cusparseStatus_t __stdcall cusparseZcsr2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5265
cusparseStatus_t __stdcall cusparseShyb2csr(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, float * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 5272
cusparseStatus_t __stdcall cusparseDhyb2csr(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, double * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 5279
cusparseStatus_t __stdcall cusparseChyb2csr(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cuComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 5286
cusparseStatus_t __stdcall cusparseZhyb2csr(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cuDoubleComplex * csrSortedValA, int * csrSortedRowPtrA, int * csrSortedColIndA); 
#line 5295
cusparseStatus_t __stdcall cusparseScsc2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const float * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5306
cusparseStatus_t __stdcall cusparseDcsc2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const double * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5317
cusparseStatus_t __stdcall cusparseCcsc2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5328
cusparseStatus_t __stdcall cusparseZcsc2hyb(cusparseHandle_t handle, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * cscSortedValA, const int * cscSortedRowIndA, const int * cscSortedColPtrA, cusparseHybMat_t hybA, int userEllWidth, cusparseHybPartition_t partitionType); 
#line 5341
cusparseStatus_t __stdcall cusparseShyb2csc(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, float * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr); 
#line 5348
cusparseStatus_t __stdcall cusparseDhyb2csc(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, double * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr); 
#line 5355
cusparseStatus_t __stdcall cusparseChyb2csc(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cuComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr); 
#line 5362
cusparseStatus_t __stdcall cusparseZhyb2csc(cusparseHandle_t handle, const cusparseMatDescr_t descrA, const cusparseHybMat_t hybA, cuDoubleComplex * cscSortedVal, int * cscSortedRowInd, int * cscSortedColPtr); 
#line 5371
cusparseStatus_t __stdcall cusparseXcsr2bsrNnz(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, int * bsrSortedRowPtrC, int * nnzTotalDevHostPtr); 
#line 5383
cusparseStatus_t __stdcall cusparseScsr2bsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, float * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC); 
#line 5397
cusparseStatus_t __stdcall cusparseDcsr2bsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, double * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC); 
#line 5411
cusparseStatus_t __stdcall cusparseCcsr2bsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, cuComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC); 
#line 5425
cusparseStatus_t __stdcall cusparseZcsr2bsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, cuDoubleComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC); 
#line 5441
cusparseStatus_t __stdcall cusparseSbsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, float * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5455
cusparseStatus_t __stdcall cusparseDbsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, double * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5469
cusparseStatus_t __stdcall cusparseCbsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, cuComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5483
cusparseStatus_t __stdcall cusparseZbsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int blockDim, const cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5499
cusparseStatus_t __stdcall cusparseSgebsr2gebsc_bufferSize(cusparseHandle_t handle, int mb, int nb, int nnzb, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5510
cusparseStatus_t __stdcall cusparseDgebsr2gebsc_bufferSize(cusparseHandle_t handle, int mb, int nb, int nnzb, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5521
cusparseStatus_t __stdcall cusparseCgebsr2gebsc_bufferSize(cusparseHandle_t handle, int mb, int nb, int nnzb, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5532
cusparseStatus_t __stdcall cusparseZgebsr2gebsc_bufferSize(cusparseHandle_t handle, int mb, int nb, int nnzb, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5543
cusparseStatus_t __stdcall cusparseSgebsr2gebsc_bufferSizeExt(cusparseHandle_t handle, int mb, int nb, int nnzb, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5554
cusparseStatus_t __stdcall cusparseDgebsr2gebsc_bufferSizeExt(cusparseHandle_t handle, int mb, int nb, int nnzb, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5565
cusparseStatus_t __stdcall cusparseCgebsr2gebsc_bufferSizeExt(cusparseHandle_t handle, int mb, int nb, int nnzb, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5576
cusparseStatus_t __stdcall cusparseZgebsr2gebsc_bufferSizeExt(cusparseHandle_t handle, int mb, int nb, int nnzb, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5588
cusparseStatus_t __stdcall cusparseSgebsr2gebsc(cusparseHandle_t handle, int mb, int nb, int nnzb, const float * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, float * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 5604
cusparseStatus_t __stdcall cusparseDgebsr2gebsc(cusparseHandle_t handle, int mb, int nb, int nnzb, const double * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, double * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 5620
cusparseStatus_t __stdcall cusparseCgebsr2gebsc(cusparseHandle_t handle, int mb, int nb, int nnzb, const cuComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, cuComplex * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 5636
cusparseStatus_t __stdcall cusparseZgebsr2gebsc(cusparseHandle_t handle, int mb, int nb, int nnzb, const cuDoubleComplex * bsrSortedVal, const int * bsrSortedRowPtr, const int * bsrSortedColInd, int rowBlockDim, int colBlockDim, cuDoubleComplex * bscVal, int * bscRowInd, int * bscColPtr, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, void * pBuffer); 
#line 5654
cusparseStatus_t __stdcall cusparseXgebsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5667
cusparseStatus_t __stdcall cusparseSgebsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, const cusparseMatDescr_t descrC, float * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5683
cusparseStatus_t __stdcall cusparseDgebsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, const cusparseMatDescr_t descrC, double * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5699
cusparseStatus_t __stdcall cusparseCgebsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, const cusparseMatDescr_t descrC, cuComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5715
cusparseStatus_t __stdcall cusparseZgebsr2csr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDim, int colBlockDim, const cusparseMatDescr_t descrC, cuDoubleComplex * csrSortedValC, int * csrSortedRowPtrC, int * csrSortedColIndC); 
#line 5732
cusparseStatus_t __stdcall cusparseScsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5744
cusparseStatus_t __stdcall cusparseDcsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5756
cusparseStatus_t __stdcall cusparseCcsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5768
cusparseStatus_t __stdcall cusparseZcsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, int * pBufferSizeInBytes); 
#line 5780
cusparseStatus_t __stdcall cusparseScsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5792
cusparseStatus_t __stdcall cusparseDcsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5804
cusparseStatus_t __stdcall cusparseCcsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5816
cusparseStatus_t __stdcall cusparseZcsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, int rowBlockDim, int colBlockDim, size_t * pBufferSize); 
#line 5830
cusparseStatus_t __stdcall cusparseXcsr2gebsrNnz(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrC, int * bsrSortedRowPtrC, int rowBlockDim, int colBlockDim, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 5844
cusparseStatus_t __stdcall cusparseScsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrC, float * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer); 
#line 5860
cusparseStatus_t __stdcall cusparseDcsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrC, double * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer); 
#line 5876
cusparseStatus_t __stdcall cusparseCcsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrC, cuComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer); 
#line 5892
cusparseStatus_t __stdcall cusparseZcsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int m, int n, const cusparseMatDescr_t descrA, const cuDoubleComplex * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const cusparseMatDescr_t descrC, cuDoubleComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDim, int colBlockDim, void * pBuffer); 
#line 5910
cusparseStatus_t __stdcall cusparseSgebsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes); 
#line 5925
cusparseStatus_t __stdcall cusparseDgebsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes); 
#line 5940
cusparseStatus_t __stdcall cusparseCgebsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes); 
#line 5955
cusparseStatus_t __stdcall cusparseZgebsr2gebsr_bufferSize(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, int * pBufferSizeInBytes); 
#line 5971
cusparseStatus_t __stdcall cusparseSgebsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, size_t * pBufferSize); 
#line 5986
cusparseStatus_t __stdcall cusparseDgebsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, size_t * pBufferSize); 
#line 6001
cusparseStatus_t __stdcall cusparseCgebsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, size_t * pBufferSize); 
#line 6016
cusparseStatus_t __stdcall cusparseZgebsr2gebsr_bufferSizeExt(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, int rowBlockDimC, int colBlockDimC, size_t * pBufferSize); 
#line 6033
cusparseStatus_t __stdcall cusparseXgebsr2gebsrNnz(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, const cusparseMatDescr_t descrC, int * bsrSortedRowPtrC, int rowBlockDimC, int colBlockDimC, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 6050
cusparseStatus_t __stdcall cusparseSgebsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const float * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, const cusparseMatDescr_t descrC, float * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer); 
#line 6069
cusparseStatus_t __stdcall cusparseDgebsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const double * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, const cusparseMatDescr_t descrC, double * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer); 
#line 6088
cusparseStatus_t __stdcall cusparseCgebsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const cuComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, const cusparseMatDescr_t descrC, cuComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer); 
#line 6107
cusparseStatus_t __stdcall cusparseZgebsr2gebsr(cusparseHandle_t handle, cusparseDirection_t dirA, int mb, int nb, int nnzb, const cusparseMatDescr_t descrA, const cuDoubleComplex * bsrSortedValA, const int * bsrSortedRowPtrA, const int * bsrSortedColIndA, int rowBlockDimA, int colBlockDimA, const cusparseMatDescr_t descrC, cuDoubleComplex * bsrSortedValC, int * bsrSortedRowPtrC, int * bsrSortedColIndC, int rowBlockDimC, int colBlockDimC, void * pBuffer); 
#line 6129
cusparseStatus_t __stdcall cusparseCreateIdentityPermutation(cusparseHandle_t handle, int n, int * p); 
#line 6134
cusparseStatus_t __stdcall cusparseXcoosort_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnz, const int * cooRowsA, const int * cooColsA, size_t * pBufferSizeInBytes); 
#line 6142
cusparseStatus_t __stdcall cusparseXcoosortByRow(cusparseHandle_t handle, int m, int n, int nnz, int * cooRowsA, int * cooColsA, int * P, void * pBuffer); 
#line 6151
cusparseStatus_t __stdcall cusparseXcoosortByColumn(cusparseHandle_t handle, int m, int n, int nnz, int * cooRowsA, int * cooColsA, int * P, void * pBuffer); 
#line 6161
cusparseStatus_t __stdcall cusparseXcsrsort_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnz, const int * csrRowPtrA, const int * csrColIndA, size_t * pBufferSizeInBytes); 
#line 6169
cusparseStatus_t __stdcall cusparseXcsrsort(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, const int * csrRowPtrA, int * csrColIndA, int * P, void * pBuffer); 
#line 6180
cusparseStatus_t __stdcall cusparseXcscsort_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnz, const int * cscColPtrA, const int * cscRowIndA, size_t * pBufferSizeInBytes); 
#line 6188
cusparseStatus_t __stdcall cusparseXcscsort(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, const int * cscColPtrA, int * cscRowIndA, int * P, void * pBuffer); 
#line 6200
cusparseStatus_t __stdcall cusparseScsru2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnz, float * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes); 
#line 6210
cusparseStatus_t __stdcall cusparseDcsru2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnz, double * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes); 
#line 6220
cusparseStatus_t __stdcall cusparseCcsru2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnz, cuComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes); 
#line 6230
cusparseStatus_t __stdcall cusparseZcsru2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnz, cuDoubleComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, size_t * pBufferSizeInBytes); 
#line 6240
cusparseStatus_t __stdcall cusparseScsru2csr(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, float * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6251
cusparseStatus_t __stdcall cusparseDcsru2csr(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, double * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6262
cusparseStatus_t __stdcall cusparseCcsru2csr(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6273
cusparseStatus_t __stdcall cusparseZcsru2csr(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6286
cusparseStatus_t __stdcall cusparseScsr2csru(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, float * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6297
cusparseStatus_t __stdcall cusparseDcsr2csru(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, double * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6308
cusparseStatus_t __stdcall cusparseCcsr2csru(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, cuComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6319
cusparseStatus_t __stdcall cusparseZcsr2csru(cusparseHandle_t handle, int m, int n, int nnz, const cusparseMatDescr_t descrA, cuDoubleComplex * csrVal, const int * csrRowPtr, int * csrColInd, csru2csrInfo_t info, void * pBuffer); 
#line 6332
cusparseStatus_t __stdcall cusparseHpruneDense2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, const __half * A, int lda, const __half * threshold, const cusparseMatDescr_t descrC, const __half * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 6346 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneDense2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, const float * A, int lda, const float * threshold, const cusparseMatDescr_t descrC, const float * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 6359
cusparseStatus_t __stdcall cusparseDpruneDense2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, const double * A, int lda, const double * threshold, const cusparseMatDescr_t descrC, const double * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 6373
cusparseStatus_t __stdcall cusparseHpruneDense2csrNnz(cusparseHandle_t handle, int m, int n, const __half * A, int lda, const __half * threshold, const cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 6386 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneDense2csrNnz(cusparseHandle_t handle, int m, int n, const float * A, int lda, const float * threshold, const cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 6398
cusparseStatus_t __stdcall cusparseDpruneDense2csrNnz(cusparseHandle_t handle, int m, int n, const double * A, int lda, const double * threshold, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 6411
cusparseStatus_t __stdcall cusparseHpruneDense2csr(cusparseHandle_t handle, int m, int n, const __half * A, int lda, const __half * threshold, const cusparseMatDescr_t descrC, __half * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 6425 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneDense2csr(cusparseHandle_t handle, int m, int n, const float * A, int lda, const float * threshold, const cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 6438
cusparseStatus_t __stdcall cusparseDpruneDense2csr(cusparseHandle_t handle, int m, int n, const double * A, int lda, const double * threshold, const cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 6453
cusparseStatus_t __stdcall cusparseHpruneCsr2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const __half * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const __half * threshold, const cusparseMatDescr_t descrC, const __half * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 6470 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneCsr2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * threshold, const cusparseMatDescr_t descrC, const float * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 6486
cusparseStatus_t __stdcall cusparseDpruneCsr2csr_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * threshold, const cusparseMatDescr_t descrC, const double * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, size_t * pBufferSizeInBytes); 
#line 6503
cusparseStatus_t __stdcall cusparseHpruneCsr2csrNnz(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const __half * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const __half * threshold, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 6519 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneCsr2csrNnz(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * threshold, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 6534
cusparseStatus_t __stdcall cusparseDpruneCsr2csrNnz(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * threshold, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, void * pBuffer); 
#line 6550
cusparseStatus_t __stdcall cusparseHpruneCsr2csr(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const __half * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const __half * threshold, const cusparseMatDescr_t descrC, __half * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 6567 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneCsr2csr(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const float * threshold, const cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 6583
cusparseStatus_t __stdcall cusparseDpruneCsr2csr(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, const double * threshold, const cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, void * pBuffer); 
#line 6601
cusparseStatus_t __stdcall cusparseHpruneDense2csrByPercentage_bufferSizeExt(cusparseHandle_t handle, int m, int n, const __half * A, int lda, float percentage, const cusparseMatDescr_t descrC, const __half * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes); 
#line 6616 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneDense2csrByPercentage_bufferSizeExt(cusparseHandle_t handle, int m, int n, const float * A, int lda, float percentage, const cusparseMatDescr_t descrC, const float * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes); 
#line 6630
cusparseStatus_t __stdcall cusparseDpruneDense2csrByPercentage_bufferSizeExt(cusparseHandle_t handle, int m, int n, const double * A, int lda, float percentage, const cusparseMatDescr_t descrC, const double * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes); 
#line 6645
cusparseStatus_t __stdcall cusparseHpruneDense2csrNnzByPercentage(cusparseHandle_t handle, int m, int n, const __half * A, int lda, float percentage, const cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer); 
#line 6659 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneDense2csrNnzByPercentage(cusparseHandle_t handle, int m, int n, const float * A, int lda, float percentage, const cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer); 
#line 6672
cusparseStatus_t __stdcall cusparseDpruneDense2csrNnzByPercentage(cusparseHandle_t handle, int m, int n, const double * A, int lda, float percentage, const cusparseMatDescr_t descrC, int * csrRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer); 
#line 6686
cusparseStatus_t __stdcall cusparseHpruneDense2csrByPercentage(cusparseHandle_t handle, int m, int n, const __half * A, int lda, float percentage, const cusparseMatDescr_t descrC, __half * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, pruneInfo_t info, void * pBuffer); 
#line 6701 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneDense2csrByPercentage(cusparseHandle_t handle, int m, int n, const float * A, int lda, float percentage, const cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, pruneInfo_t info, void * pBuffer); 
#line 6715
cusparseStatus_t __stdcall cusparseDpruneDense2csrByPercentage(cusparseHandle_t handle, int m, int n, const double * A, int lda, float percentage, const cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, pruneInfo_t info, void * pBuffer); 
#line 6732
cusparseStatus_t __stdcall cusparseHpruneCsr2csrByPercentage_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const __half * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, const __half * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes); 
#line 6750 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneCsr2csrByPercentage_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, const float * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes); 
#line 6767
cusparseStatus_t __stdcall cusparseDpruneCsr2csrByPercentage_bufferSizeExt(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, const double * csrSortedValC, const int * csrSortedRowPtrC, const int * csrSortedColIndC, pruneInfo_t info, size_t * pBufferSizeInBytes); 
#line 6785
cusparseStatus_t __stdcall cusparseHpruneCsr2csrNnzByPercentage(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const __half * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer); 
#line 6802 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneCsr2csrNnzByPercentage(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer); 
#line 6818
cusparseStatus_t __stdcall cusparseDpruneCsr2csrNnzByPercentage(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, int * csrSortedRowPtrC, int * nnzTotalDevHostPtr, pruneInfo_t info, void * pBuffer); 
#line 6835
cusparseStatus_t __stdcall cusparseHpruneCsr2csrByPercentage(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const __half * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, __half * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, pruneInfo_t info, void * pBuffer); 
#line 6853 "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v10.1\\include\\cusparse.h"
cusparseStatus_t __stdcall cusparseSpruneCsr2csrByPercentage(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const float * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, float * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, pruneInfo_t info, void * pBuffer); 
#line 6870
cusparseStatus_t __stdcall cusparseDpruneCsr2csrByPercentage(cusparseHandle_t handle, int m, int n, int nnzA, const cusparseMatDescr_t descrA, const double * csrSortedValA, const int * csrSortedRowPtrA, const int * csrSortedColIndA, float percentage, const cusparseMatDescr_t descrC, double * csrSortedValC, const int * csrSortedRowPtrC, int * csrSortedColIndC, pruneInfo_t info, void * pBuffer); 
#line 6898
typedef 
#line 6895
enum { 
#line 6896
CUSPARSE_CSR2CSC_ALG1 = 1, 
#line 6897
CUSPARSE_CSR2CSC_ALG2
#line 6898
} cusparseCsr2CscAlg_t; 
#line 6901
cusparseStatus_t __stdcall cusparseCsr2cscEx2(cusparseHandle_t handle, int m, int n, int nnz, const void * csrVal, const int * csrRowPtr, const int * csrColInd, void * cscVal, int * cscColPtr, int * cscRowInd, cudaDataType valType, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, cusparseCsr2CscAlg_t alg, void * buffer); 
#line 6918
cusparseStatus_t __stdcall cusparseCsr2cscEx2_bufferSize(cusparseHandle_t handle, int m, int n, int nnz, const void * csrVal, const int * csrRowPtr, const int * csrColInd, void * cscVal, int * cscColPtr, int * cscRowInd, cudaDataType valType, cusparseAction_t copyValues, cusparseIndexBase_t idxBase, cusparseCsr2CscAlg_t alg, size_t * bufferSize); 
#line 6944
typedef 
#line 6940
enum { 
#line 6941
CUSPARSE_FORMAT_CSR = 1, 
#line 6942
CUSPARSE_FORMAT_CSC, 
#line 6943
CUSPARSE_FORMAT_COO
#line 6944
} cusparseFormat_t; 
#line 6949
typedef 
#line 6946
enum { 
#line 6947
CUSPARSE_ORDER_COL = 1, 
#line 6948
CUSPARSE_ORDER_ROW
#line 6949
} cusparseOrder_t; 
#line 6955
typedef 
#line 6951
enum { 
#line 6952
CUSPARSE_COOMM_ALG1 = 1, 
#line 6953
CUSPARSE_COOMM_ALG2, 
#line 6954
CUSPARSE_COOMM_ALG3
#line 6955
} cusparseSpMMAlg_t; 
#line 6960
typedef 
#line 6957
enum { 
#line 6958
CUSPARSE_INDEX_16U = 1, 
#line 6959
CUSPARSE_INDEX_32I
#line 6960
} cusparseIndexType_t; 
#line 6962
struct cusparseSpMatDescr; 
#line 6963
struct cusparseDnMatDescr; 
#line 6964
typedef cusparseSpMatDescr *cusparseSpMatDescr_t; 
#line 6965
typedef cusparseDnMatDescr *cusparseDnMatDescr_t; 
#line 6971
cusparseStatus_t __stdcall cusparseCreateCoo(cusparseSpMatDescr_t * spMatDescr, int rows, int cols, int nnz, void * cooRowInd, void * cooColInd, void * cooValues, cusparseIndexType_t cooIdxType, cusparseIndexBase_t idxBase, cudaDataType valueType); 
#line 6983
cusparseStatus_t __stdcall cusparseDestroySpMat(cusparseSpMatDescr_t spMatDescr); 
#line 6986
cusparseStatus_t __stdcall cusparseCooGet(const cusparseSpMatDescr_t spMatDescr, int * rows, int * cols, int * nnz, void ** cooRowInd, void ** cooColInd, void ** cooValues, cusparseIndexType_t * idxType, cusparseIndexBase_t * idxBase, cudaDataType * valueType); 
#line 6998
cusparseStatus_t __stdcall cusparseSpMatGetFormat(const cusparseSpMatDescr_t spMatDescr, cusparseFormat_t * format); 
#line 7002
cusparseStatus_t __stdcall cusparseSpMatGetIndexBase(const cusparseSpMatDescr_t spMatDescr, cusparseIndexBase_t * idxBase); 
#line 7006
cusparseStatus_t __stdcall cusparseSpMatSetNumBatches(cusparseSpMatDescr_t spMatDescr, int batchCount); 
#line 7010
cusparseStatus_t __stdcall cusparseSpMatGetNumBatches(const cusparseSpMatDescr_t spMatDescr, int * batchCount); 
#line 7017
cusparseStatus_t __stdcall cusparseCreateDnMat(cusparseDnMatDescr_t * dnMatDescr, size_t rows, size_t cols, int64_t ld, void * valuesPtr, cudaDataType type, cusparseOrder_t order); 
#line 7026
cusparseStatus_t __stdcall cusparseDestroyDnMat(cusparseDnMatDescr_t dnMatDescr); 
#line 7029
cusparseStatus_t __stdcall cusparseDnMatGet(const cusparseDnMatDescr_t dnMatDescr, size_t * rows, size_t * cols, int64_t * ld, void ** valuesPtr, cudaDataType * type, cusparseOrder_t * order); 
#line 7038
cusparseStatus_t __stdcall cusparseDnMatSetStridedBatch(cusparseDnMatDescr_t dnMatDescr, int batchCount, size_t batchStride); 
#line 7043
cusparseStatus_t __stdcall cusparseDnMatGetStridedBatch(const cusparseDnMatDescr_t dnMatDescr, int * batchCount, size_t * batchStride); 
#line 7051
cusparseStatus_t __stdcall cusparseSpMM(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, const void * alpha, const cusparseSpMatDescr_t matA, const cusparseDnMatDescr_t matB, const void * beta, cusparseDnMatDescr_t matC, cudaDataType computeType, cusparseSpMMAlg_t alg, void * externalBuffer); 
#line 7064
cusparseStatus_t __stdcall cusparseSpMM_bufferSize(cusparseHandle_t handle, cusparseOperation_t transA, cusparseOperation_t transB, const void * alpha, const cusparseSpMatDescr_t matA, const cusparseDnMatDescr_t matB, const void * beta, cusparseDnMatDescr_t matC, cudaDataType computeType, cusparseSpMMAlg_t alg, size_t * bufferSize); 
#line 7080
}
#line 9 "e:\\workspace\\singleprec\\pyneurogpu_win2\\neurogpu6\\CudaStuff.cuh"
extern char smem[]; 
#line 11
void stEfork2Main(Stim stim, Sim sim, double * ParamsM, double * InitStatesM, HMat & InMat, double * V, short CompDepth, short CompFDepth, int NSets, int * p2pCapableGPUs, int np2p); 
#line 12
void stEfork2TimeLoopGPU(Stim stim, Sim sim, double * ParamsM, double * InitStatesM, HMat & InMat, double * V, short CompDepth, short CompFDepth, short NSets); 
#line 13
void initFrameWork(Stim stim, Sim sim, double * ParamsM, double * InitStatesM, HMat & InMat, short CompDepth, short CompFDepth, short NSets, HMat & Mat_d); 
#line 14
void ReadParamsMatX(const char * FN, double * ParamsM, short NParams, short Nx); 
#line 15
void ReadParamsMat(const char * FN, double ** ParamsM, short NParams, short Nx); 
#line 16
double *ReadAllParams(const char * FN, short NParams, short Nx, short & NSets); 
#line 17
void FreeParallelNeuronData(HMat & InMat); 
#line 25 "e:\\workspace\\singleprec\\pyneurogpu_win2\\neurogpu6\\AllModels.cuh"
void CuInitModel_Ca_HVA(double v, double & m, double & h, double gCa_HVAbar_Ca_HVA, double & ica, double & eca, double & cai); 
#line 26
void CuInitModel_Ca_LVAst(double v, double & m, double & h, double gCa_LVAstbar_Ca_LVAst, double & ica, double & eca, double & cai); 
#line 27
void CuInitModel_CaDynamics_E2(double v, double & cai, double gamma_CaDynamics_E2, double decay_CaDynamics_E2, double depth_CaDynamics_E2, double minCai_CaDynamics_E2, double ica, double & eca); 
#line 28
void CuInitModel_Ih(double v, double & m, double gIhbar_Ih, double ehcn_Ih); 
#line 29
void CuInitModel_Im(double v, double & m, double gImbar_Im); 
#line 30
void CuInitModel_K_Pst(double v, double & m, double & h, double gK_Pstbar_K_Pst); 
#line 31
void CuInitModel_K_Tst(double v, double & m, double & h, double gK_Tstbar_K_Tst); 
#line 32
void CuInitModel_Nap_Et2(double v, double & m, double & h, double gNap_Et2bar_Nap_Et2); 
#line 33
void CuInitModel_NaTa_t(double v, double & m, double & h, double gNaTa_tbar_NaTa_t); 
#line 34
void CuInitModel_NaTs2_t(double v, double & m, double & h, double gNaTs2_tbar_NaTs2_t); 
#line 35
void CuInitModel_pas(double v, double g_pas, double e_pas); 
#line 36
void CuInitModel_SK_E2(double v, double & z, double gSK_E2bar_SK_E2, double zTau_SK_E2, double cai, double & eca); 
#line 37
void CuInitModel_SKv3_1(double v, double & m, double gSKv3_1bar_SKv3_1); 
#line 38
void CuDerivModel_Ca_HVA(double dt, double v, double & m, double & h, double gCa_HVAbar_Ca_HVA, double & ica); 
#line 39
void CuDerivModel_Ca_LVAst(double dt, double v, double & m, double & h, double gCa_LVAstbar_Ca_LVAst, double & ica); 
#line 40
void CuDerivModel_CaDynamics_E2(double dt, double v, double & cai, double gamma_CaDynamics_E2, double decay_CaDynamics_E2, double depth_CaDynamics_E2, double minCai_CaDynamics_E2, double ica, double & eca); 
#line 41
void CuDerivModel_Ih(double dt, double v, double & m, double gIhbar_Ih, double ehcn_Ih); 
#line 42
void CuDerivModel_Im(double dt, double v, double & m, double gImbar_Im); 
#line 43
void CuDerivModel_K_Pst(double dt, double v, double & m, double & h, double gK_Pstbar_K_Pst); 
#line 44
void CuDerivModel_K_Tst(double dt, double v, double & m, double & h, double gK_Tstbar_K_Tst); 
#line 45
void CuDerivModel_Nap_Et2(double dt, double v, double & m, double & h, double gNap_Et2bar_Nap_Et2); 
#line 46
void CuDerivModel_NaTa_t(double dt, double v, double & m, double & h, double gNaTa_tbar_NaTa_t); 
#line 47
void CuDerivModel_NaTs2_t(double dt, double v, double & m, double & h, double gNaTs2_tbar_NaTs2_t); 
#line 48
void CuDerivModel_SK_E2(double dt, double v, double & z, double gSK_E2bar_SK_E2, double zTau_SK_E2, double cai, double & eca); 
#line 49
void CuDerivModel_SKv3_1(double dt, double v, double & m, double gSKv3_1bar_SKv3_1); 
#line 50
void CuBreakpointModel_Ca_HVA(double & sumCurrents, double & sumConductivity, double v, double & m, double & h, double gCa_HVAbar_Ca_HVA, double & ica, double & eca, double & cai); 
#line 52
void CuBreakpointModel_Ca_LVAst(double & sumCurrents, double & sumConductivity, double v, double & m, double & h, double gCa_LVAstbar_Ca_LVAst, double & ica, double & eca, double & cai); 
#line 54
void CuBreakpointModel_CaDynamics_E2(double & sumCurrents, double & sumConductivity, double v, double & cai, double gamma_CaDynamics_E2, double decay_CaDynamics_E2, double depth_CaDynamics_E2, double minCai_CaDynamics_E2, double ica, double & eca); 
#line 56
void CuBreakpointModel_Ih(double & sumCurrents, double & sumConductivity, double v, double & m, double gIhbar_Ih, double ehcn_Ih); 
#line 58
void CuBreakpointModel_Im(double & sumCurrents, double & sumConductivity, double v, double & m, double gImbar_Im); 
#line 60
void CuBreakpointModel_K_Pst(double & sumCurrents, double & sumConductivity, double v, double & m, double & h, double gK_Pstbar_K_Pst); 
#line 62
void CuBreakpointModel_K_Tst(double & sumCurrents, double & sumConductivity, double v, double & m, double & h, double gK_Tstbar_K_Tst); 
#line 64
void CuBreakpointModel_Nap_Et2(double & sumCurrents, double & sumConductivity, double v, double & m, double & h, double gNap_Et2bar_Nap_Et2); 
#line 66
void CuBreakpointModel_NaTa_t(double & sumCurrents, double & sumConductivity, double v, double & m, double & h, double gNaTa_tbar_NaTa_t); 
#line 68
void CuBreakpointModel_NaTs2_t(double & sumCurrents, double & sumConductivity, double v, double & m, double & h, double gNaTs2_tbar_NaTs2_t); 
#line 70
void CuBreakpointModel_pas(double & sumCurrents, double & sumConductivity, double v, double g_pas, double e_pas); 
#line 72
void CuBreakpointModel_SK_E2(double & sumCurrents, double & sumConductivity, double v, double & z, double gSK_E2bar_SK_E2, double zTau_SK_E2, double cai, double & eca); 
#line 74
void CuBreakpointModel_SKv3_1(double & sumCurrents, double & sumConductivity, double v, double & m, double gSKv3_1bar_SKv3_1); 
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\direct.h"
__pragma( pack ( push, 8 )) extern "C" {
#line 23
struct _diskfree_t { 
#line 25
unsigned total_clusters; 
#line 26
unsigned avail_clusters; 
#line 27
unsigned sectors_per_cluster; 
#line 28
unsigned bytes_per_sector; 
#line 29
}; 
#line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\direct.h"
__declspec(dllimport) unsigned __cdecl _getdiskfree(unsigned _Drive, _diskfree_t * _DiskFree); 
#line 41
__declspec(dllimport) int __cdecl _chdrive(int _Drive); 
#line 43
__declspec(dllimport) int __cdecl _getdrive(); 
#line 45
__declspec(dllimport) unsigned long __cdecl _getdrives(); 
#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\direct.h"
__declspec(dllimport) __declspec(allocator) char *__cdecl _getcwd(char * _DstBuf, int _SizeInBytes); 
#line 66
__declspec(dllimport) __declspec(allocator) char *__cdecl _getdcwd(int _Drive, char * _DstBuf, int _SizeInBytes); 
#line 77
__declspec(dllimport) int __cdecl _chdir(const char * _Path); 
#line 79
__declspec(dllimport) int __cdecl _mkdir(const char * _Path); 
#line 81
__declspec(dllimport) int __cdecl _rmdir(const char * _Path); 
#line 94
__declspec(dllimport) char *__cdecl getcwd(char * _DstBuf, int _SizeInBytes); 
#line 102
__declspec(dllimport) int __cdecl chdir(const char * _Path); 
#line 111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\direct.h"
__declspec(dllimport) int __cdecl mkdir(const char * _Path); 
#line 116
__declspec(dllimport) int __cdecl rmdir(const char * _Path); 
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17763.0\\ucrt\\direct.h"
}__pragma( pack ( pop )) 
#line 22 "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu"
HMat TheMMat; 
#line 23
Stim stim; 
#line 24
Sim sim; 
#line 25
char debugFN[] = "Debug.dat"; 
#line 26
FILE *fdebug, *fdebug2, *fdebug3; 
#line 27
double **ParamsMSerial; 
#line 28
double *ParamsM; 
#line 29
double *InitStatesM; 
#line 30
int NSets; 
#line 31
short FParams; 
#line 32
short comp; 
#line 33
double *V; 
#line 35
double *VV; 
#line 36
double **StatesM; 
#line 37
void Init() { 
#line 39
ReadSimData("..\\Data\\Sim", TheMMat.N, sim); 
#line 47
ReadCSVStim(stim); 
#line 51 "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu"
V = ((double *)malloc((TheMMat.N) * sizeof(double))); 
#line 52
VV = ((double *)malloc((TheMMat.N) * sizeof(double))); 
#line 53
CopyVec(V, sim.Vs, TheMMat.N); 
#line 54
CopyVecTwoTypes(VV, sim.Vs, TheMMat.N); 
#line 55
ParamsMSerial = ((double **)malloc((19) * sizeof(double))); 
#line 56
StatesM = ((double **)malloc((19) * sizeof(double *))); 
#line 57
for (int i = 0; i < 19; i++) { 
#line 58
(StatesM[i]) = ((double *)calloc(TheMMat.N, sizeof(double))); 
#line 59
}  
#line 64
short tempNsets; 
#line 65
tempNsets = (TheMMat.NComps); 
#line 66
printf(" ntempnsets%d\n", tempNsets); 
#line 68
ParamsM = ReadAllParams("..\\Data\\AllParams.csv", 19, TheMMat.NComps, NSets); 
#line 77
} 
#line 78
void freeInit() { 
#line 92 "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu"
free(V); 
#line 93
free(VV); 
#line 96
free(ParamsMSerial); 
#line 98
for (int i = 0; i < 19; i++) { 
#line 99
free(StatesM[i]); 
#line 100
}  
#line 101
free(StatesM); 
#line 103
free(ParamsM); 
#line 104
} 
#line 329
void InitP() { 
#line 330
} 
#line 332
void ReadParallelNeuronData(const char *FN, HMat &TheMat, short *CompDepth, short *CompFDepth) { 
#line 333
char FileName[300]; 
#line 334
char cwd[300]; 
#line 335
double *tmpe, *tmpf; 
#line 336
_getcwd(cwd, sizeof cwd); 
#line 337
printf("working dir is %s\n", cwd); 
#line 339
sprintf(FileName, "%sSegP.csv", FN); 
#line 341
printf("Start reading file - ReadSerialNeuronData() %s\n", FileName); 
#line 342
FILE *fl; 
#line 343
fl = fopen(FileName, "r"); 
#line 344
if (!fl) 
#line 345
{ 
#line 346
printf("Failed to read TreeData.x\n"); 
#line 347
return; 
#line 348
}  
#line 349
char line[409600]; 
#line 350
fgets(line, sizeof line, fl); 
#line 351
ReadShortFromCSV(line, &(TheMat.N), 1); 
#line 352
printf("printing line %s\n", line); 
#line 353
fgets(line, sizeof line, fl); 
#line 354
ReadShortFromCSV(line, &(TheMat.NComps), 1); 
#line 355
fgets(line, sizeof line, fl); 
#line 358
(TheMat.e) = ((double *)malloc((TheMat.N) * sizeof(double))); 
#line 359
(TheMat.f) = ((double *)malloc((TheMat.N) * sizeof(double))); 
#line 360
tmpe = (TheMat.e); 
#line 361
tmpf = (TheMat.f); 
#line 362
(TheMat.Ks) = ((short *)malloc((TheMat.N) * sizeof(short))); 
#line 363
(TheMat.SegToComp) = ((short *)malloc((TheMat.N) * sizeof(short))); 
#line 365
(TheMat.Cms) = ((double *)malloc((TheMat.N) * sizeof(double))); 
#line 366
(TheMat.SonNoVec) = ((short *)malloc((TheMat.N) * sizeof(short))); 
#line 368
ReadDoubleFromCSV(line, tmpe, TheMat.N); 
#line 369
fgets(line, sizeof line, fl); 
#line 370
ReadDoubleFromCSV(line, tmpf, TheMat.N); 
#line 371
fgets(line, sizeof line, fl); 
#line 379
(TheMat.e) = tmpe; 
#line 380
(TheMat.f) = tmpf; 
#line 382
ReadShortFromCSV(line, TheMat.Ks, TheMat.N); 
#line 383
printf("*2"); 
#line 384
fgets(line, sizeof line, fl); 
#line 385
ReadShortFromCSV(line, TheMat.SegToComp, TheMat.N); 
#line 386
fgets(line, sizeof line, fl); 
#line 387
ReadFloatFromCSV(line, TheMat.Cms, TheMat.N); 
#line 388
fgets(line, sizeof line, fl); 
#line 389
ReadShortFromCSV(line, &(TheMat.NModels), 1); 
#line 390
fgets(line, sizeof line, fl); 
#line 391
(TheMat.boolModel) = ((short *)malloc(((TheMat.N) * (TheMat.NModels)) * sizeof(short))); 
#line 392
printf("*3"); 
#line 393
ReadShortFromCSV(line, TheMat.boolModel, (TheMat.N) * (TheMat.NModels)); 
#line 394
fgets(line, sizeof line, fl); 
#line 395
ReadShortFromCSV(line, TheMat.SonNoVec, (TheMat.N) * (TheMat.NModels)); 
#line 396
fgets(line, sizeof line, fl); 
#line 397
ReadShortFromCSV(line, &(TheMat.Depth), 1); 
#line 399
fgets(line, sizeof line, fl); 
#line 400
ReadShortFromCSV(line, &(TheMat.LognDepth), 1); 
#line 401
fgets(line, sizeof line, fl); 
#line 402
ReadShortFromCSV(line, &(TheMat.nFathers), 1); 
#line 403
fgets(line, sizeof line, fl); 
#line 404
ReadShortFromCSV(line, &(TheMat.nCallForFather), 1); 
#line 405
fgets(line, sizeof line, fl); 
#line 407
printf("*3.5\n"); 
#line 408
(TheMat.RelStarts) = ((short *)malloc((TheMat.nFathers) * sizeof(short))); 
#line 409
printf("*4*\n"); 
#line 410
ReadShortFromCSV(line, TheMat.RelStarts, TheMat.nFathers); 
#line 411
fgets(line, sizeof line, fl); 
#line 412
(TheMat.RelEnds) = ((short *)malloc((TheMat.nFathers) * sizeof(short))); 
#line 413
printf("*5*\n"); 
#line 414
ReadShortFromCSV(line, TheMat.RelEnds, TheMat.nFathers); 
#line 415
fgets(line, sizeof line, fl); 
#line 416
(TheMat.RelVec) = ((short *)malloc((TheMat.nCallForFather) * sizeof(short))); 
#line 417
printf("*6*\n"); 
#line 418
ReadShortFromCSV(line, TheMat.RelVec, TheMat.nCallForFather); 
#line 419
printf("*7*\n"); 
#line 420
fgets(line, sizeof line, fl); 
#line 421
printf("*8*\n"); 
#line 422
(TheMat.SegStartI) = ((short *)malloc(((TheMat.nCallForFather) + 1) * sizeof(short))); 
#line 423
ReadShortFromCSV(line, TheMat.SegStartI, (TheMat.nCallForFather) + 1); 
#line 424
printf("*8.5*\n"); 
#line 425
fgets(line, sizeof line, fl); 
#line 426
printf("*9*\n"); 
#line 427
(TheMat.SegEndI) = ((short *)malloc(((TheMat.nCallForFather) + 1) * sizeof(short))); 
#line 428
printf("*10*\n"); 
#line 429
ReadShortFromCSV(line, TheMat.SegEndI, (TheMat.nCallForFather) + 1); 
#line 430
fgets(line, sizeof line, fl); 
#line 431
printf("*9"); 
#line 433
(TheMat.Fathers) = ((short *)malloc((TheMat.nFathers) * sizeof(short))); 
#line 434
ReadShortFromCSV(line, TheMat.Fathers, TheMat.nFathers); 
#line 435
fgets(line, sizeof line, fl); 
#line 437
(TheMat.FIdxs) = ((short *)malloc(((TheMat.LognDepth) * (TheMat.N)) * sizeof(short))); 
#line 438
ReadShortFromCSV(line, TheMat.FIdxs, (TheMat.LognDepth) * (TheMat.N)); 
#line 439
fgets(line, sizeof line, fl); 
#line 446 "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu"
ReadShortFromCSV(line, CompDepth, 1); 
#line 447
fgets(line, sizeof line, fl); 
#line 448
ReadShortFromCSV(line, CompFDepth, 1); 
#line 450
fgets(line, sizeof line, fl); 
#line 453
(TheMat.CompByLevel32) = ((short *)malloc(((*CompDepth) * 32) * sizeof(short))); 
#line 454
ReadShortFromCSV(line, TheMat.CompByLevel32, (*CompDepth) * 32); 
#line 455
fgets(line, sizeof line, fl); 
#line 456
(TheMat.CompByFLevel32) = ((short *)malloc(((*CompFDepth) * 32) * sizeof(short))); 
#line 457
ReadShortFromCSV(line, TheMat.CompByFLevel32, (*CompFDepth) * 32); 
#line 458
fgets(line, sizeof line, fl); 
#line 459
ReadShortFromCSV(line, &(TheMat.nLRel), 1); 
#line 461
fgets(line, sizeof line, fl); 
#line 463
(TheMat.LRelStarts) = ((short *)malloc((TheMat.nLRel) * sizeof(short))); 
#line 464
ReadShortFromCSV(line, TheMat.LRelStarts, TheMat.nLRel); 
#line 465
fgets(line, sizeof line, fl); 
#line 466
(TheMat.LRelEnds) = ((short *)malloc((TheMat.nLRel) * sizeof(short))); 
#line 467
ReadShortFromCSV(line, TheMat.LRelEnds, TheMat.nLRel); 
#line 468
fgets(line, sizeof line, fl); 
#line 469
ReadShortFromCSV(line, &(TheMat.nFLRel), 1); 
#line 471
fgets(line, sizeof line, fl); 
#line 472
(TheMat.FLRelStarts) = ((short *)malloc((TheMat.nFLRel) * sizeof(short))); 
#line 473
ReadShortFromCSV(line, TheMat.FLRelStarts, TheMat.nFLRel); 
#line 474
fgets(line, sizeof line, fl); 
#line 476
(TheMat.FLRelEnds) = ((short *)malloc((TheMat.nFLRel) * sizeof(short))); 
#line 477
ReadShortFromCSV(line, TheMat.FLRelEnds, TheMat.nFLRel); 
#line 478
fgets(line, sizeof line, fl); 
#line 482
short *Temp = (short *)malloc(((TheMat.N) + 1) * sizeof(short)); 
#line 483
fread(Temp, ((TheMat.N) + 1) * sizeof(short), 1, fl); 
#line 484
free(Temp); 
#line 491 "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu"
fclose(fl); 
#line 492
printf("done with mallocs"); 
#line 494
} 
#line 495
void FreeReadParallelNeuronData(HMat *TheMat) { 
#line 499
free(TheMat->SegToComp); 
#line 500
free(TheMat->Ks); 
#line 502
free(TheMat->e); 
#line 503
free(TheMat->f); 
#line 504
free(TheMat->Cms); 
#line 505
free(TheMat->SonNoVec); 
#line 507
free(TheMat->boolModel); 
#line 511
free(TheMat->RelStarts); 
#line 512
free(TheMat->RelEnds); 
#line 513
free(TheMat->RelVec); 
#line 514
free(TheMat->SegStartI); 
#line 515
free(TheMat->SegEndI); 
#line 516
free(TheMat->Fathers); 
#line 518
free(TheMat->FIdxs); 
#line 520 "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu"
free(TheMat->CompByLevel32); 
#line 521
free(TheMat->CompByFLevel32); 
#line 523
free(TheMat->LRelStarts); 
#line 524
free(TheMat->LRelEnds); 
#line 525
free(TheMat->FLRelStarts); 
#line 526
free(TheMat->FLRelEnds); 
#line 527
free(&TheMat); 
#line 528
printf("done with frees"); 
#line 530
} 
#line 535
void RunByModelP() { 
#line 536
short CompDepth, CompFDepth; 
#line 537
char *buffer; 
#line 540
printf("printing pwd"); 
#line 541
if ((buffer = _getcwd(0, 0)) == (0)) { 
#line 542
perror("getcwd error"); } else 
#line 544
{ 
#line 545
printf("%s \nLength: %d\n", buffer, strnlen(buffer, 5000)); 
#line 546
free(buffer); 
#line 547
}  
#line 548
printf("starting to read"); 
#line 549
ReadParallelNeuronData("..\\Data\\BasicConst", TheMMat, &CompDepth, &CompFDepth); 
#line 550
printf("done reding\n****\n"); 
#line 551
Init(); 
#line 552
printf("reading file %s", "..\\Data\\BasicConst"); 
#line 553
int *p2pCapableGPUs; 
#line 554
int np2p; 
#line 555
p2pCapableGPUs = checkPeerAccess(np2p); 
#line 556
printf("after check peer p2pCapableGPUs[0] is %d\n", p2pCapableGPUs[0]); 
#line 557
enablePeerAccess(p2pCapableGPUs, np2p); 
#line 558
printf("after enable peer p2pCapableGPUs[0] is %d\n", p2pCapableGPUs[0]); 
#line 559
printf("done enablePeerAccess\n"); 
#line 560
{ cudaError_t cudaStatus = cudaSetDevice(0); if ((cudaSuccess) != cudaStatus) { printf("ERROR: CUDA RT call \"%s\" in line %d of file %s failed with %s (%d).\n", cudaSetDevice(0), 560, "E:/Workspace/SinglePrec/pyNeuroGPU_win2/NeuroGPU6/MainC.cu", cudaGetErrorString(cudaStatus), cudaStatus); }  } ; 
#line 562
stEfork2Main(stim, sim, ParamsM, InitStatesM, TheMMat, V, CompDepth, CompFDepth, NSets, p2pCapableGPUs, np2p); 
#line 564
} 
#line 565
void freeRunByModelP() { 
#line 569
} 
#line 1 "MainC.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__13_MainC_cpp1_ii_debugFN
#pragma pack()
#line 1 "MainC.cudafe1.stub.c"
#include "MainC.cudafe1.stub.c"
#line 1 "MainC.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
